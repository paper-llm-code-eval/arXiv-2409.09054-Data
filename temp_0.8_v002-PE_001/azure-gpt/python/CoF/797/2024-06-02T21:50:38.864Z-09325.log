---------- user ----------

Here is a programming challenge.
Please solve this problem efficiently, optimizing both time and memory usage.
Create the most efficient solution for this challenge in python. Utilize numpy and other highly efficient libraries whenever possible.
This problem has a memory limit of ~8MB so please be sensitive on using memory.Using unavoided memory may result in OOM.
The code must compile and be correct.
The solution must read from `loto.in` and write to `loto.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

La Loteria Națională există $N$ bile inscripționate cu numere naturale, nenule, distincte de cel mult $4$ cifre. Șeful de la loterie primește o cutie în care se află cele $6$ bile extrase la ultima rundă, restul bilelor neextrase fiind puse într-un seif. Deoarece are o fire poznașă, el scoate din cutie bila pe care este înscris numărul cel mai mic și o păstrează în buzunarul hainei sale. În locul ei va pune o bilă neextrasă, aflată în seif, având numărul cel mai apropiat de aceasta. Apoi continuă operația și scoate din cutie și bila pe care este înscris numărul maxim extras inițial, pe care o va pune în celălalt buzunar al său. De asemenea o va înlocui cu o altă bilă neextrasă inițial, aflată în seif, având numărul cel mai apropiat de aceasta.

# Cerință

Realizați un program care afișează în ordine crescătoare numerele de pe bilele aflate în cutie după modificările făcute de șef.

# Date de intrare

Fișierul de intrare `loto.in` conține pe prima linie numărul natural $N$, pe a doua linie cele $N$ numere naturale scrise pe bile, iar pe a treia linie cele $6$ numere naturale scrise pe bilele extrase de angajații loteriei. Valorile scrise pe aceeași linie sunt separate prin spații.

# Date de ieșire

În fișierul de ieșire `loto.out` se vor afișa pe prima linie, separate prin câte un spațiu, cele $6$ numere obținute în cutie după modificărie făcute de șef, în ordine crescătoare.

# Restricții și precizări

* $8 < N < 1 \ 000$
* Dacă o bilă poate fi înlocuită cu două bile la fel de apropiate de ea, atunci aceasta se va înlocui cu bila având numărul mai mare.
* Pentru datele de test, atât bila cu numărul cel mai mic, cât și bila cu numărul cel mai mare pot fi înlocuite cu alte bile.

---

Example:
`loto.in`
```
10
231 212 32 123 453 675 1321 54 67 567
212 32 67 567 675 1321
```

`loto.out`
```
54 67 212 453 567 675
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```python
import numpy as np

# Function to find the closest number in the unselected set to the given number
def find_closest_num(num, unselected, selected):
    candidates = unselected[np.abs(unselected - num).argmin()]
    # If there's a tie, choose the larger number
    closest_num = max(candidates) if isinstance(candidates, np.ndarray) else candidates
    # Update the selected and unselected sets
    selected.add(closest_num)
    unselected.remove(closest_num)
    return closest_num

# Load the numbers from the 'loto.in' file
with open('loto.in', 'r') as file:
    N = int(next(file))
    all_numbers = np.array(list(map(int, next(file).split())))
    selected_numbers = set(map(int, next(file).split()))

# Get the unselected numbers as a sorted set for efficient closest number search
unselected_numbers = set(all_numbers) - selected_numbers

# Find the smallest and largest numbers in the selected set
min_selected = min(selected_numbers)
max_selected = max(selected_numbers)

# Remove the smallest and largest numbers from the selected set
selected_numbers.remove(min_selected)
selected_numbers.remove(max_selected)

# Find the closest numbers to the smallest and largest selected numbers
closest_to_min = find_closest_num(min_selected, unselected_numbers, selected_numbers)
closest_to_max = find_closest_num(max_selected, unselected_numbers, selected_numbers)

# Include the closest numbers in the selected set
selected_numbers.add(closest_to_min)
selected_numbers.add(closest_to_max)

# Write the resulting selected numbers to the 'loto.out' file
with open('loto.out', 'w') as file:
    file.write(' '.join(map(str, sorted(selected_numbers))) + '\n')
```
The solution uses NumPy to efficiently calculate the closest number in the unselected set and minimizes memory usage by using sets for the unselected and selected numbers. It also takes care of the case where there is a tie for the closest number by selecting the larger one as per the problem statement.
---------- user ----------


Program exited with code 1.
stdout:
```

```
stderr:
```
Traceback (most recent call last):
  File "/app/app.py", line 1, in <module>
    import numpy as np
ModuleNotFoundError: No module named 'numpy'

```

Think of what has caused the exit code. Use the standard out and standard error to help you understand the issue.
Implement a solution to fix the program

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The exit code indicates that the program tried to import the `numpy` module, which was not available in the environment. Since adding external libraries like `numpy` might not be possible within the constraints of the current environment, and considering the memory restriction, I will rewrite the solution without using `numpy`.

Here's the rewritten solution in plain Python, which does not rely on external libraries:

```python
# Function to find the closest number in the unselected set to the given number
def find_closest_num(num, unselected):
    # Initialize the closest number and its distance to a large value
    closest_num = None
    closest_distance = float('inf')
    for candidate in unselected:
        distance = abs(candidate - num)
        # Update the closest number if a closer one is found
        # or if the distance is the same but the number is larger
        if distance < closest_distance or (distance == closest_distance and candidate > closest_num):
            closest_num = candidate
            closest_distance = distance
    return closest_num

# Load the numbers from the 'loto.in' file
with open('loto.in', 'r') as file:
    N = int(next(file))
    all_numbers = list(map(int, next(file).split()))
    selected_numbers = list(map(int, next(file).split()))

# Get the unselected numbers as a set for efficient search
unselected_numbers = set(all_numbers) - set(selected_numbers)

# Find the smallest and largest numbers in the selected set
min_selected = min(selected_numbers)
max_selected = max(selected_numbers)

# Remove the smallest and largest numbers from the selected set
selected_numbers.remove(min_selected)
selected_numbers.remove(max_selected)

# Find the closest numbers to the smallest and largest selected numbers
closest_to_min = find_closest_num(min_selected, unselected_numbers)
closest_to_max = find_closest_num(max_selected, unselected_numbers)

# Update the unselected set by removing the closest numbers
unselected_numbers.remove(closest_to_min)
unselected_numbers.remove(closest_to_max)

# Include the closest numbers in the selected set
selected_numbers.extend([closest_to_min, closest_to_max])

# Write the resulting selected numbers to the 'loto.out' file
with open('loto.out', 'w') as file:
    file.write(' '.join(map(str, sorted(selected_numbers))) + '\n')
```
The above solution uses plain Python data structures and functions to achieve the desired results. It finds the closest number efficiently by iterating through the unselected numbers set, and it updates both the selected and unselected sets according to the problem requirements.
