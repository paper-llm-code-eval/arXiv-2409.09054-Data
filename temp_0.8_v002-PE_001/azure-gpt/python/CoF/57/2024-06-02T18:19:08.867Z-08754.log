---------- user ----------

Here is a programming challenge.
Please solve this problem efficiently, optimizing both time and memory usage.
Create the most efficient solution for this challenge in python. Utilize numpy and other highly efficient libraries whenever possible.
This problem has a memory limit of ~8MB so please be sensitive on using memory.Using unavoided memory may result in OOM.
The code must compile and be correct.
The solution must read from `urgenta.in` and write to `urgenta.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Autorităţile dintr-o zonă de munte intenţionează să stabilească un plan de urgenţă, pentru a reacţiona mai eficient la frecventele calamităţi naturale din zonă. În acest scop au identificat $N$ puncte de interes strategic şi le-au numerotat distinct de la $1$ la $N$. Punctele de interes strategic sunt conectate prin $M$ căi de acces având priorităţi în funcţie de importanţă. Între oricare două puncte de interes strategic există cel mult o cale de acces ce poate fi parcursă în ambele sensuri şi cel puţin un drum (format din una sau mai multe căi de acces) ce le conectează. 

În cazul unei calamităţi unele căi de acces pot fi temporar întrerupte şi astfel între anumite puncte de interes nu mai există legătură. Ca urmare pot rezulta mai multe grupuri de puncte în aşa fel încât între oricare două puncte din acelaşi grup să existe măcar un drum şi între oricare două puncte din grupuri diferite să nu existe drum. 

Autorităţile estimează gravitatea unei calamităţi ca fiind suma priorităţilor căilor de acces distruse de aceasta şi doresc să determine un scenariu de gravitate maximă, în care punctele de interes strategic să fie împărţite într-un număr de $K$ grupuri.

# Date de intrare
Fişierul de intrare `urgenta.in` are următorul format:
$N\ M\ K$
$i_1 \; j_1 \; p_1 $ – între punctele $i_1$ şi $j_1$ există o cale de acces de prioritate $p_1$
$i_2 \; j_2 \; p_2 $ – între punctele $i_2$ şi $j_2$ există o cale de acces de prioritate $p_2$
...
$i_M \; j_M \; p_M $ – între punctele $i_M$ şi $j_M$ există o cale de acces de prioritate $p_M$

# Date de ieşire
Fişierul de ieşire `urgenta.out` va avea următorul format:
$\text{gravmax}$ – gravitatea maximă
$C$	– numărul de căi de acces întrerupte de calamitate
$k_1 \; h_1$ – între punctele $k_1$ şi $h_1$ a fost întreruptă calea de acces
$k_2 \; h_2$ – între punctele $k_2$ şi $h_2$ a fost întreruptă calea de acces
...
$k_C \; h_C$ – între punctele $k_C$ şi $h_C$ a fost întreruptă calea de acces

# Restricţii şi precizări
* $1 \leq N \leq 255$
* $N - 1 \leq M \leq 32 \ 384$
* $1 \leq K \leq N$
* Priorităţile căilor de acces sunt întregi strict pozitivi mai mici decât $256$.
* Un grup de puncte poate conţine între $1$ şi $N$ puncte inclusiv.
* Dacă există mai multe soluţii, programul va determina una singură.

---

Example:
`urgenta.in`
```
7 11 4
1 2 1
1 3 2
1 7 3
2 4 3
3 4 2
3 5 1
3 6 1
3 7 5
4 5 5
5 6 4
6 7 3
```

`urgenta.out`
```
27
8
1 3
1 7
2 4
3 4
3 7
4 5
5 6
6 7
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```markdown
```python
import numpy as np

# Read the input data
with open('urgenta.in', 'r') as file:
    n, m, k = map(int, file.readline().split())
    edges = np.array([list(map(int, file.readline().split())) for _ in range(m)])

# Sort the edges by their priority in descending order
edges = edges[edges[:, 2].argsort()[::-1]]

# Find the most significant edges to remove, such that we are left with K clusters
edges_to_remove = edges[:n - k]

# Calculate the maximum gravity
max_gravity = np.sum(edges_to_remove[:, 2])

# Prepare the output data
output_data = f"{max_gravity}\n{n - k}\n" + "\n".join(
    [" ".join(map(str, edge[:2])) for edge in edges_to_remove]
)

# Write the output data
with open('urgenta.out', 'w') as file:
    file.write(output_data)
```
```

This code is a simple version of Kruskal's algorithm with a union-find data structure replaced by a simple counting strategy since we know how many clusters we want in the end. It sorts the edges by priority, removes the most significant ones to break the graph into K clusters, and then it calculates the sum of the priorities of the removed edges to find the maximum gravity of the disaster.

The solution assumes that the input is correct and does not contain any errors. If the input file can contain errors or cases where it is not possible to split the graph into exactly K clusters, additional error checking and handling would be necessary.
---------- user ----------


Expected program to write result to `urgenta.out` and read from `urgenta.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Function to find the parent of a node
def find(parent, i):
    if parent[i] == i:
        return i
    return find(parent, parent[i])

# Function to perform the union of two sets
def union(parent, rank, x, y):
    xroot = find(parent, x)
    yroot = find(parent, y)

    if rank[xroot] < rank[yroot]:
        parent[xroot] = yroot
    elif rank[xroot] > rank[yroot]:
        parent[yroot] = xroot
    else:
        parent[yroot] = xroot
        rank[xroot] += 1

# Read the input data
with open('urgenta.in', 'r') as file:
    n, m, k = map(int, file.readline().split())
    edges = [list(map(int, line.split())) for line in file]

# Sort the edges by their priority in descending order
edges.sort(key=lambda x: x[2], reverse=True)

# Initialize parent and rank arrays for Union-Find
parent = np.arange(n + 1)
rank = np.zeros(n + 1, dtype=int)

# Initialize variables for the result
removed_edges = []
max_gravity = 0
num_clusters = n

# Process edges in descending order of priority
for edge in edges:
    u, v, priority = edge
    x = find(parent, u)
    y = find(parent, v)

    # If u and v are already in the same set, remove the edge
    if x == y:
        removed_edges.append(edge)
        max_gravity += priority
    else:
        if num_clusters > k:
            # Otherwise, join the two sets if it does not decrease the number of clusters below k
            union(parent, rank, x, y)
            num_clusters -= 1
        else:
            # If we already have k clusters, all remaining edges will be removed
            removed_edges.append(edge)
            max_gravity += priority

# Write the output data
with open('urgenta.out', 'w') as file:
    file.write(f"{max_gravity}\n{len(removed_edges)}\n")
    for edge in removed_edges:
        file.write(f"{edge[0]} {edge[1]}\n")
```
```
---------- user ----------


Expected program to write result to `urgenta.out` and read from `urgenta.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Function to find the parent of a node
def find(parent, i):
    if parent[i] == i:
        return i
    return find(parent, parent[i])

# Function to perform the union of two sets
def union(parent, rank, x, y):
    xroot = find(parent, x)
    yroot = find(parent, y)

    if rank[xroot] < rank[yroot]:
        parent[xroot] = yroot
    elif rank[xroot] > rank[yroot]:
        parent[yroot] = xroot
    else:
        parent[yroot] = xroot
        rank[xroot] += 1

# Read the input data
with open('urgenta.in', 'r') as file:
    n, m, k = map(int, file.readline().split())
    edges = [list(map(int, line.split())) for line in file]

# Sort the edges by their priority in descending order
edges.sort(key=lambda x: x[2], reverse=True)

# Initialize parent and rank arrays for Union-Find
parent = list(range(n + 1))
rank = [0] * (n + 1)

# Process edges in descending order of priority
removed_edges = []
max_gravity = 0

for i in range(m):
    if k <= 1:
        break
    u, v, w = edges[i]
    x = find(parent, u)
    y = find(parent, v)
    
    if x != y:
        union(parent, rank, x, y)
        k -= 1
    else:
        removed_edges.append((u, v))
        max_gravity += w

# Write the output data
with open('urgenta.out', 'w') as file:
    file.write(f"{max_gravity}\n{len(removed_edges)}\n")
    for u, v in removed_edges:
        file.write(f"{u} {v}\n")
```
```
---------- user ----------


Expected program to write result to `urgenta.out` and read from `urgenta.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import heapq

# Read the input data from 'urgenta.in'
with open('urgenta.in', 'r') as file:
    n, m, k = map(int, file.readline().split())
    edges = [tuple(map(int, line.split())) for line in file.readlines()]

# Sort the edges by priority in a max heap
edges = [(-priority, u, v) for u, v, priority in edges]
heapq.heapify(edges)

# Union-Find data structure initialization
parent = list(range(n + 1))
rank = [0] * (n + 1)

def find(x):
    if parent[x] != x:
        parent[x] = find(parent[x])
    return parent[x]

def union(x, y):
    xroot = find(x)
    yroot = find(y)
    if xroot != yroot:
        if rank[xroot] < rank[yroot]:
            parent[xroot] = yroot
        elif rank[xroot] > rank[yroot]:
            parent[yroot] = xroot
        else:
            parent[yroot] = xroot
            rank[xroot] += 1
        return True
    return False

# Keep track of the total weight of the minimum spanning forest
total_weight = 0
components = n
selected_edges = []

while edges and components > k:
    weight, u, v = heapq.heappop(edges)
    if union(u, v):
        components -= 1
        selected_edges.append((u, v))
    else:
        total_weight -= weight  # weight is negative

# Write the output data to 'urgenta.out'
with open('urgenta.out', 'w') as file:
    file.write(f"{total_weight}\n{len(selected_edges)}\n")
    for u, v in sorted(selected_edges):
        file.write(f"{u} {v}\n")
```
```
---------- user ----------


Expected program to write result to `urgenta.out` and read from `urgenta.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
# Kruskal's algorithm implementation to maximize the sum of removed edges
from heapq import heappop, heappush

# Read the input data from 'urgenta.in'
with open('urgenta.in', 'r') as file:
    n, m, k = map(int, file.readline().split())
    edges = []
    for _ in range(m):
        u, v, w = map(int, file.readline().split())
        heappush(edges, (-w, u, v))

# Disjoint set data structure
def find(parent, i):
    if parent[i] != i:
        parent[i] = find(parent, parent[i])
    return parent[i]

def union(parent, rank, x, y):
    xroot = find(parent, x)
    yroot = find(parent, y)
    if xroot != yroot:
        if rank[xroot] < rank[yroot]:
            parent[xroot] = yroot
        elif rank[xroot] > rank[yroot]:
            parent[yroot] = xroot
        else:
            parent[yroot] = xroot
            rank[xroot] += 1
        return True
    return False

# Initialize disjoint set
parent = list(range(n + 1))
rank = [0] * (n + 1)

# Kruskal's algorithm to find the Maximum Spanning Tree (MST)
num_clusters = n
removed_edges = []
max_gravity = 0

while edges and num_clusters > k:
    weight, u, v = heappop(edges)
    if union(parent, rank, u, v):
        num_clusters -= 1
    else:
        removed_edges.append((u, v))
        max_gravity -= weight

# Write the output data to 'urgenta.out'
with open('urgenta.out', 'w') as file:
    file.write(f"{max_gravity}\n{len(removed_edges)}\n")
    for u, v in removed_edges:
        file.write(f"{u} {v}\n")
```
```
---------- user ----------


Expected program to write result to `urgenta.out` and read from `urgenta.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
# Kruskal's algorithm implementation to find the maximum sum of edges for K clusters

class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n

    def find(self, i):
        if self.parent[i] != i:
            self.parent[i] = self.find(self.parent[i])
        return self.parent[i]

    def union(self, x, y):
        xroot = self.find(x)
        yroot = self.find(y)
        if xroot != yroot:
            if self.rank[xroot] < self.rank[yroot]:
                self.parent[xroot] = yroot
            elif self.rank[xroot] > self.rank[yroot]:
                self.parent[yroot] = xroot
            else:
                self.parent[yroot] = xroot
                self.rank[xroot] += 1
            return True
        return False

# Read the input data from 'urgenta.in'
with open('urgenta.in', 'r') as file:
    n, m, k = map(int, file.readline().split())
    edges = [tuple(map(int, line.split())) for line in file]

# Sort edges based on weight in descending order
edges.sort(key=lambda x: x[2], reverse=True)

# Initialize UnionFind
uf = UnionFind(n + 1)

# Kruskal's algorithm to maximize sum of removed edges
num_clusters = n
removed_edges = []
max_gravity = 0

for edge in edges:
    u, v, weight = edge
    if uf.union(u, v):
        num_clusters -= 1
        if num_clusters < k:
            uf.union(u, v)  # Re-unite to correct the premature union
            break

# After getting k clusters, remove all remaining edges
for edge in edges[m - n + k - 1:]:  # Start from the edge that made the clusters k
    u, v, weight = edge
    if uf.find(u) != uf.find(v):  # If they are in different clusters, remove the edge
        removed_edges.append((u, v))
        max_gravity += weight

# Write the output data to 'urgenta.out'
with open('urgenta.out', 'w') as file:
    file.write(f"{max_gravity}\n{len(removed_edges)}\n")
    for u, v in removed_edges:
        file.write(f"{u} {v}\n")
```
```
---------- user ----------


Expected program to write result to `urgenta.out` and read from `urgenta.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import heapq

class UnionFind:
    def __init__(self, size):
        self.parent = list(range(size))
        self.rank = [0] * size

    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def union(self, x, y):
        x_root = self.find(x)
        y_root = self.find(y)
        if x_root == y_root:
            return False
        if self.rank[x_root] < self.rank[y_root]:
            self.parent[x_root] = y_root
        elif self.rank[x_root] > self.rank[y_root]:
            self.parent[y_root] = x_root
        else:
            self.parent[y_root] = x_root
            self.rank[x_root] += 1
        return True

# Read the input data from 'urgenta.in'
edges = []
with open('urgenta.in', 'r') as file:
    n, m, k = map(int, file.readline().split())
    for _ in range(m):
        u, v, p = map(int, file.readline().split())
        heapq.heappush(edges, (-p, u, v))  # negate the priority for a max-heap

uf = UnionFind(n + 1)
total_removed_weight = 0
num_edges_removed = 0
removed_edges = []

# Use a max-heap to always remove the edge with the highest weight
while edges and n - uf.rank[uf.find(1)] > k:
    weight, u, v = heapq.heappop(edges)
    if not uf.union(u, v):
        total_removed_weight += -weight
        num_edges_removed += 1
        removed_edges.append((u, v))

# Write the output data to 'urgenta.out'
with open('urgenta.out', 'w') as file:
    file.write(f"{total_removed_weight}\n{num_edges_removed}\n")
    for u, v in removed_edges:
        file.write(f"{u} {v}\n")
```
```
