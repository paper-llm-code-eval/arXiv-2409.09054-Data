---------- user ----------

Here is a programming challenge.
Please solve this problem efficiently, optimizing both time and memory usage.
Create the most efficient solution for this challenge in python. Utilize numpy and other highly efficient libraries whenever possible.
This problem has a memory limit of ~8MB so please be sensitive on using memory. Using too much memory may result in OOM.
The code must compile and be correct.
The solution must read from `partitura.in` and write to `partitura.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

~[partitura.png|align=right|width=25%]

Mihai s-a decis în sfârșit să compună o melodie. Fără să știe de unde să înceapă, a scris pe o foaie $n$ note muzicale. Fiecare notă muzicală este definită de două valori reprezentând durata și înălțimea acesteia astfel:
* **durata** este exprimată printr-o fracție de forma $\displaystyle \frac{1}{2^x}$, unde $x$ este un număr natural nenul;
* **înălțimea** este exprimată printr-un număr natural nenul $y$.

Durata unui grup de note este egală cu suma duratelor notelor din grup. Pentru a compune o melodie corect din punct de vedere muzical, el trebuie să distribuie toate notele în grupuri disjuncte, astfel încât durata fiecărui grup să fie $1$. Mihai definește **scorul unui grup** de note ca fiind suma înălțimilor tuturor notelor din grup, ridicată la pătrat. De asemenea, el definește **scorul unei melodii** ca fiind suma scorurilor tuturor grupurilor de note formate
care pot forma un grup.

Mihai vrea să afle care este scorul maxim al unei melodii pe care îl poate obține după gruparea tuturor notelor date.

# Cerință

Dându-se $n$ note sub forma a $n$ perechi de numere, $x$ și $y$, să se afișeze scorul maxim ce poate fi obținut după gruparea tuturor notelor date în grupuri disjuncte.

# Date de intrare

Fișierul de intrare `partitura.in` va conține pe prima linie un număr natural $n$, reprezentând numărul de note, iar pe următoarele $n$ linii se vor afla câte două numere naturale $x$ și $y$ separate prin câte un spațiu, cu semnificația din enunț, pentru fiecare din cele $n$ note.

# Date de ieșire

Fișierul de ieșire `partitura.out` va conține un singur număr natural reprezentând scorul maxim cerut.

# Restricții și precizări
* $1 \leq n \leq 300 \ 000$;
* $1 \leq x \leq 18$;
* $1 \leq y \leq 10 \ 000$;
* Se garantează că se pot distribui toate notele date în grupuri de durată $1$.
* Pentru $20$ de puncte, $n \leq 4$, $x = 1$;
* Pentru $22$ de puncte, $x = 1$;
* Pentru $17$ puncte, pentru toate notele, $x$ are aceeași valoare;
* Pentru $41$ de puncte, nu există restricții suplimentare.

---

Example:
`partitura.in`
```
5
2 3
3 2
2 1
2 2
3 5
```

`partitura.out`
```
169
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```markdown
```python
import numpy as np
from collections import defaultdict

# Function to read the notes, calculate and write the maximum score
def calculate_max_score(input_file, output_file):
    with open(input_file, 'r') as fin:
        n = int(fin.readline().strip())  # Number of notes
        notes = defaultdict(int)  # Dictionary to store sum of heights for each duration
        
        # Read notes and group by duration
        for _ in range(n):
            x, y = map(int, fin.readline().split())
            duration = 1 / (2 ** x)  # Calculating the actual duration
            notes[duration] += y  # Summing heights for each unique duration

    # Sort the durations in descending order
    sorted_durations = sorted(notes.keys(), reverse=True)
    
    # List to store the groups
    groups = []

    # Distribute notes into groups
    for duration in sorted_durations:
        # Calculate how many times this duration can be fit into a group
        frequency = int(1 / duration)
        height_sum = notes[duration]
        
        # Create the groups
        for _ in range(frequency):
            groups.append(height_sum)
            height_sum = max(0, height_sum - frequency)

    # Calculate the sum of squares of the group sums
    result = sum([height ** 2 for height in groups if height > 0])

    # Write the result to the output file
    with open(output_file, 'w') as fout:
        fout.write(str(result))

# Path to the input and output files
input_file = 'partitura.in'
output_file = 'partitura.out'

# Call the function to calculate and write the maximum score
calculate_max_score(input_file, output_file)
```
```
---------- user ----------


Expected program to write result to `partitura.out` and read from `partitura.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Function to calculate the score of a melody by maximizing the score of each group
def calculate_max_score(notes):
    # Sort notes by duration (1/2^x) and then by height in descending order
    notes.sort(key=lambda note: (note[0], -note[1]))

    # Group notes by duration, each group with total duration of 1
    groups = []
    group_sum = 0
    current_duration = 0.0
    for duration, height in notes:
        while current_duration + duration > 1:
            # Complete the current group and start a new group
            groups.append(group_sum)
            group_sum = 0
            current_duration = 0.0
        group_sum += height
        current_duration += duration

    # Add the last group if it's not empty
    if group_sum:
        groups.append(group_sum)

    # Calculate the score of the melody as the sum of the squares of the group sums
    score = np.sum(np.square(groups))

    return score

# Read notes from the input file
def read_notes(filename):
    with open(filename, 'r') as file:
        n = int(file.readline().strip())
        notes = []
        for _ in range(n):
            x, y = map(int, file.readline().split())
            duration = 1 / (2 ** x)
            notes.append((duration, y))
    return notes

# Write the score to the output file
def write_score(filename, score):
    with open(filename, 'w') as file:
        file.write(str(score))

# Input and output files
input_file = 'partitura.in'
output_file = 'partitura.out'

# Process the input and output the result
notes = read_notes(input_file)
max_score = calculate_max_score(notes)
write_score(output_file, max_score)
```
---------- user ----------


Expected program to write result to `partitura.out` and read from `partitura.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Utilize numpy to handle large amounts of data efficiently
np.set_printoptions(suppress=True)

# Function to read notes from a file, calculate and write the maximum score to another file
def process_partitura(input_file, output_file):
    # Load data from input_file
    raw_data = np.loadtxt(input_file, skiprows=1)
    if raw_data.size == 0:
        notes = np.array([], dtype=[('x', int), ('y', int)])
    else:
        notes = np.core.records.fromarrays(raw_data.transpose(), 
                                           names='x, y', 
                                           formats='i4, i4')

    # Calculate the inverse duration and sort notes by this value and by height
    inverse_durations = np.power(2, notes['x']).astype(np.int64)
    sorted_indices = np.lexsort((-notes['y'], inverse_durations))
    inverse_durations = inverse_durations[sorted_indices]
    heights = notes['y'][sorted_indices]
    
    # Calculate the maximum score
    max_score = 0
    current_duration = 0
    current_height_sum = 0
    
    for inv_dur, height in zip(inverse_durations, heights):
        current_duration += inv_dur
        current_height_sum += height
        # Check if the current group duration is equal to 1
        if current_duration == inverse_durations[0]:
            max_score += current_height_sum ** 2
            current_duration = 0
            current_height_sum = 0
        elif current_duration > inverse_durations[0]:
            # This should never happen since the input guarantees groupings of duration 1
            raise ValueError("Grouping of notes with total duration 1 is not possible.")

    # Write the result to the output file
    with open(output_file, 'w') as fout:
        fout.write(f'{max_score}\n')

# File paths
input_file = 'partitura.in'
output_file = 'partitura.out'

# Call the function to process the input and output the result
process_partitura(input_file, output_file)
```
---------- user ----------


Expected program to write result to `partitura.out` and read from `partitura.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
from collections import defaultdict

# Read notes from the input file
def read_notes(filename):
    with open(filename, 'r') as file:
        n = int(file.readline().strip())
        notes = defaultdict(int)
        for _ in range(n):
            x, y = map(int, file.readline().split())
            notes[x] += y
    return notes

# Write the score to the output file
def write_score(filename, score):
    with open(filename, 'w') as file:
        file.write(str(score))

# Calculate the score of the melody
def calculate_score(notes):
    score = 0
    for x in sorted(notes, reverse=True):
        count = 1 << (x - 1)  # Number of notes that fit in a whole note
        y_total = notes[x]
        while y_total > 0:
            score += (y_total // count) ** 2
            y_total %= count
            count >>= 1
    return score

# Input and output files
input_file = 'partitura.in'
output_file = 'partitura.out'

# Process the input and output the result
notes = read_notes(input_file)
max_score = calculate_score(notes)
write_score(output_file, max_score)
```
```
---------- user ----------


Expected program to write result to `partitura.out` and read from `partitura.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
# Function to read notes from a file, calculate and write the maximum score to another file
def process_partitura(input_file, output_file):
    # Read the notes from input_file
    with open(input_file, 'r') as fin:
        n = int(fin.readline().strip())
        durations = [0] * 19  # Since x can be at most 18, we need 19 slots
        for _ in range(n):
            x, y = map(int, fin.readline().split())
            durations[x] += y

    # Calculate the maximum score
    score = 0
    for i in range(18, 0, -1):
        groups = durations[i] // (1 << (i - 1))
        score += groups * (durations[i] // groups) ** 2
        carried_height = groups * (durations[i] % groups)
        durations[i - 1] += carried_height

    # Write the result to the output file
    with open(output_file, 'w') as fout:
        fout.write(f'{score}\n')

# File paths
input_file = 'partitura.in'
output_file = 'partitura.out'

# Call the function to process the input and output the result
process_partitura(input_file, output_file)
```
```
---------- user ----------


Expected program to write result to `partitura.out` and read from `partitura.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
# Solution without using numpy or any external libraries

# Function to calculate the maximum melody score
def calculate_max_score(notes):
    # Dictionary to store cumulative height for each duration
    duration_height = {}
    for duration, height in notes:
        if duration not in duration_height:
            duration_height[duration] = 0
        duration_height[duration] += height
    
    # List to store the sum of heights for each completed group
    groups = []
    
    # Process notes from shortest to longest duration
    for duration in sorted(duration_height.keys()):
        # Calculate the number of notes needed to complete a group
        notes_needed = 2 ** duration
        while duration_height[duration] >= notes_needed:
            # Complete a group and add its square of height sum to the list
            groups.append(notes_needed)
            duration_height[duration] -= notes_needed
            # Pass the remaining height to the next shorter duration
            next_duration = duration - 1
            if next_duration in duration_height:
                duration_height[next_duration] += duration_height[duration]
            else:
                duration_height[next_duration] = duration_height[duration]
            duration_height[duration] = 0
    
    # Calculate the final score as the sum of squares of the group heights
    max_score = sum([height**2 for height in groups])
    return max_score

# Read the notes from the input file
def read_input_file(filename):
    with open(filename, 'r') as file:
        n = int(file.readline().strip())
        notes = []
        for _ in range(n):
            x, y = map(int, file.readline().split())
            notes.append((x, y))
    return notes

# Write the maximum score to the output file
def write_output_file(filename, score):
    with open(filename, 'w') as file:
        file.write(str(score) + '\n')

# Read notes from the input file
notes = read_input_file('partitura.in')

# Calculate the maximum melody score
max_score = calculate_max_score(notes)

# Write the maximum score to the output file
write_output_file('partitura.out', max_score)
```
---------- user ----------


Expected program to write result to `partitura.out` and read from `partitura.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
# Function to read the input file and return a list of notes with their durations and heights
def read_notes(input_file):
    with open(input_file, 'r') as file:
        n = int(file.readline().strip())
        notes = []
        for _ in range(n):
            x, y = map(int, file.readline().split())
            notes.append((x, y))
    return notes

# Function to calculate the maximum score of a melody given notes with durations and heights
def calculate_max_score(notes):
    # Initialize a dictionary to hold the sum of heights for notes with the same duration
    duration_to_height = {}
    for x, y in notes:
        duration = 1 / (2**x)
        if duration in duration_to_height:
            duration_to_height[duration] += y
        else:
            duration_to_height[duration] = y

    # Calculate the score
    score = 0
    # Process the durations from smallest to largest
    for duration in sorted(duration_to_height.keys()):
        # Calculate the number of notes with the current duration that fit in a whole note
        num_notes = 1 / duration
        while duration_to_height[duration] >= num_notes:
            # Add the score for the current group of notes
            score += (duration_to_height[duration] // num_notes)**2
            # Subtract the height of the current group from the total height
            duration_to_height[duration] %= num_notes

    return score

# Function to write the maximum score to the output file
def write_score(output_file, score):
    with open(output_file, 'w') as file:
        file.write(str(score))

# Read notes from the input file
notes = read_notes('partitura.in')

# Calculate the maximum score of the melody
max_score = calculate_max_score(notes)

# Write the maximum score to the output file
write_score('partitura.out', max_score)
```
```
