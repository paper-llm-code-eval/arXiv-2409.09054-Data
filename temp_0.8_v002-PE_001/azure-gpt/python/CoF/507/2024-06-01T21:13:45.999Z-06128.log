---------- user ----------

Here is a programming challenge.
Please solve this problem efficiently, optimizing both time and memory usage.
Create the most efficient solution for this challenge in python. Utilize numpy and other highly efficient libraries whenever possible.
This problem has a memory limit of ~8MB so please be sensitive on using memory. Using too much memory may result in OOM.
The code must compile and be correct.
The solution must read from `partitura.in` and write to `partitura.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

~[partitura.png|align=right|width=25%]

Mihai s-a decis în sfârșit să compună o melodie. Fără să știe de unde să înceapă, a scris pe o foaie $n$ note muzicale. Fiecare notă muzicală este definită de două valori reprezentând durata și înălțimea acesteia astfel:
* **durata** este exprimată printr-o fracție de forma $\displaystyle \frac{1}{2^x}$, unde $x$ este un număr natural nenul;
* **înălțimea** este exprimată printr-un număr natural nenul $y$.

Durata unui grup de note este egală cu suma duratelor notelor din grup. Pentru a compune o melodie corect din punct de vedere muzical, el trebuie să distribuie toate notele în grupuri disjuncte, astfel încât durata fiecărui grup să fie $1$. Mihai definește **scorul unui grup** de note ca fiind suma înălțimilor tuturor notelor din grup, ridicată la pătrat. De asemenea, el definește **scorul unei melodii** ca fiind suma scorurilor tuturor grupurilor de note formate
care pot forma un grup.

Mihai vrea să afle care este scorul maxim al unei melodii pe care îl poate obține după gruparea tuturor notelor date.

# Cerință

Dându-se $n$ note sub forma a $n$ perechi de numere, $x$ și $y$, să se afișeze scorul maxim ce poate fi obținut după gruparea tuturor notelor date în grupuri disjuncte.

# Date de intrare

Fișierul de intrare `partitura.in` va conține pe prima linie un număr natural $n$, reprezentând numărul de note, iar pe următoarele $n$ linii se vor afla câte două numere naturale $x$ și $y$ separate prin câte un spațiu, cu semnificația din enunț, pentru fiecare din cele $n$ note.

# Date de ieșire

Fișierul de ieșire `partitura.out` va conține un singur număr natural reprezentând scorul maxim cerut.

# Restricții și precizări
* $1 \leq n \leq 300 \ 000$;
* $1 \leq x \leq 18$;
* $1 \leq y \leq 10 \ 000$;
* Se garantează că se pot distribui toate notele date în grupuri de durată $1$.
* Pentru $20$ de puncte, $n \leq 4$, $x = 1$;
* Pentru $22$ de puncte, $x = 1$;
* Pentru $17$ puncte, pentru toate notele, $x$ are aceeași valoare;
* Pentru $41$ de puncte, nu există restricții suplimentare.

---

Example:
`partitura.in`
```
5
2 3
3 2
2 1
2 2
3 5
```

`partitura.out`
```
169
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```markdown
```python
import numpy as np
from collections import defaultdict

# Read input data
with open('partitura.in', 'r') as file:
    n = int(file.readline().strip())
    notes = [tuple(map(int, line.strip().split())) for line in file]

# Sort notes by duration (x) in descending order
notes.sort(key=lambda note: note[0], reverse=True)

# Initialize a dictionary to store the sums of pitches for each duration
pitch_sums = defaultdict(int)

# Initialize variables for the result and the current sum of pitches
max_score = 0
current_sum = 0

# Process each note
for x, y in notes:
    duration = 1 / (2 ** x)
    # Update pitch sums for the corresponding duration
    pitch_sums[duration] += y
    # Find the largest duration that still needs pitches to complete a group
    for dur in sorted(pitch_sums.keys(), reverse=True):
        # Check if the current duration can complete any group
        while pitch_sums[dur] >= dur:
            # Complete the group and update the score
            pitch_sums[dur] -= dur
            current_sum += dur * (2 ** x)  # Convert duration back to pitch
            max_score += current_sum ** 2
            current_sum = 0

# Write the result to the output file
with open('partitura.out', 'w') as file:
    file.write(str(max_score))
```
```
---------- user ----------


Expected program to write result to `partitura.out` and read from `partitura.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

def read_notes(filename):
    with open(filename, 'r') as file:
        n = int(file.readline().strip())
        notes = [list(map(int, line.strip().split())) for line in file]
    return np.array(notes, dtype=np.int)

def calculate_score(notes):
    # Sort notes by pitch (y) in descending order since we want to maximize score
    notes = notes[notes[:, 1].argsort()[::-1]]

    # Initialize the score
    score = 0
    # Initialize a list to keep track of durations that need to be paired
    durations_needed = []

    # Process each note
    for x, y in notes:
        duration = 1 / (2 ** x)
        pitch = y
        # Check if we can pair this with an existing duration that is needed
        found_pair = False
        for i, dur in enumerate(durations_needed):
            if duration + dur <= 1:
                durations_needed[i] += duration
                score += 2 * pitch ** 2  # since pitch is added to both the notes in the pair
                found_pair = True
                if durations_needed[i] == 1:
                    # If the group is complete, remove it from the list
                    durations_needed.pop(i)
                break
        # If this duration couldn't be paired, add it to the list of durations that need a pair
        if not found_pair:
            durations_needed.append(duration)
            score += pitch ** 2  # only one pitch in the group

    return score

def write_score(filename, score):
    with open(filename, 'w') as file:
        file.write(str(score))

# Read notes from the input file
notes = read_notes('partitura.in')
# Calculate the maximum score
max_score = calculate_score(notes)
# Write the maximum score to the output file
write_score('partitura.out', max_score)
```
```
---------- user ----------


Expected program to write result to `partitura.out` and read from `partitura.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
from collections import defaultdict

# Function to calculate the maximum score efficiently
def calculate_max_score(notes):
    # Store partial sums of pitches with the same duration in a dictionary
    duration_groups = defaultdict(int)
    # Variable to keep the total score
    total_score = 0

    # Process each note and group by duration
    for duration, pitch in notes:
        duration = 2 ** -duration  # Convert x to actual duration
        duration_groups[duration] += pitch  # Add the pitch to the corresponding group

        # Merge groups if possible
        while duration <= 1:
            if duration_groups[duration] >= 1:
                total_score += (duration_groups[duration] ** 2)
                duration_groups[duration] -= 1
            else:
                break

            duration *= 2

    return total_score

# Read notes from the input file
def read_notes_from_file(filename):
    with open(filename, 'r') as file:
        n = int(file.readline().strip())
        notes = [tuple(map(int, line.strip().split())) for line in file]
    return notes

# Write the score to the output file
def write_score_to_file(filename, score):
    with open(filename, 'w') as file:
        file.write(str(score))

# Read the notes from 'partitura.in'
notes = read_notes_from_file('partitura.in')
# Calculate the maximum score
max_score = calculate_max_score(notes)
# Write the maximum score to 'partitura.out'
write_score_to_file('partitura.out', max_score)
```
```
---------- user ----------


Expected program to write result to `partitura.out` and read from `partitura.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np
from collections import defaultdict

def maximize_score(notes):
    # We will use dynamic programming to maximize the score. The state dp[mask] will store
    # the maximum score achievable with the set of notes represented by the bitmask mask.
    # The bitmask has a bit for each possible duration (1/2, 1/4, 1/8, ..., 1/(2^18)),
    # where bit i corresponds to duration 1/(2^(i+1)). The bit is set if a note with this
    # duration is present, and we can use this note to form a group of duration 1.

    # Maximum bitmask value, each bit from 0 to 17 can be used to represent a duration
    max_mask = 1 << 18

    # Initialize dp array with negative infinity for all values except the starting state
    dp = np.full(max_mask, -np.inf)
    dp[0] = 0  # Starting state, no notes used, score is 0

    # Process each note and update the dp array
    for x, y in notes:
        # Convert the duration to a bitmask
        duration_mask = 1 << (x - 1)
        new_dp = np.copy(dp)
        # Iterate over all possible states/masks
        for mask in range(max_mask):
            # If the current state is reachable
            if dp[mask] > -np.inf:
                # If adding the current note does not exceed a full duration (mask & duration_mask == 0)
                if mask & duration_mask == 0:
                    # Calculate the new mask
                    new_mask = mask | duration_mask
                    # Update the dp value for the new state
                    new_dp[new_mask] = max(new_dp[new_mask], dp[mask] + y ** 2)

                    # If the new mask represents a full duration, reset it and add the score
                    if bin(new_mask).count('1') == 1:  # Only one bit is set
                        new_dp[0] = max(new_dp[0], dp[mask] + y ** 2)
        dp = new_dp

    # The maximum score will be the value at the state where no notes are left to be used
    return int(dp[0])

# Read the notes from 'partitura.in'
with open('partitura.in', 'r') as fin:
    n = int(fin.readline().strip())
    notes = [tuple(map(int, fin.readline().split())) for _ in range(n)]

# Calculate the maximum score
max_score = maximize_score(notes)

# Write the maximum score to 'partitura.out'
with open('partitura.out', 'w') as fout:
    fout.write(str(max_score))
```
```
---------- user ----------


Expected program to write result to `partitura.out` and read from `partitura.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
# Import defaultdict from collections
from collections import defaultdict

# Define the function to calculate the maximum score for the melody
def get_max_score(notes, n):
    # Create a defaultdict to hold the sum of pitches for each duration
    duration_to_pitches = defaultdict(list)
    
    # Initialize the max score to zero
    max_score = 0
    
    # Populate the defaultdict with the pitches for each duration
    for duration, pitch in notes:
        duration_to_pitches[duration].append(pitch)
    
    # Sort the pitches for each duration in decreasing order
    for duration in duration_to_pitches:
        duration_to_pitches[duration].sort(reverse=True)

    # We start creating the groups for the melody
    while n > 0:
        # Initialize sum of pitches and duration for the current group
        current_group_duration = 0
        current_group_sum = 0

        # We keep track of used pitches to remove them after creating a group
        used_pitches = []

        # Try to create a full group with total duration 1
        for duration in sorted(duration_to_pitches.keys()):
            # Calculate the fractional duration
            fractional_duration = 1 / (2 ** duration) 

            # While we can add notes of this duration, add them to the current group
            while duration_to_pitches[duration] and current_group_duration + fractional_duration <= 1:
                pitch = duration_to_pitches[duration].pop()
                current_group_sum += pitch
                current_group_duration += fractional_duration
                used_pitches.append((duration, pitch))
                n -= 1  # We used one note

        # Add the squared sum of pitches to the max score
        max_score += current_group_sum ** 2

        # If we didn't reach a full group, put the used pitches back
        if current_group_duration < 1:
            for duration, pitch in used_pitches:
                duration_to_pitches[duration].append(pitch)
                n += 1  # Return the note back as unused
            break

    return max_score

# Read input data from 'partitura.in'
with open('partitura.in', 'r') as file:
    n = int(file.readline().strip())
    notes = [tuple(map(int, file.readline().split())) for _ in range(n)]

# Calculate the max score
max_score = get_max_score(notes, n)

# Write the result to 'partitura.out'
with open('partitura.out', 'w') as file:
    file.write(str(max_score))
```
```
---------- user ----------


Expected program to write result to `partitura.out` and read from `partitura.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```python
import numpy as np
from collections import defaultdict

# Custom data structure to hold note information and optimize memory usage
class Notes:
    def __init__(self, n):
        self.durations = np.zeros(n, dtype=np.uint8)
        self.heights = np.zeros(n, dtype=np.uint16)

    def add(self, i, duration, height):
        self.durations[i] = duration
        self.heights[i] = height

    def __getitem__(self, item):
        return self.durations[item], self.heights[item]

# Function to read notes from a file and return a Notes object
def read_notes(filename):
    with open(filename, 'r') as file:
        n = int(file.readline().strip())
        notes = Notes(n)
        for i in range(n):
            x, y = map(int, file.readline().split())
            notes.add(i, x, y)
    return notes

# Function to write the result to a file
def write_result(filename, result):
    with open(filename, 'w') as file:
        file.write(str(result))

# Function to calculate the maximum score of a melody
def max_score(notes, n):
    # Sort notes by height in descending order to maximize score when summing heights
    order = np.argsort(-notes.heights)
    sorted_notes = Notes(n)
    for i, idx in enumerate(order):
        x, y = notes[idx]
        sorted_notes.add(i, x, y)

    # Initialize data structures
    duration_counts = defaultdict(int)
    score = 0
    current_group_sum = 0

    # Distribute notes into groups
    for i in range(n):
        x, y = sorted_notes[i]
        duration = 1 / (2 ** x)
        duration_counts[duration] += 1
        current_group_sum += y
        # Check if we can form a group
        while duration_counts[duration] >= 1 and duration <= 1:
            duration_counts[duration] -= 1
            duration *= 2
        if duration > 1:
            # We have completed a group and can calculate the score
            score += current_group_sum ** 2
            current_group_sum = 0
            duration_counts.clear()

    return score

# Read the notes
notes = read_notes('partitura.in')
# Calculate the maximum score
result = max_score(notes, len(notes.heights))
# Write the result to 'partitura.out'
write_result('partitura.out', result)
```
---------- user ----------


Program exited with code 1.
stdout:
```

```
stderr:
```
Traceback (most recent call last):
  File "/app/app.py", line 1, in <module>
    import numpy as np
ModuleNotFoundError: No module named 'numpy'

```

Think of what has caused the exit code. Use the standard out and standard error to help you understand the issue.
Implement a solution to fix the program

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```python
from collections import defaultdict

# Function to calculate the maximum score of a melody
def max_score(notes):
    # Dictionary to hold the total duration for each power of two
    durations = defaultdict(int)
    # Dictionary to hold the score of complete groups
    scores = defaultdict(int)
    # Total score
    total_score = 0

    # Add each note's duration and height to the dictionaries
    for x, y in notes:
        power_of_two = 2 ** x
        durations[power_of_two] += 1 / power_of_two
        scores[power_of_two] += y

        # Check if we have completed a group and if so, add its score to the total
        if durations[power_of_two] == 1:
            # Reset the duration for this power of two
            durations[power_of_two] = 0
            # Add the score for this group to the total score
            total_score += scores[power_of_two] ** 2
            # Reset the score for this power of two
            scores[power_of_two] = 0

    return total_score

# Function to read notes from 'partitura.in'
def read_notes_from_file(filename):
    with open(filename, 'r') as file:
        n = int(file.readline().strip())
        notes = [tuple(map(int, file.readline().split())) for _ in range(n)]
    return notes

# Function to write the score to 'partitura.out'
def write_score_to_file(filename, score):
    with open(filename, 'w') as file:
        file.write(str(score))

# Read the notes from 'partitura.in'
notes = read_notes_from_file('partitura.in')
# Calculate the maximum score
max_score = max_score(notes)
# Write the maximum score to 'partitura.out'
write_score_to_file('partitura.out', max_score)
```
