---------- user ----------

Here is a programming challenge.
Please solve this problem efficiently, optimizing both time and memory usage.
Create the most efficient solution for this challenge in python. Utilize numpy and other highly efficient libraries whenever possible.
This problem has a memory limit of ~8MB so please be sensitive on using memory. Using too much memory may result in OOM.
The code must compile and be correct.
The solution must read from `permutare.in` and write to `permutare.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Definim o permutare dublă de ordin `n` ca fiind un șir format din primele `2n` numere naturale nenule:
$(a_1, a_2, ... , a_n, a_{n+1}, a_{n+2}, ... , a_{2n})$. Această permutare dublă este de trei ori în creștere, dacă sunt adevărate următoarele trei proprietăți:
1. secvența formată din primele `n` elemente este crescătoare: $a_1 < a_2 < ... < a_n$
2. secvența formată din ultimele `n` elemente este crescătoare: $a_{n+1} < a_{n+2} < ... < a_{2n}$
3. perechile ordonate formate din elementele aflate pe poziții identice ale celor două secvențe sunt de asemenea în ordine crescătoare: $a_1 < a_{n+1}, a_2 < a_{n+2}, ... , a_n < a_{2n}$.

De exemplu permutarea `(1,3,4,2,5,6)` este o permutare dublă de ordin `3`, de trei ori în creștere, pentru că secvențele `(1,3,4)` și `(2,5,6)` formează șiruri crescătoare, iar toate perechile formate din elementele de pe poziții identice: `(1,2), (3,5), (4,6)` formează de asemenea șiruri crescătoare.

Următoarele permutări duble nu au proprietatea de trei ori în creștere:
`(1,4,3,2,5,6)` – secvența `(1,4,3)` nu este crescătoare,
`(1,3,4,2,6,5)` - secvența `(2,6,5)` nu este crescătoare,
`(1,4,5,2,3,6)` – perechea `(4,3)` nu este crescătoare.

Pentru simplificare în continuare permutarea dublă de trei ori în creștere se va numi permutare.

Vom considera toate permutările de ordin n ordonate lexicografic, numerotate începând cu `1`. Tabelul de mai jos conține datele pentru n=3:
poziție	permutare
| poziție 	| permutare   	|
|---------	|-------------	|
| 1       	| 1 2 3 4 5 6 	|
| 2       	| 1 2 4 3 5 6 	|
| 3       	| 1 2 5 3 4 6 	|
| 4       	| 1 3 4 2 5 6 	|
| 5       	| 1 3 5 2 4 6 	|

Există două tipuri de întrebări:
1. Ce permutare se află pe o poziție dată? 
2. Pe ce poziție se află o permutare dată?

Prima întrebare este codificată astfel: `1 n p` și se compune din valorile 
`1` – tipul întrebării, 
`n` – ordinul permutării, 
`p` – poziția permutării cerute.

A doua întrebare este codificată astfel: $2 n a_1 a_2 ... a_{2n}$ și se compune din valorile 
`2` – tipul întrebării, 
`n` – ordinul permutării, 
$a_1 a_2 ... a_{2n}$ – elementele permutării.

# Exemple
Întrebarea  `1 3 2` înseamnă:
“Ce permutare de ordin `3` se află pe poziția `2` în ordine lexicografică?”  și are răspunsul: `1 2 4 3 5 6`.
Întrebarea  `2 3 1 3 5 2 4 6`  înseamnă:
“Pe ce poziție se află permutarea de ordin `3`: `1 3 5 2 4 6`?” și are răspunsul: `5`.

# Cerința
Să se răspundă corect la un set de întrebări.

# Date de intrare
Fișierul `permutare.in` conține pe fiecare linie câte o întrebare de orice tip.

# Date de ieșire
Fișierul `permutare.out` va conține pe câte o linie câte un răspuns la fiecare întrebare din fișierul de intrare, în ordinea întrebărilor.

# Restricții și precizări
* `2 < n < 1 000`;
* `0 < p ≤ 1 000 000 000` (în cazul întrebărilor de tip `1`);
* răspunsul la întrebările de tip `2` este `≤  1 000 000 000`;
* fișierele de intrare vor conține cel mult `2000` de întrebări;
* pentru teste în valoare de `20` de puncte numărul de întrebări va fi `1000` iar numerele de ordine ce intervin în calcule vor fi mai mici decât `5000`;
* pentru teste în valoare de `30` de puncte întrebările vor fi de tipul `1`;
* pentru teste în valoare de `30` de puncte întrebările vor fi de tipul `2`;
* pentru teste în valoare de `30` de puncte întrebările vor fi mixte.
* problema va fi evaluată pe teste in valoare de `90` de puncte.
* se vor acorda `10` puncte din oficiu.

---

Example:
`permutare.in`
```
1 3 2
2 3 1 3 5 2 4 6
1 4 1
2 4 1 2 3 4 5 6 7 8	
```

`permutare.out`
```
1 2 4 3 5 6
5
1 2 3 4 5 6 7 8
1
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```markdown
```python
import numpy as np
from math import factorial

# Read the data from the input file
with open('permutare.in', 'r') as file:
    queries = file.readlines()

# Function to find the nth permutation of a given sequence
def nth_permutation(sequence, n):
    sequence = np.array(sequence)
    permutation = []
    while sequence.size > 0:
        f = factorial(sequence.size - 1)
        index = n // f
        n %= f
        permutation.append(sequence[index])
        sequence = np.delete(sequence, index)
    return permutation

# Function to find the position of a given permutation
def permutation_position(sequence, permutation):
    sequence = np.array(sequence)
    permutation = np.array(permutation)
    n = permutation.size
    position = 0
    for i in range(n):
        rank = np.sum(sequence < permutation[i])
        position += rank * factorial(n - i - 1)
        sequence = sequence[sequence != permutation[i]]
    return position

# Write the results to the output file
with open('permutare.out', 'w') as file:
    for query in queries:
        parts = list(map(int, query.strip().split(' ')))
        if parts[0] == 1:
            # Query type 1
            n = parts[1]
            p = parts[2] - 1
            # Generate the lexicographically sorted sequence for the given n
            sequence = np.r_[1:n+1, 1:n+1]
            # Find the nth permutation
            result = nth_permutation(sequence, p)
            file.write(' '.join(map(str, result)) + '\n')
        elif parts[0] == 2:
            # Query type 2
            n = parts[1]
            perm = parts[2:]
            # Generate the lexicographically sorted sequence for the given n
            sequence = np.r_[1:n+1, 1:n+1]
            # Find the position of the permutation
            position = permutation_position(sequence, perm) + 1
            file.write(str(position) + '\n')
```
```
---------- user ----------


Expected program to write result to `permutare.out` and read from `permutare.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np
from itertools import permutations
from math import factorial

def calculate_double_permutations(n):
    # Generate base permutations for a single sequence
    single_sequence = list(range(1, n + 1))
    base_perms = list(permutations(single_sequence))
    # Create double permutations based on base permutations
    double_perms = [perm1 + perm2 for perm1 in base_perms for perm2 in base_perms if all(perm1[i] < perm2[i] for i in range(n))]
    return double_perms

def find_permutation_at_position(n, p):
    double_perms = calculate_double_permutations(n)
    return double_perms[p-1]

def find_position_of_permutation(n, perm):
    double_perms = calculate_double_permutations(n)
    return double_perms.index(perm) + 1

def process_queries(queries):
    results = []
    for query in queries:
        parts = query.strip().split()
        q_type = int(parts[0])
        n = int(parts[1])
        if q_type == 1:
            p = int(parts[2])
            perm = find_permutation_at_position(n, p)
            results.append(' '.join(map(str, perm)))
        elif q_type == 2:
            perm = tuple(map(int, parts[2:]))
            pos = find_position_of_permutation(n, perm)
            results.append(str(pos))
    return results

# Read the data from the input file
with open('permutare.in', 'r') as file:
    queries = file.readlines()

# Process queries and get results
results = process_queries(queries)

# Write the results to the output file
with open('permutare.out', 'w') as file:
    file.write('\n'.join(results))
```
```
---------- user ----------


Expected program to write result to `permutare.out` and read from `permutare.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np
from scipy.special import comb

# Efficient functions for factorial and inverse modulo
fact = np.vectorize(np.math.factorial)
modinv = np.vectorize(lambda x, m: pow(x, m-2, m))

# Constants
MOD = 10**9

# Precompute factorials and modular inverses for efficient computation
max_n = 1000
factorials = fact(np.arange(max_n*2+1)) % MOD
inv_factorials = modinv(factorials, MOD)

# Efficient function to compute nCr modulo MOD
def nCr_mod(n, r, mod=MOD):
    return (factorials[n] * inv_factorials[r] * inv_factorials[n-r]) % mod

# Function to decode the position to permutation
def decode_position(n, pos):
    pos -= 1  # Make position zero-indexed
    permutation = []
    available = set(range(1, n+1))
    for i in range(n, 0, -1):
        count = 0
        for num in sorted(available):
            combos = nCr_mod(i-1, n-i)
            if count + combos >= pos:
                permutation.append(num)
                available.remove(num)
                break
            count += combos
        pos -= count
    return permutation + sorted(available)

# Function to encode permutation to its position
def encode_permutation(perm):
    n = len(perm) // 2
    position = 1  # One-indexed
    available = set(range(1, n+1))
    for i, val in enumerate(perm[:n]):
        for smaller in sorted(available):
            if smaller == val:
                available.remove(val)
                break
            position += nCr_mod(n-i-1, n-i-1)
    return position

# Read queries from file, process them, and write results to another file
with open('permutare.in', 'r') as infile, open('permutare.out', 'w') as outfile:
    for line in infile:
        query = list(map(int, line.split()))
        if query[0] == 1:
            n, p = query[1], query[2]
            perm = decode_position(n, p)
            outfile.write(' '.join(map(str, perm)) + ' ' + ' '.join(map(str, sorted(perm))) + '\n')
        else:
            n, perm = query[1], query[2:]
            position = encode_permutation(perm)
            outfile.write(str(position) + '\n')
```
```
---------- user ----------


Expected program to write result to `permutare.out` and read from `permutare.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np
from math import factorial

# Helper function to find the rank of a permutation
def find_rank(n, perm):
    rank = 0
    multiplier = factorial(n)
    for i in range(n):
        multiplier //= n - i
        count = 0
        # Count elements smaller than perm[i] in perm[i+1:]
        for j in range(i+1, n):
            if perm[j] < perm[i]:
                count += 1
        rank += count * multiplier
    return rank

# Helper function to generate a permutation given its rank
def unrank(n, rank):
    perm = np.zeros(n, dtype=int)
    elements = list(range(1, n + 1))
    
    multiplier = factorial(n)
    for i in range(n):
        multiplier //= n - i
        index, rank = divmod(rank, multiplier)
        perm[i] = elements.pop(index)
    
    return perm

# Process query of type 1
def process_query_type_1(n, pos):
    # Divide the position by 2 to handle double permutation
    pos = (pos - 1) // 2
    first_half_perm = unrank(n, pos)
    second_half_perm = np.setdiff1d(np.arange(1, n*2+1), first_half_perm, assume_unique=True)
    return np.concatenate([first_half_perm, second_half_perm])

# Process query of type 2
def process_query_type_2(perm):
    n = len(perm) // 2
    first_half_rank = find_rank(n, perm[:n])
    second_half_rank = find_rank(n, perm[n:] - n)
    # Combine the two ranks to get the final position
    return first_half_rank * factorial(n) + second_half_rank + 1

# Read from input file and write to output file
with open('permutare.in', 'r') as file_in, open('permutare.out', 'w') as file_out:
    for line in file_in:
        query = list(map(int, line.strip().split()))
        if query[0] == 1:
            # Query type 1: Find the permutation at a given position
            n, pos = query[1:]
            permutation = process_query_type_1(n, pos)
            file_out.write(' '.join(map(str, permutation)) + '\n')
        else:
            # Query type 2: Find the position of a given permutation
            n = query[1]
            permutation = np.array(query[2:])
            position = process_query_type_2(permutation)
            file_out.write(str(position) + '\n')
```
```
---------- user ----------


Expected program to write result to `permutare.out` and read from `permutare.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np
from math import factorial

# Helper function to generate a factorial lookup
def generate_factorial_lookup(max_n):
    fact_lookup = np.zeros(max_n+1, dtype=np.int64)
    fact_lookup[0] = 1
    for i in range(1, max_n + 1):
        fact_lookup[i] = (fact_lookup[i-1] * i)
    return fact_lookup

# Helper function to calculate the permutation at a given position
def permutation_at_position(n, p, factorial_lookup):
    numbers = list(range(1, n+1))
    permutation = []
    p -= 1  # Convert to 0-based index
    for i in range(n, 0, -1):
        f = factorial_lookup[i - 1]
        index = p // f
        p %= f
        permutation.append(numbers.pop(index))
    return permutation

# Helper function to calculate the position of a given permutation
def position_of_permutation(perm, factorial_lookup):
    n = len(perm)
    position = 1
    for i in range(n):
        position += perm[i] * factorial_lookup[n - 1 - i]
        for j in range(i+1, n):
            if perm[j] > perm[i]:
                perm[j] -= 1
    return position

# Read from input file and write to output file
with open('permutare.in', 'r') as file_in, open('permutare.out', 'w') as file_out:
    queries = file_in.readlines()
    factorial_lookup = generate_factorial_lookup(2*1000)  # n is less than 1000 as per the restrictions

    for query in queries:
        parts = list(map(int, query.strip().split()))
        q_type = parts[0]
        n = parts[1]

        if q_type == 1:
            # Query type 1: Find the permutation at a given position
            p = parts[2]
            first_half = permutation_at_position(n, (p + 1) // 2, factorial_lookup)
            second_half = permutation_at_position(n, (p + 2) // 2, factorial_lookup)
            permutation = first_half + [x + n for x in second_half]
            file_out.write(' '.join(map(str, permutation)) + '\n')
        elif q_type == 2:
            # Query type 2: Find the position of a given permutation
            perm = parts[2:]
            first_half = perm[:n]
            second_half = [x - n for x in perm[n:]]
            position_first_half = position_of_permutation(first_half, factorial_lookup)
            position_second_half = position_of_permutation(second_half, factorial_lookup)
            position = (position_first_half - 1) * factorial(n) + position_second_half
            file_out.write(str(position) + '\n')
```
```
---------- user ----------


Expected program to write result to `permutare.out` and read from `permutare.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np
from itertools import permutations

# Function to calculate the factorial of a number
def factorial(n):
    result = 1
    for i in range(2, n + 1):
        result *= i
    return result

# Function to calculate the rank of a permutation
def permutation_rank(perm, n):
    rank = 1
    for i in range(n):
        smaller_count = sum(val < perm[i] for val in perm[i+1:])
        rank += smaller_count * factorial(n - i - 1)
    return rank

# Function to return the k-th permutation of a list
def kth_permutation(lst, k):
    n = len(lst)
    k -= 1  # Convert to 0-based index
    perm = []
    elements = lst[:]
    while n > 0:
        n -= 1
        fact_n = factorial(n)
        index = k // fact_n
        k %= fact_n
        perm.append(elements.pop(index))
    return perm

# Read from input file and write to output file
with open('permutare.in', 'r') as file_in, open('permutare.out', 'w') as file_out:
    for line in file_in:
        parts = list(map(int, line.strip().split()))
        query_type = parts[0]
        n = parts[1]

        if query_type == 1:
            # Find permutation at given position
            position = parts[2]
            all_numbers = list(range(1, n + 1))
            all_perms = sorted(permutations(all_numbers))
            first_half = kth_permutation(all_perms, (position + 1) // 2)
            second_half = kth_permutation(all_perms, (position + 2) // 2)
            permutation = list(first_half) + list(second_half)
            file_out.write(' '.join(map(str, permutation)) + '\n')
        else:
            # Find position of a given permutation
            permutation = parts[2:]
            first_half = permutation[:n]
            second_half = permutation[n:]
            rank_first = permutation_rank(first_half, n)
            rank_second = permutation_rank(second_half, n)
            position = (rank_first - 1) * factorial(n) + rank_second
            file_out.write(str(position) + '\n')
```
```
---------- user ----------


Expected program to write result to `permutare.out` and read from `permutare.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
from math import factorial

# Function to generate the kth permutation of n elements
def get_permutation(n, k):
    numbers = list(range(1, n + 1))
    permutation = []
    k -= 1 # Convert to zero-indexed
    for i in range(n, 0, -1):
        f = factorial(i - 1)
        index = k // f
        k %= f
        permutation.append(numbers.pop(index))
    return permutation

# Function to get the position of a permutation
def get_position(n, perm):
    position = 0
    factor = 1
    numbers = list(range(1, n + 1))
    for i in range(n - 1, -1, -1):
        num = perm[i]
        numbers.remove(num)
        rank = numbers.index(num) if num in numbers else 0
        position += rank * factor
        factor *= (n - i)
    return position + 1

# Process queries from the file
def process_queries(queries):
    results = []
    for query in queries:
        parts = list(map(int, query.split()))
        q_type, n = parts[:2]
        if q_type == 1:
            # Find the permutation at the given position
            k = parts[2]
            results.append(get_permutation(n, k))
        elif q_type == 2:
            # Find the position of the given permutation
            perm = parts[2:]
            results.append(get_position(n, perm))
    return results

# Read from "permutare.in" and write to "permutare.out"
with open('permutare.in', 'r') as file_in:
    queries = file_in.readlines()

# Process the queries to get the results
results = process_queries(queries)

# Write the results to "permutare.out"
with open('permutare.out', 'w') as file_out:
    for result in results:
        if isinstance(result, list):
            file_out.write(' '.join(map(str, result)) + '\n')
        else:
            file_out.write(str(result) + '\n')
```
```
