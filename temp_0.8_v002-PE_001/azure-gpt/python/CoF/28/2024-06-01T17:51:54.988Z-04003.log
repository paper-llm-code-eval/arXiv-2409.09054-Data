---------- user ----------

Here is a programming challenge.
Please solve this problem efficiently, optimizing both time and memory usage.
Create the most efficient solution for this challenge in python. Utilize numpy and other highly efficient libraries whenever possible.
This problem has a memory limit of ~8MB so please be sensitive on using memory. Using too much memory may result in OOM.
The code must compile and be correct.
The solution must read from `permutare.in` and write to `permutare.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Definim o permutare dublă de ordin `n` ca fiind un șir format din primele `2n` numere naturale nenule:
$(a_1, a_2, ... , a_n, a_{n+1}, a_{n+2}, ... , a_{2n})$. Această permutare dublă este de trei ori în creștere, dacă sunt adevărate următoarele trei proprietăți:
1. secvența formată din primele `n` elemente este crescătoare: $a_1 < a_2 < ... < a_n$
2. secvența formată din ultimele `n` elemente este crescătoare: $a_{n+1} < a_{n+2} < ... < a_{2n}$
3. perechile ordonate formate din elementele aflate pe poziții identice ale celor două secvențe sunt de asemenea în ordine crescătoare: $a_1 < a_{n+1}, a_2 < a_{n+2}, ... , a_n < a_{2n}$.

De exemplu permutarea `(1,3,4,2,5,6)` este o permutare dublă de ordin `3`, de trei ori în creștere, pentru că secvențele `(1,3,4)` și `(2,5,6)` formează șiruri crescătoare, iar toate perechile formate din elementele de pe poziții identice: `(1,2), (3,5), (4,6)` formează de asemenea șiruri crescătoare.

Următoarele permutări duble nu au proprietatea de trei ori în creștere:
`(1,4,3,2,5,6)` – secvența `(1,4,3)` nu este crescătoare,
`(1,3,4,2,6,5)` - secvența `(2,6,5)` nu este crescătoare,
`(1,4,5,2,3,6)` – perechea `(4,3)` nu este crescătoare.

Pentru simplificare în continuare permutarea dublă de trei ori în creștere se va numi permutare.

Vom considera toate permutările de ordin n ordonate lexicografic, numerotate începând cu `1`. Tabelul de mai jos conține datele pentru n=3:
poziție	permutare
| poziție 	| permutare   	|
|---------	|-------------	|
| 1       	| 1 2 3 4 5 6 	|
| 2       	| 1 2 4 3 5 6 	|
| 3       	| 1 2 5 3 4 6 	|
| 4       	| 1 3 4 2 5 6 	|
| 5       	| 1 3 5 2 4 6 	|

Există două tipuri de întrebări:
1. Ce permutare se află pe o poziție dată? 
2. Pe ce poziție se află o permutare dată?

Prima întrebare este codificată astfel: `1 n p` și se compune din valorile 
`1` – tipul întrebării, 
`n` – ordinul permutării, 
`p` – poziția permutării cerute.

A doua întrebare este codificată astfel: $2 n a_1 a_2 ... a_{2n}$ și se compune din valorile 
`2` – tipul întrebării, 
`n` – ordinul permutării, 
$a_1 a_2 ... a_{2n}$ – elementele permutării.

# Exemple
Întrebarea  `1 3 2` înseamnă:
“Ce permutare de ordin `3` se află pe poziția `2` în ordine lexicografică?”  și are răspunsul: `1 2 4 3 5 6`.
Întrebarea  `2 3 1 3 5 2 4 6`  înseamnă:
“Pe ce poziție se află permutarea de ordin `3`: `1 3 5 2 4 6`?” și are răspunsul: `5`.

# Cerința
Să se răspundă corect la un set de întrebări.

# Date de intrare
Fișierul `permutare.in` conține pe fiecare linie câte o întrebare de orice tip.

# Date de ieșire
Fișierul `permutare.out` va conține pe câte o linie câte un răspuns la fiecare întrebare din fișierul de intrare, în ordinea întrebărilor.

# Restricții și precizări
* `2 < n < 1 000`;
* `0 < p ≤ 1 000 000 000` (în cazul întrebărilor de tip `1`);
* răspunsul la întrebările de tip `2` este `≤  1 000 000 000`;
* fișierele de intrare vor conține cel mult `2000` de întrebări;
* pentru teste în valoare de `20` de puncte numărul de întrebări va fi `1000` iar numerele de ordine ce intervin în calcule vor fi mai mici decât `5000`;
* pentru teste în valoare de `30` de puncte întrebările vor fi de tipul `1`;
* pentru teste în valoare de `30` de puncte întrebările vor fi de tipul `2`;
* pentru teste în valoare de `30` de puncte întrebările vor fi mixte.
* problema va fi evaluată pe teste in valoare de `90` de puncte.
* se vor acorda `10` puncte din oficiu.

---

Example:
`permutare.in`
```
1 3 2
2 3 1 3 5 2 4 6
1 4 1
2 4 1 2 3 4 5 6 7 8	
```

`permutare.out`
```
1 2 4 3 5 6
5
1 2 3 4 5 6 7 8
1
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```markdown
```python
import numpy as np
from math import factorial as fact
from itertools import permutations as perm

# Function to find nth permutation
def find_perm(n, k):
    nums = list(range(1, n + 1))
    ans = []
    k -= 1  # Convert to 0-based index
    while n:
        n -= 1
        # Find the index of current number
        index, k = divmod(k, fact(n))
        ans.append(nums.pop(index))
    return ans

# Function to find rank of a given permutation
def find_rank(n, perm):
    nums = list(range(1, n + 1))
    rank = 1
    for i in range(n):
        pos = nums.index(perm[i])
        rank += pos * fact(n - i - 1)
        nums.pop(pos)
    return rank

# Main function to process each query
def process_query(query):
    q_type = query[0]
    n = query[1]

    if q_type == 1:  # Find the permutation
        p = query[2]
        first_half = find_perm(n, (p - 1) // fact(n) + 1)
        second_half = find_perm(n, ((p - 1) % fact(n)) + 1)
        return first_half + second_half

    elif q_type == 2:  # Find the rank of the permutation
        first_half = query[2:2 + n]
        second_half = query[2 + n:]
        rank1 = find_rank(n, first_half)
        rank2 = find_rank(n, second_half)
        return (rank1 - 1) * fact(n) + rank2

# Read from 'permutare.in', process queries, and write to 'permutare.out'
with open('permutare.in', 'r') as f_in:
    queries = [list(map(int, line.strip().split())) for line in f_in]

results = []
for query in queries:
    result = process_query(query)
    results.append(result)

with open('permutare.out', 'w') as f_out:
    for result in results:
        if isinstance(result, list):
            f_out.write(' '.join(map(str, result)) + '\n')
        else:
            f_out.write(str(result) + '\n')
```
```
---------- user ----------


Expected program to write result to `permutare.out` and read from `permutare.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np
from math import factorial as fact

# Function to generate the kth permutation of n numbers
def kth_permutation(n, k):
    sequence = list(range(1, n + 1))
    permutation = []
    k -= 1  # Convert to 0-based index
    for i in range(n, 0, -1):
        factorial = fact(i - 1)
        index = k // factorial
        k %= factorial
        permutation.append(sequence.pop(index))
    return permutation

# Function to find the rank of a given permutation
def permutation_rank(n, perm):
    sequence = list(range(1, n + 1))
    rank = 1
    factorial = fact(n)
    for i in range(n):
        factorial //= (n - i)
        rank += factorial * sequence.index(perm[i])
        sequence.remove(perm[i])
    return rank

# Main function to process each query
def process_queries(queries):
    results = []
    for query in queries:
        q_type, n = query[0], query[1]
        if q_type == 1:  # Find the permutation at position p
            p = query[2]
            first_half = kth_permutation(n, (p - 1) // fact(n) + 1)
            second_half = kth_permutation(n, ((p - 1) % fact(n)) + 1)
            results.append(first_half + second_half)
        elif q_type == 2:  # Find the position of a given permutation
            perm = np.array(query[2:]).reshape(2, n).T
            # Verify if the permutation is valid
            if not (np.all(perm[:, 0] < perm[:, 1]) and np.all(np.diff(perm[:, 0]) > 0) and np.all(np.diff(perm[:, 1]) > 0)):
                raise ValueError("Invalid permutation")
            first_half_rank = permutation_rank(n, perm[:, 0].tolist())
            second_half_rank = permutation_rank(n, perm[:, 1].tolist())
            results.append((first_half_rank - 1) * fact(n) + second_half_rank)
    return results

# Read from 'permutare.in' and write to 'permutare.out'
with open('permutare.in', 'r') as file_in:
    queries = [[int(num) for num in line.split()] for line in file_in]

results = process_queries(queries)

with open('permutare.out', 'w') as file_out:
    for result in results:
        if isinstance(result, list):
            file_out.write(' '.join(map(str, result)) + '\n')
        else:
            file_out.write(str(result) + '\n')
```
```
---------- user ----------


Expected program to write result to `permutare.out` and read from `permutare.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
from math import factorial as fact

# Function to generate the kth permutation of n numbers
def kth_permutation(n, k):
    sequence = list(range(1, n + 1))
    permutation = []
    k -= 1  # Convert to 0-based index
    for i in range(n, 0, -1):
        factorial = fact(i - 1)
        index = k // factorial
        k %= factorial
        permutation.append(sequence.pop(index))
    return permutation

# Function to find the rank of a given permutation
def permutation_rank(n, perm):
    sequence = list(range(1, n + 1))
    rank = 0
    for i in range(n):
        rank *= len(sequence)
        rank += sequence.index(perm[i])
        sequence.remove(perm[i])
    return rank + 1

# Main function to process each query
def process_query(query):
    q_type, n = query[0], query[1]
    if q_type == 1:  # Find the permutation at position p
        p = query[2]
        first_half = kth_permutation(n, (p - 1) // fact(n) + 1)
        second_half = kth_permutation(n, ((p - 1) % fact(n)) + 1)
        return first_half + second_half
    elif q_type == 2:  # Find the position of a given permutation
        first_half, second_half = query[2:2 + n], query[2 + n:]
        first_half_rank = permutation_rank(n, first_half)
        second_half_rank = permutation_rank(n, second_half)
        position = (first_half_rank - 1) * fact(n) + second_half_rank
        return position

# Read from 'permutare.in' and write to 'permutare.out'
with open('permutare.in', 'r') as file_in:
    queries = [list(map(int, line.strip().split())) for line in file_in]

with open('permutare.out', 'w') as file_out:
    for query in queries:
        result = process_query(query)
        if isinstance(result, list):
            file_out.write(' '.join(map(str, result)) + '\n')
        else:
            file_out.write(str(result) + '\n')
```
```
---------- user ----------


Expected program to write result to `permutare.out` and read from `permutare.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
from math import factorial as fact

# Function to generate the kth permutation of n numbers
def kth_permutation(n, k):
    sequence = list(range(1, n + 1))
    permutation = []
    k -= 1  # Convert to 0-based index
    for i in range(n, 0, -1):
        factorial = fact(i - 1)
        index = k // factorial
        k %= factorial
        permutation.append(sequence.pop(index))
    return permutation

# Function to find the rank of a given permutation
def permutation_rank(n, perm):
    sequence = list(range(1, n + 1))
    rank = 0
    for i in range(n):
        rank *= len(sequence)
        rank += sequence.index(perm[i])
        sequence.remove(perm[i])
    return rank + 1

# Read from 'permutare.in' and write to 'permutare.out'
with open('permutare.in', 'r') as file_in:
    queries = [list(map(int, line.strip().split())) for line in file_in]

# Process each query and write results to 'permutare.out'
with open('permutare.out', 'w') as file_out:
    for query in queries:
        q_type, n = query[0], query[1]
        if q_type == 1:  # Find the permutation at position p
            p = query[2]
            first_half = kth_permutation(n, (p - 1) // fact(n) + 1)
            second_half = kth_permutation(n, (p - 1) % fact(n) + 1)
            permutation = first_half + second_half
            file_out.write(' '.join(map(str, permutation)) + '\n')
        elif q_type == 2:  # Find the position of a given permutation
            first_half, second_half = query[2:2 + n], query[2 + n:]
            first_half_rank = permutation_rank(n, first_half)
            second_half_rank = permutation_rank(n, second_half)
            position = (first_half_rank - 1) * fact(n) + second_half_rank
            file_out.write(str(position) + '\n')
```
```
---------- user ----------


Expected program to write result to `permutare.out` and read from `permutare.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
# Function to generate the kth lexicographic permutation of n numbers
def kth_permutation(n, k):
    sequence = list(range(1, n + 1))
    permutation = []
    k -= 1  # Convert to 0-based index
    for i in range(n, 0, -1):
        factorial = fact(i - 1)
        index = k // factorial
        k %= factorial
        permutation.append(sequence.pop(index))
    return permutation

# Function to find the rank of a given permutation
def permutation_rank(perm):
    n = len(perm)
    rank = 1
    factorial = fact(n)
    for i in range(n):
        factorial //= n - i
        rank += factorial * perm[i] // (i + 1)
    return rank

# Function to process a single query
def process_query(query):
    query_type = query[0]
    n = query[1]

    if query_type == 1:  # Query type 1: Find the permutation at position p
        p = query[2]
        first_half_rank = (p - 1) // fact(n) + 1
        second_half_rank = (p - 1) % fact(n) + 1
        first_half = kth_permutation(n, first_half_rank)
        second_half = kth_permutation(n, second_half_rank)
        return first_half + second_half
    else:  # Query type 2: Find the rank of the given permutation
        permutation = query[2:]
        first_half = permutation[:n]
        second_half = permutation[n:]
        first_half_rank = permutation_rank(first_half)
        second_half_rank = permutation_rank(second_half)
        return (first_half_rank - 1) * fact(n) + second_half_rank

# Read input from 'permutare.in' and write output to 'permutare.out'
with open('permutare.in', 'r') as fin:
    queries = [list(map(int, line.split())) for line in fin.readlines()]

results = [process_query(query) for query in queries]

with open('permutare.out', 'w') as fout:
    for result in results:
        if isinstance(result, list):
            fout.write(' '.join(map(str, result)) + '\n')
        else:
            fout.write(str(result) + '\n')
```
```
---------- user ----------


Expected program to write result to `permutare.out` and read from `permutare.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
# Importing the factorial function from the math module
from math import factorial as fact

# Function to find the kth permutation of n distinct objects
def get_permutation(n, k):
    numbers = list(range(1, n + 1))
    permutation = []
    k -= 1  # kth index of permutation is k-1 (0-indexed)
    for i in range(n, 0, -1):
        fact_i_1 = fact(i - 1)
        index = k // fact_i_1
        k %= fact_i_1
        permutation.append(numbers.pop(index))
    return permutation

# Function to find the rank of a given permutation
def find_rank(permutation):
    n = len(permutation)
    rank = 0
    numbers = list(range(1, n + 1))
    for i in range(n):
        index = numbers.index(permutation[i])
        rank += index * fact(n - i - 1)
        numbers.pop(index)
    return rank + 1

# Read the list of queries from the input file
with open('permutare.in', 'r') as infile:
    queries = [[int(num) for num in line.split()] for line in infile]

# Process each query and generate the output
output = []
for query in queries:
    if query[0] == 1:
        # Get the double permutation from its lexicographical rank
        n, rank = query[1], query[2]
        first_half = get_permutation(n, (rank - 1) // fact(n) + 1)
        second_half = get_permutation(n, (rank - 1) % fact(n) + 1)
        output.append(first_half + second_half)
    else:
        # Get the lexicographical rank of the double permutation
        n = query[1]
        permutation = query[2:]
        rank = (find_rank(permutation[:n]) - 1) * fact(n) + find_rank(permutation[n:])
        output.append(rank)

# Write the output to the output file
with open('permutare.out', 'w') as outfile:
    for result in output:
        if isinstance(result, list):
            outfile.write(' '.join(map(str, result)) + '\n')
        else:
            outfile.write(str(result) + '\n')
```
```
---------- user ----------


Expected program to write result to `permutare.out` and read from `permutare.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
from math import factorial

# Function to calculate the k-th permutation of numbers 1 to n
def get_kth_permutation(n, k):
    numbers = list(range(1, n + 1))
    permutation = []
    k -= 1  # Adjust for zero-indexing
    for _ in range(n):
        n -= 1
        fact_n = factorial(n)
        index = k // fact_n
        k %= fact_n
        permutation.append(numbers.pop(index))
    return permutation

# Function to calculate the rank of a permutation
def get_permutation_rank(permutation):
    rank = 0
    n = len(permutation)
    factor = factorial(n)
    numbers = list(range(1, n + 1))
    
    for i in range(n):
        factor //= n - i
        rank += numbers.index(permutation[i]) * factor
        numbers.remove(permutation[i])
        
    return rank + 1

# Process queries
def process_queries(queries):
    results = []
    for query in queries:
        q_type, n = query[0], query[1]
        if q_type == 1:
            p = query[2]
            first_half = get_kth_permutation(n, (p - 1) // factorial(n) + 1)
            second_half = get_kth_permutation(n, (p - 1) % factorial(n) + 1)
            results.append(' '.join(map(str, first_half + second_half)))
        else:
            perm = query[2:]
            first_half_rank = get_permutation_rank(perm[:n])
            second_half_rank = get_permutation_rank(perm[n:])
            position = ((first_half_rank - 1) * factorial(n)) + second_half_rank
            results.append(str(position))
    return results

# Read input from 'permutare.in'
with open('permutare.in', 'r') as file:
    queries = [list(map(int, line.strip().split())) for line in file]

# Process and write output to 'permutare.out'
with open('permutare.out', 'w') as file:
    for result in process_queries(queries):
        file.write(result + '\n')
```
```
