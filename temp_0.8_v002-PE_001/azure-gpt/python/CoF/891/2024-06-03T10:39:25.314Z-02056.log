---------- user ----------

Here is a programming challenge.
Please solve this problem efficiently, optimizing both time and memory usage.
Create the most efficient solution for this challenge in python. Utilize numpy and other highly efficient libraries whenever possible.
This problem has a memory limit of ~8MB so please be sensitive on using memory. Using too much memory may result in OOM.
The code must compile and be correct.
The solution must read from `fadema.in` and write to `fadema.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Corina a cumpărat de la magazin un material din pânză colorată, de formă dreptunghiulară pentru a decupa din el o față de masă pentru masa din bucătărie. Fiindcă este pasionată de șah, Corina a ales un material format din $n \times m$ pătrate de aceeași dimensiune colorate cu alb sau negru. Pătratele sunt lipite și sunt dispuse pe linii și coloane paralele cu laturile dreptunghiului din pânză care a fost cumpărat. Două pătrate se numesc vecine dacă au în comun o latură.

Materialul din pânză nu respectă neapărat structura unei table de șah, adică pătratele vecine pe aceeași linie sau pe aceeași coloană nu sunt în mod necesar colorate în mod alternativ.

Corina își propune prin urmare să decupeze un dreptunghi cu un număr maxim de pătrate, paralel cu laturile dreptunghiului din pânză care a fost cumpărat, care să respecte alternanța culorilor pe o tablă de șah.

# Cerință
Să se determine numărul maxim de pătrate întregi ale unui dreptunghi cu laturile paralele cu cele ale materialului cumpărat, care poate fi decupat astfel încât să nu existe două pătrate vecine având aceeași culoare.

# Date de intrare
Fișierul `fadema.in` conține pe prima linie două numere naturale $n$ și $m$ reprezentând numărul de linii, respectiv numărul de coloane ale materialului din pânză care a fost cumpărat.
Pe fiecare dintre următoarele $n$ linii se află câte $m$ cifre `0` sau `1` despărțite prin câte un spațiu, reprezentând culorile pătratelor materialului. Cifra `0` codifică culoarea albă, iar cifra `1` codifică culoarea neagră.

# Date de ieşire
Fișierul `fadema.out` va conține pe prima linie un singur număr natural $A$, reprezentând numărul maxim de pătrate ale unui dreptunghi care poate fi decupat astfel încât să respecte cerința din enunț. Dacă nu există dreptunghiuri cu cel puțin două pătrate având culori alternante, se va scrie valoarea $1$.

# Restricţii și precizări
- $2 \leq N \leq 1\ 000$
- $2 \leq M \leq 1\ 000$
- Pentru rezolvarea corectă a cerinței respectând restricțiile problemei se acordă 90 de puncte.
- Pentru rezultate corecte respectând restricțiile problemei și $n, m \leq 100$ se acordă 20 de puncte.
- Pentru rezultate corecte respectând restricțiile problemei și $n, m \leq 200$ se acordă 40 de puncte.
- Pentru rezultate corecte respectând restricțiile problemei și $n, m \leq 400$ se acordă 65 de puncte.
- Din oficiu se acordă 10 puncte.

---

Example:
`fadema.in`
```
3 4
0 0 1 0
1 1 0 0
1 0 1 0
```

`fadema.out`
```
6
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```markdown
```python
import numpy as np

# Function to check if a submatrix with top-left corner at (i, j) and
# dimensions (height, width) is a valid checkerboard.
def is_valid_submatrix(mat, i, j, height, width):
    submat = mat[i:i+height, j:j+width]
    # Create a mask of expected values (0 and 1, alternating)
    mask = np.indices((height, width)).sum(axis=0) % 2
    # A valid checkerboard alternates between 0 and 1. XOR with mask should result in all True
    return np.all(np.logical_xor(submat, mask))

def main():
    # Read input file
    with open('fadema.in', 'r') as f:
        n, m = map(int, f.readline().split())
        mat = np.array([list(map(int, f.readline().split())) for _ in range(n)])

    # Initialize the maximum size to 1 (the case where no rectangle can be found)
    max_size = 1

    # Try for each possible submatrix, starting with the largest
    for height in range(n, 1, -1):
        for width in range(m, 1, -1):
            if height * width <= max_size:
                break  # No point in checking smaller rectangles
            for i in range(n - height + 1):
                for j in range(m - width + 1):
                    if is_valid_submatrix(mat, i, j, height, width):
                        max_size = height * width
                        # Found a valid submatrix, so break out of both loops
                        break
                if max_size == height * width:
                    break
            if max_size == height * width:
                break

    # Write output file
    with open('fadema.out', 'w') as f:
        f.write(str(max_size))

if __name__ == "__main__":
    main()
```
```
The above code attempts to check all possible submatrices starting from the largest size downward. When it finds a valid checkerboard, it immediately breaks out of the loops and writes the result. It uses numpy for efficient submatrix extraction and comparison. However, due to the size constraints and memory limitations, this approach can still be improved. For an even more efficient solution, we could try dynamic programming or another algorithm to avoid checking all submatrices.
---------- user ----------


Expected program to write result to `fadema.out` and read from `fadema.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

Certainly! Here's the improved solution tailored to the specifications. It leverages NumPy for efficient computation and ensures minimal memory usage by avoiding extra copies of the array. The solution is written within a markdown code block:

```markdown
```python
import numpy as np

def largest_checkerboard(matrix):
    # Precompute prefix sums for 0's and 1's in a chessboard pattern.
    n, m = matrix.shape
    prefix = np.zeros((n + 1, m + 1), dtype=int)
    for i in range(1, n + 1):
        for j in range(1, m + 1):
            prefix[i, j] = prefix[i - 1, j] + prefix[i, j - 1] - prefix[i - 1, j - 1]
            if matrix[i - 1, j - 1] == (i + j) % 2:
                prefix[i, j] += 1

    max_checkerboard = 1
    # Check all possible top-left corners of the submatrix.
    for i in range(n):
        for j in range(m):
            # Check all possible sizes of the submatrix.
            for size in range(max_checkerboard + 1, min(n - i, m - j) + 1):
                total = prefix[i + size, j + size] - prefix[i, j + size] - prefix[i + size, j] + prefix[i, j]
                if total == size * size // 2 + size * size % 2:
                    max_checkerboard = size

    return max_checkerboard * max_checkerboard

def main():
    # Read input file
    with open('fadema.in', 'r') as f:
        n, m = map(int, f.readline().split())
        matrix = np.array([list(map(int, f.readline().split())) for _ in range(n)])

    result = largest_checkerboard(matrix)

    # Write output file
    with open('fadema.out', 'w') as f:
        f.write(str(result))

if __name__ == "__main__":
    main()
```
```
This code reads a matrix from the `fadema.in` file, computes the largest possible checkerboard size that can be cut from the cloth, and then writes the number of squares in that checkerboard to the `fadema.out` file. It uses a prefix sum approach to efficiently determine if a submatrix is a valid checkerboard in constant time for each size and position, avoiding the need to recompute the sum for overlapping submatrices. This optimized approach significantly reduces the time complexity of the solution.
---------- user ----------


Expected program to write result to `fadema.out` and read from `fadema.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

def calculate_largest_checkerboard(matrix):
    n, m = matrix.shape
    # Initialize the dp table
    dp = np.zeros((n, m, 2), dtype=int)
    
    # Set the initial max size to 1 since single squares are always valid
    max_size = 1
    
    # Populate the dp table
    for i in range(n):
        for j in range(m):
            if i == 0 or j == 0:
                dp[i, j, matrix[i, j]] = 1
            else:
                if matrix[i, j] != matrix[i - 1, j - 1]:
                    dp[i, j, matrix[i, j]] = min(dp[i - 1, j, 1 - matrix[i, j]], dp[i, j - 1, 1 - matrix[i, j]], dp[i - 1, j - 1, matrix[i, j]]) + 1
                else:
                    dp[i, j, matrix[i, j]] = 1
                # Update the maximum size if necessary
                max_size = max(max_size, dp[i, j, matrix[i, j]])
    return max_size ** 2

def main():
    # Read input file
    with open('fadema.in', 'r') as fin:
        n, m = map(int, fin.readline().split())
        matrix = np.array([list(map(int, fin.readline().split())) for _ in range(n)])
    
    # Calculate the largest possible checkerboard
    result = calculate_largest_checkerboard(matrix)
    
    # Write output file
    with open('fadema.out', 'w') as fout:
        fout.write(str(result))

if __name__ == "__main__":
    main()
```
```
This solution uses dynamic programming to efficiently calculate the largest possible rectangle that acts as a checkerboard pattern for the given input cloth. The `calculate_largest_checkerboard` function computes the largest square ending at each cell that follows the checkerboard pattern. The `dp` table stores the size of the largest valid square ending at each cell for both black and white cells separately. The `main` function reads the input from `fadema.in`, processes it, and then writes the output to `fadema.out`.
---------- user ----------


Expected program to write result to `fadema.out` and read from `fadema.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
