---------- user ----------

Here is a programming challenge.
Please solve this problem efficiently, optimizing both time and memory usage.
Create the most efficient solution for this challenge in python. Utilize numpy and other highly efficient libraries whenever possible.
This problem has a memory limit of ~8MB so please be sensitive on using memory. Using too much memory may result in OOM.
The code must compile and be correct.
The solution must read from `arhitect.in` and write to `arhitect.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

~[arhitect.jpg|align=right|width=20em]

Construcția unei noi clădiri a fost finalizată! Frank, celebrul arhitect a  făcut o poză cu fațada. Nu este chiar mulțumit de poză deoarece a observat o înclinație a pozei relativ la orizontală. Asta se poate repara printr-o rotație, iar Frank se întreabă dacă procesul de îndreptare nu ar putea fi automatizat.

Cu acest scop, imaginea este transformată într-o mulțime de segmente din plan, detectate automat cu algoritmi speciali, ca în imaginea din dreapta. Segmentele care se obțin sunt identificate prin cele două extremități, puncte având coordonate numere naturale, în sistemul *xOy*: ($x_1$, $y_1$), ($x_2$, $y_2$). Un segment este numit *aliniat* cu axele dacă este orizontal (paralel cu axa *Ox*, deci $y_1=y_2$) sau vertical (paralel cu axa *Oy*, deci $x_1=x_2$).
Prin rotația imaginii în ansamblu, o parte dintre segmente devin *aliniate* cu cele două axe.

# Cerință

Scrieți un program care pentru o mulțime de segmente determină numărul maxim de segmente care se pot *alinia*, prin rotirea cu un același unghi a tuturor segmentelor. Unghiul de rotație poate fi orice număr real.

# Date de intrare

Fişierul de intrare `arhitect.in` conţine pe prima linie numărul de segmente $N$ și pe următoarele $N$ linii câte patru numere întregi separate prin câte un spațiu $x_1$, $y_1$, $x_2$, $y_2$, în această ordine, cu semnificația din enunț, coordonatele ce definesc extremitățile segmentelor.

# Date de ieșire

Fișierul de ieșire `arhitect.out` conține pe prima linie numărul maxim de segmente determinat.

# Restricții și precizări

* $1 \leq N \leq 100 \ 000$ și $1 \leq x_1, y_1, x_2, y_2 \leq 1 \ 000 \ 000 \ 000$;
* Toate segmentele au lungime nenulă;
* Pentru $40$ de puncte, segmentele inițiale sunt paralele cu *Ox*, *Oy* sau cu bisectoarele axelor de coordonate.
* Pentru $60$ de puncte, fără resticții suplimentare.

---

Example:
`arhitect.in`
```
3
1 1 1 3
4 1 1 4
5 2 7 4
```

`arhitect.out`
```
2
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```markdown
```python
import numpy as np
from collections import defaultdict

# Read the input data
with open('arhitect.in', 'r') as file:
    N = int(file.readline().strip())
    segments = [list(map(int, file.readline().split())) for _ in range(N)]

# Function to calculate the angle to align a segment with the x-axis or y-axis
def calculate_alignment_angle(segment):
    x1, y1, x2, y2 = segment
    if x1 == x2:  # vertical segment
        return float('inf')  # represents a vertical alignment
    else:
        return np.arctan((y2 - y1) / (x2 - x1))

# Dictionary to count the number of segments for each alignment angle
alignment_counter = defaultdict(int)

# Calculate and count alignment angles
for segment in segments:
    angle = calculate_alignment_angle(segment)
    alignment_counter[angle] += 1

# Determine the maximum number of aligned segments
max_aligned_segments = max(alignment_counter.values())

# Write the output data
with open('arhitect.out', 'w') as file:
    file.write(str(max_aligned_segments))
```
```
---------- user ----------


Expected program to write result to `arhitect.out` and read from `arhitect.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np
from collections import defaultdict

# Function to calculate the angle to align a segment with the axes
def calculate_alignment_angles(x1, y1, x2, y2):
    if x1 == x2:
        return float('inf'), float('inf')  # Represents a vertical alignment
    else:
        dx = x2 - x1
        dy = y2 - y1
        angle_to_x = np.arctan2(dy, dx)  # Angle relative to the x-axis
        angle_to_y = np.arctan2(dx, dy)  # Angle relative to the y-axis
        return angle_to_x, angle_to_y

# Read the input data
with open('arhitect.in', 'r') as file:
    N = int(file.readline().strip())
    angles_to_x = defaultdict(int)
    angles_to_y = defaultdict(int)

    for _ in range(N):
        x1, y1, x2, y2 = map(int, file.readline().split())
        angle_x, angle_y = calculate_alignment_angles(x1, y1, x2, y2)
        angles_to_x[angle_x] += 1
        angles_to_y[angle_y] += 1

# Determine the maximum number of aligned segments (either to x-axis or y-axis)
max_aligned_segments = max(max(angles_to_x.values()), max(angles_to_y.values()))

# Write the output data
with open('arhitect.out', 'w') as file:
    file.write(str(max_aligned_segments))

```
```
---------- user ----------


Expected program to write result to `arhitect.out` and read from `arhitect.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
from collections import defaultdict

def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

def normalize_angle(dx, dy):
    if dx == 0:
        return (0, 1)
    elif dy == 0:
        return (1, 0)
    else:
        d = gcd(abs(dx), abs(dy))
        return (dx // d, dy // d)

def count_aligned_segments(segments):
    angle_count = defaultdict(int)
    for segment in segments:
        x1, y1, x2, y2 = segment
        angle = normalize_angle(x2 - x1, y2 - y1)
        angle_count[angle] += 1
    return max(angle_count.values())

# Read the input data
with open('arhitect.in', 'r') as file:
    N = int(file.readline())
    segments = [list(map(int, file.readline().split())) for _ in range(N)]

# Calculate the result
max_aligned = count_aligned_segments(segments)

# Write the output data
with open('arhitect.out', 'w') as file:
    file.write(str(max_aligned))
```
```
---------- user ----------


Expected program to write result to `arhitect.out` and read from `arhitect.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
from math import atan2, pi
from collections import defaultdict

# Function to calculate the normalization of an angle
def normalize_angle(x1, y1, x2, y2):
    # Handle the special case of vertical lines
    if x1 == x2:
        return float('inf'), 0
    # Calculate the angle in radians and take modulo pi
    angle = atan2(y2 - y1, x2 - x1) % pi
    return angle

# Read the input data
with open('arhitect.in', 'r') as file:
    N = int(file.readline().strip())
    angle_counter = defaultdict(int)

    for _ in range(N):
        x1, y1, x2, y2 = map(int, file.readline().split())
        angle = normalize_angle(x1, y1, x2, y2)
        angle_counter[angle] += 1

# Determine the maximum number of aligned segments
max_aligned_segments = max(angle_counter.values())

# Write the output data
with open('arhitect.out', 'w') as file:
    file.write(str(max_aligned_segments))
```
```
---------- user ----------


Expected program to write result to `arhitect.out` and read from `arhitect.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
from math import gcd

# Function to normalize the direction of a segment
def normalize(dx, dy):
    g = gcd(dx, dy)
    return dx // g, dy // g

# Read input data from file
with open('arhitect.in', 'r') as f:
    n = int(f.readline())
    directions = {}

    for _ in range(n):
        x1, y1, x2, y2 = map(int, f.readline().split())
        dx, dy = normalize(x2 - x1, y2 - y1)
        # We only need to store one of the two perpendicular directions
        # due to the symmetry (rotating by 90 degrees yields the same result)
        if (dy, dx) in directions:
            directions[(dy, dx)] += 1
        else:
            directions[(dx, dy)] = directions.get((dx, dy), 0) + 1

# Find the maximum number of segments that can be aligned
max_aligned = max(directions.values())

# Write the output to file
with open('arhitect.out', 'w') as f:
    f.write(str(max_aligned))
```
```
---------- user ----------


Expected program to write result to `arhitect.out` and read from `arhitect.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
from math import gcd

# Read input data from file
with open('arhitect.in', 'r') as f:
    n = int(f.readline().strip())
    # Create a dictionary to hold the normalized slope counts
    slope_counts = dict()

    for _ in range(n):
        x1, y1, x2, y2 = map(int, f.readline().split())
        dx, dy = x2 - x1, y2 - y1
        # Normalize the slope
        if dx == 0:  # Vertical line
            slope = 'inf'
        elif dy == 0:  # Horizontal line
            slope = '0'
        else:
            g = gcd(dx, dy)
            slope = (dy // g, dx // g)
        # Count the occurrence of each slope
        slope_counts[slope] = slope_counts.get(slope, 0) + 1

# Find the maximum number of segments that can be aligned
max_aligned = max(slope_counts.values())

# Write the output to file
with open('arhitect.out', 'w') as f:
    f.write(str(max_aligned))
```
```
---------- user ----------


Expected program to write result to `arhitect.out` and read from `arhitect.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
# Function to compute GCD (Greatest Common Divisor)
def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

# Function to normalize a vector (dx, dy)
def normalize(dx, dy):
    if dx == 0:  # Vertical line
        return (0, 1)
    if dy == 0:  # Horizontal line
        return (1, 0)
    d = gcd(abs(dx), abs(dy))
    return (dx // d, dy // d)

# Read the input data from 'arhitect.in' file
with open('arhitect.in', 'r') as infile:
    n = int(infile.readline().strip())
    normalized_directions = {}

    for _ in range(n):
        x1, y1, x2, y2 = map(int, infile.readline().split())
        dx = x2 - x1
        dy = y2 - y1
        norm_dir = normalize(dx, dy)
        normalized_directions[norm_dir] = normalized_directions.get(norm_dir, 0) + 1

# Find the maximum number of segments that can be aligned
max_aligned_segments = max(normalized_directions.values(), default=0)

# Write the output data to 'arhitect.out' file
with open('arhitect.out', 'w') as outfile:
    outfile.write(f'{max_aligned_segments}\n')
```
```
