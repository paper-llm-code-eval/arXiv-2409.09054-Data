---------- user ----------

Here is a programming challenge.
Please solve this problem efficiently, optimizing both time and memory usage.
Create the most efficient solution for this challenge in python. Utilize numpy and other highly efficient libraries whenever possible.
This problem has a memory limit of ~8MB so please be sensitive on using memory.Using unavoided memory may result in OOM.
The code must compile and be correct.
The solution must read from `vecini.in` and write to `vecini.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Se consideră matricea $A$ ale cărei elemente pot avea doar valorile $0$ sau $1$ și în care numerotarea liniilor și numerotarea coloanelor începe de la $1$. Pentru un element oarecare al matricei, definim noțiunea de vecin ca fiind acele elementele din matrice aflate în imediata sa apropiere pe una dintre direcțiile orizontală, verticală sau pe cele două diagonale (vezi figura de mai jos în care s-au marcat cu $x$ vecinii elementului marcat cu $o$). Un vecin bun al elementului $A_{ij}$ este un vecin care are aceeași valoare cu $A_{ij}$.

~[vecini.png]

# Cerință

Dându-se matricea $A$, să se determine numărul maxim de vecini buni pe care îi are unul dintre elementele matricei precum și numărul de elemente care au acest număr maxim de vecini buni.

# Date de intrare

Fișierul de intrare `vecini.in` conține pe prima linie trei valori naturale $m \ n \ k$ reprezentând numărul de linii, numărul de coloane și respectiv numărul de valori egale cu $1$ din matricea $A$. Pe fiecare dintre următoarele $k$ linii se află două valori $i$ si $j$ cu semnificația $A_{ij}$ este egal cu $1$. Aceste valori sunt date in ordinea parcurgerii matricei pe linii de la linia $1$ la linia $m$.

# Date de ieșire

Fișierul de ieșire `vecini.out` va conține pe prima linie două numere naturale $x$ și $y$ separate printr-un singur spațiu: $x$ va reprezenta numărul maxim de vecini buni pe care îi are unul dintre elementele matricei date, iar $y$ va reprezenta numărul de elemente din matricea dată care au acest număr maxim de vecini buni.

# Restricții și precizări

* $2 \leq m,n \leq 1 \ 000$;
* $0 \leq k \leq n \cdot m / 2+1$;
* Pentru $30$% dintre teste $2 \leq m,n \leq 200$;

---

Example:
`vecini.in`
```
3 4 7
1 3
2 1
2 4
3 1
3 4
3 3
3 2
```

`vecini.out`
```
3 6
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```markdown
```python
import numpy as np

def main():
    # Read the input data from vecini.in
    with open('vecini.in', 'r') as file:
        m, n, k = map(int, file.readline().split())
        ones_positions = [tuple(map(int, line.split())) for line in file.readlines()]

    # Initialize a zero matrix with one extra border to avoid edge cases when counting neighbors
    A = np.zeros((m + 2, n + 2), dtype=np.int8)

    # Mark the positions with 1s in the matrix A, taking into account the extra border
    for i, j in ones_positions:
        A[i, j] = 1

    # Create a kernel to count the neighbors
    kernel = np.array([[1, 1, 1],
                       [1, 0, 1],
                       [1, 1, 1]], dtype=np.int8)

    # Apply 2D convolution to count the good neighbors for each element
    good_neighbors = np.zeros_like(A)
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if A[i, j] == 1:
                good_neighbors[i, j] = np.sum(A[i - 1:i + 2, j - 1:j + 2] * kernel)

    # Find the maximum number of good neighbors and the number of elements with that number
    max_neighbors = np.max(good_neighbors)
    num_elements = np.sum(good_neighbors == max_neighbors)

    # Write the output data to vecini.out
    with open('vecini.out', 'w') as file:
        file.write(f"{max_neighbors} {num_elements}")

if __name__ == '__main__':
    main()
```
```
---------- user ----------


Expected program to write result to `vecini.out` and read from `vecini.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

def count_good_neighbors(matrix, m, n):
    # Count the number of good neighbors for each cell with value 1
    # Initialize the count matrix with zeros
    count_matrix = np.zeros((m + 2, n + 2), dtype=np.int8)
    # Apply the kernel to each cell with value 1
    kernel = np.array([[1, 1, 1], [1, 0, 1], [1, 1, 1]], dtype=np.int8)
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if matrix[i, j] == 1:
                count_matrix[i, j] = np.sum(matrix[i - 1:i + 2, j - 1:j + 2] * kernel)
    return count_matrix[1:-1, 1:-1]

def main():
    with open('vecini.in', 'r') as file:
        m, n, k = map(int, file.readline().split())
        matrix = np.zeros((m + 2, n + 2), dtype=np.int8)  # Add padding to the matrix
        for _ in range(k):
            i, j = map(int, file.readline().split())
            matrix[i, j] = 1  # Set the cell to 1

    good_neighbors_matrix = count_good_neighbors(matrix, m, n)

    # Find the max number of good neighbors and how many elements have that number
    max_good_neighbors = good_neighbors_matrix.max()
    elements_with_max_neighbors = np.sum(good_neighbors_matrix == max_good_neighbors)

    with open('vecini.out', 'w') as file:
        file.write(f"{max_good_neighbors} {elements_with_max_neighbors}\n")

if __name__ == '__main__':
    main()
```
```
---------- user ----------


Expected program to write result to `vecini.out` and read from `vecini.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Function to calculate the number of good neighbors for each cell
def calculate_good_neighbors(matrix, ones_positions):
    # Create padded matrix to handle edge cases
    padded_matrix = np.pad(matrix, pad_width=1, mode='constant', constant_values=0)
    # Initialize the neighbor count matrix
    neighbor_count = np.zeros_like(matrix, dtype=np.int8)
    # Define the relative positions of neighbors
    neighbors = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]

    # Count good neighbors for each cell with a 1 in it
    for i, j in ones_positions:
        count = 0
        for di, dj in neighbors:
            if padded_matrix[i + di + 1, j + dj + 1] == matrix[i, j]:
                count += 1
        neighbor_count[i, j] = count

    return neighbor_count

# Main function to read from 'vecini.in' and write to 'vecini.out'
def main():
    with open('vecini.in', 'r') as file:
        m, n, k = map(int, file.readline().split())
        matrix = np.zeros((m, n), dtype=np.int8)
        ones_positions = []
        for _ in range(k):
            i, j = map(int, file.readline().split())
            matrix[i - 1, j - 1] = 1  # Adjust indices to be zero-based
            ones_positions.append((i - 1, j - 1))

    good_neighbors = calculate_good_neighbors(matrix, ones_positions)

    # Find the maximum number of good neighbors and how many cells have that maximum
    max_good = np.max(good_neighbors)
    max_count = np.sum(good_neighbors == max_good)

    with open('vecini.out', 'w') as file:
        file.write(f"{max_good} {max_count}")

if __name__ == '__main__':
    main()
```
```
---------- user ----------


Expected program to write result to `vecini.out` and read from `vecini.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

def find_max_good_neighbors(matrix, ones_positions):
    # Neighbors relative positions
    neighbors_offsets = [
        (-1, -1), (-1, 0), (-1, 1),
        (0, -1),           (0, 1),
        (1, -1),  (1, 0),  (1, 1)
    ]
    
    max_neighbors = 0
    max_count = 0
    
    # Iterate over all positions that have a 1
    for x, y in ones_positions:
        good_neighbors = 0
        # Count good neighbors for each cell
        for dx, dy in neighbors_offsets:
            nx, ny = x + dx, y + dy
            if 0 <= nx < matrix.shape[0] and 0 <= ny < matrix.shape[1]:
                if matrix[nx, ny] == 1:
                    good_neighbors += 1
        # Update max_neighbors and max_count accordingly
        if good_neighbors > max_neighbors:
            max_neighbors = good_neighbors
            max_count = 1
        elif good_neighbors == max_neighbors:
            max_count += 1
            
    return max_neighbors, max_count

def main():
    with open('vecini.in', 'r') as file:
        m, n, k = map(int, file.readline().split())
        matrix = np.zeros((m, n), dtype=np.int8)
        ones_positions = []
        for _ in range(k):
            i, j = map(int, file.readline().split())
            matrix[i - 1][j - 1] = 1  # Adjust for zero index
            ones_positions.append((i - 1, j - 1))

    max_neighbors, max_count = find_max_good_neighbors(matrix, ones_positions)

    with open('vecini.out', 'w') as file:
        file.write(f"{max_neighbors} {max_count}\n")

if __name__ == '__main__':
    main()
```
```
---------- user ----------


Expected program to write result to `vecini.out` and read from `vecini.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

def main():
    # Read the input file
    with open('vecini.in', 'r') as file:
        m, n, k = map(int, file.readline().split())
        # Create an array to store the matrix with padding to avoid edge checks
        A = np.zeros((m + 2, n + 2), dtype=int)
        # Read the positions where the element is 1
        for _ in range(k):
            i, j = map(int, file.readline().split())
            A[i, j] = 1

    # Define the neighbor indices relative to a given element
    neighbors_idx = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]
    max_neighbors = 0
    count_max_neighbors = 0

    # Iterate over the original matrix boundaries, excluding the padding
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if A[i, j] == 1:
                # Count the good neighbors
                count = sum(A[i + dx, j + dy] == 1 for dx, dy in neighbors_idx)
                # Update the max_neighbors and count_max_neighbors
                if count > max_neighbors:
                    max_neighbors = count
                    count_max_neighbors = 1
                elif count == max_neighbors:
                    count_max_neighbors += 1

    # Write the result to the output file
    with open('vecini.out', 'w') as file:
        file.write(f'{max_neighbors} {count_max_neighbors}\n')

if __name__ == '__main__':
    main()
```
```
---------- user ----------


Expected program to write result to `vecini.out` and read from `vecini.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Load the data from "vecini.in"
def load_data(filename):
    with open(filename, 'r') as f:
        m, n, k = map(int, f.readline().strip().split())
        data = np.zeros((m + 2, n + 2), dtype=np.uint8)
        for line in f:
            i, j = map(int, line.strip().split())
            data[i, j] = 1
    return data, m, n, k

# Find the maximum number of good neighbors and the number of elements with that number
def find_max_good_neighbors(data, m, n):
    max_neighbors = 0
    count = 0
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if data[i, j] == 1:
                neighbors = (data[i-1:i+2, j-1:j+2].sum() - 1)
                if neighbors > max_neighbors:
                    max_neighbors = neighbors
                    count = 1
                elif neighbors == max_neighbors:
                    count += 1
    return max_neighbors, count

# Save the result to "vecini.out"
def save_result(filename, result):
    with open(filename, 'w') as f:
        f.write(f"{result[0]} {result[1]}\n")

# Main function
def main():
    data, m, n, k = load_data('vecini.in')
    result = find_max_good_neighbors(data, m, n)
    save_result('vecini.out', result)

if __name__ == "__main__":
    main()
```
```
---------- user ----------


Expected program to write result to `vecini.out` and read from `vecini.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

def main():
    # Read the input data from 'vecini.in'
    with open('vecini.in', 'r') as f_input:
        m, n, k = map(int, f_input.readline().split())
        matrix = np.zeros((m + 2, n + 2), dtype=np.uint8)  # Matrix with padding
        for _ in range(k):
            x, y = map(int, f_input.readline().split())
            matrix[x, y] = 1  # Mark the cells with 1 based on input

    # Initialize variables to keep track of maximum number of good neighbors
    max_good_neighbors = -1
    count_max_good = 0

    # Iterate through the matrix and find the number of good neighbors
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if matrix[i, j] == 1:
                good_neighbors = (matrix[i-1:i+2, j-1:j+2] == 1).sum() - 1  # Count the good neighbors
                if good_neighbors > max_good_neighbors:
                    max_good_neighbors = good_neighbors
                    count_max_good = 1
                elif good_neighbors == max_good_neighbors:
                    count_max_good += 1

    # Write the output data to 'vecini.out'
    with open('vecini.out', 'w') as f_output:
        f_output.write(f"{max_good_neighbors} {count_max_good}\n")

if __name__ == '__main__':
    main()
```
```
