---------- user ----------

Here is a programming challenge.
Please solve this problem efficiently, optimizing both time and memory usage.
Create the most efficient solution for this challenge in python. Utilize numpy and other highly efficient libraries whenever possible.
This problem has a memory limit of ~8MB so please be sensitive on using memory.Using unavoided memory may result in OOM.
The code must compile and be correct.
The solution must read from `vecini.in` and write to `vecini.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Se consideră matricea $A$ ale cărei elemente pot avea doar valorile $0$ sau $1$ și în care numerotarea liniilor și numerotarea coloanelor începe de la $1$. Pentru un element oarecare al matricei, definim noțiunea de vecin ca fiind acele elementele din matrice aflate în imediata sa apropiere pe una dintre direcțiile orizontală, verticală sau pe cele două diagonale (vezi figura de mai jos în care s-au marcat cu $x$ vecinii elementului marcat cu $o$). Un vecin bun al elementului $A_{ij}$ este un vecin care are aceeași valoare cu $A_{ij}$.

~[vecini.png]

# Cerință

Dându-se matricea $A$, să se determine numărul maxim de vecini buni pe care îi are unul dintre elementele matricei precum și numărul de elemente care au acest număr maxim de vecini buni.

# Date de intrare

Fișierul de intrare `vecini.in` conține pe prima linie trei valori naturale $m \ n \ k$ reprezentând numărul de linii, numărul de coloane și respectiv numărul de valori egale cu $1$ din matricea $A$. Pe fiecare dintre următoarele $k$ linii se află două valori $i$ si $j$ cu semnificația $A_{ij}$ este egal cu $1$. Aceste valori sunt date in ordinea parcurgerii matricei pe linii de la linia $1$ la linia $m$.

# Date de ieșire

Fișierul de ieșire `vecini.out` va conține pe prima linie două numere naturale $x$ și $y$ separate printr-un singur spațiu: $x$ va reprezenta numărul maxim de vecini buni pe care îi are unul dintre elementele matricei date, iar $y$ va reprezenta numărul de elemente din matricea dată care au acest număr maxim de vecini buni.

# Restricții și precizări

* $2 \leq m,n \leq 1 \ 000$;
* $0 \leq k \leq n \cdot m / 2+1$;
* Pentru $30$% dintre teste $2 \leq m,n \leq 200$;

---

Example:
`vecini.in`
```
3 4 7
1 3
2 1
2 4
3 1
3 4
3 3
3 2
```

`vecini.out`
```
3 6
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```markdown
```python
import numpy as np

# Read input data from "vecini.in"
with open('vecini.in', 'r') as fin:
    m, n, k = map(int, fin.readline().split())
    ones_positions = [tuple(map(int, line.split())) for line in fin.readlines()]

# Initialize matrix with zeros
A = np.zeros((m + 2, n + 2), dtype=int)  # Padding to handle edges

# Place ones in the matrix
for row, col in ones_positions:
    A[row, col] = 1

# Get the slice of A without padding
B = A[1:-1, 1:-1]

# Define the kernel to use with convolution to count good neighbors
kernel = np.array([[1, 1, 1],
                   [1, 0, 1],
                   [1, 1, 1]])

# Count good neighbors for each element
good_neighbors = np.zeros_like(B)
for dx in range(-1, 2):
    for dy in range(-1, 2):
        if dx != 0 or dy != 0:  # Skip the center element
            good_neighbors += A[1 + dx:m + 1 + dx, 1 + dy:n + 1 + dy]

# Now, we can multiply good_neighbors with B to get good neighbors count of 1s only
good_neighbors *= B

# Get the maximum number of good neighbors and the count
max_good_neighbors = np.max(good_neighbors)
count_max_good_neighbors = np.sum(good_neighbors == max_good_neighbors)

# Write output data to "vecini.out"
with open('vecini.out', 'w') as fout:
    fout.write(f"{max_good_neighbors} {count_max_good_neighbors}\n")
```
```
---------- user ----------


Expected program to write result to `vecini.out` and read from `vecini.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

def count_good_neighbors(matrix, m, n):
    # Initialize the good neighbors count matrix
    good_neighbor_counts = np.zeros((m + 2, n + 2), dtype=int)
    
    # Iterate through all neighbors offsets
    for dx in [-1, 0, 1]:
        for dy in [-1, 0, 1]:
            if dx != 0 or dy != 0:
                good_neighbor_counts[1:-1, 1:-1] += matrix[1 + dx:m + 1 + dx, 1 + dy:n + 1 + dy]
    
    # Only consider good neighbors for positions with 1's in the original matrix
    good_neighbor_counts *= matrix[1:-1, 1:-1]
    
    return good_neighbor_counts

# Read input data from "vecini.in"
with open('vecini.in', 'r') as fin:
    m, n, k = map(int, fin.readline().split())
    # Initialize matrix with zeros and padding to avoid boundary checking
    matrix = np.zeros((m + 2, n + 2), dtype=int)
    for _ in range(k):
        x, y = map(int, fin.readline().split())
        matrix[x, y] = 1

# Count good neighbors
good_neighbor_counts = count_good_neighbors(matrix, m, n)

# Find the maximum number of good neighbors and the number of elements with this number
max_good_neighbors = np.max(good_neighbor_counts)
num_elements_with_max_neighbors = np.sum(good_neighbor_counts == max_good_neighbors)

# Write output data to "vecini.out"
with open('vecini.out', 'w') as fout:
    fout.write(f"{max_good_neighbors} {num_elements_with_max_neighbors}\n")
```
```
---------- user ----------


Expected program to write result to `vecini.out` and read from `vecini.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Open the input file and read the dimensions and the positions with value 1
with open('vecini.in', 'r') as file:
    m, n, k = map(int, file.readline().split())
    # Create a zero-filled matrix with padding to handle edge cases more easily
    A = np.zeros((m + 2, n + 2), dtype=int)
    for _ in range(k):
        x, y = map(int, file.readline().split())
        A[x, y] = 1

# Compute the number of good neighbors for each cell
good_neighbors = np.zeros_like(A)
for dx in [-1, 0, 1]:
    for dy in [-1, 0, 1]:
        if dx != 0 or dy != 0:
            good_neighbors += np.roll(np.roll(A, dx, axis=0), dy, axis=1)

# Consider good neighbors only for cells initially set to 1
good_neighbors = good_neighbors[1:-1, 1:-1] * A[1:-1, 1:-1]

# Find the maximum number of good neighbors
max_good = np.max(good_neighbors)
# Count how many cells have the maximum number of good neighbors
num_max = np.sum(good_neighbors == max_good)

# Open the output file and write the result
with open('vecini.out', 'w') as file:
    file.write(f"{max_good} {num_max}\n")
```
```
---------- user ----------


Expected program to write result to `vecini.out` and read from `vecini.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Read input data from "vecini.in"
with open('vecini.in', 'r') as fin:
    m, n, k = map(int, fin.readline().split())
    # Create a padded matrix
    A = np.zeros((m + 2, n + 2), dtype=int)
    for _ in range(k):
        i, j = map(int, fin.readline().split())
        A[i, j] = 1

# Generate offsets for all 8 directions
dirs = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]

max_good_neighbors = 0
count_max_good_neighbors = 0

# Calculate good neighbors for each cell with value 1
for i in range(1, m + 1):
    for j in range(1, n + 1):
        if A[i, j] == 1:
            good_neighbors = sum(A[i + dx, j + dy] for dx, dy in dirs)
            if good_neighbors > max_good_neighbors:
                max_good_neighbors = good_neighbors
                count_max_good_neighbors = 1
            elif good_neighbors == max_good_neighbors:
                count_max_good_neighbors += 1

# Write output data to "vecini.out"
with open('vecini.out', 'w') as fout:
    fout.write(f"{max_good_neighbors} {count_max_good_neighbors}\n")
```
```
---------- user ----------


Expected program to write result to `vecini.out` and read from `vecini.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Read the input values
with open('vecini.in', 'r') as file:
    m, n, k = map(int, file.readline().split())
    matrix = np.zeros((m + 2, n + 2), dtype=int)  # Padding to avoid edge checking
    for _ in range(k):
        i, j = map(int, file.readline().split())
        matrix[i, j] = 1

# Prepare an array to count good neighbors
neighbors_count = np.zeros((m + 2, n + 2), dtype=int)

# Using convolution to count neighbors
kernel = np.array([[1, 1, 1],
                   [1, 0, 1],
                   [1, 1, 1]], dtype=int)

# Apply the kernel to the matrix
for i in range(1, m + 1):
    for j in range(1, n + 1):
        sub_matrix = matrix[i - 1:i + 2, j - 1:j + 2]
        neighbors_count[i, j] = np.sum(sub_matrix * kernel)

# Filter the counts for only the places that originally had a 1
good_neighbors = neighbors_count[1:-1, 1:-1] * matrix[1:-1, 1:-1]

# Find the maximum number of good neighbors and the count of cells that have that number
max_neighbors = np.max(good_neighbors)
max_count = np.sum(good_neighbors == max_neighbors)

# Write the output values
with open('vecini.out', 'w') as file:
    file.write(f'{max_neighbors} {max_count}\n')
```
```
---------- user ----------


Expected program to write result to `vecini.out` and read from `vecini.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Read the input values
with open('vecini.in', 'r') as file:
    m, n, k = map(int, file.readline().split())
    # Initialize an empty matrix with padding
    matrix = np.zeros((m+2, n+2), dtype=int)
    for _ in range(k):
        i, j = map(int, file.readline().split())
        matrix[i, j] = 1

# Initialize variables to hold the max number of good neighbors and their count
max_good_neighbors = 0
counter = 0

# Check all elements which are 1 in the input matrix
for i in range(1, m+1):
    for j in range(1, n+1):
        if matrix[i, j] == 1:
            # Count the good neighbors by checking the adjacent cells
            good_neighbors = (matrix[i-1:i+2, j-1:j+2] == 1).sum() - 1  # Subtract the element itself
            if good_neighbors > max_good_neighbors:
                max_good_neighbors = good_neighbors
                counter = 1
            elif good_neighbors == max_good_neighbors:
                counter += 1

# Write the output values
with open('vecini.out', 'w') as file:
    file.write(f'{max_good_neighbors} {counter}\n')
```
```
---------- user ----------


Expected program to write result to `vecini.out` and read from `vecini.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Read the input values
with open('vecini.in', 'r') as file:
    m, n, k = map(int, file.readline().split())
    # Initialize a matrix with padding
    matrix = np.zeros((m + 2, n + 2), dtype=int)
    # Fill the matrix with 1s based on the input data
    for _ in range(k):
        i, j = map(int, file.readline().split())
        matrix[i, j] = 1

# Prepare an array to count good neighbors
neighbors_count = np.zeros((m + 2, n + 2), dtype=int)

# Count the good neighbors for each cell
for i in range(1, m + 1):
    for j in range(1, n + 1):
        # Only count for cells that originally had 1
        if matrix[i, j] == 1:
            neighbors_count[i, j] = (matrix[i-1:i+2, j-1:j+2].sum() - 1)

# Find the maximum number of good neighbors and the count of elements with that number
max_neighbors = neighbors_count.max()
max_count = (neighbors_count == max_neighbors).sum()

# Write the output values
with open('vecini.out', 'w') as file:
    file.write(f'{max_neighbors} {max_count}\n')
```
