---------- user ----------

Here is a programming challenge.
Please solve this problem efficiently, optimizing both time and memory usage.
Create the most efficient solution for this challenge in python. Utilize numpy and other highly efficient libraries whenever possible.
This problem has a memory limit of ~8MB so please be sensitive on using memory.Using unavoided memory may result in OOM.
The code must compile and be correct.
The solution must read from `vecini.in` and write to `vecini.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Se consideră matricea $A$ ale cărei elemente pot avea doar valorile $0$ sau $1$ și în care numerotarea liniilor și numerotarea coloanelor începe de la $1$. Pentru un element oarecare al matricei, definim noțiunea de vecin ca fiind acele elementele din matrice aflate în imediata sa apropiere pe una dintre direcțiile orizontală, verticală sau pe cele două diagonale (vezi figura de mai jos în care s-au marcat cu $x$ vecinii elementului marcat cu $o$). Un vecin bun al elementului $A_{ij}$ este un vecin care are aceeași valoare cu $A_{ij}$.

~[vecini.png]

# Cerință

Dându-se matricea $A$, să se determine numărul maxim de vecini buni pe care îi are unul dintre elementele matricei precum și numărul de elemente care au acest număr maxim de vecini buni.

# Date de intrare

Fișierul de intrare `vecini.in` conține pe prima linie trei valori naturale $m \ n \ k$ reprezentând numărul de linii, numărul de coloane și respectiv numărul de valori egale cu $1$ din matricea $A$. Pe fiecare dintre următoarele $k$ linii se află două valori $i$ si $j$ cu semnificația $A_{ij}$ este egal cu $1$. Aceste valori sunt date in ordinea parcurgerii matricei pe linii de la linia $1$ la linia $m$.

# Date de ieșire

Fișierul de ieșire `vecini.out` va conține pe prima linie două numere naturale $x$ și $y$ separate printr-un singur spațiu: $x$ va reprezenta numărul maxim de vecini buni pe care îi are unul dintre elementele matricei date, iar $y$ va reprezenta numărul de elemente din matricea dată care au acest număr maxim de vecini buni.

# Restricții și precizări

* $2 \leq m,n \leq 1 \ 000$;
* $0 \leq k \leq n \cdot m / 2+1$;
* Pentru $30$% dintre teste $2 \leq m,n \leq 200$;

---

Example:
`vecini.in`
```
3 4 7
1 3
2 1
2 4
3 1
3 4
3 3
3 2
```

`vecini.out`
```
3 6
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```markdown
```python
import numpy as np

# Read data from the file
with open('vecini.in', 'r') as file:
    m, n, k = map(int, file.readline().split())
    coords = [tuple(map(int, line.split())) for line in file.readlines()]

# Initialize the matrix with zeros
A = np.zeros((m+2, n+2), dtype=int)  # Padding with an extra border of zeros to handle edge cases

# Set the ones in the matrix according to the input coordinates
for i, j in coords:
    A[i, j] = 1

# Define the relative coordinates of all 8 possible neighbors
neighbors_offsets = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]

# Compute the number of good neighbors for all elements
good_neighbors = np.zeros_like(A)
for di, dj in neighbors_offsets:
    good_neighbors[1:m+1, 1:n+1] += A[1+di:m+1+di, 1+dj:n+1+dj] * A[1:m+1, 1:n+1]

# Find the maximum number of good neighbors and how many times it occurs
max_good_neighbors = np.max(good_neighbors)
num_elements_with_max = np.sum(good_neighbors == max_good_neighbors)

# Write the results to the output file
with open('vecini.out', 'w') as file:
    file.write(f"{max_good_neighbors} {num_elements_with_max}\n")
```
```
---------- user ----------


Expected program to write result to `vecini.out` and read from `vecini.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Function to count good neighbors for each cell
def count_good_neighbors(matrix, m, n):
    # Initialize an array to count good neighbors
    good_neighbors = np.zeros_like(matrix)
    # Offsets for the 8 neighboring cells
    neighbors_offsets = [(i, j) for i in (-1, 0, 1) for j in (-1, 0, 1) if not (i == j == 0)]
    # Iterate through the matrix and count good neighbors
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            # Use offsets to find values of neighbors and compare with current cell
            for offset in neighbors_offsets:
                # Check if neighbor is within bounds before comparing
                if 0 < i+offset[0] <= m and 0 < j+offset[1] <= n:
                    good_neighbors[i, j] += matrix[i+offset[0], j+offset[1]] == matrix[i, j]
    return good_neighbors

# Read input from file
with open('vecini.in', 'r') as file:
    m, n, k = map(int, file.readline().split())
    # Create an extra border around the matrix to simplify neighbor checking
    matrix = np.zeros((m+2, n+2), dtype=int)
    for _ in range(k):
        i, j = map(int, file.readline().split())
        matrix[i, j] = 1

# Count the good neighbors
good_neighbors = count_good_neighbors(matrix, m, n)

# Find the maximum number of good neighbors and its frequency
max_neighbors = np.max(good_neighbors)
num_max_neighbors = np.sum(good_neighbors == max_neighbors)

# Write the output to a file
with open('vecini.out', 'w') as file:
    file.write(f"{max_neighbors} {num_max_neighbors}\n")
```
```
---------- user ----------


Expected program to write result to `vecini.out` and read from `vecini.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

def main():
    with open('vecini.in', 'r') as file:
        m, n, k = map(int, file.readline().split())
        # Add padding to the matrix to simplify neighbor checks
        A = np.zeros((m + 2, n + 2), dtype=np.int8)
        for _ in range(k):
            i, j = map(int, file.readline().split())
            A[i, j] = 1

    # Calculate the sum of neighbors for each cell
    neighbor_counts = np.zeros_like(A, dtype=np.int8)
    for di in range(-1, 2):
        for dj in range(-1, 2):
            if di != 0 or dj != 0:  # Skip the cell itself
                neighbor_counts[1:-1, 1:-1] += A[1 + di:m + 1 + di, 1 + dj:n + 1 + dj]

    # Find the maximum number of good neighbors
    max_good_neighbors = np.max(neighbor_counts[1:-1, 1:-1] * A[1:-1, 1:-1])
    # Count how many elements have the maximum number of good neighbors
    num_elements_max_good = np.sum(neighbor_counts[1:-1, 1:-1] == max_good_neighbors)

    with open('vecini.out', 'w') as file:
        file.write(f"{max_good_neighbors} {num_elements_max_good}\n")

if __name__ == "__main__":
    main()
```
```
---------- user ----------


Expected program to write result to `vecini.out` and read from `vecini.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Define the kernel for the convolution operation to count the neighbors
kernel = np.array([[1, 1, 1],
                   [1, 0, 1],
                   [1, 1, 1]], dtype=np.uint8)

# Read data from 'vecini.in'
with open('vecini.in', 'r') as file:
    m, n, k = map(int, file.readline().split())
    # Create a zero-padded matrix for safe neighbor calculations
    A = np.zeros((m + 2, n + 2), dtype=np.uint8)
    indices = np.array([list(map(int, line.split())) for line in file], dtype=np.int32)
    A[indices[:, 0], indices[:, 1]] = 1

# Count neighbors using convolution, considering only the original matrix without padding
good_neighbors = np.zeros((m, n), dtype=np.uint8)
for i in range(1, m + 1):
    for j in range(1, n + 1):
        # Sum the product of the kernel with the corresponding submatrix from A
        good_neighbors[i - 1, j - 1] = np.sum(kernel * A[i - 1:i + 2, j - 1:j + 2])

# Apply the condition for good neighbors, i.e., same value as the center cell
good_neighbors *= A[1:-1, 1:-1]

# Find the maximum number of good neighbors and the occurrence count
max_good_neighbors = good_neighbors.max()
num_elements_max_good = np.sum(good_neighbors == max_good_neighbors)

# Write the result to 'vecini.out'
with open('vecini.out', 'w') as file:
    file.write(f"{max_good_neighbors} {num_elements_max_good}\n")
```
```
---------- user ----------


Expected program to write result to `vecini.out` and read from `vecini.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

def main():
    # Read data from 'vecini.in'
    with open('vecini.in', 'r') as file:
        m, n, k = map(int, file.readline().split())
        # Initialize a zero matrix with padding to avoid boundary issues
        matrix = np.zeros((m + 2, n + 2), dtype=np.int8)
        for _ in range(k):
            x, y = map(int, file.readline().split())
            matrix[x, y] = 1

    # Count good neighbors
    max_good = 0
    num_max_good = 0
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if matrix[i, j] == 1:
                good_neighbors = (
                    matrix[i-1, j-1] + matrix[i-1, j] + matrix[i-1, j+1] +
                    matrix[i, j-1]                    + matrix[i, j+1] +
                    matrix[i+1, j-1] + matrix[i+1, j] + matrix[i+1, j+1]
                )
                # Update max_good and num_max_good accordingly
                if good_neighbors > max_good:
                    max_good, num_max_good = good_neighbors, 1
                elif good_neighbors == max_good:
                    num_max_good += 1

    # Write the result to 'vecini.out'
    with open('vecini.out', 'w') as file:
        file.write(f"{max_good} {num_max_good}\n")

if __name__ == "__main__":
    main()
```
```
---------- user ----------


Expected program to write result to `vecini.out` and read from `vecini.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Initialize variables for maximum number of good neighbors and count
max_good_neighbors = 0
max_count = 0

# Read input from 'vecini.in'
with open('vecini.in', 'r') as f:
    m, n, k = map(int, f.readline().split())
    # Initialize the matrix with zeros and an extra border to handle edges
    matrix = np.zeros((m + 2, n + 2), dtype=np.int8)
    # Read the positions where the value is 1
    for _ in range(k):
        x, y = map(int, f.readline().split())
        matrix[x][y] = 1

# Create a sliding window to calculate the number of good neighbors for each cell
for i in range(1, m + 1):
    for j in range(1, n + 1):
        if matrix[i][j] == 1:
            # Count the number of good neighbors
            good_neighbors = np.sum(matrix[i-1:i+2, j-1:j+2]) - 1
            # Update the maximum number of good neighbors and the count
            if good_neighbors > max_good_neighbors:
                max_good_neighbors = good_neighbors
                max_count = 1
            elif good_neighbors == max_good_neighbors:
                max_count += 1

# Write the output to 'vecini.out'
with open('vecini.out', 'w') as f:
    f.write(f"{max_good_neighbors} {max_count}\n")
```
```
---------- user ----------


Expected program to write result to `vecini.out` and read from `vecini.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Open the input file and read the parameters
with open('vecini.in', 'r') as file:
    lines = file.readlines()
    m, n, k = map(int, lines[0].split())

    # Initialize the matrix with zeros
    matrix = np.zeros((m+2, n+2), dtype=int)  # Pad with a border of zeros

    # Fill the matrix with 1s according to the given positions
    for line in lines[1:]:
        i, j = map(int, line.split())
        matrix[i, j] = 1

# Kernel to compute the sum of neighbors
kernel = np.array([[1, 1, 1],
                   [1, 0, 1],
                   [1, 1, 1]])

# Convolution to count the neighbors
conv_result = np.zeros((m, n), dtype=int)
for i in range(1, m+1):
    for j in range(1, n+1):
        conv_result[i-1, j-1] = np.sum(matrix[i-1:i+2, j-1:j+2] * kernel)

# Element-wise multiplication to count only good neighbors
good_neighbors = conv_result * matrix[1:-1, 1:-1]

# Find the maximum number of good neighbors
max_good = np.max(good_neighbors)
# Count number of elements with the maximum number of good neighbors
num_max_good = np.count_nonzero(good_neighbors == max_good)

# Open the output file and write the results
with open('vecini.out', 'w') as file:
    file.write(f"{max_good} {num_max_good}\n")
```
```
