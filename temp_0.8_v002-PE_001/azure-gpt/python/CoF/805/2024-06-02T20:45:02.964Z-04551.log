---------- user ----------

Here is a programming challenge.
Please solve this problem efficiently, optimizing both time and memory usage.
Create the most efficient solution for this challenge in python. Utilize numpy and other highly efficient libraries whenever possible.
This problem has a memory limit of ~8MB so please be sensitive on using memory.Using unavoided memory may result in OOM.
The code must compile and be correct.
The solution must read from `vase.in` and write to `vase.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

~[0.jpg|align=right|width=12em]

Specialiştii chimişti au reuşit crearea în laborator a unei game diversificate de substanţe lichide nemiscibile (care nu se amestecă între ele), de aceeaşi densitate şi de culori diferite.

Acest rezultat a fost utilizat de către specialiştii fizicieni pentru studiul principiului vaselor comunicante. Conform acestui principiu „*într-un sistem de vase comunicante nivelul lichidului este acelaşi, indiferent de forma vaselor*”.

\
Experimentele fizicienilor se desfăşoară astfel:

Într-un sistem cu **două** vase comunicante, gradat identic pe fiecare ramură cu $0$, $1$, $2$, $3$, $\dots$, fizicienii introduc un număr de $n$ lichide, pe ramura din stânga sau pe ramura din dreapta. Volumele introduse din fiecare lichid, notate cu $V_i$ ($1 \leq i \leq n$), sunt **numere naturale nenule pare** astfel încât, la echilibru, orice lichid se va aşeza între două gradaţii de aceeaşi parte a unei ramuri sau pe cele două ramuri ale sistemului de vase comunicante. Lichidele sunt identificate prin intermediul culorii acestora, culori numerotate cu $1$, $2$, $3$, $\dots$, $n$. Introducerea lichidelor în sistemul cu două vase comunicante se face în ordinea crescătoare a numerelor culorilor, începând cu lichidul de culoare $1$.

~[1.png|align=right|width=15em]

\
Scopul experimentului este de a determina gradaţia maximă la care se ridică lichidele în sistemul cu două vase comunicante, precum şi între ce gradaţii se găseşte un lichid de culoare $x$, dintre cele introduse.

De exemplu, dacă în sistemul cu două vase comunicante se introduc $n=3$ lichide în ordinea: $V_1=4$ lichid de culoare $1$ introdus prin ramura din dreapta (operaţie codificată `4 D`), $V_2=4$ lichid de culoare $2$ introdus prin ramura din stânga (operaţie codificată `4 S`) şi $V_3=2$ lichid de culoare $3$ introdus prin ramura din stânga (operaţie codificată `2 S`) atunci gradaţia maximă la care se ridică nivelul lichidelor în sistemul cu două vase comunicante este $5$, iar lichidul de culoare $x=2$ se găseşte între gradaţiile: $3$ pe ramura din stânga (`3 S`) şi $1$ pe ramura din dreapta (`1 D`), conform figurii alăturate.

# Cerinţă
Să se scrie un program care cunoscând numărul $n$ de lichide introduse în sistemul cu două vase comunicante, volumul $V_i$ şi ramura prin care se face introducerea lichidului de culoare $i$ ($1 \leq i \leq n$), precum şi culoarea $x$, să calculeze gradaţia maximă la care se ridică lichidele în acest sistem la echilibru şi între ce gradaţii se găseşte lichidul de culoare $x$.

# Date de intrare
Prima linie a fişierului de intrare `vase.in` conţine un singur număr natural nenul $n$, cu semnificaţia de mai sus. Fiecare linie, din următoarele $n$, conţine câte două valori separate printr-un spaţiu: un număr natural nenul par şi o literă mare, `S` sau `D`, reprezentând volumul introdus din lichidul de culoare $i$, respectiv ramura (`S` pentru ramura din stânga şi `D` pentru ramura din dreapta) prin care se face introducerea acestuia. Linia $n+2$ a fişierului de intrare conţine un singur număr nenul $x$ ce reprezintă culoarea lichidului căutat.

# Date de ieşire
Fişierul de ieşire `vase.out` va conţine pe prima linie un număr natural nenul ce reprezintă gradaţia maximă la care se ridică lichidele în sistemul de vase comunicante la echilibru. Următoarele două linii vor conţine fiecare câte două valori separate printr-un spaţiu: un număr natural şi o literă mare (`S` sau `D`), reprezentând gradaţia şi ramura între care se aşează lichidul căutat.

# Restricţii şi precizări
- $1 \leq x \leq n \leq 100\ 000$
- $2 \leq V_i \leq 100\ 000$ pentru $1 \leq i \leq n$
- Sistemul de vase este gradat în aceleaşi unităţi de măsură în care sunt exprimate volumele de lichid.
- Dacă lichidul căutat, de culoare $x$, se aşează pe aceeaşi ramură se va afişa întâi gradaţia superioară şi apoi cea inferioară.
- Dacă lichidul căutat, de culoare $x$, se aşează pe ramuri diferite se va afişa întâi gradaţia de pe ramura din stânga şi apoi cea de pe ramura din dreapta.
- Dacă una dintre gradaţiile între care se situează lichidul căutat, de culoare $x$, este $0$ atunci se consideră că aceasta gradaţie se găseşte pe aceeaşi ramură cu cealaltă gradaţie.
- Pentru rezolvarea primei cerinţe se acordă $20\%$ din punctaj, iar pentru a doua cerinţă $80\%$ din punctaj.

---

Example:
`vase.in`
```
3
4 D
4 S
2 S
2
```

`vase.out`
```
5
3 S
1 D
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```markdown
```python
import numpy as np

# Read the input data from 'vase.in'.
with open('vase.in', 'r') as fin:
    n = int(fin.readline().strip())  # Number of liquids
    liquids = [fin.readline().strip().split() for _ in range(n)]
    x_color = int(fin.readline().strip())  # The color of the liquid to find

# Initialize left and right side levels
left_level = 0
right_level = 0

# Track the position of each liquid
positions = []

# Process the liquids
for i, (vol, side) in enumerate(liquids):
    vol = int(vol)
    # Add the current liquid volume to the corresponding side and record its position
    if side == 'S':
        positions.append((left_level + vol, left_level, 'S'))
        left_level += vol
    else:  # side == 'D'
        positions.append((right_level, right_level + vol, 'D'))
        right_level += vol

    # Balance the levels if needed
    if left_level > right_level:
        right_level = left_level
    elif right_level > left_level:
        left_level = right_level

# Find the maximum level and the position of the x-th color liquid
max_level = max(left_level, right_level)
x_position = positions[x_color - 1]

# Write the output to 'vase.out'.
with open('vase.out', 'w') as fout:
    fout.write(f"{max_level}\n")
    if x_position[2] == 'S':
        fout.write(f"{x_position[0]} S\n{x_position[1]} D\n")
    else:  # x_position[2] == 'D'
        fout.write(f"{x_position[1]} S\n{x_position[0]} D\n")
```
```
---------- user ----------


Expected program to write result to `vase.out` and read from `vase.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
# Efficient solution utilizing minimal memory to solve the vase challenge.

# The code reads from 'vase.in' and writes to 'vase.out'.
# numpy is not used because the problem doesn't involve large numerical computations or arrays that would benefit from it.

def write_output(file_path, max_level, upper_pos, lower_pos, upper_side, lower_side):
    with open(file_path, 'w') as f:
        f.write(f"{max_level}\n")
        # Determine the order based on the side for the x-th liquid position
        if upper_side == 'S':
            f.write(f"{upper_pos} S\n{lower_pos} D\n")
        else:
            f.write(f"{upper_pos} D\n{lower_pos} S\n")

def main():
    with open('vase.in', 'r') as file:
        n = int(file.readline().strip())  # Number of liquids
        levels = {'S': 0, 'D': 0}
        positions = {}

        for i in range(1, n + 1):
            volume, side = file.readline().split()
            volume = int(volume)
            # Update the levels
            levels[side] += volume
            # Store the positions for each liquid
            positions[i] = (levels['S'], levels['D'], side)
            # Balance the levels
            max_level = max(levels['S'], levels['D'])
            levels['S'] = levels['D'] = max_level

        # Liquid color to find
        x = int(file.readline().strip())

    # Find the color x positions and max level
    upper_pos, lower_pos, upper_side = positions[x]
    lower_side = 'S' if upper_side == 'D' else 'D'

    # Determine the positions relative to the sides
    if upper_side == 'S':
        upper_pos, lower_pos = upper_pos, levels[lower_side] - (upper_pos - lower_pos)
    else:
        upper_pos, lower_pos = levels[upper_side] - (lower_pos - upper_pos), lower_pos

    # Write the result to 'vase.out'
    write_output('vase.out', max_level, upper_pos, lower_pos, upper_side, lower_side)

if __name__ == "__main__":
    main()
```
```
---------- user ----------


Expected program to write result to `vase.out` and read from `vase.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
# Efficient solution to read from 'vase.in' and write to 'vase.out', without using 'input()' or 'print()'.

def main():
    with open('vase.in', 'r') as file:
        n = int(file.readline().strip())  # Number of liquids
        liquids = [file.readline().strip().split() for _ in range(n)]
        x = int(file.readline().strip())  # Color x to find

    # Initialize levels for left and right sides
    left = 0
    right = 0
    # Store the levels at which each color liquid is located
    color_positions = {}

    # Process each liquid
    for color, (volume, side) in enumerate(liquids, 1):
        volume = int(volume)
        # Add the volume to the appropriate side
        if side == 'S':
            left += volume
            color_positions[color] = (left, right, side)
        else:  # side == 'D'
            right += volume
            color_positions[color] = (left, right, side)
        # Equalize the levels if necessary
        max_level = max(left, right)
        left = right = max_level

    # Find the max level and the position of the x-th color liquid
    upper_pos, lower_pos, upper_side = color_positions[x]
    if upper_side == 'S':
        lower_pos = upper_pos - (left - right)  # Calculate the opposite level
    else:  # upper_side == 'D'
        upper_pos = lower_pos - (right - left)  # Calculate the opposite level

    # Write the output to 'vase.out'
    with open('vase.out', 'w') as file:
        file.write(f"{max_level}\n")
        if upper_side == 'S':
            file.write(f"{upper_pos} S\n{lower_pos} D\n")
        else:
            file.write(f"{lower_pos} S\n{upper_pos} D\n")

if __name__ == "__main__":
    main()
```
```
---------- user ----------


Expected program to write result to `vase.out` and read from `vase.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
# Efficient solution to solve the vase challenge, reading from 'vase.in' and writing to 'vase.out'.

# Open the input file and read the input data.
with open('vase.in', 'r') as file:
    n = int(file.readline())  # Read the number of liquids
    liquids = [list(file.readline().split()) for _ in range(n)]  # Read the volumes and sides of the liquids
    x = int(file.readline())  # Read the color to find

left = right = 0  # Initialize the left and right levels
colors = {}  # Dictionary to store the levels for each color

# Process each liquid and determine the levels
for i, (volume, side) in enumerate(liquids):
    volume = int(volume)
    if side == 'S':
        left += volume
        colors[i+1] = (left, right, side)
    else:  # side == 'D'
        right += volume
        colors[i+1] = (left, right, side)

    # Equalize the levels
    if left > right:
        right = left
    elif right > left:
        left = right

# Find the maximum level
max_level = max(left, right)

# Determine the position of the x-th color
x_left, x_right, x_side = colors[x]

# Calculate the exact levels between which the x-th color is situated
if x_side == 'S':
    x_lower_level = x_left - (volume if i+1 == x else 0)
    x_upper_level = x_left
else:  # x_side == 'D'
    x_lower_level = x_right - (volume if i+1 == x else 0)
    x_upper_level = x_right

# Write the output to 'vase.out'
with open('vase.out', 'w') as file:
    file.write(f"{max_level}\n")
    if x_side == 'S':
        file.write(f"{x_upper_level} S\n{x_lower_level} D\n")
    else:  # x_side == 'D'
        file.write(f"{x_lower_level} S\n{x_upper_level} D\n")
```
```
---------- user ----------


Expected program to write result to `vase.out` and read from `vase.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
# Open the input file and read the contents
with open('vase.in', 'r') as f:
    n = int(f.readline())  # Read the number of liquids
    operations = [f.readline().strip().split() for _ in range(n)]
    x = int(f.readline().strip())  # Read the color of the liquid to find

# Initialize the levels on the left and right sides
left_level = 0
right_level = 0
# List to store the level ranges for each liquid
liquids = []

# Process each operation to fill the liquids
for op in operations:
    volume, side = int(op[0]), op[1]  # Extract volume and side from operation
    # Fill the liquid on the specified side and record the level range
    if side == 'S':
        liquids.append((left_level + volume, left_level, 'S'))
        left_level += volume  # Update the left level
    else:
        liquids.append((right_level, right_level + volume, 'D'))
        right_level += volume  # Update the right level
    # Balance the levels to maintain the principle of communicating vessels
    left_level = right_level = max(left_level, right_level)

# Get the range for the specified color
x_range = liquids[x-1]

# Write the output to 'vase.out'
with open('vase.out', 'w') as f:
    # Write the max level
    f.write("{}\n".format(max(left_level, right_level)))
    # Write the range for the specified color, formatted according to the side
    if x_range[2] == 'S':
        f.write("{} S\n{} D\n".format(x_range[0], x_range[1]))
    else:
        f.write("{} S\n{} D\n".format(x_range[1], x_range[0]))
```
---------- user ----------


Expected program to write result to `vase.out` and read from `vase.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
# Open the input file 'vase.in' and read the input data
with open('vase.in', 'r') as file:
    n = int(file.readline().strip())  # Number of liquids
    liquids_info = [file.readline().strip().split() for _ in range(n)]
    liquid_to_find = int(file.readline().strip())  # The color x to be found

# Variables to maintain the current level of liquid in each of the two branches
left_liquid_level = 0
right_liquid_level = 0

# Dictionary to store the position of each color
color_positions = {}

# Process the liquid information
for i in range(n):
    volume, branch = int(liquids_info[i][0]), liquids_info[i][1]
    # Update the levels based on the branch where the liquid is poured
    if branch == 'S':
        left_liquid_level += volume
    else:
        right_liquid_level += volume

    # Balance the levels if necessary to obey the principle of communicating vessels
    max_level = max(left_liquid_level, right_liquid_level)
    left_liquid_level = right_liquid_level = max_level

    # Store the position of the liquid color
    color_positions[i + 1] = (left_liquid_level, right_liquid_level, branch)

# Find the maximum level and the position of the liquid with the specified color
max_liquid_level = max(left_liquid_level, right_liquid_level)
left_position, right_position, position_branch = color_positions[liquid_to_find]

# Write the resulting information to 'vase.out'
with open('vase.out', 'w') as file:
    file.write(f"{max_liquid_level}\n")
    if position_branch == 'S':
        # The liquid spans from its left_position to the right position at the time of its pouring
        file.write(f"{left_position} S\n{left_position - volume} D\n")
    else:
        # The liquid spans from its right_position to the left position at the time of its pouring
        file.write(f"{right_position - volume} S\n{right_position} D\n")
```
```
---------- user ----------


Expected program to write result to `vase.out` and read from `vase.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
# Define a function to compute the levels in the communicating vessels
def compute_liquid_levels(operations):
    left_level, right_level = 0, 0
    levels = []
    for volume, branch in operations:
        volume = int(volume)
        if branch == 'S':
            left_level += volume
        elif branch == 'D':
            right_level += volume
        # Balance the liquid levels
        max_level = max(left_level, right_level)
        left_level = right_level = max_level
        levels.append((left_level, right_level))
    return levels

# Read input from 'vase.in'
with open('vase.in', 'r') as file:
    n = int(file.readline().strip())
    operations = [file.readline().strip().split() for _ in range(n)]
    liquid_color_to_find = int(file.readline().strip())

# Compute the levels for all liquids
liquid_levels = compute_liquid_levels(operations)

# Find the maximum height reached by the liquids
max_height = liquid_levels[-1][0]

# Find the range of levels where the specified color liquid is located
color_level = liquid_levels[liquid_color_to_find - 1]
prev_level = liquid_levels[liquid_color_to_find - 2] if liquid_color_to_find > 1 else (0, 0)
color_volume = int(operations[liquid_color_to_find - 1][0])
color_branch = operations[liquid_color_to_find - 1][1]

# Determine the exact position of the liquid color_to_find
if color_branch == 'S':
    color_start = prev_level[0]
    color_end = color_start + color_volume
else:  # color_branch == 'D'
    color_end = prev_level[1]
    color_start = color_end + color_volume

# Write output to 'vase.out'
with open('vase.out', 'w') as file:
    # Write the maximum height
    file.write(f"{max_height}\n")
    # Write the starting and ending levels of the liquid color_to_find
    if color_branch == 'S':
        file.write(f"{color_end} S\n{color_start} D\n")
    else:  # color_branch == 'D'
        file.write(f"{color_start} S\n{color_end} D\n")
```
