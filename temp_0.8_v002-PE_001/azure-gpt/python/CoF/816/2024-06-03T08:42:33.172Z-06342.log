---------- user ----------

Here is a programming challenge.
Please solve this problem efficiently, optimizing both time and memory usage.
Create the most efficient solution for this challenge in python. Utilize numpy and other highly efficient libraries whenever possible.
This problem has a memory limit of ~8MB so please be sensitive on using memory. Using too much memory may result in OOM.
The code must compile and be correct.
The solution must read from `expresie.in` and write to `expresie.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Prin convenţie numim _expresie aritmetică ponderată_ o expresie construită astfel:
- expresia conţine numere întregi de cel mult $2$ cifre despărţite prin virgulă; 
- numim **k-şir** o enumerare de $k$ numere despărţite prin virgulă $(k \geq 1)$;
- o expresie poate conţine unul sau mai multe $k$-şiruri;
- expresia foloseşte paranteze rotunde şi paranteze drepte.

Evaluarea expresiei se face după următoarele reguli:

- dacă expresia conţine un singur $k$-şir atunci rezultatul expresiei este reprezentat de suma celor $k$ numere (**Exemplu:**  $2,4,1 = 2+4+1 = 7$);
- dacă în expresie întâlnim un $k$-şir delimitat de paranteze rotunde rezultatul evaluării acestui $k$-şir va fi reprezentat de suma maximă a unui secvenţe ce aparţine $k$-şirului, unde prin secvenţă se înţelege o succesiune de numere aflate pe poziţii consecutive în şir (**Exemplu:** $(-2,4,-1,3,-2,-3,2) =>$ secvenţa de sumă maximă este $4,-1,3$  a cărui sumă este egală cu $6$);
- dacă în expresie întâlnim un $k$-şir delimitat de paranteze pătrate, elementele $k$-şirului fiind numerotate $1,2,..,k,$ rezultatul evaluării acestui $k$-şir va fi reprezentat de valoarea elementului aflat pe poziţia $[ \frac{k + 1}{2} ]$ dacă şirul ar fi ordonat crescător (**mediana unui şir**) (**Exemplu:**  $ [-2,9,10,3,5]  =>$  şirul ordonat $[-2,3,5,9,10] =>$ iar valoarea expresiei este egală cu $5$).
- evaluarea parantezelor se face dinspre interior spre exterior.

# Cerinţă

Fiind dată o expresie aritmetică ponderată să se determine:
-	câte numere întregi conţine expresia aritmetică;
-	care este valoarea expresiei aritmetice.


# Date de intrare


Fişierul de intrare `expresie.in` conţine pe prima linie un şir de caractere ce reprezintă o expresie aritmetică ponderată. 

# Date de ieșire


Fişierul de ieşire `expresie.out` va conţine pe prima linie numărul de numere întregi din expresie, iar pe următoarea linie va fi scris un număr ce reprezintă valoarea expresiei aritmetice.

# Restricții și precizări

* expresia se consideră corectă
* $3 ≤$ lungimea unei expresii $≤ 100 \ 000$ 
* şirul prin care se codifică expresia poate să conţină doar următoarele caractere: cifre, paranteze rotunde şi pătrate deschise şi închise, caracterul virgulă, caracterul minus
* pentru rezolvarea primei cerinţe se obţine $20\%$ din valoarea fiecărui test
* $10\%$ dintre teste nu vor conţine paranteze
* $20\%$ dintre teste nu vor conţine paranteze imbricate

---

Example:
`expresie.in`
```
2,(2,-4,1,-1,5)
```

`expresie.out`
```
6
7
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```python
# Utilize numpy for efficient array handling
import numpy as np

def max_subarray_sum(arr):
    max_sum = arr[0]
    current_sum = arr[0]
    for num in arr[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
    return max_sum

def median_of_array(arr):
    arr.sort()
    k = len(arr)
    return arr[(k - 1) // 2]

def evaluate_expression(expression):
    stack = []
    num_count = 0

    for char in expression:
        if char.isdigit() or char == '-':
            # Start of a number
            if stack and (isinstance(stack[-1], int) or stack[-1] == '-'):
                stack[-1] = str(stack[-1]) + char
            else:
                stack.append(char)
        elif char == ',':
            if isinstance(stack[-1], str):
                # Finish the current number
                stack[-1] = int(stack[-1])
                num_count += 1
        elif char == '(':
            stack.append(char)
        elif char == '[':
            stack.append(char)
        elif char == ')':
            # Evaluate the sum of the maximum subarray
            subarr = []
            while stack and stack[-1] != '(':
                subarr.append(stack.pop())
            stack.pop()  # Remove the '('
            subarr.reverse()
            stack.append(max_subarray_sum(np.array(subarr)))
        elif char == ']':
            # Evaluate the median
            subarr = []
            while stack and stack[-1] != '[':
                subarr.append(stack.pop())
            stack.pop()  # Remove the '['
            subarr.reverse()
            stack.append(median_of_array(np.array(subarr)))

    # At the end of the loop, stack should only contain integers
    # and they represent the sum of the whole expression
    return num_count, sum(stack)

# Read from file
with open('expresie.in', 'r') as infile:
    expression = infile.read().strip()

# Evaluate expression
count, result = evaluate_expression(expression)

# Write to file
with open('expresie.out', 'w') as outfile:
    outfile.write(f"{count}\n{result}\n")
```

I've written the code assuming that the input format is strictly followed and there are no syntactical errors in the input expression (as per the problem constraints). This code utilizes NumPy for sorting and basic array manipulations, which is efficient in terms of both time and memory. The stack-based evaluation of the expression ensures that no additional data structure with significant memory overhead is used.
---------- user ----------


Program exited with code 1.
stdout:
```

```
stderr:
```
Traceback (most recent call last):
  File "/app/app.py", line 2, in <module>
    import numpy as np
ModuleNotFoundError: No module named 'numpy'

```

Think of what has caused the exit code. Use the standard out and standard error to help you understand the issue.
Implement a solution to fix the program

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

It seems like the `numpy` module is not available in the execution environment, which caused the `ModuleNotFoundError`. Since the environment may not allow third-party libraries or they may not be installed, I have to rewrite the solution without using `numpy`. 

Here's the solution using only the Python standard library, ensuring that it complies with the memory constraints:

```python
def max_subarray_sum(arr):
    max_sum = current_sum = arr[0]
    for num in arr[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
    return max_sum

def median_of_array(arr):
    arr.sort()
    k = len(arr)
    return arr[(k - 1) // 2]

def evaluate_expression(expression):
    stack = []
    num_count = 0
    number_buffer = ''

    for char in expression:
        if char.isdigit() or (char == '-' and not number_buffer):
            number_buffer += char
        elif char == ',':
            if number_buffer:
                stack.append(int(number_buffer))
                num_count += 1
                number_buffer = ''
        elif char in '([':
            if number_buffer:
                stack.append(int(number_buffer))
                num_count += 1
                number_buffer = ''
            stack.append(char)
        elif char in ')]':
            if number_buffer:
                stack.append(int(number_buffer))
                num_count += 1
                number_buffer = ''
            subarr = []
            while stack[-1] != '(' and stack[-1] != '[':
                subarr.append(stack.pop())
            start_char = stack.pop()
            subarr.reverse()
            if start_char == '(':
                stack.append(max_subarray_sum(subarr))
            elif start_char == '[':
                stack.append(median_of_array(subarr))

    if number_buffer:
        stack.append(int(number_buffer))
        num_count += 1

    return num_count, sum(stack)

# Read from file
with open('expresie.in', 'r') as infile:
    expression = infile.read().strip()

# Evaluate expression
count, result = evaluate_expression(expression)

# Write to file
with open('expresie.out', 'w') as outfile:
    outfile.write(f"{count}\n{result}\n")
```

This solution uses a manual buffer `number_buffer` to handle multi-digit numbers and to distinguish between negative signs and subtraction operations. The `stack` is used for evaluating the expressions inside parentheses and brackets, and the output is written to a file as required. It avoids the use of any external libraries and sticks to the Python standard library to make sure it runs in the given environment.
