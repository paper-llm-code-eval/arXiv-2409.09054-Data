---------- user ----------

Here is a programming challenge.
Please solve this problem efficiently, optimizing both time and memory usage.
Create the most efficient solution for this challenge in python. Utilize numpy and other highly efficient libraries whenever possible.
This problem has a memory limit of ~8MB so please be sensitive on using memory. Using too much memory may result in OOM.
The code must compile and be correct.
The solution must read from `paranteze.in` and write to `paranteze.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Considerăm şiruri formate din paranteze de două tipuri: paranteze rotunde şi paranteze drepte. Parantezele se codifică în felul următor: paranteză rotundă deschisă cu $0$, paranteză rotundă închisă cu $1$, paranteză dreaptă deschisă cu $2$, paranteză dreaptă închisă cu $3$. Spre deosebire de convenţia uzuală din matematică, aici pot exista şi paranteze rotunde incluse în paranteze drepte şi paranteze drepte incluse în paranteze rotunde. Nu putem asocia unei paranteze rotunde deschise o paranteză dreaptă închisă sau viceversa.

# Cerință

Să se decidă dacă un astfel de şir este corect construit, în sensul că putem asocia corect două câte două parantezele de fiecare tip


# Date de intrare

Fişierul de intrare `paranteze.in` conţine pe prima linie numărul $n$ (numărul de şiruri ale testului). 

Apoi pe fiecare din liniile $2, 3, \dots, n+1$ se află numerele $L \ c_1 \ c_2 \ \dots \ c_L$, numărul natural $L$ reprezintă lungimea unui şir de paranteze codificat conform enunţului. 

Valorile $c_1, c_2, \dots, c_L$ reprezintă codurile respective. Toate numerele sunt despărţite prin câte un spaţiu.

# Date de ieșire

În fişierului de ieșire `paranteze.out` se va scrie $n$ linii. Pe câte o linie va fi scris câte un mesaj. Pe fiecare linie se va scrie unul din mesajele `Da`, respectiv `Nu`, reprezentând rezultatele verificării corectitudinii şirurilor. Ordinea lor corespunde ordinii şirurilor din fişierul de intrare

# Restricții și precizări

* $1 \leq n \leq 10$;
* Fiecare valoare $L$ îndeplineşte condiţia: $1 \leq L \leq 500$.

---

Example:
`paranteze.in`
```
8
6 0 2 3 1 0 1
6 2 0 1 0 1 3
4 0 2 1 3
6 2 0 0 3 1 1
6 2 2 0 1 1 3
6 2 0 0 1 3 0
10 2 2 0 1 0 1 3 3 0 1
10 0 0 0 1 1 1 0 2 3 1
```

`paranteze.out`
```
Da
Da
Nu
Nu
Nu
Nu
Da
Da
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```markdown
```python
import numpy as np

def check_brackets(sequence):
    stack = []
    for bracket in sequence:
        if bracket == 0 or bracket == 2:
            stack.append(bracket)
        else:
            if not stack:
                return "Nu"
            last = stack.pop()
            if (bracket == 1 and last != 0) or (bracket == 3 and last != 2):
                return "Nu"
    return "Da" if not stack else "Nu"

# Read from input file and write to output file
with open('paranteze.in', 'r') as infile, open('paranteze.out', 'w') as outfile:
    n = int(next(infile).strip())
    for _ in range(n):
        line = list(map(int, next(infile).strip().split()))
        L, sequence = line[0], np.array(line[1:], dtype=np.int8)
        result = check_brackets(sequence)
        outfile.write(result + '\n')
```
```
---------- user ----------


Expected program to write result to `paranteze.out` and read from `paranteze.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

Certainly! Here's the updated Python solution:

```markdown
```python
def check_brackets(sequence):
    stack = []
    for bracket in sequence:
        if bracket == 0 or bracket == 2:
            stack.append(bracket)
        else:
            if not stack:
                return "Nu"
            last = stack.pop()
            if (bracket == 1 and last != 0) or (bracket == 3 and last != 2):
                return "Nu"
    return "Da" if not stack else "Nu"

# Read from 'paranteze.in' and write to 'paranteze.out'
with open('paranteze.in', 'r') as infile, open('paranteze.out', 'w') as outfile:
    n = int(next(infile).strip())
    for _ in range(n):
        # The first value in the line is L, the rest are the bracket sequence
        line = list(map(int, next(infile).strip().split()))
        sequence = line[1:]  # Ignore L when passing to the function
        result = check_brackets(sequence)
        outfile.write(result + '\n')
```
```

This code will read the number of test cases and each sequence of brackets from `paranteze.in`, determine if each sequence of brackets is correctly built, and write the results (`Da` or `Nu`) to `paranteze.out`. It avoids using `input()` or `print()` for I/O operations and adheres to the memory constraints by not using any additional large data structures or libraries beyond what's necessary.
---------- user ----------


Expected program to write result to `paranteze.out` and read from `paranteze.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

I apologize for any confusion. Here is the revised and complete Python solution, which reads from `paranteze.in` and writes to `paranteze.out`, without using `input()` or `print()`:

```markdown
```python
# Define the function to check if the sequence of brackets is correct
def check_brackets(sequence):
    stack = []
    for bracket in sequence:
        if bracket % 2 == 0:  # If it's an opening bracket (0 or 2)
            stack.append(bracket)
        else:  # If it's a closing bracket (1 or 3)
            if not stack:
                return "Nu"
            last = stack.pop()
            # Check if the opening bracket matches the closing bracket
            if (bracket == 1 and last != 0) or (bracket == 3 and last != 2):
                return "Nu"
    return "Da" if not stack else "Nu"

# Read from 'paranteze.in' and write to 'paranteze.out'
with open('paranteze.in', 'r') as infile, open('paranteze.out', 'w') as outfile:
    n = int(next(infile).strip())  # Read the number of test cases
    for _ in range(n):
        line = list(map(int, next(infile).strip().split()))  # Read each sequence
        sequence = line[1:]  # Exclude the length of the sequence (first element)
        result = check_brackets(sequence)  # Check the sequence
        outfile.write(result + '\n')  # Write the result to 'paranteze.out'
```
```

This code correctly addresses the requirements of the challenge and should work within the specified memory constraints, as it processes each sequence one at a time without storing unnecessary data.
---------- user ----------


Expected program to write result to `paranteze.out` and read from `paranteze.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

Here's the complete Python solution that strictly reads from `paranteze.in` and writes to `paranteze.out`. It does not use `input()` or `print()` for I/O operations.

```python
def check_brackets(sequence):
    stack = []
    for bracket in sequence:
        if bracket in [0, 2]:  # Open brackets
            stack.append(bracket)
        elif bracket in [1, 3]:  # Close brackets
            if not stack:
                return "Nu"
            last_open = stack.pop()
            if last_open == 0 and bracket != 1 or last_open == 2 and bracket != 3:
                return "Nu"
    return "Da" if not stack else "Nu"

with open('paranteze.in', 'r') as infile:
    n = int(infile.readline().strip())  # Read the number of test cases
    results = []
    for _ in range(n):
        line = list(map(int, infile.readline().strip().split()))[1:]  # Skip the first number
        result = check_brackets(line)  # Check the bracket sequence
        results.append(result)

with open('paranteze.out', 'w') as outfile:
    outfile.write('\n'.join(results))  # Write all results to the file
```

This solution uses a stack to track open brackets. When a closing bracket is encountered, it checks for a matching open bracket on top of the stack. If the sequence is valid, it returns "Da"; otherwise, it returns "Nu". The results are collected and written to the output file in one go, which is memory efficient.
