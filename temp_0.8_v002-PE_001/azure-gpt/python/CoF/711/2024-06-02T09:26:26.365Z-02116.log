---------- user ----------

Here is a programming challenge.
Please solve this problem efficiently, optimizing both time and memory usage.
Create the most efficient solution for this challenge in python. Utilize numpy and other highly efficient libraries whenever possible.
This problem has a memory limit of ~8MB so please be sensitive on using memory. Using too much memory may result in OOM.
The code must compile and be correct.
The solution must read from `text.in` and write to `text.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Vasile lucrează intens la un editor de texte. Un text este format din unul sau mai multe paragrafe. Orice paragraf se termină cu `Enter` şi oricare două cuvinte consecutive din acelaşi paragraf sunt separate prin spaţii (unul sau mai multe). În funcţie de modul de setare a paginii, numărul maxim de caractere care încap în pagină pe o linie este unic determinat (notăm cu $MAX$).
\
Funcţia pe care Vasile trebuie să o implementeze acum este alinierea în pagină a fiecărui paragraf din text la stânga şi la dreapta. Pentru aceasta el va trebui să împartă fiecare paragraf în linii separate de lungime $MAX$ (fiecare linie terminată cu `Enter`). Împărţirea se realizează punând numărul maxim posibil de cuvinte pe fiecare linie, fără împărţirea cuvintelor în silabe. Pentru aliniere stânga-dreapta, el trebuie să repartizeze spaţii în mod **uniform** între cuvintele de pe fiecare linie, astfel încât ultimul caracter de pe linie să fie diferit de spaţiu, iar numărul total de caractere de pe linie să fie egal cu $MAX$. Excepţie face numai ultima linie din paragraf, care rămâne aliniată la stânga (cuvintele fiind separate printr-un singur spaţiu, chiar dacă linia nu este plină).

În general, este puţin probabil ca alinierea să fie realizabilă prin plasarea aceluiaşi număr de spaţii între oricare două cuvinte consecutive de pe linie. Vasile consideră că este mai elegant ca, dacă între unele cuvinte consecutive trebuie plasat un spaţiu în plus faţă de alte perechi de cuvinte consecutive, acestea să fie plasate la începutul liniei.

# Cerinţă
Scrieţi un program care să citească lungimea unei linii şi textul dat şi care să alinieze textul la stânga şi la dreapta.

# Date de intrare
Fişierul de intrare `text.in` conţine pe prima linie $MAX$, lungimea maximă a unui rând.
Pe următoarele linii este scris textul.

# Date de ieşire
Fişierul de ieşire `text.out` conţine textul aliniat stânga-dreapta.

# Restricţii și precizări
- $2 \leq MAX \leq 1\ 000$
- **Atenție!** Lungimea maximă a oricărui cuvânt din text este de $40$ de caractere şi nu depăşeşte $MAX$. În enunțul original limita unui cuvânt era de $25$ de caractere, însă se pare că testele nu respectau această limită.
- **Atenție!** În cazul în care o linie este goală, aceasta se păstrează.
- Lungimea unui paragraf nu depăşeşte $1\ 000$ de caractere.
- Soluţia este unică.

---

Example:
`text.in`
```
20
Vasile are multe bomboane bune.
```

`text.out`
```
Vasile   are   multe
bomboane bune.
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```markdown
```python
import numpy as np

def justified_text(max_length, text):
    words = text.split()
    lines = []
    current_line = []
    current_length = 0

    for word in words:
        if current_length + len(word) + len(current_line) <= max_length:
            current_line.append(word)
            current_length += len(word)
        else:
            lines.append(current_line)
            current_line = [word]
            current_length = len(word)

    # Append the last line
    lines.append(current_line)

    justified_lines = []
    for line in lines[:-1]:  # Justify all but the last line
        if len(line) == 1:
            justified_lines.append(line[0].ljust(max_length))
        else:
            total_space = max_length - sum(len(word) for word in line)
            spaces = np.linspace(0, total_space, len(line) - 1, dtype=int)
            difference = total_space - spaces.sum()
            spaces[:difference] += 1
            justified_line = ''.join(word.ljust(len(word) + space) for word, space in zip(line, spaces))
            justified_lines.append(justified_line.rstrip())

    # Handle the last line (left-aligned)
    justified_lines.append(' '.join(lines[-1]).ljust(max_length))

    return '\n'.join(justified_lines)


# Read from 'text.in'
with open('text.in', 'r') as file:
    max_length = int(file.readline().strip())
    text = file.read().strip()

justified = justified_text(max_length, text)

# Write to 'text.out'
with open('text.out', 'w') as file:
    file.write(justified)
```
```
This code snippet reads the maximum line length and the text to be justified from 'text.in', justifies it according to the prescribed algorithm, and writes the resulting justified text to 'text.out'. The numpy library is used to distribute the spaces uniformly between words for each justified line.
---------- user ----------


Expected program to write result to `text.out` and read from `text.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Function to justify a single line
def justify_line(line_words, max_length):
    if len(line_words) == 1:
        return line_words[0].ljust(max_length)
    total_chars = sum(len(word) for word in line_words)
    total_spaces = max_length - total_chars
    space_slots = len(line_words) - 1
    spaces = np.full(space_slots, total_spaces // space_slots)
    spaces[:total_spaces % space_slots] += 1
    justified_line = ''.join(word + ' ' * space for word, space in zip(line_words, spaces))
    return justified_line

# Read from 'text.in'
with open('text.in', 'r') as file:
    max_length = int(file.readline().strip())
    text = file.read()

# Split text into paragraphs
paragraphs = text.split('\n')

# Process each paragraph
justified_text = []
for paragraph in paragraphs:
    words = paragraph.split()
    lines = []
    current_line = []
    current_length = 0

    # Break paragraph into lines
    for word in words:
        if current_length + len(word) + len(current_line) > max_length:
            lines.append(current_line)
            current_line = []
            current_length = 0
        current_line.append(word)
        current_length += len(word)
    lines.append(current_line)  # Add the last line

    # Justify lines
    for line in lines[:-1]:
        justified_text.append(justify_line(line, max_length))
    # Last line should be left-justified
    justified_text.append(' '.join(lines[-1]))

    # Add a blank line to separate paragraphs
    justified_text.append('')

# Write to 'text.out'
with open('text.out', 'w') as file:
    # Join all lines and remove the last blank line
    file.write('\n'.join(justified_text[:-1]).rstrip())
```
```
This updated solution reads from `text.in`, processes the input to justify the text, and writes the output to `text.out` without using `input()` or `print()`. The code takes into account both left and right justification of text, except for the last line of each paragraph, which is left-justified. Numpy is used for even spacing distribution between words in a line.
---------- user ----------


Expected program to write result to `text.out` and read from `text.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

def justify_paragraph(paragraph, max_length):
    words = paragraph.split()
    lines = []
    line = []

    for word in words:
        # Check if adding the next word exceeds the max_length
        if sum(len(w) for w in line) + len(word) + len(line) > max_length:
            lines.append(line)
            line = []
        line.append(word)
    lines.append(line)

    justified_lines = []
    for i, line in enumerate(lines):
        if i < len(lines) - 1:
            # Calculate spaces for justification
            spaces_needed = max_length - sum(len(word) for word in line)
            gaps = len(line) - 1
            if gaps > 0:
                spaces = np.full(gaps, spaces_needed // gaps)
                spaces[:spaces_needed % gaps] += 1
                justified_line = ''.join(word + ' ' * space for word, space in zip(line, spaces))
            else:
                justified_line = line[0] + ' ' * spaces_needed
            justified_lines.append(justified_line)
        else:
            # Last line is left-justified
            justified_lines.append(' '.join(line).ljust(max_length))

    return justified_lines

# Read from 'text.in'
with open('text.in', 'r') as file:
    max_length = int(file.readline().strip())
    paragraphs = file.read().split('\n')

# Process each paragraph and justify the text
justified_text = []
for paragraph in paragraphs:
    if paragraph:
        justified_text.extend(justify_paragraph(paragraph, max_length))
    justified_text.append('')  # Add empty line for paragraph separation

# Write to 'text.out'
with open('text.out', 'w') as file:
    file.write('\n'.join(justified_text).strip('\n'))
```
```
This complete solution reads the maximum line length and text from `text.in`, processes each paragraph by justifying it as specified, and writes the justified text to `text.out`. Justification is performed using NumPy's array capabilities for evenly distributing spaces between words where required. The code ensures that the last line of each paragraph is left-justified and that paragraphs are separated by an empty line. The final output is written without any trailing newline characters.
---------- user ----------


Expected program to write result to `text.out` and read from `text.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Open the input file and read the max length and the text
with open('text.in', 'r') as f:
    max_length = int(f.readline().strip())
    text = f.read().strip()

# Split the text into paragraphs
paragraphs = text.split('\n\n')

# A function to distribute spaces evenly between words on a line
def distribute_spaces(words, max_length):
    if len(words) == 1:
        return words[0].ljust(max_length)
    total_spaces = max_length - sum(len(word) for word in words)
    spaces_between_words = total_spaces // (len(words) - 1)
    extra_spaces = total_spaces % (len(words) - 1)
    line = words[0]
    for word in words[1:]:
        spaces_to_insert = spaces_between_words + (1 if extra_spaces > 0 else 0)
        extra_spaces -= 1
        line += ' ' * spaces_to_insert + word
    return line

# Function to justify a paragraph
def justify_paragraph(paragraph, max_length):
    words = paragraph.split()
    lines = []
    current_line = []
    current_line_length = 0
    for word in words:
        if current_line_length + len(word) + len(current_line) > max_length:
            lines.append(distribute_spaces(current_line, max_length))
            current_line = [word]
            current_line_length = len(word)
        else:
            current_line.append(word)
            current_line_length += len(word)
    lines.append(' '.join(current_line))  # Last line is left-justified
    return lines

# Justify the entire text
justified_lines = []
for paragraph in paragraphs:
    justified_lines.extend(justify_paragraph(paragraph, max_length))
    justified_lines.append('')  # Paragraph separator

# Open the output file and write the justified text
with open('text.out', 'w') as f:
    f.write('\n'.join(justified_lines).strip('\n'))
```
```
This solution opens the input file `text.in` to read the maximum line length and the text. It processes the text by splitting it into paragraphs and justifying each paragraph according to the specified rules. For each paragraph, it distributes spaces evenly between words on each line (except for the last line, which is left-justified) and writes the justified text to the output file `text.out`. The code uses the NumPy library for efficient calculation, although it is not strictly necessary in this latest version of the code.
---------- user ----------


Expected program to write result to `text.out` and read from `text.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
# Read 'text.in' and get MAX and paragraphs
with open('text.in', 'r') as fin:
    MAX = int(fin.readline().strip())
    paragraphs = fin.read().strip().split('\n\n')

# Helper function to justify a line
def justify_line(words, max_width):
    if len(words) == 1:  # If the line contains only one word
        return words[0].ljust(max_width)
    total_spaces = max_width - sum(len(w) for w in words)
    spaces_between_words = total_spaces // (len(words) - 1)
    extra_spaces = total_spaces % (len(words) - 1)
    justified = ''
    for i, word in enumerate(words[:-1]):
        justified += word + ' ' * (spaces_between_words + (1 if i < extra_spaces else 0))
    justified += words[-1]  # Append the last word without extra space
    return justified

# Process paragraphs and write the result to 'text.out'
with open('text.out', 'w') as fout:
    for p in paragraphs:
        words = p.split()
        line_words = []
        char_count = 0

        for word in words:
            if char_count + len(word) + len(line_words) > MAX:  # Time to create a new line
                fout.write(justify_line(line_words, MAX) + '\n')
                line_words = [word]
                char_count = len(word)
            else:
                line_words.append(word)
                char_count += len(word)

        # Write the last line of the paragraph (left-justified)
        fout.write(' '.join(line_words).ljust(MAX) + '\n')

        # Add a newline to separate paragraphs if not the last paragraph
        if p != paragraphs[-1]:
            fout.write('\n')
```
```
This Python solution reads from 'text.in', processes the text to justify it, and writes the output to 'text.out'. It uses a helper function to justify a line of text by distributing spaces evenly between words. The solution takes into account paragraphs and ensures the last line of each paragraph is left-justified. It avoids using `input()` and `print()` and writes directly to the output file in accordance with the constraints.
---------- user ----------


Expected program to write result to `text.out` and read from `text.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
# Function to justify text within a paragraph
def justify_paragraph(paragraph, max_length):
    words = paragraph.split()
    lines = []
    current_line = []
    line_length = 0

    for word in words:
        if line_length + len(word) + len(current_line) > max_length:
            # Distribute spaces for the line being processed
            for i in range(max_length - line_length):
                current_line[i % (len(current_line) - 1)] += ' '
            lines.append(''.join(current_line))
            current_line = [word]
            line_length = len(word)
        else:
            current_line.append(word)
            line_length += len(word)

    # Left-justify the last line of the paragraph
    lines.append(' '.join(current_line).ljust(max_length))
    return lines

# Open 'text.in', read MAX and text, split into paragraphs
with open('text.in', 'r') as file_input:
    max_length = int(file_input.readline().strip())
    content = file_input.read().strip()
    paragraphs = content.split('\n\n')

# Process each paragraph and write justified text to 'text.out'
with open('text.out', 'w') as file_output:
    for index, paragraph in enumerate(paragraphs):
        justified = justify_paragraph(paragraph, max_length)
        file_output.write('\n'.join(justified))
        if index < len(paragraphs) - 1:
            file_output.write('\n\n')  # Separate paragraphs with a blank line
```
```
This code defines a function `justify_paragraph` to justify text within a paragraph and make sure the last line is left-justified. It reads from 'text.in', processes the text, and writes the justified output to 'text.out'. The function processes each paragraph and writes the justified text to the file, ensuring paragraphs are separated by a blank line. The solution does not use `input()` or `print()` for I/O operations.
---------- user ----------


Expected program to write result to `text.out` and read from `text.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
# Read the file 'text.in'
with open('text.in', 'r') as file:
    MAX = int(file.readline().strip())
    text = file.read()

# Helper function to add spaces and justify the lines
def add_spaces(words, max_length, last_line=False):
    if last_line or len(words) == 1: # If it's the last line or a single word
        return ' '.join(words).ljust(max_length)
    spaces_needed = max_length - sum(len(word) for word in words)
    spaces = [' ' * (spaces_needed // (len(words) - 1))] * (len(words) - 1)
    for i in range(spaces_needed % (len(words) - 1)):
        spaces[i] += ' '
    return ''.join(word + space for word, space in zip(words, spaces + ['']))

# Split the text into paragraphs and process each paragraph
justified_text = ''
for paragraph in text.split('\n'):
    words = paragraph.split()
    line = []
    line_length = 0
    for word in words:
        if line_length + len(word) + len(line) > MAX:
            justified_text += add_spaces(line, MAX) + '\n'
            line = [word]
            line_length = len(word)
        else:
            line.append(word)
            line_length += len(word)
    justified_text += add_spaces(line, MAX, last_line=True) + '\n'

# Write the justified text to 'text.out'
with open('text.out', 'w') as file:
    file.write(justified_text.rstrip('\n'))
```
```
This code will read the maximum line length and text from `text.in`, justify the text, and write it to `text.out`. The `add_spaces` function is used to distribute spaces between words uniformly for each line, except for the last line of a paragraph, which is left-justified. The output text will be trimmed of any trailing newline characters before being written to the output file.
