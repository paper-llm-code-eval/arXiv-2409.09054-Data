---------- user ----------

Here is a programming challenge.
Please solve this problem efficiently, optimizing both time and memory usage.
Create the most efficient solution for this challenge in python. Utilize numpy and other highly efficient libraries whenever possible.
This problem has a memory limit of ~8MB so please be sensitive on using memory.Using unavoided memory may result in OOM.
The code must compile and be correct.
The solution must read from `mouse.in` and write to `mouse.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Un experiment urmărește comportarea unui șoricel pus într-o cutie dreptunghiulară, împărțită în $m \times n$ cămăruțe egale de formă pătrată. Fiecare cămăruță conține o anumită cantitate de hrană. Șoricelul trebuie să pornească din colțul $(1,1)$ al cutiei și să ajungă în colțul opus, mâncând cât mai multă hrană. El poate trece dintr-o cameră în una alăturată (două camere sunt alăturate dacă au un perete comun), mănâncă toată hrana din cămăruță atunci când intră și nu intră niciodată într-o cameră în care a mai intrat înainte. 

# Cerință

Stabiliți care este cantitatea maximă de hrană pe care o poate mânca și traseul pe care îl poate urma pentru a culege această cantitate maximă.

# Date de intrare
Fișierul de intrare `mouse.in` conține pe prima linie două numere $m$ și $n$ reprezentând numărul de linii respectiv numărul de coloane ale cutiei, iar pe următoarele $m$ linii cele $m \cdot n$ numere reprezentând cantitatea de hrană existentă în fiecare cămăruță, câte $n$ numere pe fiecare linie, separate prin spații.

# Date de ieșire
În fișierul de ieșire `mouse.out` se vor scrie pe prima linie două numere separate printr-un spațiu: numărul de cămăruțe vizitate și cantitatea de hrană maximă culeasă. Pe următoarele linii se va scrie un traseu posibil pentru cantitatea dată, sub formă de perechi de numere, începând cu $(1, 1)$ și terminând cu $(m, n)$.

# Restricții și precizări
- Toate valorile din fișier sunt numere naturale între $1$ și $100$.
- Veți primi 40 de puncte pentru afișarea primelor două numere.

---

Example:
`mouse.in`
```
2 4
1 2 6 3
3 4 1 2
```

`mouse.out`
```
7 21
1 1
2 1
2 2
1 2
1 3
1 4
2 4
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```python
import numpy as np

# Read the content of the input file 'mouse.in'
with open('mouse.in', 'r') as file:
    m, n = map(int, file.readline().split())
    food_matrix = np.array([list(map(int, file.readline().split())) for _ in range(m)], dtype=np.int32)

# Utility functions
def valid(row, col):
    return 0 <= row < m and 0 <= col < n

def backtrack(row, col):
    if not valid(row, col) or visited[row, col]:
        return 0, []
    if (row, col) == (m - 1, n - 1):
        return food_matrix[row, col], [(row + 1, col + 1)]
    
    visited[row, col] = True
    max_food = food_matrix[row, col]
    path = [(row + 1, col + 1)]
    
    # Explore the next possible moves (right, down, left, up)
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    for dr, dc in directions:
        next_food, next_path = backtrack(row + dr, col + dc)
        if next_food + food_matrix[row, col] > max_food:
            max_food = next_food + food_matrix[row, col]
            path = [(row + 1, col + 1)] + next_path
    
    visited[row, col] = False
    return max_food, path

# Initialize the visited matrix
visited = np.zeros((m, n), dtype=bool)

# Start backtracking from the first cell
total_food, route = backtrack(0, 0)

# Write the result to the output file 'mouse.out'
with open('mouse.out', 'w') as file:
    file.write(f"{len(route)} {total_food}\n")
    for r in route:
        file.write(f"{r[0]} {r[1]}\n")
```

This code uses backtracking to explore each possible path the mouse can take, collecting the maximum amount of food on its way from the top-left corner to the bottom-right corner of the matrix. The visited matrix ensures that no cell is visited more than once on any given path. When the bottom-right corner is reached, the function returns the amount of food collected along with the path taken. The main backtracking function then compares the food collected from each path and chooses the one with the maximum food. The code handles the file I/O as specified, reading from 'mouse.in' and writing to 'mouse.out'.
---------- user ----------


Program exited with code 1.
stdout:
```

```
stderr:
```
Traceback (most recent call last):
  File "/app/app.py", line 1, in <module>
    import numpy as np
ModuleNotFoundError: No module named 'numpy'

```

Think of what has caused the exit code. Use the standard out and standard error to help you understand the issue.
Implement a solution to fix the program

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The error indicates that the `numpy` library is not available in the environment where the code is being executed. Since the requirement is to optimize for both time and memory, and we have a strict memory limit, it's best to avoid using `numpy`.

I will rewrite the solution without using `numpy` or any other external libraries, relying only on built-in Python functionality to ensure compatibility and adherence to the memory constraints.

Here's the updated solution:

```python
# Utility function to check if the move is valid
def valid(row, col, m, n):
    return 0 <= row < m and 0 <= col < n

# Backtracking function to find the maximum food and path
def backtrack(row, col, m, n, food_matrix, visited):
    if not valid(row, col, m, n) or visited[row][col]:
        return 0, []
    if (row, col) == (m - 1, n - 1):
        return food_matrix[row][col], [(row + 1, col + 1)]
    
    visited[row][col] = True
    max_food = food_matrix[row][col]
    path = [(row + 1, col + 1)]
    
    # Explore the next possible moves (right and down only, to avoid revisiting cells)
    directions = [(0, 1), (1, 0)]
    for dr, dc in directions:
        next_food, next_path = backtrack(row + dr, col + dc, m, n, food_matrix, visited)
        if next_food + food_matrix[row][col] > max_food:
            max_food = next_food + food_matrix[row][col]
            path = [(row + 1, col + 1)] + next_path
    
    visited[row][col] = False
    return max_food, path

# Read the data from the input file
with open('mouse.in', 'r') as file:
    m, n = map(int, file.readline().split())
    food_matrix = [list(map(int, file.readline().split())) for _ in range(m)]

# Initialize the visited matrix
visited = [[False for _ in range(n)] for _ in range(m)]

# Start backtracking from the first cell
total_food, route = backtrack(0, 0, m, n, food_matrix, visited)

# Write the result to the output file
with open('mouse.out', 'w') as file:
    file.write(f"{len(route)} {total_food}\n")
    for r in route:
        file.write(f"{r[0]} {r[1]}\n")
```

This solution uses list comprehensions to create the matrix and visited list, which are part of Python's standard library and do not require additional memory overhead from external libraries. The backtracking is performed in a similar way as before, but only right and down moves are considered to avoid cycles, as the mouse cannot go back to a visited cell. The code reads from 'mouse.in' and writes to 'mouse.out' as required.
---------- user ----------


Program result did not match expected result.
Input data:
```
2 4
1 2 6 3
3 4 1 2
```
Expected output:
```
7 21
1 1
2 1
2 2
1 2
1 3
1 4
2 4
```
Found output:
```
5 14
1 1
1 2
1 3
1 4
2 4
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The backtracking implementation above only considers going right or down, but in order to find the true maximum food path, it should also consider going left or up when possible. However, we must be careful to prevent the mouse from revisiting the same cell, which requires careful tracking of the mouse's path.

We can implement this correctly by trying all four possible directions (right, down, left, up) while ensuring that the mouse does not backtrack on its path. For this, we'll use a dynamic programming approach with memoization to store the best results found for each cell. This way, we can avoid recomputing the same state multiple times and potentially reduce the overall execution time.

Here's the correct implementation:

```python
# Function to find the maximum food and path using dynamic programming and memoization
def find_max_food(row, col, food_matrix, visited, memo):
    if not (0 <= row < m and 0 <= col < n) or visited[row][col]:
        return 0, []
    if (row, col) == (m - 1, n - 1):
        return food_matrix[row][col], [(row + 1, col + 1)]
    if (row, col) in memo:
        return memo[(row, col)]

    visited[row][col] = True
    max_food = 0
    path = []
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up

    for dr, dc in directions:
        next_row, next_col = row + dr, col + dc
        food, next_path = find_max_food(next_row, next_col, food_matrix, visited, memo)
        if food > max_food:
            max_food = food
            path = next_path

    visited[row][col] = False
    max_food += food_matrix[row][col]
    memo[(row, col)] = (max_food, [(row + 1, col + 1)] + path)
    return memo[(row, col)]

# Read the data from the input file
with open('mouse.in', 'r') as file:
    m, n = map(int, file.readline().split())
    food_matrix = [list(map(int, file.readline().split())) for _ in range(m)]

# Initialize visited matrix and memoization dictionary
visited = [[False for _ in range(n)] for _ in range(m)]
memo = {}

# Compute the maximum food and path
total_food, route = find_max_food(0, 0, food_matrix, visited, memo)

# Write the result to the output file
with open('mouse.out', 'w') as file:
    file.write(f"{len(route)} {total_food}\n")
    for r in route:
        file.write(f"{r[0]} {r[1]}\n")
```

In this version, the `find_max_food` function uses a memoization dictionary (`memo`) to store the results of subproblems, avoiding redundant calculations. It also correctly considers all four directions that the mouse can move. The `visited` matrix ensures that the mouse does not visit any cell more than once. The result should now match the expected output.
---------- user ----------


Program result did not match expected result.
Input data:
```
2 4
1 2 6 3
3 4 1 2
```
Expected output:
```
7 21
1 1
2 1
2 2
1 2
1 3
1 4
2 4
```
Found output:
```
6 17
1 1
1 2
1 3
2 3
2 2
2 1
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
