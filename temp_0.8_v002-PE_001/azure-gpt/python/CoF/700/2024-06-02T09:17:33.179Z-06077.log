---------- user ----------

Here is a programming challenge.
Please solve this problem efficiently, optimizing both time and memory usage.
Create the most efficient solution for this challenge in python. Utilize numpy and other highly efficient libraries whenever possible.
This problem has a memory limit of ~8MB so please be sensitive on using memory. Using too much memory may result in OOM.
The code must compile and be correct.
The solution must read from `mouse.in` and write to `mouse.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Un experiment urmărește comportarea unui șoricel pus într-o cutie dreptunghiulară, împărțită în $m \times n$ cămăruțe egale de formă pătrată. Fiecare cămăruță conține o anumită cantitate de hrană. Șoricelul trebuie să pornească din colțul $(1,1)$ al cutiei și să ajungă în colțul opus, mâncând cât mai multă hrană. El poate trece dintr-o cameră în una alăturată (două camere sunt alăturate dacă au un perete comun), mănâncă toată hrana din cămăruță atunci când intră și nu intră niciodată într-o cameră în care a mai intrat înainte. 

# Cerință

Stabiliți care este cantitatea maximă de hrană pe care o poate mânca și traseul pe care îl poate urma pentru a culege această cantitate maximă.

# Date de intrare
Fișierul de intrare `mouse.in` conține pe prima linie două numere $m$ și $n$ reprezentând numărul de linii respectiv numărul de coloane ale cutiei, iar pe următoarele $m$ linii cele $m \cdot n$ numere reprezentând cantitatea de hrană existentă în fiecare cămăruță, câte $n$ numere pe fiecare linie, separate prin spații.

# Date de ieșire
În fișierul de ieșire `mouse.out` se vor scrie pe prima linie două numere separate printr-un spațiu: numărul de cămăruțe vizitate și cantitatea de hrană maximă culeasă. Pe următoarele linii se va scrie un traseu posibil pentru cantitatea dată, sub formă de perechi de numere, începând cu $(1, 1)$ și terminând cu $(m, n)$.

# Restricții și precizări
- Toate valorile din fișier sunt numere naturale între $1$ și $100$.
- Veți primi 40 de puncte pentru afișarea primelor două numere.

---

Example:
`mouse.in`
```
2 4
1 2 6 3
3 4 1 2
```

`mouse.out`
```
7 21
1 1
2 1
2 2
1 2
1 3
1 4
2 4
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```python
import numpy as np

def find_max_food_path(matrix):
    rows, cols = matrix.shape
    dp = np.zeros_like(matrix)
    dp[0, 0] = matrix[0, 0]
    path = {(0, 0): [(1, 1)]}

    for r in range(rows):
        for c in range(cols):
            if r > 0:
                if dp[r, c] < dp[r-1, c] + matrix[r, c]:
                    dp[r, c] = dp[r-1, c] + matrix[r, c]
                    path[(r, c)] = path.get((r-1, c), []) + [(r+1, c+1)]
            if c > 0:
                if dp[r, c] < dp[r, c-1] + matrix[r, c]:
                    dp[r, c] = dp[r, c-1] + matrix[r, c]
                    path[(r, c)] = path.get((r, c-1), []) + [(r+1, c+1)]
                    
    return dp[-1, -1], path[(rows-1, cols-1)]

def main():
    with open('mouse.in', 'r') as file:
        m, n = map(int, file.readline().strip().split())
        matrix_values = [list(map(int, line.strip().split())) for line in file]
        
    matrix = np.array(matrix_values)
    max_food, max_path = find_max_food_path(matrix)
    
    # Write the result to the output file
    with open('mouse.out', 'w') as file:
        file.write(f"{len(max_path)} {max_food}\n")
        for position in max_path:
            file.write(f"{position[0]} {position[1]}\n")

if __name__ == "__main__":
    main()
```

This code loads the input data from `mouse.in`, calculates the optimal path and maximum amount of food the mouse can eat using dynamic programming, and writes the result to `mouse.out`. It avoids memory-intensive operations and uses numpy for efficient array manipulation.
---------- user ----------


Program exited with code 1.
stdout:
```

```
stderr:
```
Traceback (most recent call last):
  File "/app/app.py", line 1, in <module>
    import numpy as np
ModuleNotFoundError: No module named 'numpy'

```

Think of what has caused the exit code. Use the standard out and standard error to help you understand the issue.
Implement a solution to fix the program

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

It seems that the environment where the code is being executed does not have the `numpy` module installed. Since the challenge specifies optimizing both time and memory usage and suggests using numpy, it is possible that we have a misunderstanding about the actual constraints.

Given this situation and considering the memory limit, I will provide an alternative solution that doesn't rely on numpy or any external libraries, which should work in any standard Python environment. Here's the revised solution:

```python
def find_max_food_path(matrix, m, n):
    dp = [[0 for _ in range(n)] for _ in range(m)]
    path = [[[] for _ in range(n)] for _ in range(m)]
    dp[0][0] = matrix[0][0]
    path[0][0] = [(1, 1)]

    for r in range(m):
        for c in range(n):
            if r > 0 and dp[r][c] < dp[r-1][c] + matrix[r][c]:
                dp[r][c] = dp[r-1][c] + matrix[r][c]
                path[r][c] = path[r-1][c] + [(r+1, c+1)]
            if c > 0 and dp[r][c] < dp[r][c-1] + matrix[r][c]:
                dp[r][c] = dp[r][c-1] + matrix[r][c]
                path[r][c] = path[r][c-1] + [(r+1, c+1)]
    
    return dp[-1][-1], path[-1][-1]

def main():
    with open('mouse.in', 'r') as file:
        m, n = map(int, file.readline().strip().split())
        matrix = [list(map(int, line.strip().split())) for line in file]

    max_food, max_path = find_max_food_path(matrix, m, n)
    
    # Write the result to the output file
    with open('mouse.out', 'w') as file:
        file.write(f"{len(max_path)} {max_food}\n")
        for position in max_path:
            file.write(f"{position[0]} {position[1]}\n")

if __name__ == "__main__":
    main()
```

This code does much the same as the previous one but uses built-in Python lists instead of numpy arrays. It computes the dynamic programming table (`dp`) and the path (`path`) using nested lists, which will use more memory than the numpy version but will still stay within the constraint as long as `m` and `n` are reasonable.
---------- user ----------


Program result did not match expected result.
Input data:
```
2 4
1 2 6 3
3 4 1 2
```
Expected output:
```
7 21
1 1
2 1
2 2
1 2
1 3
1 4
2 4
```
Found output:
```
5 14
1 1
1 2
1 3
1 4
2 4
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The issue is that the current implementation does not consider all possible paths: it only updates the cell value when it is strictly less than the value from the previous row or column. This does not account for the possibility that the mouse could have taken a different path to arrive at a cell with more food.

To address this, we must consider paths from both the top and left cells, even if they lead to the same value, as they might lead to different paths further on. Additionally, we need to backtrack from the bottom-right cell to construct the path taken by the mouse, since multiple paths might lead to the same maximum value.

Here's the corrected solution with proper path tracking:

```python
def find_max_food_path(matrix, m, n):
    dp = [[0] * n for _ in range(m)]
    dp[0][0] = matrix[0][0]

    for r in range(m):
        for c in range(n):
            if r > 0:
                dp[r][c] = max(dp[r][c], dp[r-1][c] + matrix[r][c])
            if c > 0:
                dp[r][c] = max(dp[r][c], dp[r][c-1] + matrix[r][c])

    max_food = dp[-1][-1]
    path = []
    r, c = m - 1, n - 1
    while r != 0 or c != 0:
        path.append((r + 1, c + 1))
        if r > 0 and c > 0:
            if dp[r-1][c] >= dp[r][c-1]:
                r -= 1
            else:
                c -= 1
        elif r > 0:
            r -= 1
        elif c > 0:
            c -= 1
    path.append((1, 1))

    return max_food, path[::-1]

def main():
    with open('mouse.in', 'r') as file:
        m, n = map(int, file.readline().strip().split())
        matrix = [list(map(int, line.strip().split())) for line in file]

    max_food, max_path = find_max_food_path(matrix, m, n)

    with open('mouse.out', 'w') as file:
        file.write(f"{len(max_path)} {max_food}\n")
        for position in max_path:
            file.write(f"{position[0]} {position[1]}\n")

if __name__ == "__main__":
    main()
```

This code will create a DP table to calculate the maximum amount of food that can be collected. Then, it will backtrack from the bottom-right corner to the top-left corner to find one of the possible paths that lead to the maximal food collection. It writes the length of the path and the maximum food collected to the `mouse.out` file, followed by the coordinates of the path. The path is reversed at the end because we are appending the cells from the end to the start.
---------- user ----------


Program result did not match expected result.
Input data:
```
2 4
1 2 6 3
3 4 1 2
```
Expected output:
```
7 21
1 1
2 1
2 2
1 2
1 3
1 4
2 4
```
Found output:
```
5 14
1 1
1 2
1 3
1 4
2 4
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
