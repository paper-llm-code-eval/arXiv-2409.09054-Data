---------- user ----------

Here is a programming challenge.
Please solve this problem efficiently, optimizing both time and memory usage.
Create the most efficient solution for this challenge in python. Utilize numpy and other highly efficient libraries whenever possible.
This problem has a memory limit of ~8MB so please be sensitive on using memory. Using too much memory may result in OOM.
The code must compile and be correct.
The solution must read from `parc.in` and write to `parc.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Un parc de formă dreptunghiulară este format din zone pietonale şi piste de biciclete. Reprezentând harta parcului într-un sistem cartezian, cu coordonata colţului stânga-jos `(0,0)`, pistele de biciclete sunt reprezentate prin dungi orizontale sau verticale colorate cu gri, iar zonele pietonale au culoarea albă, ca în figura din dreapta.

Vizitatorii parcului se pot plimba liber pe zonele pietonale în orice direcţie, însă pistele de biciclete se vor traversa, în linie dreaptă,  paralel cu axele. În figura alăturată avem un parc de dimensiuni `10 x 8`, cu piste de biciclete verticale între `2` şi `4` respectiv `5` şi `8`, şi  orizontale între `0` şi `1` respectiv între `2` şi `4`. Gigel se află în punctul `A(1 , 1)` şi poate sa ajungă pe drumul cel mai scurt la prietenul lui, în punctul `B(8 , 7)` deplasându-se astfel: porneşte din punctul `(1, 1)` şi parcurge un traseu format din segmente cu extremităţile în punctele de coordonate `(1.5 , 2) (1.5, 4) (2 , 5) (4 , 5) (5 , 7)` şi în final ajunge în punctul de coordonate `(8 , 7)`. 

Lungimea totală a drumului va fi aproximativ `11.4721359`.
\
~[parc.png]
# Cerinţă
Cunoscând dimensiunile parcului, coordonatele lui Gigel, coordonatele prietenului lui şi poziţiile pistelor de biciclete, să se calculeze lungimea drumului minim şi numărul drumurilor distincte de lungime minimă.

# Date de intrare
Fişierul `parc.in` conţine pe prima linie două numere naturale `Xparc` şi `Yparc` separate prin spaţiu, reprezentând dimensiunile parcului în direcţiile `Ox` respectiv `Oy`. Linia a doua va conţine patru numere separate prin spaţiu `xG, yG, xpr` şi `ypr` ce reprezintă coordonatele lui Gigel şi coordonatele prietenului lui. Linia a treia va conţine un număr natural `m`, reprezentând numărul pistelor verticale. Următoarele `m` linii vor conţine perechi de valori de pe axa `Ox` ce delimitează câte o pistă de biciclete verticală. Următoarea linie va conţine un număr natural `n`, reprezentând numărul pistelor orizontale. Următoarele `n` linii vor conţine perechi de valori de pe axa `Oy` ce delimitează câte o pistă de biciclete orizontală.

# Date de ieşire
Fişierul `parc.out` va conţine pe prima linie lungimea minimă a drumului cerut de problemă, un număr real. Linia a doua va conţine numărul drumurilor minime distincte, un număr natural. 

# Restricţii şi precizări
* `0 ≤ xG, xpr ≤ Xparc ≤ 30 000, 0 ≤ yG, ypr ≤ Yparc ≤ 30 000`;
* `0 < m, n < 2000`;
* perechile de numere naturale ce definesc o pistă nu sunt ordonate;
* pistele orizontale, şi cele verticale nu sunt ordonate în fişierul de intrare;
* două piste de aceeaşi direcţie nu se suprapun;
* Gigel şi prietenului lui sunt pe zone pietonale (incluzând şi marginile acestora);
* două drumuri sunt distincte dacă diferă prin cel puţin un punct;
* numărul de drumuri distincte nu va depăşi `1 000 000 000`;
* lungimea drumului din fişierul de ieşire este un număr real ce se va accepta cu eroare maxima de `0.01`;
* nu se admite formatul ştiinţific pentru afişarea numerelor reale; 
* prima cerinţă valorează `40%` din punctaj, iar a doua valorează `60%` din punctaj.

---

Example:
`parc.in`
```
10 8
1 1 8 7
2
5 8 
2 4
2
4 2
0 1
```

`parc.out`
```
11.472136
1
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```markdown
```python
import numpy as np


def read_input(filename):
    with open(filename, 'r') as file:
        Xparc, Yparc = map(int, file.readline().split())
        xG, yG, xpr, ypr = map(int, file.readline().split())
        m = int(file.readline())
        vertical_bike_paths = [list(map(int, file.readline().split())) for _ in range(m)]
        n = int(file.readline())
        horizontal_bike_paths = [list(map(int, file.readline().split())) for _ in range(n)]
    return Xparc, Yparc, (xG, yG), (xpr, ypr), vertical_bike_paths, horizontal_bike_paths


def write_output(filename, min_distance, num_paths):
    with open(filename, 'w') as file:
        file.write(f"{min_distance:.8f}\n")
        file.write(f"{num_paths}\n")


def calculate_min_distance_and_paths(Xparc, Yparc, start, end, vertical_bike_paths, horizontal_bike_paths):
    # Prepare bike paths
    vertical_bike_paths.sort()
    horizontal_bike_paths.sort()

    # Calculate the minimum distance
    path_length = abs(start[0] - end[0]) + abs(start[1] - end[1])

    # Determine the number of distinct minimum paths
    # We need to count the number of ways to reach each bike path intersection
    intersections = np.zeros((len(vertical_bike_paths) + 1, len(horizontal_bike_paths) + 1), dtype=np.int64)
    intersections[0, 0] = 1

    for i in range(1, len(vertical_bike_paths) + 1):
        intersections[i, 0] = intersections[i - 1, 0]

    for i in range(1, len(horizontal_bike_paths) + 1):
        intersections[0, i] = intersections[0, i - 1]

    for i in range(1, len(vertical_bike_paths) + 1):
        for j in range(1, len(horizontal_bike_paths) + 1):
            intersections[i, j] += intersections[i - 1, j] + intersections[i, j - 1]

    x_bike_paths = [x for path in vertical_bike_paths for x in path]
    y_bike_paths = [y for path in horizontal_bike_paths for y in path]
    x_bike_paths = sorted(set(x_bike_paths))
    y_bike_paths = sorted(set(y_bike_paths))

    x_index = x_bike_paths.index(start[0]) if start[0] in x_bike_paths else -1
    y_index = y_bike_paths.index(start[1]) if start[1] in y_bike_paths else -1

    num_paths_start = intersections[x_index + 1, y_index + 1]

    x_index = x_bike_paths.index(end[0]) if end[0] in x_bike_paths else -1
    y_index = y_bike_paths.index(end[1]) if end[1] in y_bike_paths else -1

    num_paths_end = intersections[x_index + 1, y_index + 1]

    num_paths = num_paths_start * num_paths_end

    return path_length, num_paths


def main():
    filename_input = 'parc.in'
    filename_output = 'parc.out'
    Xparc, Yparc, start, end, vertical_bike_paths, horizontal_bike_paths = read_input(filename_input)
    min_distance, num_paths = calculate_min_distance_and_paths(Xparc, Yparc, start, end, vertical_bike_paths, horizontal_bike_paths)
    write_output(filename_output, min_distance, num_paths)


if __name__ == "__main__":
    main()
```
```
---------- user ----------


Expected program to write result to `parc.out` and read from `parc.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

def read_input(filename):
    with open(filename, 'r') as file:
        Xparc, Yparc = map(int, file.readline().split())
        xG, yG, xpr, ypr = map(int, file.readline().split())
        m = int(file.readline())
        vertical_bike_paths = [tuple(map(int, file.readline().split())) for _ in range(m)]
        n = int(file.readline())
        horizontal_bike_paths = [tuple(map(int, file.readline().split())) for _ in range(n)]
    return Xparc, Yparc, xG, yG, xpr, ypr, vertical_bike_paths, horizontal_bike_paths

def write_output(filename, distance, paths):
    with open(filename, 'w') as file:
        file.write(f'{distance:.8f}\n')
        file.write(f'{paths}\n')

def calc_distance(xG, yG, xpr, ypr, vertical_bike_paths, horizontal_bike_paths):
    # Your efficient algorithm to calculate the shortest path and number of distinct shortest paths
    pass

def main():
    Xparc, Yparc, xG, yG, xpr, ypr, vertical_bike_paths, horizontal_bike_paths = read_input('parc.in')
    distance, paths = calc_distance(xG, yG, xpr, ypr, vertical_bike_paths, horizontal_bike_paths)
    write_output('parc.out', distance, paths)

if __name__ == "__main__":
    main()
```
```
---------- user ----------


Expected program to write result to `parc.out` and read from `parc.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

def read_input(filename):
    with open(filename, 'r') as file:
        Xparc, Yparc = map(int, file.readline().split())
        xG, yG, xpr, ypr = map(int, file.readline().split())
        m = int(file.readline())
        vertical_bike_paths = [list(map(int, file.readline().split())) for _ in range(m)]
        n = int(file.readline())
        horizontal_bike_paths = [list(map(int, file.readline().split())) for _ in range(n)]
    return Xparc, Yparc, (xG, yG), (xpr, ypr), vertical_bike_paths, horizontal_bike_paths

def write_output(filename, min_distance, num_paths):
    with open(filename, 'w') as file:
        file.write(f"{min_distance:.8f}\n")
        file.write(f"{num_paths}\n")

def calculate_min_distance_and_paths(Xparc, Yparc, start, end, vertical_bike_paths, horizontal_bike_paths):
    # Considering the constraints, more sophisticated algorithm may be required for large inputs

    # Convert bike paths to numpy arrays for efficient computation
    vertical_paths = np.array(vertical_bike_paths)
    horizontal_paths = np.array(horizontal_bike_paths)

    # Sort the bike paths
    vertical_paths.sort(axis=0)
    horizontal_paths.sort(axis=0)

    # Find the paths that are between the start and end points
    vertical_in_range = vertical_paths[(vertical_paths[:, 1] > start[1]) & (vertical_paths[:, 0] < end[0])]
    horizontal_in_range = horizontal_paths[(horizontal_paths[:, 1] > start[0]) & (horizontal_paths[:, 0] < end[1])]

    # Calculate the Manhattan distance between the start and end points
    min_distance = abs(start[0] - end[0]) + abs(start[1] - end[1])

    # Count the number of distinct minimum paths
    num_paths = 1  # Starting with a direct path without any bike paths

    if vertical_in_range.size > 0:
        # Count ways to traverse vertical paths
        num_paths *= 2 ** vertical_in_range.shape[0]
    if horizontal_in_range.size > 0:
        # Count ways to traverse horizontal paths
        num_paths *= 2 ** horizontal_in_range.shape[0]

    # Return minimum distance and the number of distinct minimum paths
    return min_distance, num_paths

def main():
    input_file = "parc.in"
    output_file = "parc.out"
    
    # Read input data
    Xparc, Yparc, start, end, vertical_bike_paths, horizontal_bike_paths = read_input(input_file)
    
    # Calculate minimum distance and number of distinct minimum paths
    min_distance, num_paths = calculate_min_distance_and_paths(Xparc, Yparc, start, end, vertical_bike_paths, horizontal_bike_paths)
    
    # Write output data
    write_output(output_file, min_distance, num_paths)

if __name__ == "__main__":
    main()
```
```
---------- user ----------


Expected program to write result to `parc.out` and read from `parc.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Function to read data from file
def read_data_from_file(file_path):
    with open(file_path, 'r') as file:
        Xparc, Yparc = map(int, file.readline().split())
        xG, yG, xP, yP = map(int, file.readline().split())
        m = int(file.readline().strip())
        vertical_paths = [tuple(map(int, file.readline().split())) for _ in range(m)]
        n = int(file.readline().strip())
        horizontal_paths = [tuple(map(int, file.readline().split())) for _ in range(n)]
    return Xparc, Yparc, xG, yG, xP, yP, vertical_paths, horizontal_paths

# Function to write data to file
def write_data_to_file(file_path, min_length, num_paths):
    with open(file_path, 'w') as file:
        file.write(f"{min_length:.8f}\n")
        file.write(f"{num_paths}\n")

# Function to compute the number of paths
def compute_number_of_paths(dp, bike_paths, pos_G, pos_P):
    for path in bike_paths:
        r1, r2 = sorted(path)
        for i in range(r1, r2):
            if pos_G < i < pos_P:
                dp[i + 1] += dp[i]

# The main function that computes the shortest path and number of paths
def find_shortest_path(Xparc, Yparc, xG, yG, xP, yP, vertical_paths, horizontal_paths):
    # Initialize dp arrays for dynamic programming approach
    dp_x = np.zeros(Xparc + 1, dtype=np.int64)
    dp_y = np.zeros(Yparc + 1, dtype=np.int64)

    # Set the starting positions
    dp_x[xG] = 1
    dp_y[yG] = 1

    # Compute the number of ways to reach each bike path intersection
    compute_number_of_paths(dp_x, vertical_paths, xG, xP)
    compute_number_of_paths(dp_y, horizontal_paths, yG, yP)

    # Calculate the total number of distinct paths
    num_paths = dp_x[xP] * dp_y[yP]

    # Calculate the minimum path length which is the Manhattan distance
    min_length = abs(xG - xP) + abs(yG - yP)

    return min_length, num_paths

# Main execution
def main():
    # Read the input data from file
    Xparc, Yparc, xG, yG, xP, yP, vertical_paths, horizontal_paths = read_data_from_file('parc.in')

    # Find the shortest path and the number of distinct minimum paths
    min_length, num_paths = find_shortest_path(Xparc, Yparc, xG, yG, xP, yP, vertical_paths, horizontal_paths)

    # Write the output data to file
    write_data_to_file('parc.out', min_length, num_paths)

# Execute the main function
if __name__ == "__main__":
    main()
```
```
---------- user ----------


Expected program to write result to `parc.out` and read from `parc.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

def read_park_data():
    with open('parc.in', 'r') as file:
        Xparc, Yparc = map(int, file.readline().split())
        xG, yG, xpr, ypr = map(int, file.readline().split())
        m = int(file.readline())
        vertical_bike_paths = [tuple(map(int, file.readline().split())) for _ in range(m)]
        vertical_bike_paths.sort(key=lambda x: x[0])
        n = int(file.readline())
        horizontal_bike_paths = [tuple(map(int, file.readline().split())) for _ in range(n)]
        horizontal_bike_paths.sort(key=lambda x: x[0])
    return Xparc, Yparc, xG, yG, xpr, ypr, vertical_bike_paths, horizontal_bike_paths

def count_paths(xG, yG, xpr, ypr, vertical_bike_paths, horizontal_bike_paths):
    # Function to return number of paths for horizontal or vertical direction
    def count_paths_in_direction(start, end, paths):
        count = 1
        for path_start, path_end in paths:
            low, high = sorted((path_start, path_end))
            if start < high and low < end:
                count *= 2
        return count

    # Count paths horizontally and vertically
    horizontal_paths_count = count_paths_in_direction(xG, xpr, horizontal_bike_paths)
    vertical_paths_count = count_paths_in_direction(yG, ypr, vertical_bike_paths)

    return horizontal_paths_count * vertical_paths_count

def calculate_path_length(xG, yG, xpr, ypr):
    return np.linalg.norm([xpr - xG, ypr - yG])

def write_results(min_distance, num_paths):
    with open('parc.out', 'w') as file:
        file.write(f"{min_distance:.8f}\n")
        file.write(f"{num_paths}\n")

def main():
    Xparc, Yparc, xG, yG, xpr, ypr, vertical_bike_paths, horizontal_bike_paths = read_park_data()
    num_paths = count_paths(xG, yG, xpr, ypr, vertical_bike_paths, horizontal_bike_paths)
    min_distance = calculate_path_length(xG, yG, xpr, ypr)
    write_results(min_distance, num_paths)

if __name__ == '__main__':
    main()
```
```
---------- user ----------


Expected program to write result to `parc.out` and read from `parc.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Function to read data from input file
def read_file():
    with open('parc.in', 'r') as f:
        Xparc, Yparc = map(int, f.readline().split())
        xG, yG, xpr, ypr = map(int, f.readline().split())
        m = int(f.readline())
        vertical_paths = [list(map(int, f.readline().split())) for _ in range(m)]
        n = int(f.readline())
        horizontal_paths = [list(map(int, f.readline().split())) for _ in range(n)]

    return Xparc, Yparc, xG, yG, xpr, ypr, vertical_paths, horizontal_paths

# Function to calculate the shortest path length using Manhattan distance
def calculate_shortest_path_length(xG, yG, xpr, ypr):
    return abs(xpr - xG) + abs(ypr - yG)

# Function to calculate the number of distinct shortest paths
def calculate_number_of_paths(Xparc, Yparc, xG, yG, xpr, ypr, vertical_paths, horizontal_paths):
    # Convert the bike paths into a binary grid where paths are marked
    bike_grid = np.zeros((Xparc + 1, Yparc + 1), dtype=np.int8)
    for x1, x2 in vertical_paths:
        bike_grid[min(x1, x2):max(x1, x2) + 1, :] = 1
    for y1, y2 in horizontal_paths:
        bike_grid[:, min(y1, y2):max(y1, y2) + 1] = 1

    # Calculate number of paths from Gigel to each bike path intersection
    dp = np.zeros((Xparc + 1, Yparc + 1), dtype=np.int64)
    dp[xG, yG] = 1
    for x in range(xG, xpr + 1):
        for y in range(yG, ypr + 1):
            if bike_grid[x, y] == 0 or (x == xG and y == yG):
                if x > xG:
                    dp[x, y] += dp[x - 1, y]
                if y > yG:
                    dp[x, y] += dp[x, y - 1]

    # Return the number of distinct paths to the friend's location
    return dp[xpr, ypr]

# Function to write data to output file
def write_file(min_path_length, num_paths):
    with open('parc.out', 'w') as f:
        f.write(f"{min_path_length:.8f}\n")
        f.write(f"{num_paths}\n")

# Main function to read input, process data, and write output
def main():
    Xparc, Yparc, xG, yG, xpr, ypr, vertical_paths, horizontal_paths = read_file()
    min_path_length = calculate_shortest_path_length(xG, yG, xpr, ypr)
    num_paths = calculate_number_of_paths(Xparc, Yparc, xG, yG, xpr, ypr, vertical_paths, horizontal_paths)
    write_file(min_path_length, num_paths)

if __name__ == '__main__':
    main()
```
```
---------- user ----------


Expected program to write result to `parc.out` and read from `parc.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Function to read the input from a file
def read_input_from_file():
    with open('parc.in', 'r') as file:
        Xparc, Yparc = map(int, file.readline().split())
        xG, yG, xP, yP = map(int, file.readline().split())
        m = int(file.readline())
        v_paths = [tuple(map(int, file.readline().split())) for _ in range(m)]
        n = int(file.readline())
        h_paths = [tuple(map(int, file.readline().split())) for _ in range(n)]
    return Xparc, Yparc, xG, yG, xP, yP, v_paths, h_paths

# Function to write the output to a file
def write_output_to_file(min_path_length, num_distinct_paths):
    with open('parc.out', 'w') as file:
        file.write(f"{min_path_length:.8f}\n")
        file.write(f"{num_distinct_paths}\n")

# Main function to solve the problem
def main():
    # Read the input data
    Xparc, Yparc, xG, yG, xP, yP, v_paths, h_paths = read_input_from_file()

    # Sort the paths to make it easier to calculate the unique paths
    v_paths.sort(key=lambda x: x[0])
    h_paths.sort(key=lambda y: y[0])

    # Initialize the number of distinct paths to 1 (the direct path between G and P)
    num_distinct_paths = 1

    # For each vertical bike path segment between Gx and Px, double the number of paths
    for x1, x2 in v_paths:
        if min(x1, x2) <= xG < max(x1, x2) and min(x1, x2) < xP <= max(x1, x2):
            num_distinct_paths *= 2

    # For each horizontal bike path segment between Gy and Py, double the number of paths
    for y1, y2 in h_paths:
        if min(y1, y2) <= yG < max(y1, y2) and min(y1, y2) < yP <= max(y1, y2):
            num_distinct_paths *= 2

    # Calculate the minimum path length as the Manhattan distance between G and P
    min_path_length = abs(xG - xP) + abs(yG - yP)

    # Write the results to the output file
    write_output_to_file(min_path_length, num_distinct_paths)

# Execute the main function
if __name__ == "__main__":
    main()
```
```
