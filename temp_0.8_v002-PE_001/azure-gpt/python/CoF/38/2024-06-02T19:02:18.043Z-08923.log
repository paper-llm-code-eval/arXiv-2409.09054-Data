---------- user ----------

Here is a programming challenge.
Please solve this problem efficiently, optimizing both time and memory usage.
Create the most efficient solution for this challenge in python. Utilize numpy and other highly efficient libraries whenever possible.
This problem has a memory limit of ~8MB so please be sensitive on using memory.Using unavoided memory may result in OOM.
The code must compile and be correct.
The solution must read from `parc.in` and write to `parc.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Un parc de formă dreptunghiulară este format din zone pietonale şi piste de biciclete. Reprezentând harta parcului într-un sistem cartezian, cu coordonata colţului stânga-jos `(0,0)`, pistele de biciclete sunt reprezentate prin dungi orizontale sau verticale colorate cu gri, iar zonele pietonale au culoarea albă, ca în figura din dreapta.

Vizitatorii parcului se pot plimba liber pe zonele pietonale în orice direcţie, însă pistele de biciclete se vor traversa, în linie dreaptă,  paralel cu axele. În figura alăturată avem un parc de dimensiuni `10 x 8`, cu piste de biciclete verticale între `2` şi `4` respectiv `5` şi `8`, şi  orizontale între `0` şi `1` respectiv între `2` şi `4`. Gigel se află în punctul `A(1 , 1)` şi poate sa ajungă pe drumul cel mai scurt la prietenul lui, în punctul `B(8 , 7)` deplasându-se astfel: porneşte din punctul `(1, 1)` şi parcurge un traseu format din segmente cu extremităţile în punctele de coordonate `(1.5 , 2) (1.5, 4) (2 , 5) (4 , 5) (5 , 7)` şi în final ajunge în punctul de coordonate `(8 , 7)`. 

Lungimea totală a drumului va fi aproximativ `11.4721359`.
\
~[parc.png]
# Cerinţă
Cunoscând dimensiunile parcului, coordonatele lui Gigel, coordonatele prietenului lui şi poziţiile pistelor de biciclete, să se calculeze lungimea drumului minim şi numărul drumurilor distincte de lungime minimă.

# Date de intrare
Fişierul `parc.in` conţine pe prima linie două numere naturale `Xparc` şi `Yparc` separate prin spaţiu, reprezentând dimensiunile parcului în direcţiile `Ox` respectiv `Oy`. Linia a doua va conţine patru numere separate prin spaţiu `xG, yG, xpr` şi `ypr` ce reprezintă coordonatele lui Gigel şi coordonatele prietenului lui. Linia a treia va conţine un număr natural `m`, reprezentând numărul pistelor verticale. Următoarele `m` linii vor conţine perechi de valori de pe axa `Ox` ce delimitează câte o pistă de biciclete verticală. Următoarea linie va conţine un număr natural `n`, reprezentând numărul pistelor orizontale. Următoarele `n` linii vor conţine perechi de valori de pe axa `Oy` ce delimitează câte o pistă de biciclete orizontală.

# Date de ieşire
Fişierul `parc.out` va conţine pe prima linie lungimea minimă a drumului cerut de problemă, un număr real. Linia a doua va conţine numărul drumurilor minime distincte, un număr natural. 

# Restricţii şi precizări
* `0 ≤ xG, xpr ≤ Xparc ≤ 30 000, 0 ≤ yG, ypr ≤ Yparc ≤ 30 000`;
* `0 < m, n < 2000`;
* perechile de numere naturale ce definesc o pistă nu sunt ordonate;
* pistele orizontale, şi cele verticale nu sunt ordonate în fişierul de intrare;
* două piste de aceeaşi direcţie nu se suprapun;
* Gigel şi prietenului lui sunt pe zone pietonale (incluzând şi marginile acestora);
* două drumuri sunt distincte dacă diferă prin cel puţin un punct;
* numărul de drumuri distincte nu va depăşi `1 000 000 000`;
* lungimea drumului din fişierul de ieşire este un număr real ce se va accepta cu eroare maxima de `0.01`;
* nu se admite formatul ştiinţific pentru afişarea numerelor reale; 
* prima cerinţă valorează `40%` din punctaj, iar a doua valorează `60%` din punctaj.

---

Example:
`parc.in`
```
10 8
1 1 8 7
2
5 8 
2 4
2
4 2
0 1
```

`parc.out`
```
11.472136
1
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```python
# parc.py

import numpy as np

# Read the input file
with open('parc.in', 'r') as file:
    Xparc, Yparc = map(int, file.readline().split())
    xG, yG, xpr, ypr = map(int, file.readline().split())
    m = int(file.readline().strip())
    vertical_tracks = [tuple(map(int, file.readline().split())) for _ in range(m)]
    n = int(file.readline().strip())
    horizontal_tracks = [tuple(map(int, file.readline().split())) for _ in range(n)]

# Initialize the grid
grid = np.zeros((Xparc + 1, Yparc + 1))

# Set the tracks on the grid (1 for inaccessible, 0 for accessible)
for x1, x2 in vertical_tracks:
    grid[min(x1, x2):max(x1, x2) + 1, :] = 1
for y1, y2 in horizontal_tracks:
    grid[:, min(y1, y2):max(y1, y2) + 1] = 1

# Calculate the minimum path length using Manhattan distance
min_length = abs(xG - xpr) + abs(yG - ypr)

# Calculate the number of distinct minimum paths using dynamic programming
def calculate_paths(grid, start, end):
    Xparc, Yparc = grid.shape
    paths = np.zeros((Xparc, Yparc), dtype=np.int64)
    paths[start] = 1

    for x in range(start[0], end[0] + 1):
        for y in range(start[1], end[1] + 1):
            if grid[x, y] == 1:
                continue
            if x > start[0]:
                paths[x, y] += paths[x - 1, y]
            if y > start[1]:
                paths[x, y] += paths[x, y - 1]

    return paths[end]

# Adjust the grid for dynamic programming (1 for accessible, 0 for inaccessible)
grid = (grid == 0).astype(np.int64)

# Calculate the number of distinct minimum paths
distinct_paths = calculate_paths(grid, (xG, yG), (xpr, ypr))

# Write the output to the file
with open('parc.out', 'w') as file:
    file.write(f"{min_length:.8f}\n")
    file.write(f"{distinct_paths}\n")
```

The above solution calculates the minimum path length and the number of distinct minimum paths by using dynamic programming. It uses numpy for efficient memory and time usage, and it writes the result to an output file.

This solution is designed to work efficiently within the constraints given in the problem description. However, it should be noted that the problem has a memory limit of ~8MB, and depending on the size of the grid, the dynamic programming table may exceed this limit. To further optimize for memory, one may need to use a more memory-efficient method instead of storing the entire grid or paths table. This could involve using a compressed sparse row representation for the grid or computing paths on-the-fly without storing intermediate results.

Please ensure that the `parc.in` file is provided in the same directory as this script before running it and that the environment has sufficient memory and resources to handle the computation.
---------- user ----------


Program exited with code 1.
stdout:
```

```
stderr:
```
Traceback (most recent call last):
  File "/app/app.py", line 3, in <module>
    import numpy as np
ModuleNotFoundError: No module named 'numpy'

```

Think of what has caused the exit code. Use the standard out and standard error to help you understand the issue.
Implement a solution to fix the program

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

Based on the error message, it seems that the `numpy` module is not installed in the environment where the program is being executed. However, since this challenge requires optimizing for both time and memory usage, and given the memory limit of ~8MB, it would be better to avoid using `numpy` or any other external libraries that might consume memory beyond the limit.

Instead, we can solve the problem using vanilla Python with basic data structures such as lists and dictionaries to keep memory usage within bounds. Here is the rewritten solution without using `numpy`:

```python
# parc.py

# Utility function to calculate the minimum path length (Manhattan distance)
def calculate_min_length(xG, yG, xpr, ypr):
    return abs(xG - xpr) + abs(yG - ypr)

# Utility function to calculate the number of distinct minimum paths
def calculate_paths(Xparc, Yparc, xG, yG, xpr, ypr, vertical_tracks, horizontal_tracks):
    paths = {}
    paths[(xG, yG)] = 1  # Starting point

    for x in range(xG, xpr + 1):
        for y in range(yG, ypr + 1):
            # Check if current position is on a bike track
            if any(x1 <= x <= x2 for x1, x2 in vertical_tracks) or \
               any(y1 <= y <= y2 for y1, y2 in horizontal_tracks):
                continue

            # Accumulate paths from the left and bottom cells if available
            if (x - 1, y) in paths:
                paths[(x, y)] = paths.get((x, y), 0) + paths[(x - 1, y)]
            if (x, y - 1) in paths:
                paths[(x, y)] = paths.get((x, y), 0) + paths[(x, y - 1)]

    return paths.get((xpr, ypr), 0)

# Read the input file
with open('parc.in', 'r') as file:
    Xparc, Yparc = map(int, file.readline().split())
    xG, yG, xpr, ypr = map(int, file.readline().split())
    m = int(file.readline().strip())
    vertical_tracks = [tuple(sorted(map(int, file.readline().split()))) for _ in range(m)]
    n = int(file.readline().strip())
    horizontal_tracks = [tuple(sorted(map(int, file.readline().split()))) for _ in range(n)]

# Calculate the minimum path length
min_length = calculate_min_length(xG, yG, xpr, ypr)

# Calculate the number of distinct minimum paths
distinct_paths = calculate_paths(Xparc, Yparc, xG, yG, xpr, ypr, vertical_tracks, horizontal_tracks)

# Write the output to the file
with open('parc.out', 'w') as file:
    file.write(f"{min_length:.8f}\n")
    file.write(f"{distinct_paths}\n")
```

This solution uses basic Python data structures like lists and dictionaries to represent the state of the park and to calculate the number of distinct paths. It avoids using `numpy` or other external libraries, thus keeping the memory footprint low, which is essential given the stated memory limit of ~8MB. The code reads from `parc.in` and writes to `parc.out` as specified in the challenge.
---------- user ----------


Program result did not match expected result.
Input data:
```
10 8
1 1 8 7
2
5 8 
2 4
2
4 2
0 1
```
Expected output:
```
11.472136
1
```
Found output:
```
13.00000000
0
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
