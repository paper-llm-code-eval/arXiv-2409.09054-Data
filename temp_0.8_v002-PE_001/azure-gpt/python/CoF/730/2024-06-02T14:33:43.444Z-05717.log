---------- user ----------

Here is a programming challenge.
Please solve this problem efficiently, optimizing both time and memory usage.
Create the most efficient solution for this challenge in python. Utilize numpy and other highly efficient libraries whenever possible.
This problem has a memory limit of ~8MB so please be sensitive on using memory. Using too much memory may result in OOM.
The code must compile and be correct.
The solution must read from `joc.in` and write to `joc.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Jocul “Nu te supăra, frate!” se joacă de către doi jucatori. Pe o pistă circulară cu $n$ căsuţe numerotate de la $1$ la $n$, în ordinea dată de sensul acelor de ceasornic, se află înscrise valorile $0, 1$ şi $10$. Cei doi jucători vor avea fiecare câte un pion şi vor porni pe rând, din căsuţa $1$. Începe jucătorul $1$. Fiecare jucător va muta pionul său conform cu valoarea obţinută prin aruncarea zarului, cumulând sau pierzând puncte în funcţie de căsuţa în care ajunge. Fiecare jucător citeşte valoarea zarului când îi vine rândul.

Jocul are urmatoarele reguli:
1. Câştigătorul poate fi:
	- jucătorul care ajunge primul din nou în căsuţa cu numărul $1$, indiferent de punctaj (exceptând cazul în care are punctaj $0$)
	- în cazul în care se termină şirul aruncărilor cu zarul, înseamnă că jucătorii s-au plictisit şi câştigă cel care a cumulat mai multe puncte, iar dacă au punctaje egale câştigă cel care se află în căsuţa cu număr de ordine mai mare.
2. După aruncarea zarului, jucătorul mută pionul cu atâtea căsuţe cât indică valoarea zarului, în ordinea acelor de ceasornic, începând numărătoarea cu căsuţa următoare poziţiei pe care se află. Prima căsuţă nu conţine valoarea $0$ (zero).
3. După mutare pot apare următoarele situaţii:
	- ajunge într-o căsuţă cu valoarea $0$ (zero) – jucătorul este penalizat, pierde toate punctele acumulate şi reia jocul din pozitia $1$
	- ajunge într-o căsuţă cu valoarea $10$ – primeşte un bonus de $10$ puncte
	- ajunge într-o căsuţă cu valoarea $1$ – primeşte $1$ punct
	- ajunge într-o căsuţă în care se află celălalt pion (cu excepţia căsuţei $1$, când câştigă) – jucătorul care ajunge ultimul este penalizat, pierde toate punctele şi reia jocul de la căsuţa $1$.

# Cerință

Determinaţi jucătorul câştigător, poziţiile fiecărui jucător pe cerc şi punctajul fiecărui jucător.

# Date de intrare

În fişierul `joc.in` se dau:
- Pe prima linie numărul $n$ al casutelor din cerc.
- Linia a doua conţine o succesiune de $n$ valori ($0, 1$ sau $10$), separate printr-un spaţiu, reprezentând valoarea fiecărei căsuţe.
- Linia a treia conţine numărul de aruncări cu zarul
- Linia a patra conţine o succesiune de valori întregi cuprinse între $1$ şi $6$, separate printr-un spaţiu, reprezentând aruncarea cu zarul. 

# Date de ieșire

Fişierul `joc.out` va conţine $3$ linii cu următoarele informaţii:
- pe prima linie: jucătorul câştigător
- pe a doua linie: poziţia şi punctajul jucătorului numărul $1$.
- pe a treia linie: poziţia şi punctajul jucătorului numărul $2$.

# Restricții și precizări

* $7 \leq n \leq 100$;

---

Example:
`joc.in`
```
10
1 1 1 1 1 10 0 1 1 0
8
3 6 2 4 1 3 5 3
```

`joc.out`
```
2
6 10
1 3
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```markdown
```python
import numpy as np

# Helper function to calculate next position and score
def move_and_score(position, score, roll, board, other_position, n):
    next_position = (position + roll) % n
    if next_position == 0:
        next_position = n
    if next_position == other_position and next_position != 1:
        # Player lands on the other player's pion, reset score
        score = 0
        next_position = 1
    else:
        score += board[next_position - 1]  # Add score from the board
        if board[next_position - 1] == 0:
            # Player lands on a 0, reset score
            score = 0
            next_position = 1
    return next_position, score

# Read input
with open('joc.in', 'r') as fin:
    n = int(fin.readline().strip())
    board = np.array(list(map(int, fin.readline().strip().split())), dtype=np.int8)
    rolls_count = int(fin.readline().strip())
    rolls = np.array(list(map(int, fin.readline().strip().split())), dtype=np.int8)

# Initialize variables
position_1, position_2 = 1, 1
score_1, score_2 = 0, 0
player_turn = 1

# Game loop
for roll in rolls:
    if player_turn == 1:
        position_1, score_1 = move_and_score(position_1, score_1, roll, board, position_2, n)
    else:
        position_2, score_2 = move_and_score(position_2, score_2, roll, board, position_1, n)
    
    # Check for a win by reaching position 1
    if position_1 == 1 and score_1 > 0:
        winner = 1
        break
    if position_2 == 1 and score_2 > 0:
        winner = 2
        break

    # Switch turns
    player_turn = 3 - player_turn
else:
    # In case of a tie or if no player reached position 1 with points
    if score_1 > score_2 or (score_1 == score_2 and position_1 > position_2):
        winner = 1
    elif score_2 > score_1 or (score_2 == score_1 and position_2 > position_1):
        winner = 2

# Write output
with open('joc.out', 'w') as fout:
    fout.write(f"{winner}\n")
    fout.write(f"{position_1} {score_1}\n")
    fout.write(f"{position_2} {score_2}\n")
```
```
---------- user ----------


Expected program to write result to `joc.out` and read from `joc.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Helper function to calculate next position and score
def move_and_score(position, score, roll, board, other_position):
    position = (position + roll - 1) % len(board) + 1
    if position == other_position and position != 1:
        score = 0
        position = 1
    else:
        score_change = board[position - 1]
        score = 0 if score_change == 0 else score + score_change
    return position, score

# Read input
with open('joc.in', 'r') as fin:
    n = int(fin.readline().strip())
    board = np.fromstring(fin.readline().strip(), dtype=int, sep=' ')
    rolls_count = int(fin.readline().strip())
    rolls = np.fromstring(fin.readline().strip(), dtype=int, sep=' ')

# Initialize game state
position_1, position_2 = 1, 1
score_1, score_2 = 0, 0
turn = 1  # Start with player 1

# Game loop
for roll in rolls:
    if turn == 1:
        position_1, score_1 = move_and_score(position_1, score_1, roll, board, position_2)
        turn = 2  # Next turn is for player 2
        if position_1 == 1 and score_1 > 0:
            winner = 1
            break  # Player 1 wins by reaching position 1
    else:
        position_2, score_2 = move_and_score(position_2, score_2, roll, board, position_1)
        turn = 1  # Next turn is for player 1
        if position_2 == 1 and score_2 > 0:
            winner = 2
            break  # Player 2 wins by reaching position 1

# Determine the winner by score or position if no one reached position 1 with points
if 'winner' not in locals():
    if score_1 > score_2 or (score_1 == score_2 and position_1 > position_2):
        winner = 1
    else:
        winner = 2

# Write output
with open('joc.out', 'w') as fout:
    fout.write(f"{winner}\n")
    fout.write(f"{position_1} {score_1}\n")
    fout.write(f"{position_2} {score_2}\n")
```
```
---------- user ----------


Expected program to write result to `joc.out` and read from `joc.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Read input from joc.in
with open('joc.in', 'r') as file:
    n = int(file.readline().strip())
    board_values = np.array(file.readline().strip().split(), dtype=int)
    num_rolls = int(file.readline().strip())
    rolls = np.array(file.readline().strip().split(), dtype=int)

# Initialize game state
positions = np.array([1, 1], dtype=int)  # Player positions
scores = np.array([0, 0], dtype=int)    # Player scores
current_player = 0  # Player 1 starts

# Game loop
for roll in rolls:
    # Calculate next position
    next_pos = (positions[current_player] + roll - 1) % n + 1
    # Check for special cases
    if board_values[next_pos - 1] == 0:  # Landed on a 0
        positions[current_player] = 1  # Reset to start
        scores[current_player] = 0    # Lose all points
    elif positions[1 - current_player] == next_pos and next_pos != 1:  # Landed on the other player
        positions[current_player] = 1  # Reset to start
        scores[current_player] = 0  # Lose all points
    else:  # Normal move
        positions[current_player] = next_pos
        scores[current_player] += board_values[next_pos - 1]  # Increase score

    # Check for winning condition (back at position 1 with points)
    if positions[current_player] == 1 and scores[current_player] > 0:
        break

    # Switch player
    current_player = 1 - current_player

# Determine the winner
if scores[0] > scores[1] or (scores[0] == scores[1] and positions[0] >= positions[1]):
    winner = 1
else:
    winner = 2

# Write output to joc.out
with open('joc.out', 'w') as file:
    file.write(f"{winner}\n")
    file.write(f"{positions[0]} {scores[0]}\n")
    file.write(f"{positions[1]} {scores[1]}\n")
```
```
---------- user ----------


Expected program to write result to `joc.out` and read from `joc.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Function to perform a move
def move(player, roll, board, positions, scores):
    new_pos = (positions[player] + roll) % len(board)
    new_pos = len(board) if new_pos == 0 else new_pos  # Adjust for 1-indexed board
    if board[new_pos - 1] == 0:  # Landed on 0
        scores[player] = 0  # Lose all points
        new_pos = 1  # Move to start position
    else:
        if new_pos != 1 and new_pos == positions[1 - player]:  # Landed on the other player (not in start)
            scores[1 - player] = 0  # Other player loses all points
            positions[1 - player] = 1  # Other player moves to start
        scores[player] += board[new_pos - 1]
    positions[player] = new_pos

# Read from 'joc.in'
with open('joc.in', 'r') as f:
    n = int(f.readline().strip())
    board = np.fromstring(f.readline().strip(), sep=' ', dtype=int)
    num_rolls = int(f.readline().strip())
    rolls = np.fromstring(f.readline().strip(), sep=' ', dtype=int)

# Initialize positions and scores
positions = [1, 1]
scores = [0, 0]

# Main game loop
current_player = 0
for roll in rolls:
    move(current_player, roll, board, positions, scores)  # Perform move for current player
    if positions[current_player] == 1 and scores[current_player] > 0:
        winner = current_player + 1  # Winning condition met
        break
    current_player = 1 - current_player  # Switch player
else:
    # If no winner by reaching the start, determine winner by score or position
    if scores[0] > scores[1] or (scores[0] == scores[1] and positions[0] > positions[1]):
        winner = 1
    else:
        winner = 2

# Write to 'joc.out'
with open('joc.out', 'w') as f:
    f.write(f"{winner}\n")
    f.write(f"{positions[0]} {scores[0]}\n")
    f.write(f"{positions[1]} {scores[1]}\n")
```
```
---------- user ----------


Expected program to write result to `joc.out` and read from `joc.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
def move(player_position, player_score, dice_roll, board, other_player_position):
    # Calculate the new position (1-indexed)
    new_position = (player_position - 1 + dice_roll) % len(board) + 1
    # Check if the new position is the starting point
    if new_position == 1 and board[0] == 0:
        return 1, 0
    # Check if player lands on opponent's position (except if it's the starting point)
    if new_position == other_player_position and new_position != 1:
        return 1, 0
    # Update the score based on the board value
    new_score = player_score + board[new_position - 1]
    # Check if player lands on a zero
    if board[new_position - 1] == 0:
        return 1, 0
    return new_position, new_score

# Initialize player positions and scores
player_positions = [1, 1]
player_scores = [0, 0]
current_player = 0

# Read the game board and dice rolls
with open('joc.in', 'r') as file:
    n = int(file.readline().strip())
    board = list(map(int, file.readline().strip().split()))
    dice_rolls_count = int(file.readline().strip())
    dice_rolls = list(map(int, file.readline().strip().split()))

# Simulate the game
for roll in dice_rolls:
    player_positions[current_player], player_scores[current_player] = move(
        player_positions[current_player],
        player_scores[current_player],
        roll,
        board,
        player_positions[1 - current_player]
    )
    # Check for a winning condition
    if player_positions[current_player] == 1 and player_scores[current_player] > 0:
        winner = current_player + 1
        break
    # Switch players
    current_player = 1 - current_player
else:
    # If no one wins by reaching the starting point, determine the winner based on scores
    if player_scores[0] > player_scores[1]:
        winner = 1
    elif player_scores[1] > player_scores[0]:
        winner = 2
    # If scores are tied, the player further ahead on the board wins
    elif player_positions[0] > player_positions[1]:
        winner = 1
    else:
        winner = 2

# Write the results to the output file
with open('joc.out', 'w') as file:
    file.write(f"{winner}\n")
    file.write(f"{player_positions[0]} {player_scores[0]}\n")
    file.write(f"{player_positions[1]} {player_scores[1]}\n")
```
```
---------- user ----------


Expected program to write result to `joc.out` and read from `joc.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Function to calculate the next position and update the score
def next_position_score(pos, score, roll, board, opponent_pos):
    n = len(board)
    pos = (pos + roll - 1) % n + 1  # Get next position in 1-indexed board
    if pos == opponent_pos and pos != 1:
        return 1, 0  # Send opponent to start and reset score
    if board[pos - 1] == 0:
        return 1, 0  # Send self to start and reset score
    score += board[pos - 1]  # Update score
    return pos, score

# Read input from file
with open('joc.in', 'r') as f:
    n = int(f.readline().strip())
    board = np.fromstring(f.readline().strip(), dtype=int, sep=' ')
    num_rolls = int(f.readline().strip())
    rolls = np.fromstring(f.readline().strip(), dtype=int, sep=' ')

# Initialize starting positions and scores
pos = [1, 1]
scores = [0, 0]
player_turn = 0

# Game simulation
for roll in rolls:
    pos[player_turn], scores[player_turn] = next_position_score(
        pos[player_turn], scores[player_turn], roll, board, pos[1 - player_turn])
    # If a player wins by reaching the starting position with a positive score
    if pos[player_turn] == 1 and scores[player_turn] > 0:
        winner = player_turn + 1
        break
    player_turn = 1 - player_turn  # Switch turns
else:
    # If no player wins by the above condition, determine the winner
    if scores[0] > scores[1] or (scores[0] == scores[1] and pos[0] >= pos[1]):
        winner = 1
    else:
        winner = 2

# Write output to file
with open('joc.out', 'w') as f:
    f.write(f'{winner}\n')
    f.write(f'{pos[0]} {scores[0]}\n')
    f.write(f'{pos[1]} {scores[1]}\n')
```
```
---------- user ----------


Expected program to write result to `joc.out` and read from `joc.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
# Define a function to update the player's position and score
def update_position_score(current_position, current_score, roll, board, opponent_position):
    n = len(board)
    # Calculate the new position based on the roll
    new_position = (current_position - 1 + roll) % n + 1
    # If the player lands on the same position as the opponent, they lose all points
    # unless it's the starting position
    if new_position == opponent_position and new_position != 1:
        return 1, 0
    # If the player lands on a '0', they lose all points and return to the starting position
    if board[new_position - 1] == 0:
        return 1, 0
    # Otherwise, update the score and return the new position and score
    current_score += board[new_position - 1]
    return new_position, current_score

# Read input from 'joc.in'
with open('joc.in', 'r') as file:
    n = int(file.readline())
    board = np.array(file.readline().split(), dtype=int)
    num_rolls = int(file.readline())
    rolls = np.array(file.readline().split(), dtype=int)

# Initialize player positions and scores
positions = [1, 1]
scores = [0, 0]
player_turn = 0  # 0 for player 1's turn, 1 for player 2's turn

# Simulate the game
for roll in rolls:
    positions[player_turn], scores[player_turn] = update_position_score(
        positions[player_turn], scores[player_turn], roll, board, positions[1 - player_turn])
    # Check if the current player has won
    if positions[player_turn] == 1 and scores[player_turn] > 0:
        winner = player_turn + 1
        break
    # Switch turns
    player_turn = 1 - player_turn
else:
    # Determine the winner based on scores or further position if scores are equal
    if scores[0] > scores[1] or (scores[0] == scores[1] and positions[0] > positions[1]):
        winner = 1
    else:
        winner = 2

# Write output to 'joc.out'
with open('joc.out', 'w') as file:
    file.write(f"{winner}\n")
    file.write(f"{positions[0]} {scores[0]}\n")
    file.write(f"{positions[1]} {scores[1]}\n")
```
```
