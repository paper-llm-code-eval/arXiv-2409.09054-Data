---------- user ----------

Here is a programming challenge.
Please solve this problem efficiently, optimizing both time and memory usage.
Create the most efficient solution for this challenge in python. Utilize numpy and other highly efficient libraries whenever possible.
This problem has a memory limit of ~8MB so please be sensitive on using memory. Using too much memory may result in OOM.
The code must compile and be correct.
The solution must read from `cruce.in` and write to `cruce.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Se consideră o matrice pătratică de dimensiune $N$, conţinând numere naturale. Numim **cruce de lăţime $K$** reuniunea mulțimii tuturor elementelor aflate pe $K$ linii consecutive ale matricei și a mulțimii tuturor elementelor aflate pe $K$ coloane consecutive ale matricei. Două elemente ale matricei se consideră distincte dacă sunt situate pe poziții distincte în matrice. Se acceptă şi forma degenerată a unei cruci, în formă de `T` sau `L`, când una dintre liniile sau coloanele care formează crucea sunt chiar la marginea matricei. Vom defini **valoarea** unei cruci ca fiind suma elementelor din care aceasta este formată.

# Cerință

Scrieți un program care, pentru o valoare $K$ dată, determină o cruce de lățime $K$ a cărei valoare este maximă și poziția ei în matrice. Această poziție va fi exprimată prin perechea de indici reprezentând prima linie din cele $K$ consecutive și prima coloană din cele $K$ consecutive din care este formată crucea.

# Date de intrare

Fişierul `cruce.in` conţine pe prima linie numerele $N$ şi $K$, iar pe următoarele $N$ linii câte $N$ numere întregi reprezentând în ordine, pe linii, elementele matricei. Numerele de pe aceeaşi linie sunt separate prin câte un spaţiu.

# Date de ieșire

Fişierul `cruce.out` va conţine trei numere $Vmax \ L \ C$, separate prin câte un spaţiu, reprezentând valoarea maximă determinată pentru o cruce de lățime $K$, respectiv linia și coloana care exprimă poziția acesteia în matrice.

# Restricții și precizări

* $1 \leq K < N \leq 500$;
* Numerele din matrice sunt din intervalul $[-5 \ 000, 5 \ 000]$
* Liniile şi coloanele se indexează începând cu 1.
* Dacă există mai multe cruci de lățime $K$ de valoare maximă, se va lua în considerare poziția cu indicele liniei mai mic, iar în caz de egalitate a liniilor poziția celei cu indicele coloanei mai mic.

---

Example:
`cruce.in`
```
5 2
1 -2 3 -1 4
-3 2 2 -2 -1
1 2 3 4 5
1 0 -7 1 1
3 2 1 2 3
```

`cruce.out`
```
23 2 4
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```python
import numpy as np

# Read input data
with open('cruce.in', 'r') as f:
    N, K = map(int, f.readline().split())
    matrix = np.array([list(map(int, f.readline().split())) for _ in range(N)], dtype=np.int32)

# Initialize the variables to store the position and value of the max cross
max_value = -float('inf')  # We can assume the min possible value due to constraints
max_position = (-1, -1)

# Precompute row and column sums for O(1) queries later
row_sums = np.cumsum(matrix, axis=1)
col_sums = np.cumsum(matrix, axis=0)

# Helper function to calculate the cross value given its top-left position


def cross_value(row, col):
    row_sum = row_sums[row + K - 1, col + K - 1]
    col_sum = col_sums[row + K - 1, col + K - 1]

    if col > 0:
        row_sum -= row_sums[row + K - 1, col - 1]

    if row > 0:
        col_sum -= col_sums[row - 1, col + K - 1]

    # Remove overlapping area
    if row > 0 and col > 0:
        overlap = (matrix[row:row + K, col:col + K].sum())
    else:
        overlap = 0

    return row_sum + col_sum - overlap


# Iterate over all possible positions for the top left corner of the cross
for row in range(N - K + 1):
    for col in range(N - K + 1):
        value = cross_value(row, col)
        # Update max value and position if necessary
        if value > max_value:
            max_value = value
            max_position = (row + 1, col + 1)  # +1 to convert to 1-based indexing

# Write output data
with open('cruce.out', 'w') as f:
    f.write(f"{max_value} {max_position[0]} {max_position[1]}\n")
```

This program computes the maximum value of a cross of width K within the given matrix efficiently by using cumulative sums for rows and columns. However, I realized my function `cross_value` is inefficient when it computes the overlap since it creates a temporary array and sums it each time. I can optimize this by calculating the overlap based on precomputed sums. I'll adjust the logic and ensure we stay within memory limits.
---------- user ----------


Program exited with code 1.
stdout:
```

```
stderr:
```
Traceback (most recent call last):
  File "/app/app.py", line 1, in <module>
    import numpy as np
ModuleNotFoundError: No module named 'numpy'

```

Think of what has caused the exit code. Use the standard out and standard error to help you understand the issue.
Implement a solution to fix the program

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The error indicates that the `numpy` module is not available in the environment. Since the challenge requires optimization for both time and memory, and the use of libraries like `numpy`, we have to find a way around this issue.

However, given that standard libraries may be the only option, I will rewrite the solution to use native Python lists and standard library functions to perform the necessary calculations. This should ensure compatibility with any Python environment that might not have additional modules installed.

Below is the updated solution using only the Python standard library:

```python
# Function to calculate the sum of a submatrix from cumulative sums
def submatrix_sum(cumulative, r1, c1, r2, c2):
    result = cumulative[r2][c2]
    if r1 > 0:
        result -= cumulative[r1 - 1][c2]
    if c1 > 0:
        result -= cumulative[r2][c1 - 1]
    if r1 > 0 and c1 > 0:
        result += cumulative[r1 - 1][c1 - 1]
    return result

# Read input data
with open('cruce.in', 'r') as f:
    N, K = map(int, f.readline().split())
    matrix = [list(map(int, f.readline().split())) for _ in range(N)]

# Initialize the variables to store the position and value of the max cross
max_value = None
max_position = (-1, -1)

# Create cumulative sum matrix for rows and columns
cumulative_rows = [[0] * N for _ in range(N)]
cumulative_cols = [[0] * N for _ in range(N)]

# Calculate cumulative sums for rows
for r in range(N):
    cumulative_rows[r][0] = matrix[r][0]
    for c in range(1, N):
        cumulative_rows[r][c] = cumulative_rows[r][c - 1] + matrix[r][c]

# Calculate cumulative sums for columns
for c in range(N):
    cumulative_cols[0][c] = matrix[0][c]
    for r in range(1, N):
        cumulative_cols[r][c] = cumulative_cols[r - 1][c] + matrix[r][c]

# Iterate over all possible positions for the top left corner of the cross
for row in range(N - K + 1):
    for col in range(N - K + 1):
        # Calculate sum of the horizontal part of the cross
        horizontal_sum = submatrix_sum(cumulative_rows, row, col, row + K - 1, col + K - 1)
        # Calculate sum of the vertical part of the cross
        vertical_sum = submatrix_sum(cumulative_cols, row, col, row + K - 1, col + K - 1)
        # Subtract the overlapping central part counted twice
        overlap_sum = matrix[row + K // 2][col + K // 2]
        value = horizontal_sum + vertical_sum - overlap_sum

        # Initialize max_value if None or update max value and position if necessary
        if max_value is None or value > max_value:
            max_value = value
            max_position = (row + 1, col + 1)  # +1 to convert to 1-based indexing

# Write output data
with open('cruce.out', 'w') as f:
    f.write(f"{max_value} {max_position[0]} {max_position[1]}\n")
```

This solution uses a brute force approach to find the cross with the maximum value and writes the result to `cruce.out`. The complexity is higher compared to the numpy solution, but it will work in an environment without numpy, and it should still meet the memory constraints.
---------- user ----------


Program result did not match expected result.
Input data:
```
5 2
1 -2 3 -1 4
-3 2 2 -2 -1
1 2 3 4 5
1 0 -7 1 1
3 2 1 2 3
```
Expected output:
```
23 2 4
```
Found output:
```
14 3 4
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The results differ because there was a mistake in calculating the overlap and the sum of the vertical part of the cross. The overlap was incorrectly calculated using the center element only, while it should be the sum of the overlapping KxK square. Additionally, the vertical sum should include all the columns except those in the horizontal part.

To fix the issue, we need to calculate the sum of the overlapping square correctly and adjust the sum of the vertical part to include all necessary columns. Here is the revised code:

```python
# Function to calculate the sum of a submatrix using the cumulative sum matrix
def submatrix_sum(cumulative, top, left, bottom, right):
    result = cumulative[bottom][right]
    if left > 0:
        result -= cumulative[bottom][left-1]
    if top > 0:
        result -= cumulative[top-1][right]
    if top > 0 and left > 0:
        result += cumulative[top-1][left-1]
    return result

# Read input data
with open('cruce.in', 'r') as f:
    N, K = map(int, f.readline().split())
    matrix = [list(map(int, f.readline().split())) for _ in range(N)]

# Create cumulative sum matrix
cumulative = [[0] * N for _ in range(N)]
for r in range(N):
    for c in range(N):
        cumulative[r][c] = matrix[r][c]
        if r > 0:
            cumulative[r][c] += cumulative[r-1][c]
        if c > 0:
            cumulative[r][c] += cumulative[r][c-1]
        if r > 0 and c > 0:
            cumulative[r][c] -= cumulative[r-1][c-1]

# Initialize variables to store the maximum cross value and position
max_value = None
max_pos = (0, 0)

# Iterate over all possible positions for the cross
for r in range(N - K + 1):
    for c in range(N - K + 1):
        # Calculate the sum of the horizontal and vertical parts
        horizontal_sum = submatrix_sum(cumulative, r + K//2, c, r + K//2, c + K - 1)
        vertical_sum = submatrix_sum(cumulative, r, c + K//2, r + K - 1, c + K//2)
        # Calculate sum of the overlapping KxK square
        overlap_sum = submatrix_sum(cumulative, r, c, r + K - 1, c + K - 1)
        value = horizontal_sum + vertical_sum - overlap_sum

        # Update max values if necessary
        if max_value is None or value > max_value:
            max_value = value
            max_pos = (r + 1, c + 1)

# Write output data
with open('cruce.out', 'w') as f:
    f.write(f"{max_value} {max_pos[0]} {max_pos[1]}\n")
```

This code should now calculate the correct value of each cross and find the one with the maximum value, respecting the memory constraints and not using numpy. I've fixed the calculation of the horizontal sum, vertical sum, and the overlap sum. The revised solution should produce the expected results.
---------- user ----------


Program result did not match expected result.
Input data:
```
5 2
1 -2 3 -1 4
-3 2 2 -2 -1
1 2 3 4 5
1 0 -7 1 1
3 2 1 2 3
```
Expected output:
```
23 2 4
```
Found output:
```
9 4 3
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The differences between the expected and found results are due to incorrect calculation of the cross sum. My previous approach attempted to correct the previous mistake by calculating the vertical and horizontal sums and the overlap. However, the calculation was still incorrect because the logic did not correctly account for the distinct portions of the cross (the horizontal bar and the vertical bar minus the overlap).

To correctly calculate the sum of a cross, we should:

1. Calculate the sum of the horizontal bar (K consecutive rows).
2. Calculate the sum of the vertical bar (K consecutive columns).
3. Subtract the sum of the overlap (since it's counted twice, once in the horizontal sum and once in the vertical sum).

Let's correct the implementation by fixing the overlap calculation and ensuring the cross is defined with the correct dimensions. The expected output indicates the cross is not limited to just the central overlapping square but extends across the entire K rows and K columns.

Here's the updated solution:

```python
# Function to calculate the sum of a submatrix using the prefix sum matrix
def submatrix_sum(prefix_sum, top, left, bottom, right):
    result = prefix_sum[bottom][right]
    if top > 0:
        result -= prefix_sum[top - 1][right]
    if left > 0:
        result -= prefix_sum[bottom][left - 1]
    if top > 0 and left > 0:
        result += prefix_sum[top - 1][left - 1]
    return result

# Read input data
with open('cruce.in', 'r') as f:
    N, K = map(int, f.readline().split())
    matrix = [list(map(int, f.readline().split())) for _ in range(N)]

# Create prefix sum matrix
prefix_sum = [[0] * N for _ in range(N)]
for r in range(N):
    for c in range(N):
        prefix_sum[r][c] = matrix[r][c]
        if r > 0:
            prefix_sum[r][c] += prefix_sum[r - 1][c]
        if c > 0:
            prefix_sum[r][c] += prefix_sum[r][c - 1]
        if r > 0 and c > 0:
            prefix_sum[r][c] -= prefix_sum[r - 1][c - 1]

# Initialize variables to store the maximum cross value and position
max_value = None
max_pos = (0, 0)

# Helper function to calculate the sum of the cross
def calculate_cross_sum(row, col):
    total = 0
    # Add horizontal bar
    for i in range(K):
        total += submatrix_sum(prefix_sum, row + i, col, row + i, col + K - 1)
    # Add vertical bar
    for i in range(K):
        total += submatrix_sum(prefix_sum, row, col + i, row + K - 1, col + i)
    # Subtract overlap (K-1 times the central row, since it's counted twice in the above two loops)
    total -= (K - 1) * submatrix_sum(prefix_sum, row + K//2, col, row + K//2, col + K - 1)
    return total

# Iterate over all possible positions for the cross
for r in range(N - K + 1):
    for c in range(N - K + 1):
        value = calculate_cross_sum(r, c)
        # Update max values if necessary
        if max_value is None or value > max_value:
            max_value = value
            max_pos = (r + 1, c + 1)  # Convert to 1-based indexing

# Write output data
with open('cruce.out', 'w') as f:
    f.write(f"{max_value} {max_pos[0]} {max_pos[1]}\n")
```

In this corrected version, we use a helper function `calculate_cross_sum` to calculate the cross sum for each potential position and update the max value and position accordingly. This should return the correct max cross value and position and produce the expected output.
---------- user ----------


Program result did not match expected result.
Input data:
```
5 2
1 -2 3 -1 4
-3 2 2 -2 -1
1 2 3 4 5
1 0 -7 1 1
3 2 1 2 3
```
Expected output:
```
23 2 4
```
Found output:
```
20 3 4
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The issue with the previous solutions is that they did not correctly calculate the value of the "cross" within the matrix. Specifically, there are issues with the calculation of the horizontal and vertical bars and the subtraction of the overlap. The central part of the cross was not correctly defined, and the overlaps were not properly subtracted.

We need a more straightforward approach to calculate the cross sum:

1. Calculate the sum of the full K rows (horizontal bar).
2. Calculate the sum of the full K columns (vertical bar).
3. Subtract the sum of the (K-1) x (K-1) inner matrix (since it's counted twice).

Here's the revised solution:

```python
# Function to calculate the sum of a submatrix using the prefix sum matrix
def submatrix_sum(prefix_sum, top, left, bottom, right):
    result = prefix_sum[bottom][right]
    if top > 0:
        result -= prefix_sum[top - 1][right]
    if left > 0:
        result -= prefix_sum[bottom][left - 1]
    if top > 0 and left > 0:
        result += prefix_sum[top - 1][left - 1]
    return result

# Read the input data
with open('cruce.in', 'r') as file:
    N, K = map(int, file.readline().split())
    matrix = [list(map(int, file.readline().split())) for _ in range(N)]

# Generate the prefix sum matrix
prefix_sum = [[0 for _ in range(N)] for _ in range(N)]
for r in range(N):
    for c in range(N):
        prefix_sum[r][c] = matrix[r][c]
        if r > 0:
            prefix_sum[r][c] += prefix_sum[r - 1][c]
        if c > 0:
            prefix_sum[r][c] += prefix_sum[r][c - 1]
        if r > 0 and c > 0:
            prefix_sum[r][c] -= prefix_sum[r - 1][c - 1]

# Initialize variables to store the maximum cross value and position
max_value = float('-inf')
max_pos = (-1, -1)

# Iterate over all possible positions for the top-left corner of the cross
for r in range(N - K + 1):
    for c in range(N - K + 1):
        # Calculate the sum of the K rows and K columns forming the cross
        sum_rows = sum(submatrix_sum(prefix_sum, row, c, row, c + K - 1) for row in range(r, r + K))
        sum_cols = sum(submatrix_sum(prefix_sum, r, col, r + K - 1, col) for col in range(c, c + K))
        
        # Subtract the sum of the overlapped (K-1)x(K-1) inner matrix
        overlap = submatrix_sum(prefix_sum, r + 1, c + 1, r + K - 2, c + K - 2)
        total_sum = sum_rows + sum_cols - overlap
        
        # Update maximum value and position
        if total_sum > max_value:
            max_value = total_sum
            max_pos = (r + 1, c + 1)  # Convert to 1-based indexing

# Write the output data
with open('cruce.out', 'w') as file:
    file.write(f"{max_value} {max_pos[0]} {max_pos[1]}\n")
```

This revised code should calculate the correct values for the crosses and determine the maximum value, resulting in the expected output. It tracks the maximum cross value and its position as it iterates through all possible locations for the cross's top-left corner.
---------- user ----------


Program result did not match expected result.
Input data:
```
5 2
1 -2 3 -1 4
-3 2 2 -2 -1
1 2 3 4 5
1 0 -7 1 1
3 2 1 2 3
```
Expected output:
```
23 2 4
```
Found output:
```
22 3 4
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

I apologize for the confusion. The previous solutions had a fundamental mistake in calculating the cross value, specifically in handling the overlap correctly. A proper solution must handle the sums of the K lines and K columns distinctly and subtract any overlap that is counted twice.

To calculate a cross's value:
1. Calculate the sum of K consecutive rows (horizontal bar of the cross).
2. Calculate the sum of K consecutive columns (vertical bar of the cross).
3. The center square, which has been double-counted, should be a (K-1) x (K-1) matrix if K > 1. If K = 1, there is no overlap.

We must adjust the solution to calculate these components and then combine them correctly. Let's revise the algorithm with a correct approach:

```python
# Read the input data
with open('cruce.in', 'r') as file:
    N, K = map(int, file.readline().split())
    matrix = [list(map(int, file.readline().split())) for _ in range(N)]

# Generate prefix sum array for rows and columns
row_prefix_sum = [[0] * (N + 1) for _ in range(N)]
col_prefix_sum = [[0] * N for _ in range(N + 1)]

for r in range(N):
    for c in range(N):
        row_prefix_sum[r][c + 1] = row_prefix_sum[r][c] + matrix[r][c]
        col_prefix_sum[r + 1][c] = col_prefix_sum[r][c] + matrix[r][c]

# Function to get the sum of a segment from the prefix sum array
def get_segment_sum(prefix_sum, start, end):
    return prefix_sum[end] - prefix_sum[start]

# Initialize variables to store the maximum cross value and position
max_value = float('-inf')
max_pos = (-1, -1)

# Iterate over all possible positions for the cross
for r in range(N - K + 1):
    for c in range(N - K + 1):
        # Calculate the sum of the K rows (horizontal bar of the cross)
        row_sum = sum(get_segment_sum(row_prefix_sum[r + i], c, c + K) for i in range(K))
        
        # Calculate the sum of the K columns (vertical bar of the cross)
        col_sum = sum(get_segment_sum(col_prefix_sum[r], c + i, r + K) for i in range(K))
        
        # Subtract the overlap if K > 1
        overlap = 0
        if K > 1:
            overlap = sum(get_segment_sum(row_prefix_sum[r + i], c + 1, c + K - 1) for i in range(1, K - 1))
            overlap += sum(get_segment_sum(col_prefix_sum[r + 1], c + i, r + K - 1) for i in range(1, K - 1))

        # Total value of the cross is the sum of the horizontal bar and the vertical bar minus the overlap
        total_sum = row_sum + col_sum - overlap
        
        # Update max_value and max_pos if a new maximum is found
        if total_sum > max_value or max_value == float('-inf'):
            max_value = total_sum
            max_pos = (r + 1, c + 1)  # Convert to 1-based indexing

# Write the output data
with open('cruce.out', 'w') as file:
    file.write(f"{max_value} {max_pos[0]} {max_pos[1]}\n")
```

In this solution, we correctly calculate the sums for the horizontal and vertical components of the cross and adjust the overlap calculation based on the width K. This should give us the expected output and resolve the discrepancies found in the previous attempts.
---------- user ----------


Program exited with code 1.
stdout:
```

```
stderr:
```
Traceback (most recent call last):
  File "/app/app.py", line 30, in <module>
    col_sum = sum(get_segment_sum(col_prefix_sum[r], c + i, r + K) for i in range(K))
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/app.py", line 30, in <genexpr>
    col_sum = sum(get_segment_sum(col_prefix_sum[r], c + i, r + K) for i in range(K))
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/app.py", line 17, in get_segment_sum
    return prefix_sum[end] - prefix_sum[start]
           ~~~~~~~~~~^^^^^
IndexError: list index out of range

```

Think of what has caused the exit code. Use the standard out and standard error to help you understand the issue.
Implement a solution to fix the program

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The traceback indicates that there is an `IndexError` in the `get_segment_sum` function, which suggests that an attempt was made to access an index of the `prefix_sum` list that is out of range. Specifically, the error occurs when calculating the `col_sum`. The issue arises because the `col_prefix_sum` indices for the end of the segment are not properly adjusted — they should be within the bounds of the `col_prefix_sum` array.

To fix the issue, we must ensure that we're accessing the correct indices for both `row_prefix_sum` and `col_prefix_sum`. We need to adjust the function `get_segment_sum` to correctly get the sum of the vertical bar and ensure we're using the `row_prefix_sum` and `col_prefix_sum` arrays correctly within the main loop.

Here is the corrected solution:

```python
# Read the input data
with open('cruce.in', 'r') as file:
    N, K = map(int, file.readline().split())
    matrix = [list(map(int, file.readline().split())) for _ in range(N)]

# Generate the prefix sum matrix for rows and columns
prefix_sum = [[0] * (N + 1) for _ in range(N + 1)]

for r in range(1, N + 1):
    for c in range(1, N + 1):
        prefix_sum[r][c] = matrix[r - 1][c - 1] + prefix_sum[r - 1][c] + prefix_sum[r][c - 1] - prefix_sum[r - 1][c - 1]

# Function to calculate the sum of a submatrix using the prefix sum matrix
def calculate_cross_sum(r, c):
    total = 0
    total += prefix_sum[r + K][c + K] - prefix_sum[r][c + K] - prefix_sum[r + K][c] + prefix_sum[r][c]
    row_overlap = prefix_sum[r + K][c] - prefix_sum[r + K][c - 1] - prefix_sum[r][c] + prefix_sum[r][c - 1]
    col_overlap = prefix_sum[r][c + K] - prefix_sum[r - 1][c + K] - prefix_sum[r][c] + prefix_sum[r - 1][c]
    if K > 1:
        total -= (K - 1) * (row_overlap + col_overlap)
    return total

# Initialize variables to store the maximum cross value and position
max_value = float('-inf')
max_pos = (-1, -1)

# Iterate over all possible positions for the cross
for r in range(0, N - K + 1):
    for c in range(0, N - K + 1):
        cross_sum = calculate_cross_sum(r, c)
        if cross_sum > max_value:
            max_value = cross_sum
            max_pos = (r + 1, c + 1)  # Convert to 1-based indexing

# Write the output data
with open('cruce.out', 'w') as file:
    file.write(f"{max_value} {max_pos[0]} {max_pos[1]}\n")
```

In this corrected solution, we use a single `prefix_sum` matrix to handle both row sums and column sums. The `calculate_cross_sum` function calculates the value of the cross at a specific position by adding the sum of the horizontal and vertical bars and then subtracting the sum of the overlapping parts (if K > 1). We properly account for overlaps along the borders of the cross.

This should now correctly calculate the maximum cross value and store its top-left position, producing the correct output per the problem's specification.
