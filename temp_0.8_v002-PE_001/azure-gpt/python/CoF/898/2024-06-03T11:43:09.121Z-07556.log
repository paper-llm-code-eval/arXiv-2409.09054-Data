---------- user ----------

Here is a programming challenge.
Please solve this problem efficiently, optimizing both time and memory usage.
Create the most efficient solution for this challenge in python. Utilize numpy and other highly efficient libraries whenever possible.
This problem has a memory limit of ~8MB so please be sensitive on using memory. Using too much memory may result in OOM.
The code must compile and be correct.
The solution must read from `cruce.in` and write to `cruce.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Se consideră o matrice pătratică de dimensiune $N$, conţinând numere naturale. Numim **cruce de lăţime $K$** reuniunea mulțimii tuturor elementelor aflate pe $K$ linii consecutive ale matricei și a mulțimii tuturor elementelor aflate pe $K$ coloane consecutive ale matricei. Două elemente ale matricei se consideră distincte dacă sunt situate pe poziții distincte în matrice. Se acceptă şi forma degenerată a unei cruci, în formă de `T` sau `L`, când una dintre liniile sau coloanele care formează crucea sunt chiar la marginea matricei. Vom defini **valoarea** unei cruci ca fiind suma elementelor din care aceasta este formată.

# Cerință

Scrieți un program care, pentru o valoare $K$ dată, determină o cruce de lățime $K$ a cărei valoare este maximă și poziția ei în matrice. Această poziție va fi exprimată prin perechea de indici reprezentând prima linie din cele $K$ consecutive și prima coloană din cele $K$ consecutive din care este formată crucea.

# Date de intrare

Fişierul `cruce.in` conţine pe prima linie numerele $N$ şi $K$, iar pe următoarele $N$ linii câte $N$ numere întregi reprezentând în ordine, pe linii, elementele matricei. Numerele de pe aceeaşi linie sunt separate prin câte un spaţiu.

# Date de ieșire

Fişierul `cruce.out` va conţine trei numere $Vmax \ L \ C$, separate prin câte un spaţiu, reprezentând valoarea maximă determinată pentru o cruce de lățime $K$, respectiv linia și coloana care exprimă poziția acesteia în matrice.

# Restricții și precizări

* $1 \leq K < N \leq 500$;
* Numerele din matrice sunt din intervalul $[-5 \ 000, 5 \ 000]$
* Liniile şi coloanele se indexează începând cu 1.
* Dacă există mai multe cruci de lățime $K$ de valoare maximă, se va lua în considerare poziția cu indicele liniei mai mic, iar în caz de egalitate a liniilor poziția celei cu indicele coloanei mai mic.

---

Example:
`cruce.in`
```
5 2
1 -2 3 -1 4
-3 2 2 -2 -1
1 2 3 4 5
1 0 -7 1 1
3 2 1 2 3
```

`cruce.out`
```
23 2 4
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```markdown
```python
import numpy as np

def compute_cross_sums(matrix, N, K):
    vertical_sums = np.cumsum(matrix, axis=0)
    horizontal_sums = np.cumsum(matrix, axis=1)
    
    # Consider the extra K-1 rows and columns for cross that lies on the edges
    vertical_sums[K:, :] -= vertical_sums[:-K, :]
    horizontal_sums[:, K:] -= horizontal_sums[:, :-K]
    
    cross_sums = np.zeros((N, N), dtype=int)
    for r in range(K-1, N):
        for c in range(K-1, N):
            vertical_sum = vertical_sums[r, c-K+1:c+1].sum()
            horizontal_sum = horizontal_sums[r-K+1:r+1, c].sum()
            cross_sum = vertical_sum + horizontal_sum - matrix[r, c]
            cross_sums[r-K+1, c-K+1] = cross_sum
            
    return cross_sums

# Read input
with open('cruce.in') as f:
    N, K = map(int, f.readline().split())
    matrix = np.array([list(map(int, f.readline().split())) for _ in range(N)], dtype=int)

# Compute cross sums
cross_sums = compute_cross_sums(matrix, N, K)

# Find the maximum cross sum and its position
max_value = np.max(cross_sums)
position = np.unravel_index(np.argmax(cross_sums), cross_sums.shape)

# Write output
with open('cruce.out', 'w') as f:
    f.write(f"{max_value} {position[0]+1} {position[1]+1}\n")
```
```

Note: This solution uses NumPy to perform efficient manipulation and computation of the sums of crosses in the matrix. Although NumPy typically has an overhead for small operations, for the size of the matrices considered here (up to 500x500), the library should provide significant performance benefits. Moreover, we carefully manage memory usage by reusing the same arrays for cumulative sums and computing cross sums in place. This solution should comply with the memory constraints specified.
---------- user ----------


Expected program to write result to `cruce.out` and read from `cruce.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

def compute_cross_sums(matrix, N, K):
    # Create vertical and horizontal cumulative sum arrays
    vertical_cumsum = np.cumsum(matrix, axis=0)
    horizontal_cumsum = np.cumsum(matrix, axis=1)
    
    # Create an array to store the sum of all crosses of width K
    cross_sums = np.zeros((N, N), dtype=int)
    
    # Calculate the sum for each cross of width K in the matrix
    for i in range(K - 1, N):
        for j in range(K - 1, N):
            vertical_sum = vertical_cumsum[i, j] - (vertical_cumsum[i - K, j] if i >= K else 0)
            horizontal_sum = horizontal_cumsum[i, j - K + 1:j + 1].sum() - matrix[i, j]
            
            # Adjust the sum for corner cases (edges of the matrix)
            if i < N - 1:
                vertical_sum -= vertical_cumsum[i + 1, j] - (vertical_cumsum[i - K + 1, j] if i >= K else 0)
            if j < N - 1:
                horizontal_sum -= horizontal_cumsum[i, j + 1] - horizontal_cumsum[i, j - K + 1]
                
            cross_sums[i - K + 1, j - K + 1] = vertical_sum + horizontal_sum
    
    return cross_sums

# Read input from 'cruce.in'
with open('cruce.in', 'r') as infile:
    N, K = map(int, infile.readline().split())
    matrix = np.array([list(map(int, infile.readline().split())) for _ in range(N)])

# Compute cross sums
cross_sums = compute_cross_sums(matrix, N, K)

# Find the maximum cross sum and its position
max_value = np.max(cross_sums)
position = np.unravel_index(np.argmax(cross_sums), cross_sums.shape)

# Write output to 'cruce.out'
with open('cruce.out', 'w') as outfile:
    outfile.write(f"{max_value} {position[0] + 1} {position[1] + 1}\n")
```
```
---------- user ----------


Expected program to write result to `cruce.out` and read from `cruce.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Function to calculate sum of each cross of width K in the matrix
def compute_cross_sums(matrix, N, K):
    # Compute the cumulative sum along both axes
    cumsum_vertical = np.cumsum(matrix, axis=0)
    cumsum_horizontal = np.cumsum(matrix, axis=1)
    
    # Compute vertical part sum for each cross
    vertical_sum = np.zeros((N, N), dtype=int)
    vertical_sum[K-1:] = cumsum_vertical[K-1:]
    if K > 1:
        vertical_sum[K-1:] -= cumsum_vertical[:-K+1]
    
    # Compute horizontal part sum for each cross
    horizontal_sum = np.zeros((N, N), dtype=int)
    horizontal_sum[:, K-1:] = cumsum_horizontal[:, K-1:]
    if K > 1:
        horizontal_sum[:, K-1:] -= cumsum_horizontal[:, :-K+1]
    
    # Total cross sum is vertical plus horizontal minus the common part (K-1 column and row)
    total_sum = vertical_sum + horizontal_sum - (K - 1) * matrix
    
    return total_sum

# Read data from 'cruce.in'
with open('cruce.in', 'r') as file:
    N, K = map(int, file.readline().split())
    matrix = np.array([list(map(int, file.readline().split())) for _ in range(N)], dtype=int)

# Compute the cross sums
cross_sums = compute_cross_sums(matrix, N, K)

# Find the maximum sum and the corresponding position
max_sum = np.max(cross_sums)
max_position = np.unravel_index(np.argmax(cross_sums), cross_sums.shape)

# Write the result to 'cruce.out'
with open('cruce.out', 'w') as file:
    L, C = max_position
    file.write(f"{max_sum} {L+1} {C+1}\n")
```
```
---------- user ----------


Expected program to write result to `cruce.out` and read from `cruce.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Read data from 'cruce.in'
with open('cruce.in', 'r') as file:
    N, K = map(int, file.readline().split())
    matrix = np.array([list(map(int, file.readline().split())) for _ in range(N)], dtype=int)

# Precompute the row and column sums
row_sums = np.cumsum(matrix, axis=1)
col_sums = np.cumsum(matrix, axis=0)

# Initialize max value and position
max_value = -np.inf
max_position = (-1, -1)

# Calculate the sums for all possible crosses of width K
for i in range(N - K + 1):
    for j in range(N - K + 1):
        vertical_sum = col_sums[i + K - 1, j] - (col_sums[i - 1, j] if i > 0 else 0)
        horizontal_sum = row_sums[i, j + K - 1] - (row_sums[i, j - 1] if j > 0 else 0)
        
        # If not at edges, subtract the overlapping area
        if i > 0 and j > 0:
            horizontal_sum -= row_sums[i, j - 1] - row_sums[i, 0]
        
        # Sum of the current cross
        cross_sum = vertical_sum + horizontal_sum - matrix[i, j]
        
        # Update max value and position
        if cross_sum > max_value:
            max_value = cross_sum
            max_position = (i + 1, j + 1)  # Convert to 1-based index

# Write the result to 'cruce.out'
with open('cruce.out', 'w') as file:
    file.write(f"{max_value} {max_position[0]} {max_position[1]}\n")
```
```
---------- user ----------


Expected program to write result to `cruce.out` and read from `cruce.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

def max_cross_sum(N, K, matrix):
    # Calculate row-wise and column-wise cumulative sums
    cum_row = np.cumsum(matrix, axis=1)
    cum_col = np.cumsum(matrix, axis=0)
    
    # Initialize the max sum, and position placeholders
    max_sum = None
    max_position = (0, 0)
    
    for i in range(N - K + 1):  # Rows
        for j in range(N - K + 1):  # Columns
            # Calculate cross sum at (i, j)
            if j == 0:
                row_sum = cum_row[i:i + K, j + K - 1].sum()
            else:
                row_sum = (cum_row[i:i + K, j + K - 1] - cum_row[i:i + K, j - 1]).sum()
            
            if i == 0:
                col_sum = cum_col[i + K - 1, j:j + K].sum()
            else:
                col_sum = (cum_col[i + K - 1, j:j + K] - cum_col[i - 1, j:j + K]).sum()
            
            # Subtract the overlapping middle section once as it got added twice
            cross_sum = row_sum + col_sum - matrix[i:i + K, j:j + K].sum()
            
            # Update max sum and position
            if max_sum is None or cross_sum > max_sum:
                max_sum = cross_sum
                max_position = (i + 1, j + 1)  # 1-based indexing
    
    return max_sum, max_position

# Read input from file
with open('cruce.in', 'r') as file:
    N, K = map(int, file.readline().split())
    matrix = np.array([list(map(int, file.readline().split())) for _ in range(N)], dtype=int)

# Compute the maximum cross sum and its position
max_sum, (max_i, max_j) = max_cross_sum(N, K, matrix)

# Write output to file
with open('cruce.out', 'w') as file:
    file.write(f"{max_sum} {max_i} {max_j}\n")
```
```
---------- user ----------


Expected program to write result to `cruce.out` and read from `cruce.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Load the data
with open('cruce.in', 'r') as file:
    N, K = map(int, file.readline().split())
    matrix = np.array([list(map(int, file.readline().split())) for _ in range(N)], dtype=int)

# Initialize variables to keep track of the maximum cross sum and its position
max_sum = float('-inf')
max_position = (0, 0)

# Precompute the sums for every row and column
row_sums = np.cumsum(matrix, axis=1)
col_sums = np.cumsum(matrix, axis=0)

# Iterate through each possible position for the cross
for i in range(N - K + 1):
    for j in range(N - K + 1):

        # Compute the sum of the cross
        # Sum of the vertical part of the cross
        vertical_sum = col_sums[i + K - 1, j] - (col_sums[i - 1, j] if i > 0 else 0)
        # Sum of the horizontal part of the cross, excluding the overlapping center
        horizontal_sum = row_sums[i, j + K - 1] - (row_sums[i, j - 1] if j > 0 else 0)
        # Subtract the overlapping center part once because we added it twice
        center = matrix[i, j] if K > 1 else 0
        cross_sum = vertical_sum + horizontal_sum - center

        # Check if the current cross sum is greater than the maximum found so far
        if cross_sum > max_sum:
            max_sum = cross_sum
            max_position = (i + 1, j + 1)  # Convert to 1-based indexing

# Write the result to 'cruce.out'
with open('cruce.out', 'w') as file:
    i, j = max_position
    file.write(f"{max_sum} {i} {j}\n")
```
```
---------- user ----------


Expected program to write result to `cruce.out` and read from `cruce.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Function to calculate the cross sums within the matrix given K
def calculate_cross_sums(matrix, N, K):
    # Compute the cumulative sums along the rows and columns
    cumsum_row = np.cumsum(matrix, axis=1)
    cumsum_col = np.cumsum(matrix, axis=0)
    
    cross_sums = np.zeros((N, N), dtype=int)
    max_sum = float('-inf')
    max_position = (1, 1)
    
    for i in range(N - K + 1):
        for j in range(N - K + 1):
            # Calculate vertical and horizontal sum for cross centered at (i, j)
            vert_sum = cumsum_col[i + K - 1, j] if i == 0 else cumsum_col[i + K - 1, j] - cumsum_col[i - 1, j]
            hor_sum = cumsum_row[i, j + K - 1] if j == 0 else cumsum_row[i, j + K - 1] - cumsum_row[i, j - 1]
            
            # Avoid double counting the center of the cross
            center = matrix[i, j] if K > 1 else 0
            
            # Total sum for the cross
            total_sum = vert_sum + hor_sum - center
            
            # Update the max sum and position
            if total_sum > max_sum:
                max_sum = total_sum
                max_position = (i + 1, j + 1)  # Convert to 1-based indexing

    return max_sum, max_position

# Read the input data from 'cruce.in'
with open('cruce.in', 'r') as infile:
    N, K = map(int, infile.readline().split())
    matrix = np.array([list(map(int, infile.readline().split())) for _ in range(N)])

# Calculate the maximum cross sum and its top-left position
max_sum, max_pos = calculate_cross_sums(matrix, N, K)

# Write the output data to 'cruce.out'
with open('cruce.out', 'w') as outfile:
    outfile.write(f"{max_sum} {max_pos[0]} {max_pos[1]}\n")
```
```
