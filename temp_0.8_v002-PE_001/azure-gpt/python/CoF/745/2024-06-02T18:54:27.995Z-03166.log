---------- user ----------

Here is a programming challenge.
Please solve this problem efficiently, optimizing both time and memory usage.
Create the most efficient solution for this challenge in python. Utilize numpy and other highly efficient libraries whenever possible.
This problem has a memory limit of ~8MB so please be sensitive on using memory.Using unavoided memory may result in OOM.
The code must compile and be correct.
The solution must read from `lacusta.in` and write to `lacusta.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Se consideră o matrice dreptunghiulară cu $m$ linii şi $n$ coloane, cu valori naturale. Traversăm matricea pornind de la colţul stânga-sus la colţul dreapta-jos. O traversare constă din mai multe deplasări. La fiecare deplasare se execută un salt pe orizontală şi un pas pe verticală. Un salt înseamnă că putem trece de la o celulă la oricare alta aflată pe aceeaşi linie, iar un pas înseamnă că putem trece de la o celulă la celula aflată imediat sub ea. Excepţie face ultima deplasare (cea în care ne aflăm pe ultima linie), când vom face doar un salt pentru a ajunge în colţul dreapta-jos, dar nu vom mai face şi pasul corespunzător. Astfel traversarea va consta din vizitarea a $2 \cdot m$ celule. 

# Cerinţă

Scrieţi un program care să determine suma minimă care se poate obţine pentru o astfel de traversare.

# Date de intrare


Fişierul de intrare `lacusta.in` conţine pe prima linie două numere naturale separate printr-un spaţiu $m \ n$, reprezentând numărul de linii şi respectiv numărul de coloane ale matricei. Pe următoarele $m$ linii este descrisă matricea, câte $n$ numere pe fiecare linie, separate prin câte un spaţiu.

# Date de ieșire


Fişierul de ieşire `lacusta.out` va conţine o singură linie pe care va fi scrisă suma minimă găsită.

# Restricții și precizări

* $1 \leq m, n \leq 100$
* Valorile elementelor matricei sunt numere întregi din intervalul $[1, 255]$

---

Example:
`lacusta.in`
```
4 5
3 4 5 7 9
6 6 3 4 4
6 3 3 9 6
6 5 3 8 2
```

`lacusta.out`
```
28
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```markdown
```python
import numpy as np

# Read the matrix dimensions and values from "lacusta.in"
with open('lacusta.in', 'r') as file:
    m, n = map(int, file.readline().split())
    matrix = np.array([list(map(int, file.readline().split())) for _ in range(m)])

# Initialize a 2D array for dynamic programming
dp = np.full((m, n), np.inf)
dp[0, 0] = matrix[0, 0]

# Populate the DP table
for i in range(1, m):
    for j in range(n):
        # Calculate the minimum value for the current cell
        for k in range(n):
            if k != j:  # We cannot move to the same column
                dp[i, j] = min(dp[i, j], dp[i - 1, k] + matrix[i, j] + matrix[i - 1, k])
    if i < m - 1:  # Exclude the last row for this step
        # Add the value of the row to the next row (pass step)
        dp[i + 1, :] += matrix[i, :]

# The result is the minimum value in the last row excluding the first column
result = min(dp[-1, 1:])

# Write the result to "lacusta.out"
with open('lacusta.out', 'w') as file:
    file.write(str(result))
```
```
---------- user ----------


Expected program to write result to `lacusta.out` and read from `lacusta.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

def read_matrix(filename):
    with open(filename, 'r') as file:
        m, n = map(int, file.readline().split())
        matrix = np.zeros((m, n), dtype=int)
        for i in range(m):
            matrix[i] = list(map(int, file.readline().split()))
    return matrix, m, n

def write_result(filename, result):
    with open(filename, 'w') as file:
        file.write(str(result))

def find_minimum_path_sum(matrix, m, n):
    # Create a cost matrix filled with infinity
    cost = np.full((m, n), np.inf)
    # Starting point cost
    cost[0][0] = matrix[0][0]

    # Calculate cost for second row since we can't land on first row again
    for j in range(1, n):
        cost[1][j] = matrix[0][0] + matrix[1][j] + matrix[0][j]

    # Fill in the rest of the cost matrix
    for i in range(2, m):
        for j in range(n):
            # We seek the minimum cost to land on (i, j)
            prev_costs = cost[i - 1] + matrix[i - 1]  # Cost of previous row cells
            prev_costs[j] = np.inf  # Eliminate the vertical move
            # Add the cost of moving to the current cell
            cost[i][j] = np.min(prev_costs) + matrix[i][j]

    # Find the minimum cost for the penultimate step (excluding the first column)
    min_penultimate = np.min(cost[-2][1:])
    # The last move is from penultimate row to the last row, last column
    result = min_penultimate + matrix[-1][-1]

    return result

# Read the matrix from the input file
matrix, m, n = read_matrix('lacusta.in')
# Find the minimum path sum
result = find_minimum_path_sum(matrix, m, n)
# Write the result to the output file
write_result('lacusta.out', result)
```
```
---------- user ----------


Expected program to write result to `lacusta.out` and read from `lacusta.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```python
import numpy as np

# Read from lacusta.in
with open('lacusta.in', 'r') as file:
    m, n = map(int, file.readline().split())
    grid = np.array([list(map(int, file.readline().split())) for _ in range(m)])

# Initialize the dynamic programming table
dp = np.full((m, n), np.inf, dtype=int)
dp[0, 0] = grid[0, 0]

# Calculate the cost of the initial step for the second row
for j in range(1, n):
    dp[1, j] = dp[0, 0] + grid[0, j] + grid[1, j]

# Populate the DP table with the rest of the steps
for i in range(2, m):
    for j in range(n):
        second_min = np.inf
        for k in range(n):
            if k != j:
                cost = dp[i - 1, k] + grid[i, j] + grid[i - 1, k]
                if cost < dp[i, j]:
                    second_min = min(second_min, dp[i, j])
                    dp[i, j] = cost
                elif cost < second_min:
                    second_min = cost
        # Include the second smallest cost for the next row computation
        dp[i, j] += second_min - grid[i, j] - grid[i - 1, j]

# The result is the minimum value in the last row excluding the first column
result = dp[-1, 1:].min()

# Write to lacusta.out
with open('lacusta.out', 'w') as file:
    file.write(str(result))
```
This python code reads the input matrix from `lacusta.in`, calculates the minimum path sum using dynamic programming, and writes the result to `lacusta.out`, respecting the memory constraints and without using `input()` or `print()`.
---------- user ----------


Program exited with code 1.
stdout:
```

```
stderr:
```
Traceback (most recent call last):
  File "/app/app.py", line 1, in <module>
    import numpy as np
ModuleNotFoundError: No module named 'numpy'

```

Think of what has caused the exit code. Use the standard out and standard error to help you understand the issue.
Implement a solution to fix the program

---

Rewrite the entire solution applying necessary fixes.
