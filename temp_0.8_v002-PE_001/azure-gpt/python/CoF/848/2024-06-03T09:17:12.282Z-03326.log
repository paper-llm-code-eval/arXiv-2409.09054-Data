---------- user ----------

Here is a programming challenge.
Please solve this problem efficiently, optimizing both time and memory usage.
Create the most efficient solution for this challenge in python. Utilize numpy and other highly efficient libraries whenever possible.
This problem has a memory limit of ~8MB so please be sensitive on using memory. Using too much memory may result in OOM.
The code must compile and be correct.
The solution must read from `arrows.in` and write to `arrows.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

“Arrows” este un joc care se joacă pe o tablă dreptunghiulară a cărei suprafață este împărțită în $N \cdot M$ celule, aranjate pe $N$ linii și $M$ coloane. În fiecare celulă se află o săgeată (sus, jos, stânga sau dreapta), ca în figura de mai jos:

~[arrows.png]

Când este la mutare, un jucător poate alege o poziție de start pe care plasează un jeton, apoi deplasează jetonul la celula învecinată în sensul indicat de săgeată. Deplasarea continuă până când jetonul părăsește tabla de joc, caz în care jucătorul obține un punctaj egal cu numărul de celule parcurse de jetonul său.
Există însă poziții de start denumite favorabile, pentru care jetonul **nu** va părăsi niciodată tabla de joc. De exemplu, toate pozițiile din figură cu fundal gri sunt favorabile. Jucătorul care alege o poziție de start favorabilă obține un punctaj egal cu numărul de celule distincte vizitate înmulțit cu $1000$.

Scrieți un program care, cunoscând configurația tablei de joc, rezolvă una dintre următoarele cerințe:

1. determină punctajul pe care îl obține un jucător care plasează jetonul său pe o poziție de start specificată;
2. determină numărul de celule favorabile de pe tabla de joc;
3. determină punctajul maxim pe care jucătorul îl poate obține la o mutare, alegând convenabil poziția de start.

# Date de intrare

Fișierul de intrare `arrows.in` conține pe prima linie cerința care trebuie să fie rezolvată ($1, 2$ sau $3$). Pe a doua linie se află numerele naturale $N \ M$, care reprezintă numărul de linii și respectiv de coloane de pe tabla de joc. Pe următoarele $N$ linii se află câte $M$ numere din mulțimea {$1,2,3,4$} reprezentând săgețile aflate în celulele de pe tabla de joc ($1$ semnificând săgeata la dreapta, $2$ săgeata în sus, $3$ săgeata la stânga și $4$ săgeata în jos). Pe ultima linie sunt scrise numerele naturale $lin \ col$, reprezentând linia și coloana pe care se află poziția de start specificată. Valorile scrise pe aceeași linie în fișierul de intrare sunt separate prin spații.

# Date de ieșire

Fișierul de ieșire `arrows.out` va conține o singură linie pe care va fi scris un număr natural reprezentând răspunsul pentru cerința specificată pe prima linie a fișierului de intrare.

# Restricții și precizări

* $1 \leq N, M \leq 500$;
* Liniile sunt numerotate de la $1$ la $N$, iar coloanele de la $1$ la $M$.
* Pentru teste valorând $20$ de puncte cerința este $1$. Pentru teste valorând $40$ de puncte cerința este $2$. Pentru celelalte teste, valorând de asemenea $40$ de puncte, cerința este $3$.

---

Example:
`arrows.in`
```
1
6 5
3 1 1 4 2
1 2 4 3 1
4 2 1 1 4
1 2 3 3 3
3 1 4 4 4
2 2 3 4 2
5 5
```

`arrows.out`
```
2000
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```python
import numpy as np

# Read the input from 'arrows.in'
with open('arrows.in', 'r') as file:
    lines = file.readlines()

# Parse input data
task = int(lines[0].strip())
N, M = map(int, lines[1].strip().split())
arrows = np.array([[int(x) for x in line.strip().split()] for line in lines[2:-1]], dtype=np.int8)
if task == 1:
    start_line, start_col = map(int, lines[-1].strip().split())
    start_line -= 1  # Convert to 0-based index
    start_col -= 1

# Define the move directions for the arrows
moves = {
    1: (0, 1),   # Right
    2: (-1, 0),  # Up
    3: (0, -1),  # Left
    4: (1, 0)    # Down
}

# Helper function to calculate a score from a starting position
def calculate_score(start_line, start_col):
    visited = set()
    line, col = start_line, start_col
    while 0 <= line < N and 0 <= col < M:
        if (line, col) in visited:
            return len(visited) * 1000
        visited.add((line, col))
        move = moves[arrows[line, col]]
        line += move[0]
        col += move[1]
    return len(visited)

# Solve the task
if task == 1:
    score = calculate_score(start_line, start_col)
elif task == 2:
    score = sum(calculate_score(i, j) > 1000 for i in range(N) for j in range(M))
elif task == 3:
    score = max(calculate_score(i, j) for i in range(N) for j in range(M))

# Write the output to 'arrows.out'
with open('arrows.out', 'w') as file:
    file.write(str(score) + '\n')
```

This solution reads from `arrows.in`, chooses the task based on the first line, and then proceeds to perform the task efficiently. The `calculate_score` function is used for tasks 1 and 3, and it either calculates the score for a single start position or iterates over all possible start positions to find the maximum score. For task 2, we count the number of starting positions that yield a score greater than 1000, which indicates a favorable cell. Finally, it writes the result to `arrows.out`.
---------- user ----------


Program exited with code 1.
stdout:
```

```
stderr:
```
Traceback (most recent call last):
  File "/app/app.py", line 1, in <module>
    import numpy as np
ModuleNotFoundError: No module named 'numpy'

```

Think of what has caused the exit code. Use the standard out and standard error to help you understand the issue.
Implement a solution to fix the program

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The error indicates that the `numpy` module is not installed in the environment where the code is executed. Since the environment may not allow for additional module installations, the solution must be re-implemented without the use of `numpy` or any other non-standard libraries.

I'll rewrite the solution using only Python's built-in structures to ensure compatibility.

Here is the updated solution:
```python
# Function to move the token according to the arrow directions
def move_token(direction, i, j):
    if direction == 1:
        return i, j + 1
    elif direction == 2:
        return i - 1, j
    elif direction == 3:
        return i, j - 1
    elif direction == 4:
        return i + 1, j

# Read the input from 'arrows.in'
with open('arrows.in', 'r') as file:
    task = int(file.readline().strip())
    N, M = map(int, file.readline().strip().split())
    arrows = [list(map(int, file.readline().strip().split())) for _ in range(N)]
    if task == 1:
        start_line, start_col = map(int, file.readline().strip().split())
        start_line -= 1  # Convert to 0-based index
        start_col -= 1

# Function to calculate the score from a starting position
def calculate_score(arrows, N, M, i, j):
    visited = set()
    while 0 <= i < N and 0 <= j < M:
        if (i, j) in visited:
            # The token is in a loop
            return len(visited) * 1000
        visited.add((i, j))
        i, j = move_token(arrows[i][j], i, j)
    # The token has left the board
    return len(visited)

# Solve the task
if task == 1:
    score = calculate_score(arrows, N, M, start_line, start_col)
elif task == 2:
    score = sum(calculate_score(arrows, N, M, i, j) > 1000 for i in range(N) for j in range(M))
elif task == 3:
    score = max(calculate_score(arrows, N, M, i, j) for i in range(N) for j in range(M))

# Write the output to 'arrows.out'
with open('arrows.out', 'w') as file:
    file.write(str(score) + '\n')
```

The solution no longer relies on `numpy`. All arrays and operations are now handled using built-in Python data structures and functions, ensuring that the program will not exit with an error due to missing modules.
