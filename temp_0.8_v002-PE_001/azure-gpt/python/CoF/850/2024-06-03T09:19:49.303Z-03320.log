---------- user ----------

Here is a programming challenge.
Please solve this problem efficiently, optimizing both time and memory usage.
Create the most efficient solution for this challenge in python. Utilize numpy and other highly efficient libraries whenever possible.
This problem has a memory limit of ~8MB so please be sensitive on using memory. Using too much memory may result in OOM.
The code must compile and be correct.
The solution must read from `ferma.in` and write to `ferma.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Un fermier deține o fermă de formă dreptunghiulară cu lungimea $m$ metri și lățimea $n$ metri. Respectând principiul rotației culturilor, fermierul și a realizat un plan pentru semănarea culturilor în noul an. Astfel, el a desenat un dreptunghi pe care l-a împărțit în $m \cdot n$ celule, fiecare corespunzând unui metru pătrat, și a colorat în culori diferite zonele care corespund unor culturi diferite. O cultură poate fi semănată pe mai multe parcele. Două celule care au o latură comună aparțin aceleiași parcele dacă au aceeași culoare (sunt însămânțate cu aceeași cultură).  Fermierul are posibilitatea să irige o sigură parcelă și dorește să aleagă parcela cu cea mai mare suprafață. Nefiind mulțumit de suprafața rezultată, s-a întrebat dacă ar putea schimba cultura de pe o singură celulă, astfel încât să obțină o parcelă de suprafață mai mare.

Exemplu de fermă (_imagine 1_):

~[0.png]

# Cerință

Dându-se dimensiunile fermei și pentru fiecare celulă culoarea corespunzătoare culturii semănate, determinați:

1. **Varianta 1:** Suprafața maximă a unei parcele în planul inițial.
2. **Varianta 2:** Numărul liniei, respectiv al coloanei celulei pe care va semăna o altă cultură și culoarea corespunzătoare noii culturi în vederea obţinerii celei mai mari parcele posibile.


# Date de intrare


Fișierul de intrare `ferma.in` va conține:]

* pe prima linie un număr natural $v$ ($1 ≤ v ≤ 2$) indicând varianta cerinței de rezolvare
* pe a doua linie două numere naturale $m$ şi $n$ separate printr-un spațiu, cu semnificația din enunț
* pe fiecare dintre următoarele $m$ linii se găsesc câte $n$ caractere (litere mici), reprezentând codurile culturilor ce vor fi semănate pe cele $n$ celule corespunzătoare fiecărei linii. 


# Date de ieșire


Fișierul de ieșire `ferma.out` va conține:
**Varianta 1** – pentru $v=1$: 
* pe prima linie numărul natural $s$, reprezentând suprafața maximă a unei parcele.

**Varianta 2** – pentru $v=2$: 
* pe prima linie două numere naturale separate printr-un spațiu, reprezentând numărul liniei, respectiv al coloanei celulei pe care va semăna o altă cultură, în vederea obținerii unei parcele cu suprafața maximă; 
* pe a doua linie un caracter reprezentând codul culorii corespunzătoare noii culturi din celula determinată.


# Restricții și precizări

* $2 \leq n, m \leq 400$
* Numărul de culturi distincte este cel puţin $2$ şi cel mult $26$.
* $30\%$ din teste vor avea pe prima linie valoarea $1$, iar restul de $70\%$ din teste vor avea pe prima linie valoarea $2$.
* Pentru varianta $2$ se punctează orice soluție care conduce la obținerea unei parcele cu suprafața maximă. Nu se acordă punctaje parțiale.

---

Example:
`ferma.in`
```
1
7 8
rmmgggaa
mvvgggaa
mvvgvvvv
vvvrvvvv
vvrrrgga
vvrrrggg
aaaaaaag
```

`ferma.out`
```
11
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```python
# Required Libraries
import numpy as np
from scipy.ndimage import label

# Utility function to get neighbors of a given cell
def get_neighbors(r, c, m, n):
    neighbors = []
    if r > 0: neighbors.append((r - 1, c))
    if r < m - 1: neighbors.append((r + 1, c))
    if c > 0: neighbors.append((r, c - 1))
    if c < n - 1: neighbors.append((r, c + 1))
    return neighbors

# Utility function to calculate the size of the largest parcel
def calculate_largest_parcel_size(farm):
    labeled_array, num_features = label(farm)
    areas = np.bincount(labeled_array.ravel())[1:]  # Skip background label
    return np.max(areas)

# Utility function to find the best cell to change in order to maximize parcel area
def find_best_cell_to_change(farm):
    labeled_array, num_features = label(farm)
    largest_parcel_label = np.argmax(np.bincount(labeled_array.ravel())[1:]) + 1

    m, n = farm.shape
    best_size_increase = 0
    best_cell = None
    best_color = None

    for r in range(m):
        for c in range(n):
            if labeled_array[r, c] != largest_parcel_label:
                current_color = farm[r, c]
                neighbors = get_neighbors(r, c, m, n)
                for neighbor in neighbors:
                    if labeled_array[neighbor] == largest_parcel_label:
                        farm[r, c] = farm[neighbor]
                        new_size = calculate_largest_parcel_size(farm)
                        farm[r, c] = current_color  # Revert back

                        size_increase = new_size - (np.max(np.bincount(labeled_array.ravel())[1:]))
                        if size_increase > best_size_increase:
                            best_size_increase = size_increase
                            best_cell = (r + 1, c + 1)  # 1-based indexing for output
                            best_color = farm[neighbor]

    return best_cell, best_color

# Read input
with open('ferma.in', 'r') as file:
    lines = file.readlines()
    v = int(lines[0].strip())
    m, n = map(int, lines[1].split())
    farm = np.array([list(line.strip()) for line in lines[2:2 + m]])

# Process and write output
with open('ferma.out', 'w') as file:
    if v == 1:
        max_parcel_size = calculate_largest_parcel_size(farm)
        file.write(f"{max_parcel_size}\n")
    elif v == 2:
        best_cell, best_color = find_best_cell_to_change(farm)
        if best_cell:
            file.write(f"{best_cell[0]} {best_cell[1]}\n{best_color}\n")
        else:
            file.write("0 0\nx\n")  # Fallback case
```

This code should solve the challenge efficiently by using `scipy.ndimage.label` to label connected components and `numpy` to process the farm efficiently. Additionally, this solution avoids any unnecessary memory usage that could cause an out-of-memory error with the given constraints.
---------- user ----------


Program exited with code 1.
stdout:
```

```
stderr:
```
Traceback (most recent call last):
  File "/app/app.py", line 2, in <module>
    import numpy as np
ModuleNotFoundError: No module named 'numpy'

```

Think of what has caused the exit code. Use the standard out and standard error to help you understand the issue.
Implement a solution to fix the program

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

As the error suggests, the `numpy` module is not available. Since the environment doesn't have `numpy` and potentially other external libraries like `scipy`, we need to implement the solution using only the standard Python libraries. Here's how we can do that:

```python
# Required Libraries
from collections import deque

# Utility function to get neighbors of a given cell
def get_neighbors(r, c, m, n):
    neighbors = []
    if r > 0: neighbors.append((r - 1, c))
    if r < m - 1: neighbors.append((r + 1, c))
    if c > 0: neighbors.append((r, c - 1))
    if c < n - 1: neighbors.append((r, c + 1))
    return neighbors

# Utility function to calculate the size of the largest parcel using BFS
def calculate_largest_parcel_size(farm, m, n):
    visited = [[False for _ in range(n)] for _ in range(m)]
    max_area = 0
    for r in range(m):
        for c in range(n):
            if not visited[r][c]:
                color = farm[r][c]
                area = 0
                queue = deque([(r, c)])
                visited[r][c] = True
                while queue:
                    x, y = queue.popleft()
                    area += 1
                    for nx, ny in get_neighbors(x, y, m, n):
                        if not visited[nx][ny] and farm[nx][ny] == color:
                            visited[nx][ny] = True
                            queue.append((nx, ny))
                max_area = max(max_area, area)
    return max_area

# Utility function to find the best cell to change in order to maximize parcel area
def find_best_cell_to_change(farm, m, n):
    max_area = calculate_largest_parcel_size(farm, m, n)
    best_cell = None
    best_color = None
    for r in range(m):
        for c in range(n):
            original_color = farm[r][c]
            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:  # Check four directions
                nr, nc = r + dr, c + dc
                if 0 <= nr < m and 0 <= nc < n and farm[nr][nc] != original_color:
                    farm[r][c] = farm[nr][nc]  # Change color
                    new_area = calculate_largest_parcel_size(farm, m, n)
                    farm[r][c] = original_color  # Revert color
                    if new_area > max_area:
                        max_area = new_area
                        best_cell = (r + 1, c + 1)  # Convert to 1-based indexing
                        best_color = farm[nr][nc]
    return best_cell, best_color

# Read input
with open('ferma.in', 'r') as file:
    lines = file.readlines()
    v = int(lines[0].strip())
    m, n = map(int, lines[1].split())
    farm = [list(line.strip()) for line in lines[2:2 + m]]

# Process and write output
with open('ferma.out', 'w') as file:
    if v == 1:
        max_parcel_size = calculate_largest_parcel_size(farm, m, n)
        file.write(f"{max_parcel_size}\n")
    elif v == 2:
        best_cell, best_color = find_best_cell_to_change(farm, m, n)
        if best_cell:
            file.write(f"{best_cell[0]} {best_cell[1]}\n{best_color}\n")
        else:
            file.write("0 0\nx\n")  # Fallback case
```

This code does not use `numpy` or `scipy` and relies only on standard Python libraries, which should be available in almost all Python environments. It uses a breadth-first search (BFS) to calculate the size of each parcel and determine the best cell to change for maximizing the parcel area.
