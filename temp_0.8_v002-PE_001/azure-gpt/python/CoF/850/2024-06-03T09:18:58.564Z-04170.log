---------- user ----------

Here is a programming challenge.
Please solve this problem efficiently, optimizing both time and memory usage.
Create the most efficient solution for this challenge in python. Utilize numpy and other highly efficient libraries whenever possible.
This problem has a memory limit of ~8MB so please be sensitive on using memory. Using too much memory may result in OOM.
The code must compile and be correct.
The solution must read from `ferma.in` and write to `ferma.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Un fermier deține o fermă de formă dreptunghiulară cu lungimea $m$ metri și lățimea $n$ metri. Respectând principiul rotației culturilor, fermierul și a realizat un plan pentru semănarea culturilor în noul an. Astfel, el a desenat un dreptunghi pe care l-a împărțit în $m \cdot n$ celule, fiecare corespunzând unui metru pătrat, și a colorat în culori diferite zonele care corespund unor culturi diferite. O cultură poate fi semănată pe mai multe parcele. Două celule care au o latură comună aparțin aceleiași parcele dacă au aceeași culoare (sunt însămânțate cu aceeași cultură).  Fermierul are posibilitatea să irige o sigură parcelă și dorește să aleagă parcela cu cea mai mare suprafață. Nefiind mulțumit de suprafața rezultată, s-a întrebat dacă ar putea schimba cultura de pe o singură celulă, astfel încât să obțină o parcelă de suprafață mai mare.

Exemplu de fermă (_imagine 1_):

~[0.png]

# Cerință

Dându-se dimensiunile fermei și pentru fiecare celulă culoarea corespunzătoare culturii semănate, determinați:

1. **Varianta 1:** Suprafața maximă a unei parcele în planul inițial.
2. **Varianta 2:** Numărul liniei, respectiv al coloanei celulei pe care va semăna o altă cultură și culoarea corespunzătoare noii culturi în vederea obţinerii celei mai mari parcele posibile.


# Date de intrare


Fișierul de intrare `ferma.in` va conține:]

* pe prima linie un număr natural $v$ ($1 ≤ v ≤ 2$) indicând varianta cerinței de rezolvare
* pe a doua linie două numere naturale $m$ şi $n$ separate printr-un spațiu, cu semnificația din enunț
* pe fiecare dintre următoarele $m$ linii se găsesc câte $n$ caractere (litere mici), reprezentând codurile culturilor ce vor fi semănate pe cele $n$ celule corespunzătoare fiecărei linii. 


# Date de ieșire


Fișierul de ieșire `ferma.out` va conține:
**Varianta 1** – pentru $v=1$: 
* pe prima linie numărul natural $s$, reprezentând suprafața maximă a unei parcele.

**Varianta 2** – pentru $v=2$: 
* pe prima linie două numere naturale separate printr-un spațiu, reprezentând numărul liniei, respectiv al coloanei celulei pe care va semăna o altă cultură, în vederea obținerii unei parcele cu suprafața maximă; 
* pe a doua linie un caracter reprezentând codul culorii corespunzătoare noii culturi din celula determinată.


# Restricții și precizări

* $2 \leq n, m \leq 400$
* Numărul de culturi distincte este cel puţin $2$ şi cel mult $26$.
* $30\%$ din teste vor avea pe prima linie valoarea $1$, iar restul de $70\%$ din teste vor avea pe prima linie valoarea $2$.
* Pentru varianta $2$ se punctează orice soluție care conduce la obținerea unei parcele cu suprafața maximă. Nu se acordă punctaje parțiale.

---

Example:
`ferma.in`
```
1
7 8
rmmgggaa
mvvgggaa
mvvgvvvv
vvvrvvvv
vvrrrgga
vvrrrggg
aaaaaaag
```

`ferma.out`
```
11
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```python
import numpy as np
from collections import Counter
from scipy.ndimage import label, generate_binary_structure

def parse_input(filename):
    with open(filename, 'r') as file:
        v = int(file.readline().strip())
        m, n = map(int, file.readline().strip().split())
        farm = [list(file.readline().strip()) for _ in range(m)]
    return v, np.array(farm)

def write_output(filename, result):
    with open(filename, 'w') as file:
        if isinstance(result, int):
            file.write(f'{result}\n')
        else:
            line, col, color = result
            file.write(f'{line} {col}\n{color}\n')

def variant_one(farm):
    struct = generate_binary_structure(2, 1)
    labeled, num_features = label(farm, structure=struct)
    area_counts = Counter(labeled.flatten())
    max_area = max(area_counts.values()) if num_features > 0 else 0
    return max_area

def possible_colors(farm, row, col, m, n):
    colors = set()
    if row > 0: colors.add(farm[row-1][col])
    if row < m-1: colors.add(farm[row+1][col])
    if col > 0: colors.add(farm[row][col-1])
    if col < n-1: colors.add(farm[row][col+1])
    return colors

def variant_two(farm):
    struct = generate_binary_structure(2, 1)
    labeled, num_features = label(farm, structure=struct)
    area_counts = Counter(labeled.flatten())
    original_color = farm[labeled == area_counts.most_common(1)[0][0]]
    max_area = area_counts.most_common(1)[0][1]
    m, n = farm.shape

    best_cell = (0, 0)
    best_color = ''
    best_increase = 0

    for row in range(m):
        for col in range(n):
            original_area = area_counts[labeled[row, col]]
            for color in possible_colors(labeled, row, col, m, n):
                if color != original_color and color != farm[row][col]:
                    farm[row, col] = color
                    new_labeled, new_num_features = label(farm, structure=struct)
                    new_area_counts = Counter(new_labeled.flatten())
                    new_max_area = new_area_counts.most_common(1)[0][1]
                    increase = new_max_area - max(new_max_area, original_area)
                    if increase > best_increase:
                        best_increase = increase
                        best_cell = (row + 1, col + 1) # One-indexed for output
                        best_color = color
                    farm[row, col] = original_color  # Revert back to original color

    return (*best_cell, best_color)

def solve_problem():
    v, farm = parse_input('ferma.in')
    if v == 1:
        max_area = variant_one(farm)
        write_output('ferma.out', max_area)
    elif v == 2:
        line_col_color = variant_two(farm)
        write_output('ferma.out', line_col_color)

# Running the actual solution
solve_problem()
```
Remember that the provided code assumes the numpy and scipy libraries are pre-installed in the environment where the code will run. If they are not installed, you would need to execute `pip install numpy scipy` before running this code. This solution reads from 'ferma.in', processes the data according to the described algorithm, and writes the results to 'ferma.out'.
---------- user ----------


Program exited with code 1.
stdout:
```

```
stderr:
```
Traceback (most recent call last):
  File "/app/app.py", line 1, in <module>
    import numpy as np
ModuleNotFoundError: No module named 'numpy'

```

Think of what has caused the exit code. Use the standard out and standard error to help you understand the issue.
Implement a solution to fix the program

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The error message `ModuleNotFoundError: No module named 'numpy'` indicates that the `numpy` library is not installed in the environment. The same issue would likely occur for the `scipy` library, as it is also not part of the standard Python library.

Given the memory constraints and the restriction that the solution must not rely on external libraries such as `numpy` and `scipy`, we'll need to implement the solution using only standard libraries.

Below is a modified version of the code that does not depend on `numpy` or `scipy`:

```python
from collections import deque, defaultdict

def parse_input(filename):
    with open(filename, 'r') as file:
        v = int(file.readline().strip())
        m, n = map(int, file.readline().strip().split())
        farm = [list(file.readline().strip()) for _ in range(m)]
    return v, m, n, farm

def write_output(filename, result):
    with open(filename, 'w') as file:
        if isinstance(result, int):
            file.write(f'{result}\n')
        else:
            line, col, color = result
            file.write(f'{line} {col}\n{color}\n')

def bfs(farm, start, visited):
    queue = deque([start])
    area = 0
    color = farm[start[0]][start[1]]
    while queue:
        row, col = queue.popleft()
        if visited[row][col]:
            continue
        visited[row][col] = True
        area += 1
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        for dr, dc in directions:
            r, c = row + dr, col + dc
            if 0 <= r < len(farm) and 0 <= c < len(farm[0]) and not visited[r][c] and farm[r][c] == color:
                queue.append((r, c))
    return area

def variant_one(m, n, farm):
    visited = [[False]*n for _ in range(m)]
    max_area = 0
    for row in range(m):
        for col in range(n):
            if not visited[row][col]:
                area = bfs(farm, (row, col), visited)
                max_area = max(max_area, area)
    return max_area

def variant_two(m, n, farm):
    visited = [[False]*n for _ in range(m)]
    parcel_sizes = defaultdict(int)
    best_cell = (0, 0)
    best_color = ''
    best_increase = 0

    for row in range(m):
        for col in range(n):
            if not visited[row][col]:
                color = farm[row][col]
                area = bfs(farm, (row, col), visited)
                parcel_sizes[color] = max(parcel_sizes[color], area)

    original_farm = [row[:] for row in farm]
    for row in range(m):
        for col in range(n):
            original_color = farm[row][col]
            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                r, c = row + dr, col + dc
                if 0 <= r < m and 0 <= c < n and farm[r][c] != original_color:
                    farm[row][col] = farm[r][c]
                    visited = [[False]*n for _ in range(m)]
                    new_area = bfs(farm, (r, c), visited)
                    increase = new_area - parcel_sizes[original_color]
                    if increase > best_increase:
                        best_increase = increase
                        best_cell = (row+1, col+1)  # Convert to 1-index
                        best_color = farm[r][c]
                    farm = [row[:] for row in original_farm]  # Reset farm to original state
    return best_cell + (best_color,)

def solve_problem():
    v, m, n, farm = parse_input('ferma.in')
    if v == 1:
        max_area = variant_one(m, n, farm)
        write_output('ferma.out', max_area)
    elif v == 2:
        line_col_color = variant_two(m, n, farm)
        write_output('ferma.out', line_col_color)

# Running the actual solution
solve_problem()
```

This solution uses only standard Python libraries and should meet the memory constraints. The algorithms for both variants have been updated to use a breadth-first search (BFS) approach without relying on `numpy` or `scipy` for labeling or processing the farm grid.
