---------- user ----------

Here is a programming challenge.
Please solve this problem efficiently, optimizing both time and memory usage.
Create the most efficient solution for this challenge in python. Utilize numpy and other highly efficient libraries whenever possible.
This problem has a memory limit of ~8MB so please be sensitive on using memory. Using too much memory may result in OOM.
The code must compile and be correct.
The solution must read from `expresie.in` and write to `expresie.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Se dă un șir de $n$ numere naturale nenule $x_1, x_2, \dots, x_n$ și un număr natural $m$.

# Cerință
Să se verifice dacă valoarea expresiei $\sqrt[m]{x_1 x_2 x_3 \dots x_n}$ este un număr natural. În caz afirmativ să se afișeze acest număr descompus în factori primi.

# Date de intrare
În fișierul `expresie.in` se află pe prima linie $m$, pe linia a doua $n$, iar pe linia a treia numerele $x_1$, $x_2$, $\dots$, $x_n$ separate între ele prin câte un spațiu.

# Date de ieșire
În fișierul `expresie.out` se va scrie pe prima linie cifra $0$, dacă valoarea expresiei nu este un număr natural, respectiv $1$ dacă este un număr natural. 
Dacă valoarea expresiei este un număr natural, pe următoarele linii se vor scrie perechi de forma "$p\ e$" ($p$ este factor prim care apare în descompunere la puterea $e \geq 1$). Aceste perechi se vor scrie în ordine crescătoare după primul număr (adică $p$).

# Restricții
- $n$ este un număr natural nenul mai mic strict decât $5\ 000$.
- $x_i$ este un număr natural nenul mai mic strict decât $30\ 000$, $i \in \{1, 2, \dots, n\}$.
- **$m$ poate fi una din cifrele $2$, $3$ sau $4$.**

---

Example:
`expresie.in`
```
2
4
32 81 100 19
```

`expresie.out`
```
0
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```python
import numpy as np
from collections import defaultdict
from math import gcd

# Function to factorize a number into its prime factors
def prime_factorization(n):
    factors = defaultdict(int)
    d = 2
    while d * d <= n:
        while n % d == 0:
            factors[d] += 1
            n //= d
        d += 1
    if n > 1:
        factors[n] += 1
    return factors

# Read the input from 'expresie.in'
with open('expresie.in', 'r') as fin:
    m = int(fin.readline().strip())
    n = int(fin.readline().strip())
    numbers = list(map(int, fin.readline().split()))

# Check for the memory limit by comparing the total size of the numpy array with the limit
# Each int32 takes 4 bytes, so we can roughly estimate if we stay under the limit
if 4 * n > 8 * 1024 * 1024:
    raise MemoryError("The memory limit has been exceeded")

# Initialize the product as 1 and a gcd variable to store the gcd of exponents
product = 1
exponents_gcd = 0

# Loop through the numbers and calculate the product of their prime factors raised to the power of (1/m)
for number in numbers:
    factors = prime_factorization(number)
    for factor, exponent in factors.items():
        # Multiply the exponents by (1/m) and find the gcd of all exponents
        exponents_gcd = gcd(exponents_gcd, exponent)
        product *= factor ** (exponent // m)

# Check if the exponents_gcd is divisible by m, which implies the m-th root is an integer
is_natural_number = exponents_gcd % m == 0

# Write the output to 'expresie.out'
with open('expresie.out', 'w') as fout:
    if is_natural_number:
        fout.write('1\n')
        # If it is an integer, compute the prime factors of the product
        prime_factors = prime_factorization(product)
        for factor in sorted(prime_factors):
            fout.write(f"{factor} {prime_factors[factor]}\n")
    else:
        fout.write('0\n')
```

This Python script should solve the problem, optimizing both time and memory usage. It reads the input from 'expresie.in', performs the calculations, and writes the output to 'expresie.out' as per the problem statement. Note that the script avoids the use of large data structures and instead uses a prime factorization function that operates within the memory limit.
---------- user ----------


Program exited with code 1.
stdout:
```

```
stderr:
```
Traceback (most recent call last):
  File "/app/app.py", line 1, in <module>
    import numpy as np
ModuleNotFoundError: No module named 'numpy'

```

Think of what has caused the exit code. Use the standard out and standard error to help you understand the issue.
Implement a solution to fix the program

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

It seems that the program failed because the `numpy` library is not available. However, upon reviewing the code, we can see that `numpy` is not actually used anywhere in the script. The import statement for `numpy` is unnecessary, and we can safely remove it. Moreover, the original memory check is based on an incorrect assumption that we are using a `numpy` array, which we are not. I will also remove that check and ensure that the memory usage is optimized by not storing large data structures.

Here is the revised code that does not depend on `numpy` and does not check for memory limits explicitly, but still uses efficient memory practices:

```python
from collections import defaultdict
from math import gcd

# Function to factorize a number into its prime factors
def prime_factorization(n):
    factors = defaultdict(int)
    d = 2
    while d * d <= n:
        while n % d == 0:
            factors[d] += 1
            n //= d
        d += 1
    if n > 1:
        factors[n] += 1
    return factors

# Read the input from 'expresie.in'
with open('expresie.in', 'r') as fin:
    m = int(fin.readline().strip())
    n = int(fin.readline().strip())
    numbers = list(map(int, fin.readline().split()))

# Initialize the aggregate exponents dictionary
aggregate_exponents = defaultdict(int)

# Loop through the numbers and collect the prime factors and their exponents
for number in numbers:
    factors = prime_factorization(number)
    for factor, exponent in factors.items():
        aggregate_exponents[factor] += exponent

# Now, check if the m-th root is an integer by verifying the divisibility of exponents by m
is_natural_number = all(exponent % m == 0 for exponent in aggregate_exponents.values())

# Write the output to 'expresie.out'
with open('expresie.out', 'w') as fout:
    if is_natural_number:
        fout.write('1\n')
        # Calculate the prime factors of the m-th root
        for factor in sorted(aggregate_exponents):
            exponent = aggregate_exponents[factor] // m
            if exponent:
                fout.write(f"{factor} {exponent}\n")
    else:
        fout.write('0\n')
```

The revised script removes the use of `numpy` and does not perform an explicit memory check. Instead, it performs prime factorization and works with a dictionary that keeps the aggregate exponents, which is more memory-efficient than accumulating the product of numbers.
