---------- user ----------

Here is a programming challenge.
Please solve this problem efficiently, optimizing both time and memory usage.
Create the most efficient solution for this challenge in python. Utilize numpy and other highly efficient libraries whenever possible.
This problem has a memory limit of ~8MB so please be sensitive on using memory. Using too much memory may result in OOM.
The code must compile and be correct.
The solution must read from `interesant.in` and write to `interesant.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Se consideră o mulțime $S$ care conține $N$ șiruri de caractere formate din litere mici ale alfabetului englezesc.  

Un șir de caractere se numește _interesant_ în raport cu celelalte șiruri ale mulțimii, dacă nu există un alt șir în mulțime care să-l conțină ca subșir. De exemplu, dacă mulțimea $S$ conține șirurile `abc`, `bde` și `abcdef`, atunci singurul șir *interesant* este `abcdef` deoarece `abc` și `bde` nu îl conțin ca subșir. Mai mult, `abc` și `bde` sunt subșiruri în `abcdef`, deci nu sunt *interesante*.

# Cerințe

Fiind dată o mulțime $S$ formată din $N$ șiruri de caractere se cere:

1. Să se determine cel mai lung șir. Dacă sunt mai multe șiruri având aceeași lungime maximă, se cere cel mai mic din punct de vedere lexicografic.
2. Să se determine toate șirurile _interesante_ din  mulțimea $S$.

# Date de intrare


Fișierul de intrare `interesant.in` conține pe prima linie două numere naturale $p$ și $N$, despărțite prin spațiu. Pentru toate testele de intrare, numărul $p$ poate avea doar valoarea $1$ sau valoarea $2$. Pe următoarele $N$ linii, se găsesc șirurile de caractere, câte unul pe linie.


# Date de ieșire


Dacă valoarea lui $p$ este $1$, **se va rezolva numai cerința $1$**.

În acest caz, în fișierul de ieșire `interesant.out` se va scrie cel mai lung șir dintre cele citite. Dacă există mai multe șiruri de aceeași lungime, se va scrie cel mai mic din punct de vedere lexicografic.

Dacă valoarea lui $p$ este $2$, **se va rezolva numai cerința $2$**.

În acest caz, fișierul de ieșire `interesant.out` va conține pe prima linie o valoare $K$ ce reprezintă numărul de șiruri _interesante_, iar pe următoarele $K$ linii, șirurile *interesante* **în ordinea în care apar în fișierul de intrare**.


# Restricții și precizări

* $2 \leq N \leq 200$
* Lungimea unui șir va fi cuprinsă între $1$ și $5 \ 000$.
* Un subșir al șirului de caractere $C_0 C_1 C_2 \dots C_k$ se definește ca fiind o succesiune de caractere $C_{i_1} C_{i_2} C_{i_3} \dots C_{i_k}$, unde $0 \leq i_1 < i_2 < i_3 < \dots < i_k \leq k$.
* Fișierul de intrare **NU conține șiruri identice**.

| $p$ | Punctaj |
| - | ------- |
| $1$ | 20      |
| $2$ | 80      |

---

Example:
`interesant.in`
```
1 5
abcacaaz
ad
abcacaad
acd
zyt
```

`interesant.out`
```
abcacaad
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```markdown
```python
import numpy as np

def find_longest_lex_smallest(strings):
    # Sort the strings based on their lengths in descending order,
    # if they have the same length, sort them lexicographically.
    sorted_strings = sorted(strings, key=lambda x: (-len(x), x))
    return sorted_strings[0]

def find_interesting_strings(strings):
    # Initialize a list to hold the interesting strings
    interesting = []
    # Convert list of strings to numpy array for efficient processing
    strings_array = np.array(strings)
    # Loop through each string and check if it's interesting
    for string in strings:
        is_interesting = True
        # Check if string is a substring of any other string
        for other_string in strings_array:
            if string != other_string and string in other_string:
                is_interesting = False
                break
        # If the string is interesting, add it to the list
        if is_interesting:
            interesting.append(string)
    # Return the count of interesting strings followed by the strings themselves
    return [str(len(interesting))] + interesting

# Read input from 'interesant.in'
with open('interesant.in', 'r') as file:
    p, N = map(int, file.readline().strip().split())
    strings = [file.readline().strip() for _ in range(N)]

# Depending on the value of p, either find the longest string or the interesting strings
result = []
if p == 1:
    result.append(find_longest_lex_smallest(strings))
elif p == 2:
    result += find_interesting_strings(strings)

# Write output to 'interesant.out'
with open('interesant.out', 'w') as file:
    file.write('\n'.join(result))
```
```
---------- user ----------


Expected program to write result to `interesant.out` and read from `interesant.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Function to find the longest string with smallest lexicographical order
def find_longest_lex_smallest(strings):
    longest_string = min((s for s in strings if len(s) == max(map(len, strings))), key=str)
    return longest_string

# Function to find all interesting strings
def find_interesting_strings(strings):
    # Array to hold the interesting strings
    interesting = []
    # Loop through each string to check if it's interesting
    for string in strings:
        if all(string not in other or string == other for other in strings):
            interesting.append(string)
    # Return the count of interesting strings followed by the strings themselves
    return [str(len(interesting))] + interesting

# Read input from 'interesant.in'
with open('interesant.in', 'r') as file:
    p, N = map(int, file.readline().strip().split())
    strings = [file.readline().strip() for _ in range(N)]

# Depending on the value of p, find the result
result = []
if p == 1:
    result.append(find_longest_lex_smallest(strings))
elif p == 2:
    result.extend(find_interesting_strings(strings))

# Write output to 'interesant.out'
with open('interesant.out', 'w') as file:
    file.write('\n'.join(result))
```
```
---------- user ----------


Expected program to write result to `interesant.out` and read from `interesant.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
# Function to find the longest string with smallest lexicographical order
def find_longest_lex_smallest(strings):
    longest_string = min((s for s in strings if len(s) == max(map(len, strings))), key=str)
    return longest_string

# Function to find all interesting strings
def find_interesting_strings(strings):
    # Array to hold the interesting strings
    interesting = []
    # Loop through each string to check if it's interesting
    for string in strings:
        if all(string not in other or string == other for other in strings):
            interesting.append(string)
    # Return the count of interesting strings followed by the strings themselves
    return [str(len(interesting))] + interesting

# Read input from 'interesant.in'
with open('interesant.in', 'r') as file:
    p, N = map(int, file.readline().strip().split())
    strings = [file.readline().strip() for _ in range(N)]

# Depending on the value of p, find the result
result = []
if p == 1:
    result.append(find_longest_lex_smallest(strings))
elif p == 2:
    result.extend(find_interesting_strings(strings))

# Write output to 'interesant.out'
with open('interesant.out', 'w') as file:
    file.write('\n'.join(result))
```
```
---------- user ----------


Expected program to write result to `interesant.out` and read from `interesant.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
# Function to check if the string is a substring of any other in the list
def is_substring(s, strings):
    for other in strings:
        if s != other and s in other:
            return True
    return False

# Read input from 'interesant.in'
with open('interesant.in', 'r') as file:
    p, N = map(int, file.readline().split())
    strings = [file.readline().strip() for _ in range(N)]

# Process the input based on the problem statement
result = []
if p == 1:
    # Find the longest string with the smallest lexicographical order
    longest_string = min((s for s in strings if len(s) == max(map(len, strings))), key=str)
    result.append(longest_string)
elif p == 2:
    # Find all interesting strings
    interesting_strings = [s for s in strings if not is_substring(s, strings)]
    result.append(str(len(interesting_strings)))
    result.extend(interesting_strings)

# Write output to 'interesant.out'
with open('interesant.out', 'w') as file:
    file.write('\n'.join(result))
```
```
---------- user ----------


Expected program to write result to `interesant.out` and read from `interesant.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
# Function to check if a string is interesting
def is_interesting(s, others):
    return all(s not in other for other in others if other != s)

# Read input from 'interesant.in'
with open('interesant.in', 'r') as file:
    p, N = map(int, file.readline().split())
    strings = [file.readline().strip() for _ in range(N)]

# Process the input based on the problem statement
result = []

if p == 1:
    # Find the longest string with the smallest lexicographical order
    longest_string = min(strings, key=lambda s: (-len(s), s))
    result.append(longest_string)
elif p == 2:
    # Find all interesting strings
    interesting_strings = [s for s in strings if is_interesting(s, strings)]
    result.append(str(len(interesting_strings)))
    result.extend(interesting_strings)

# Write output to 'interesant.out'
with open('interesant.out', 'w') as file:
    file.write('\n'.join(result))
```
```
---------- user ----------


Expected program to write result to `interesant.out` and read from `interesant.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
# Function to find the longest string with smallest lexicographical order
def find_longest_lex_smallest(strings):
    longest_string = min((s for s in strings if len(s) == max(map(len, strings))), key=str)
    return longest_string

# Function to find all interesting strings
def find_interesting_strings(strings):
    # Array to hold the interesting strings
    interesting = []
    # Loop through each string to check if it's interesting
    for string in strings:
        if all(string not in other or string == other for other in strings):
            interesting.append(string)
    # Return the count of interesting strings followed by the strings themselves
    return [str(len(interesting))] + interesting

# Read input from 'interesant.in'
with open('interesant.in', 'r') as file:
    p, N = map(int, file.readline().strip().split())
    strings = [file.readline().strip() for _ in range(N)]

# Depending on the value of p, find the result
result = []
if p == 1:
    result.append(find_longest_lex_smallest(strings))
elif p == 2:
    result.extend(find_interesting_strings(strings))

# Write output to 'interesant.out'
with open('interesant.out', 'w') as file:
    file.write('\n'.join(result))
```
```
---------- user ----------


Expected program to write result to `interesant.out` and read from `interesant.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
def is_interesting(s, strings):
    return not any(s in o and s != o for o in strings)

def main():
    with open('interesant.in', 'r') as f:
        p, N = map(int, f.readline().split())
        strings = [f.readline().strip() for _ in range(N)]

    if p == 1:
        result = min(strings, key=lambda s: (-len(s), s))
        with open('interesant.out', 'w') as f:
            f.write(result)
    elif p == 2:
        interesting = [s for s in strings if is_interesting(s, strings)]
        with open('interesant.out', 'w') as f:
            f.write(str(len(interesting)) + '\n')
            f.write('\n'.join(interesting))

if __name__ == '__main__':
    main()
```
```
