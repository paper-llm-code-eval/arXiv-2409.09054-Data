---------- user ----------

Here is a programming challenge.
Please solve this problem efficiently, optimizing both time and memory usage.
Create the most efficient solution for this challenge in python. Utilize numpy and other highly efficient libraries whenever possible.
This problem has a memory limit of ~8MB so please be sensitive on using memory. Using too much memory may result in OOM.
The code must compile and be correct.
The solution must read from `biperm.in` and write to `biperm.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Pentru un număr natural nenul `n`, să considerăm toate numerele naturale nenule mai mici sau egale cu `n`, luând fiecare număr de câte două ori: `1, 1, 2, 2, 3, 3, ... , n, n`. Aceste numere le amestecăm aleator, şi le aranjăm pe două linii a câte `n` elemente. Structura astfel obţinută o vom numi o bipermutare. În figurile `1, 2` şi `3` avem câte un exemplu de bipermutare pentru `n=5`. 

O bipermutare este perfectă, dacă ambele linii ale structurii reprezintă câte o permutare (vezi figurile `2` şi `3`).

Prin mutare pe poziţia `p`, înţelegem interschimbarea elementelor de pe aceeaşi coloană `p`. În exemplele de mai jos, bipermutarea perfectă din figura `2` s-a obţinut din bipermutarea din figura `1`, aplicând o mutare pe poziţa `2`. Bipermutarea perfectă din figura `3` s-a obţinut din bipermutarea din figura `1`, aplicând mutări pe poziţiile `1, 2, 4` şi `5`.

~[biperm.png]

# Cerinţe
Cunoscând o bipermutare, determinaţi:
* numărul bipermutărilor perfecte distincte ce se pot obţine prin mutări;
* numărul minim de mutări prin care se poate obţine o bipermutare perfectă;
* o bipermutare perfectă obţinută din bipermutarea iniţială.

# Date de intrare
Fişierul de intrare `biperm.in` conţine pe prima linie valoarea lui `n`. Următoarele două linii conţin, fiecare, câte `n` elemente separate prin câte un spaţiu, formând o bipermutare.

# Date de ieşire
Fişierul de ieşire `biperm.out` va conţine:
* pe prima linie două numere naturale separate printr-un spaţiu, reprezentând  numărul bipermutărilor perfecte distincte ce se pot obţine din bipermutarea dată, respectiv numărul minim de mutări prin care se poate obţine o bipermutare perfectă; 
* pe următoarele două linii se vor tipări câte n numere separate prin spaţiu, reprezentând o bipermutare perfectă obţinută din bipermutarea dată. 

# Restricţii şi precizări
* `2 < n ≤ 10 000`;
* calculul corect al numărului bipermutărilor perfecte distincte valorează `30%` din punctaj;
* calculul corect al numărului minim de mutări valorează `10%` din punctaj;
* tipărirea unei bipermutări perfecte valorează `60%` din punctaj. Pot exista mai multe soluţii, se va admite orice soluţie corectă;
* se garantează că numărul bipermutărilor perfecte distincte nu depăşeşte `2 000 000 000` pentru niciun test.
* acordarea punctajului la un răspuns corect este condiţionată de existenţa răspunsurilor anterioare, indiferent de corectitudinea lor;
* pentru `40%` din teste `n ≤ 20` 
* pentru `40%` din teste `20 < n ≤ 400`
* pentru `20%` din teste `400 < n ≤ 10 000`

---

Example:
`biperm.in`
```
5
1 5 5 3 4
3 2 2 4 1
```

`biperm.out`
```
4 1
1 2 5 3 4
3 5 2 4 1
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```markdown
```python
import numpy as np

def load_bipermutation(file_path):
    with open(file_path, 'r') as file:
        n = int(file.readline().strip())
        line1 = list(map(int, file.readline().strip().split()))
        line2 = list(map(int, file.readline().strip().split()))
    return n, np.array(line1), np.array(line2)

def save_bipermutation(file_path, num_distinct, min_moves, bipermutation):
    with open(file_path, 'w') as file:
        file.write(f"{num_distinct} {min_moves}\n")
        np.savetxt(file, bipermutation, fmt='%d')

def compute_bipermutation(n, line1, line2):
    swaps = {}
    for i in range(n):
        if line1[i] != line2[i]:
            if line1[i] not in swaps:
                swaps[line1[i]] = [i]
            else:
                swaps[line1[i]].append(i)
            if line2[i] not in swaps:
                swaps[line2[i]] = [i]
            else:
                swaps[line2[i]].append(i)

    bipermutation = np.array([line1, line2])
    num_swaps = 0

    for pair in swaps.values():
        if len(pair) == 2:
            bipermutation[:, pair[0]], bipermutation[:, pair[1]] = bipermutation[:, pair[1]], bipermutation[:, pair[0]].copy()
            num_swaps += 1

    # Check for cycles
    num_cycles = 0
    visited = [False] * n
    for i in range(n):
        if not visited[i] and swaps.get(bipermutation[0, i]) is not None:
            num_cycles += 1
            x = i
            while not visited[x]:
                visited[x] = True
                x = swaps[bipermutation[0, x]][0] if x == swaps[bipermutation[0, x]][1] else swaps[bipermutation[0, x]][1]

    num_distinct = 2 ** num_cycles
    min_moves = num_swaps + num_cycles - (1 if num_cycles > 0 else 0)

    return num_distinct, min_moves, bipermutation

# Load the bipermutation from 'biperm.in'
n, line1, line2 = load_bipermutation('biperm.in')

# Compute the number of distinct perfect bipermutations, the minimum number of moves, and one such bipermutation
num_distinct, min_moves, bipermutation = compute_bipermutation(n, line1, line2)

# Save the result to 'biperm.out'
save_bipermutation('biperm.out', num_distinct, min_moves, bipermutation)
```
```
---------- user ----------


Expected program to write result to `biperm.out` and read from `biperm.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

def load_bipermutation(file_path):
    with open(file_path, 'r') as file:
        n = int(file.readline().strip())
        line1 = list(map(int, file.readline().strip().split()))
        line2 = list(map(int, file.readline().strip().split()))
    return n, np.array(line1), np.array(line2)

def save_bipermutation(file_path, num_distinct, min_moves, bipermutation):
    with open(file_path, 'w') as file:
        file.write(f"{num_distinct} {min_moves}\n")
        for row in bipermutation:
            file.write(' '.join(map(str, row)) + '\n')

def compute_bipermutation(n, line1, line2):
    swaps = {}
    for i in range(n):
        if line1[i] != line2[i]:
            if line1[i] not in swaps:
                swaps[line1[i]] = [i]
            else:
                swaps[line1[i]].append(i)
            if line2[i] not in swaps:
                swaps[line2[i]] = [i]
            else:
                swaps[line2[i]].append(i)

    bipermutation = np.array([line1, line2])
    num_swaps = 0
    num_cycles = 0
    visited = set()

    for i in range(n):
        if i in visited or line1[i] == line2[i]:
            continue
        visited.add(i)
        cycle_length = 1
        x = i
        while line1[x] != line2[i]:
            x = swaps[line2[i]][0] if swaps[line2[i]][0] != x else swaps[line2[i]][1]
            visited.add(x)
            cycle_length += 1
        num_cycles += cycle_length // 2

    num_swaps = len(swaps) - num_cycles
    num_distinct = 2 ** num_cycles
    min_moves = num_swaps + num_cycles

    return num_distinct, min_moves, bipermutation

# Load the bipermutation from 'biperm.in'
n, line1, line2 = load_bipermutation('biperm.in')

# Compute the number of distinct perfect bipermutations, the minimum number of moves, and one such bipermutation
num_distinct, min_moves, bipermutation = compute_bipermutation(n, line1, line2)

# Save the result to 'biperm.out'
save_bipermutation('biperm.out', num_distinct, min_moves, bipermutation)
```
```
---------- user ----------


Expected program to write result to `biperm.out` and read from `biperm.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Define the functions to read and write the bipermutation
def read_bipermutation(file_path):
    with open(file_path, 'r') as file:
        n = int(file.readline().strip())
        first_line = np.fromstring(file.readline().strip(), dtype=int, sep=' ')
        second_line = np.fromstring(file.readline().strip(), dtype=int, sep=' ')
    return n, first_line, second_line

def write_result(file_path, num_distinct, min_moves, first_line, second_line):
    with open(file_path, 'w') as file:
        file.write(f"{num_distinct} {min_moves}\n")
        file.write(' '.join(str(num) for num in first_line) + '\n')
        file.write(' '.join(str(num) for num in second_line))

# Define the function to solve the bipermutation problem
def solve_bipermutation(n, first_line, second_line):
    swap_map = {}
    for i in range(n):
        swap_map.setdefault(first_line[i], []).append(i)
        swap_map.setdefault(second_line[i], []).append(i)

    min_moves = 0
    for indices in swap_map.values():
        if indices[0] != indices[1]:
            min_moves += 1
            first_line[indices[0]], second_line[indices[1]] = second_line[indices[1]], first_line[indices[0]]

    # Find cycles
    num_cycles = 0
    for i in range(n):
        if first_line[i] != i + 1:
            num_cycles += 1
            x = first_line[i] - 1
            while x != i:
                first_line[i], first_line[x] = first_line[x], first_line[i]
                x = first_line[i] - 1

    # Calculate the number of distinct perfect bipermutations
    num_distinct = 2 ** num_cycles if num_cycles > 0 else 1

    return num_distinct, min_moves, first_line, second_line

# Read the bipermutation from 'biperm.in'
n, first_line, second_line = read_bipermutation('biperm.in')

# Solve the bipermutation problem
num_distinct, min_moves, first_line, second_line = solve_bipermutation(n, first_line, second_line)

# Write the result to 'biperm.out'
write_result('biperm.out', num_distinct, min_moves, first_line, second_line)
```
```
---------- user ----------


Expected program to write result to `biperm.out` and read from `biperm.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Function to read the bipermutation from the file
def read_bipermutation(file_path):
    with open(file_path, 'r') as file:
        n = int(file.readline().strip())
        first_line = np.fromfile(file, dtype=int, count=n, sep=' ')
        second_line = np.fromfile(file, dtype=int, count=n, sep=' ')
    return n, first_line, second_line

# Function to write the result to the file
def write_result(file_path, num_distinct, min_moves, bipermutation):
    with open(file_path, 'w') as file:
        file.write(f"{num_distinct} {min_moves}\n")
        for row in bipermutation:
            file.write(' '.join(map(str, row)) + '\n')

# Function to solve the bipermutation problem
def solve_bipermutation(n, line1, line2):
    # Create a map to track the positions of the numbers
    positions = {}
    for i in range(n):
        positions.setdefault(line1[i], []).append(i)
        positions.setdefault(line2[i], []).append(i)
    
    # Calculate the number of swaps required and perform the swaps
    swaps = 0
    for indices in positions.values():
        if indices[0] != indices[1]:
            swaps += 1
            line1[indices[0]], line2[indices[1]] = line2[indices[1]], line1[indices[0]]
    
    # Detect cycles which need an extra swap
    cycles = 0
    visited = [False] * n
    for i in range(n):
        if not visited[i]:
            cycles += 1
            x = i
            while not visited[x]:
                visited[x] = True
                x = positions[line1[x]][1] if positions[line1[x]][0] == x else positions[line1[x]][0]
            cycles -= 1  # Adjust for the last cycle that doesn't need an extra swap
    
    num_distinct = 2**cycles
    min_moves = swaps + cycles  # Adding cycles because each cycle needs an extra swap
    bipermutation = np.vstack((line1, line2))
    
    return num_distinct, min_moves, bipermutation

# Read the bipermutation from 'biperm.in'
n, line1, line2 = read_bipermutation('biperm.in')

# Solve the bipermutation problem
num_distinct, min_moves, bipermutation = solve_bipermutation(n, line1, line2)

# Write the result to 'biperm.out'
write_result('biperm.out', num_distinct, min_moves, bipermutation)
```
```
---------- user ----------


Expected program to write result to `biperm.out` and read from `biperm.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
# Import the numpy library for efficient array manipulation
import numpy as np

def main():
    # Read data from biperm.in
    with open('biperm.in', 'r') as f:
        n = int(f.readline().strip())
        row1 = np.array(f.readline().strip().split(), dtype=np.int32)
        row2 = np.array(f.readline().strip().split(), dtype=np.int32)

    # Initialize variables
    perfect_biperm_count = 1
    min_swaps = 0
    swaps_needed = []
    occurrences = {}

    # Find pairs that need to be swapped and count occurrences
    for i in range(n):
        pair = (row1[i], row2[i])
        if pair in occurrences:
            occurrences[pair].append(i)
        else:
            occurrences[pair] = [i]

    # Process occurrences to count swaps needed
    for indices in occurrences.values():
        if len(indices) == 2:
            i, j = indices
            if row1[i] != row1[j]:
                min_swaps += 1
                swaps_needed.append((i, j))
        elif len(indices) == 1:
            min_swaps += 1  # Need one swap to fix this
            perfect_biperm_count *= 2

    # Perform the swaps to get a perfect bipermutation
    for i, j in swaps_needed:
        row2[i], row2[j] = row2[j], row2[i]

    # Write results to biperm.out
    with open('biperm.out', 'w') as f:
        f.write(f'{perfect_biperm_count} {min_swaps}\n')
        f.write(' '.join(map(str, row1)) + '\n')
        f.write(' '.join(map(str, row2)))

# Call the main function to execute the program
if __name__ == '__main__':
    main()
```
```
---------- user ----------


Expected program to write result to `biperm.out` and read from `biperm.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

def read_input(filename):
    with open(filename, 'r') as file:
        n = int(file.readline().strip())
        first_row = np.fromstring(file.readline().strip(), sep=' ', dtype=int)
        second_row = np.fromstring(file.readline().strip(), sep=' ', dtype=int)
    return n, first_row, second_row

def write_output(filename, num_permutations, min_swaps, perm1, perm2):
    with open(filename, 'w') as file:
        file.write(f"{num_permutations} {min_swaps}\n")
        file.write(' '.join(map(str, perm1)) + '\n')
        file.write(' '.join(map(str, perm2)))

def swap_columns(perm1, perm2, index1, index2):
    perm1[index1], perm1[index2] = perm1[index2], perm1[index1]
    perm2[index1], perm2[index2] = perm2[index2], perm2[index1]

def find_cycles(perm):
    visited = [False] * len(perm)
    cycles = 0
    for i in range(len(perm)):
        if not visited[i]:
            cycles += 1
            j = i
            while not visited[j]:
                visited[j] = True
                j = perm[j] - 1
    return cycles

def solve(n, first_row, second_row):
    # Dictionary to keep track of the positions of each number in both rows
    positions = {i + 1: [] for i in range(n)}
    for i in range(n):
        positions[first_row[i]].append(i)
        positions[second_row[i]].append(i)

    # Swapping columns in the first row to make it a correct permutation
    for number, pos in positions.items():
        if pos[0] != number - 1:
            swap_columns(first_row, second_row, pos[0], number - 1)
            positions[first_row[pos[0]]].remove(pos[0])
            positions[first_row[pos[0]]].append(number - 1)

    # Now, the first row is a correct permutation
    # We need to swap columns in the second row to make it a correct permutation
    # The number of cycles in the second row will give us the number of distinct permutations
    cycles = find_cycles(second_row)

    # The number of swaps to sort the second row will be the total number of swaps
    total_swaps = n - cycles

    # Calculate the number of distinct bipermutations
    num_permutations = 2 ** cycles

    return num_permutations, total_swaps, first_row, second_row

# Read input
n, first_row, second_row = read_input('biperm.in')

# Solve the problem
num_permutations, min_swaps, sorted_first_row, sorted_second_row = solve(n, first_row, second_row)

# Write output
write_output('biperm.out', num_permutations, min_swaps, sorted_first_row, sorted_second_row)
```
```
---------- user ----------


Expected program to write result to `biperm.out` and read from `biperm.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

def main():
    # Load the data from 'biperm.in'
    with open('biperm.in', 'r') as infile:
        n = int(infile.readline().strip())
        upper_row = np.fromstring(infile.readline().strip(), sep=' ', dtype=int)
        lower_row = np.fromstring(infile.readline().strip(), sep=' ', dtype=int)

    # Identify all positions where the numbers are the same
    same_positions = upper_row == lower_row
    # Identify all unique numbers that are at the same position on both rows
    unique_numbers = np.unique(upper_row[same_positions])

    # Determine the number of swaps and number of distinct perfect bipermutations
    swaps = 0
    distinct_bipermutations = 1
    for number in unique_numbers:
        # Find the positions of the current number in both rows
        positions = np.where(upper_row == number)[0]
        # If numbers are on the same row, we don't need to swap, but it reduces distinct permutations by half
        if same_positions[positions[0]]:
            distinct_bipermutations *= 2
        else:
            # Swap the numbers in the lower row to make them the same
            lower_row[positions[0]], lower_row[positions[1]] = lower_row[positions[1]], lower_row[positions[0]]
            swaps += 1

    # Write the output to 'biperm.out'
    with open('biperm.out', 'w') as outfile:
        outfile.write(f"{distinct_bipermutations} {swaps}\n")
        outfile.write(' '.join(map(str, upper_row)) + '\n')
        outfile.write(' '.join(map(str, lower_row)))

if __name__ == "__main__":
    main()
```
```
