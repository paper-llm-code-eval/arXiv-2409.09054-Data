---------- user ----------

Here is a programming challenge.
Please solve this problem efficiently, optimizing both time and memory usage.
Create the most efficient solution for this challenge in python. Utilize numpy and other highly efficient libraries whenever possible.
This problem has a memory limit of ~8MB so please be sensitive on using memory. Using too much memory may result in OOM.
The code must compile and be correct.
The solution must read from `biperm.in` and write to `biperm.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Pentru un număr natural nenul `n`, să considerăm toate numerele naturale nenule mai mici sau egale cu `n`, luând fiecare număr de câte două ori: `1, 1, 2, 2, 3, 3, ... , n, n`. Aceste numere le amestecăm aleator, şi le aranjăm pe două linii a câte `n` elemente. Structura astfel obţinută o vom numi o bipermutare. În figurile `1, 2` şi `3` avem câte un exemplu de bipermutare pentru `n=5`. 

O bipermutare este perfectă, dacă ambele linii ale structurii reprezintă câte o permutare (vezi figurile `2` şi `3`).

Prin mutare pe poziţia `p`, înţelegem interschimbarea elementelor de pe aceeaşi coloană `p`. În exemplele de mai jos, bipermutarea perfectă din figura `2` s-a obţinut din bipermutarea din figura `1`, aplicând o mutare pe poziţa `2`. Bipermutarea perfectă din figura `3` s-a obţinut din bipermutarea din figura `1`, aplicând mutări pe poziţiile `1, 2, 4` şi `5`.

~[biperm.png]

# Cerinţe
Cunoscând o bipermutare, determinaţi:
* numărul bipermutărilor perfecte distincte ce se pot obţine prin mutări;
* numărul minim de mutări prin care se poate obţine o bipermutare perfectă;
* o bipermutare perfectă obţinută din bipermutarea iniţială.

# Date de intrare
Fişierul de intrare `biperm.in` conţine pe prima linie valoarea lui `n`. Următoarele două linii conţin, fiecare, câte `n` elemente separate prin câte un spaţiu, formând o bipermutare.

# Date de ieşire
Fişierul de ieşire `biperm.out` va conţine:
* pe prima linie două numere naturale separate printr-un spaţiu, reprezentând  numărul bipermutărilor perfecte distincte ce se pot obţine din bipermutarea dată, respectiv numărul minim de mutări prin care se poate obţine o bipermutare perfectă; 
* pe următoarele două linii se vor tipări câte n numere separate prin spaţiu, reprezentând o bipermutare perfectă obţinută din bipermutarea dată. 

# Restricţii şi precizări
* `2 < n ≤ 10 000`;
* calculul corect al numărului bipermutărilor perfecte distincte valorează `30%` din punctaj;
* calculul corect al numărului minim de mutări valorează `10%` din punctaj;
* tipărirea unei bipermutări perfecte valorează `60%` din punctaj. Pot exista mai multe soluţii, se va admite orice soluţie corectă;
* se garantează că numărul bipermutărilor perfecte distincte nu depăşeşte `2 000 000 000` pentru niciun test.
* acordarea punctajului la un răspuns corect este condiţionată de existenţa răspunsurilor anterioare, indiferent de corectitudinea lor;
* pentru `40%` din teste `n ≤ 20` 
* pentru `40%` din teste `20 < n ≤ 400`
* pentru `20%` din teste `400 < n ≤ 10 000`

---

Example:
`biperm.in`
```
5
1 5 5 3 4
3 2 2 4 1
```

`biperm.out`
```
4 1
1 2 5 3 4
3 5 2 4 1
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```markdown
```python
import numpy as np

def bipermutation_to_perfect(n, top_row, bottom_row):
    # Track the pairs
    pairs = {}
    for i in range(n):
        if top_row[i] in pairs:
            pairs[top_row[i]].add(i)
        else:
            pairs[top_row[i]] = {i}

        if bottom_row[i] in pairs:
            pairs[bottom_row[i]].add(i)
        else:
            pairs[bottom_row[i]] = {i}

    # Find the number of distinct perfect bipermutations and the minimum number of moves
    num_distinct_perfect = 1
    min_moves = 0
    visited = set()
    for i in range(n):
        if i in visited:
            continue
        cycle_length = 0
        current = i
        while current not in visited:
            visited.add(current)
            cycle_length += 1
            next_positions = pairs[top_row[current]]
            current = next_positions.pop()
            next_positions.add(current)
        
        if cycle_length > 1:
            num_distinct_perfect *= 2
            min_moves += cycle_length - 1

    # Make the minimum number of moves to obtain a perfect bipermutation
    for i in range(n):
        pair_position = pairs[bottom_row[i]].pop()
        if pair_position != i:
            top_row[i], top_row[pair_position] = top_row[pair_position], top_row[i]

    return num_distinct_perfect, min_moves, top_row, bottom_row

# Read data from 'biperm.in'
with open('biperm.in', 'r') as infile:
    n = int(infile.readline().strip())
    top_row = np.fromstring(infile.readline().strip(), dtype=int, sep=' ')
    bottom_row = np.fromstring(infile.readline().strip(), dtype=int, sep=' ')

# Calculate perfect bipermutation
num_distinct_perfect, min_moves, perfect_top_row, perfect_bottom_row = bipermutation_to_perfect(n, top_row, bottom_row)

# Write data to 'biperm.out'
with open('biperm.out', 'w') as outfile:
    outfile.write(f"{num_distinct_perfect} {min_moves}\n")
    outfile.write(" ".join(map(str, perfect_top_row)) + "\n")
    outfile.write(" ".join(map(str, perfect_bottom_row)) + "\n")
```
```
---------- user ----------


Expected program to write result to `biperm.out` and read from `biperm.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

def read_bipermutation(file_path):
    with open(file_path, 'r') as infile:
        n = int(infile.readline().strip())
        top_row = list(map(int, infile.readline().strip().split()))
        bottom_row = list(map(int, infile.readline().strip().split()))
    return n, top_row, bottom_row

def resolve_conflicts(n, top_row, bottom_row):
    # Find positions that need to be swapped
    swap_positions = {}
    for i in range(n):
        if top_row[i] != bottom_row[i]:
            if top_row[i] not in swap_positions:
                swap_positions[top_row[i]] = i
            else:
                # Swap elements to fix the conflict
                swap_index = swap_positions[top_row[i]]
                top_row[i], top_row[swap_index] = top_row[swap_index], top_row[i]
                del swap_positions[top_row[i]]

    # Count the number of distinct perfect bipermutations
    num_distinct_perfect = 2 ** len(swap_positions)
    min_moves = len(swap_positions)
    return num_distinct_perfect, min_moves, top_row, bottom_row

def write_bipermutation(file_path, num_distinct_perfect, min_moves, top_row, bottom_row):
    with open(file_path, 'w') as outfile:
        outfile.write(f"{num_distinct_perfect} {min_moves}\n")
        outfile.write(" ".join(map(str, top_row)) + "\n")
        outfile.write(" ".join(map(str, bottom_row)) + "\n")

# Read the bipermutation from 'biperm.in'
n, top_row, bottom_row = read_bipermutation('biperm.in')

# Resolve conflicts to make it a perfect bipermutation
num_distinct_perfect, min_moves, perfect_top_row, perfect_bottom_row = resolve_conflicts(n, top_row, bottom_row)

# Write the perfect bipermutation to 'biperm.out'
write_bipermutation('biperm.out', num_distinct_perfect, min_moves, perfect_top_row, perfect_bottom_row)
```
```
---------- user ----------


Expected program to write result to `biperm.out` and read from `biperm.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Read input from file
with open('biperm.in', 'r') as file:
    n = int(file.readline().strip())
    top_row = np.array(file.readline().strip().split(), dtype=int)
    bottom_row = np.array(file.readline().strip().split(), dtype=int)

# Initialize variables to track number of distinct perfect bipermutations and minimum moves
distinct_perfect_bipermutations = 1
minimum_moves = 0
swapped = np.zeros(n, dtype=bool)

# Process the bipermutation
for i in range(n):
    if swapped[i]:
        continue  # Skip if already swapped
    if top_row[i] != bottom_row[i]:
        # Find the swap partner
        swap_partner = np.where(top_row == bottom_row[i])[0][0]
        # Swap the elements
        top_row[i], top_row[swap_partner] = top_row[swap_partner], top_row[i]
        swapped[i] = swapped[swap_partner] = True
        minimum_moves += 1
        # If the swap partner is not in the correct place, we have two options
        if top_row[swap_partner] != bottom_row[swap_partner]:
            distinct_perfect_bipermutations *= 2

# Write output to file
with open('biperm.out', 'w') as file:
    file.write(f"{distinct_perfect_bipermutations} {minimum_moves}\n")
    file.write(' '.join(map(str, top_row)) + '\n')
    file.write(' '.join(map(str, bottom_row)) + '\n')
```
```
---------- user ----------


Expected program to write result to `biperm.out` and read from `biperm.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

def read_bipermutation(file_path):
    with open(file_path, 'r') as infile:
        n = int(next(infile).strip())
        top_row = np.array(next(infile).strip().split(), dtype=np.int32)
        bottom_row = np.array(next(infile).strip().split(), dtype=np.int32)
    return n, top_row, bottom_row

def write_bipermutation(file_path, num_distinct, min_moves, top_row, bottom_row):
    with open(file_path, 'w') as outfile:
        outfile.write(f"{num_distinct} {min_moves}\n")
        outfile.write(' '.join(map(str, top_row)) + '\n')
        outfile.write(' '.join(map(str, bottom_row)) + '\n')

def find_cycles(top_row, bottom_row, n):
    cycles = []
    visited = np.zeros(n, dtype=bool)
    for i in range(n):
        if not visited[i]:
            cycle = [i]
            visited[i] = True
            next_index = np.where(top_row == bottom_row[i])[0][0]
            while not visited[next_index]:
                cycle.append(next_index)
                visited[next_index] = True
                next_index = np.where(top_row == bottom_row[next_index])[0][0]
            cycles.append(cycle)
    return cycles

def calculate_bipermutations(cycles):
    num_distinct = 1
    min_moves = 0
    for cycle in cycles:
        cycle_len = len(cycle)
        if cycle_len > 1:
            num_distinct *= 2
            min_moves += cycle_len - 1
    return num_distinct, min_moves

# Read the bipermutation from 'biperm.in'
n, top_row, bottom_row = read_bipermutation('biperm.in')

# Find cycles to identify swaps needed to get a perfect bipermutation
cycles = find_cycles(top_row, bottom_row, n)

# Calculate the number of distinct perfect bipermutations and the minimum moves
num_distinct, min_moves = calculate_bipermutations(cycles)

# Perform swaps to get one of the perfect bipermutations
for cycle in cycles:
    if len(cycle) > 1:
        top_element = top_row[cycle[-1]]
        for i in cycle:
            top_row[i], top_element = top_element, top_row[i]

# Write the perfect bipermutation to 'biperm.out'
write_bipermutation('biperm.out', num_distinct, min_moves, top_row, bottom_row)
```
```
---------- user ----------


Expected program to write result to `biperm.out` and read from `biperm.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
# Import numpy for efficient array operations
import numpy as np

def solve_bipermutation(n, top_row, bottom_row):
    # Initialize variables for counting and tracking
    num_distinct_perfect = 1
    min_moves = 0
    swaps_needed = {}

    # Count occurrences and determine swaps needed for each number
    for i in range(n):
        # If we find a number that is not in its place, record it
        if top_row[i] != bottom_row[i]:
            if top_row[i] not in swaps_needed:
                swaps_needed[top_row[i]] = [i]
            else:
                swaps_needed[top_row[i]].append(i)
            if bottom_row[i] not in swaps_needed:
                swaps_needed[bottom_row[i]] = [i]
            else:
                swaps_needed[bottom_row[i]].append(i)

    # Perform swaps and count min moves and distinct permutations
    for indices in swaps_needed.values():
        # Each pair of indices represents a swap
        min_moves += len(indices) // 2
        # If there are two pairs to swap, we have two choices, doubling the possibilities
        if len(indices) > 2:
            num_distinct_perfect *= 2 ** ((len(indices) // 2) - 1)

    # Perform swaps to make the bipermutation perfect
    for number, indices in swaps_needed.items():
        while len(indices) > 1:
            idx1, idx2 = indices[-2], indices[-1]  # Get last two indices
            # Swap the top_row elements at these indices
            top_row[idx1], top_row[idx2] = top_row[idx2], top_row[idx1]
            # Remove the last two indices as we've just resolved them
            indices.pop()
            indices.pop()

    return num_distinct_perfect, min_moves, top_row, bottom_row

# Read data from 'biperm.in'
with open('biperm.in', 'r') as infile:
    n = int(infile.readline())
    top_row = np.array(infile.readline().split(), dtype=int)
    bottom_row = np.array(infile.readline().split(), dtype=int)

# Solve for the bipermutation
num_distinct_perfect, min_moves, perfect_top_row, perfect_bottom_row = solve_bipermutation(n, top_row, bottom_row)

# Write the result to 'biperm.out'
with open('biperm.out', 'w') as outfile:
    outfile.write(f"{num_distinct_perfect} {min_moves}\n")
    outfile.write(' '.join(map(str, perfect_top_row)) + '\n')
    outfile.write(' '.join(map(str, perfect_bottom_row)) + '\n')
```
```
---------- user ----------


Expected program to write result to `biperm.out` and read from `biperm.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Read the data from 'biperm.in'
with open('biperm.in', 'r') as file:
    n = int(file.readline())
    row1 = np.fromstring(file.readline().strip(), dtype=int, sep=' ')
    row2 = np.fromstring(file.readline().strip(), dtype=int, sep=' ')

# Initialize variables
moves = 0
pairs = 1

# Use a dictionary to match the positions of the numbers in row2 to row1
match = {}
for i in range(n):
    if row1[i] in match:
        match[row1[i]].append(i)
    else:
        match[row1[i]] = [i]

# Swap the elements in row1 to make it a permutation
for i in range(n):
    if row1[i] != row2[i]:
        index_to_swap = match[row2[i]][0]
        match[row1[i]].append(index_to_swap)
        match[row1[i]].remove(i)
        match[row2[i]].remove(index_to_swap)
        row1[i], row1[index_to_swap] = row1[index_to_swap], row1[i]
        moves += 1
        if row1[i] == row2[i]:
            pairs *= 2

# Write the result to 'biperm.out'
with open('biperm.out', 'w') as file:
    file.write(f"{pairs} {moves}\n")
    file.write(' '.join(map(str, row1)) + '\n')
    file.write(' '.join(map(str, row2)) + '\n')
```
```
---------- user ----------


Expected program to write result to `biperm.out` and read from `biperm.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
# Read the data from 'biperm.in'
with open('biperm.in', 'r') as file:
    n = int(file.readline())
    row1 = list(map(int, file.readline().split()))
    row2 = list(map(int, file.readline().split()))

# Initialize variables
moves = 0
pairs = 1
swap_needed = set()

# Find the positions where swaps are needed
for i in range(n):
    if row1[i] != row2[i]:
        swap_needed.add(row1[i])
        swap_needed.add(row2[i])

# Calculate the number of distinct perfect bipermutations and minimum moves
for num in swap_needed:
    # Find the positions of the current number in both rows
    positions = [pos for pos, val in enumerate(row1) if val == num]
    if len(positions) == 1:
        positions.extend([pos for pos, val in enumerate(row2) if val == num])

    # We need to swap positions to make the numbers the same in both rows
    if len(positions) == 2:
        row1[positions[0]], row1[positions[1]] = row1[positions[1]], row1[positions[0]]
        moves += 1
    # More than two positions indicate multiple swap options, doubling the count of perfect permutations
    elif len(positions) > 2:
        pairs *= 2 ** (len(positions) // 2 - 1)
        moves += len(positions) // 2
        # Make the necessary swaps
        for i in range(0, len(positions), 2):
            row1[positions[i]], row1[positions[i+1]] = row1[positions[i+1]], row1[positions[i]]

# Write the result to 'biperm.out'
with open('biperm.out', 'w') as file:
    file.write(f"{pairs} {moves}\n")
    file.write(' '.join(map(str, row1)) + '\n')
    file.write(' '.join(map(str, row2)) + '\n')
```
```
