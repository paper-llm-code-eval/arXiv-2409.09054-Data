---------- user ----------

Here is a programming challenge.
Please solve this problem efficiently, optimizing both time and memory usage.
Create the most efficient solution for this challenge in python. Utilize numpy and other highly efficient libraries whenever possible.
This problem has a memory limit of ~8MB so please be sensitive on using memory. Using too much memory may result in OOM.
The code must compile and be correct.
The solution must read from `poarta.in` and write to `poarta.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Se consideră harta universului ca fiind o matrice cu $250$ de linii şi $250$ de coloane. În fiecare celulă se găseşte o aşa numită poartă stelară, iar în anumite celule se găsesc echipaje ale porţii stelare. La o deplasare, un echipaj se poate deplasa din locul în care se află în oricare alt loc în care se găseşte o a doua poartă, în cazul nostru în orice altă poziţie din matrice. Nu se permite situarea simultană a mai mult de un echipaj într-o celulă. La un moment dat un singur echipaj se poate deplasa de la o poartă stelară la alta.

# Cerință

Dându-se un număr $p$ de echipaje, pentru fiecare echipaj fiind precizate poziţia iniţială şi poziţia finală, determinaţi numărul minim de deplasări necesare pentru ca toate echipajele să ajungă din poziţia iniţială în cea finală.

# Date de intrare
Fișierul de intrare `poarta.in` are următorul format:
- pe prima linie se află numărul natural $p$ reprezentând numărul echipaje.
- pe următoarele $p$ linii se află câte 4 numere naturale, primele două reprezentând coordonatele poziţiei iniţiale a unui echipaj (linie respectiv coloană), următoarele două reprezentând coordonatele poziţiei finale a aceluiaşi echipaj (linie respectiv coloană).

# Date de ieşire
Pe prima linie a fişierului de ieșire `poarta.out` se scrie un singur număr reprezentând numărul minim de deplasări necesar.

# Restricții și precizări
- $1 < p < 5\ 000$
- Coordonatele poziţiilor iniţiale şi finale ale echipajelor sunt numere naturale din intervalul $[1, 250]$.
- **Atenție la cazurile când poziția inițială este identică cu cea finală!**
- Poziţiile iniţiale ale celor $p$ echipaje sunt distincte două câte două.
- Poziţiile finale ale celor $p$ echipaje sunt distincte două câte două.

---

Example:
`poarta.in`
```
3
1 2 3 4
6 5 3 9
3 4 1 2
```

`poarta.out`
```
4
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```python
import numpy as np

# Read data from file
with open('poarta.in') as f:
    p = int(f.readline().strip())
    teams_initial_final = [list(map(int, f.readline().split())) for _ in range(p)]

# Create a set of final positions for easier access
final_positions = set((x[2], x[3]) for x in teams_initial_final)

# Initialize the number of moves to zero
moves = 0

# Check for teams already in their final position and remove them from the list
teams_initial_final = [team for team in teams_initial_final if (team[0], team[1]) != (team[2], team[3])]

# As long as there are teams not in their final position, iterate
while teams_initial_final:

    # Create a set of initial positions of the remaining teams
    initial_positions = set((x[0], x[1]) for x in teams_initial_final)

    # Find a team that can directly move to its final position
    for team in teams_initial_final:
        if (team[2], team[3]) not in initial_positions:
            # Move the team to its final position
            final_positions.remove((team[2], team[3]))
            moves += 1
            teams_initial_final.remove(team)
            break
    else:  # If no team can directly move to its final position, move any team to a random final position
        team = teams_initial_final.pop()
        if (team[2], team[3]) in final_positions:
            final_positions.remove((team[2], team[3]))
        moves += 2  # One move to a random position and another to its final position

# Write the result to the output file
with open('poarta.out', 'w') as f:
    f.write(str(moves))
```

This is a very efficient solution in terms of both time and memory. It avoids unnecessary use of memory by only storing the current teams that need to move, and it minimizes the number of moves by first moving any teams that can directly reach their final positions before moving others to temporary positions. The program reads from the input file and writes directly to the output file, without any standard input/output operations, adhering to the constraints provided in the problem statement.
---------- user ----------


Program exited with code 1.
stdout:
```

```
stderr:
```
Traceback (most recent call last):
  File "/app/app.py", line 1, in <module>
    import numpy as np
ModuleNotFoundError: No module named 'numpy'

```

Think of what has caused the exit code. Use the standard out and standard error to help you understand the issue.
Implement a solution to fix the program

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

It seems that the environment in which the code is executed does not have the `numpy` library installed or available. Given that the use of `numpy` is not crucial to the solution (as it doesn't use any specific `numpy` features), I'll rewrite the solution without using `numpy`. The revised solution will still optimize for both time and memory usage within the constraints given.

Here is the modified solution:

```python
# Read data from file
with open('poarta.in') as f:
    p = int(f.readline().strip())
    teams_initial_final = [list(map(int, f.readline().split())) for _ in range(p)]

# Create a set of final positions for easier access
final_positions = set((x[2], x[3]) for x in teams_initial_final)

# Initialize the number of moves to zero
moves = 0

# Check for teams already in their final position and remove them from the list
teams_initial_final = [team for team in teams_initial_final if (team[0], team[1]) != (team[2], team[3])]

# As long as there are teams not in their final position, iterate
while teams_initial_final:

    # Create a set of initial positions of the remaining teams
    initial_positions = set((x[0], x[1]) for x in teams_initial_final)

    # Find a team that can directly move to its final position
    for team in teams_initial_final:
        if (team[2], team[3]) not in initial_positions:
            # Move the team to its final position
            final_positions.remove((team[2], team[3]))
            moves += 1
            teams_initial_final.remove(team)
            break
    else:  # If no team can directly move to its final position, move any team to a random final position
        team = teams_initial_final.pop()
        if (team[2], team[3]) in final_positions:
            final_positions.remove((team[2], team[3]))
        moves += 2  # One move to a random position and another to its final position

# Write the result to the output file
with open('poarta.out', 'w') as f:
    f.write(str(moves))
```

This updated code does not use `numpy` and should work perfectly in an environment where `numpy` is not available. It still efficiently solves the problem by minimizing the number of moves required and the memory used.
