---------- user ----------

Here is a programming challenge.
Please solve this problem efficiently, optimizing both time and memory usage.
Create the most efficient solution for this challenge in python. Utilize numpy and other highly efficient libraries whenever possible.
This problem has a memory limit of ~8MB so please be sensitive on using memory.Using unavoided memory may result in OOM.
The code must compile and be correct.
The solution must read from `tabel.in` and write to `tabel.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

După cum probabil știți, contabilii își țin datele sub formă de tabele și calculează tot felul de sume pe linii și pe coloane. Contabilul nostru Atnoc și-a organizat valorile sub forma unui tabel cu $n$ linii (numerotate de la $1$ la $n$) și $m$ coloane (numerotate de la $1$ la $m$). Elementele de pe ultima coloană sunt sumele elementelor de pe linii (mai exact, elementul de pe linia $i$ și coloana $m$ este egal cu suma elementelor de pe linia $i$ aflate pe coloanele $1, 2, \dots, m-1$), iar elementele de pe ultima linie sunt sumele elementelor de pe coloane (mai exact, elementul de pe linia $n$ și coloana $i$ este egal cu suma elementelor de pe coloana $i$ aflate pe liniile $1, 2, \dots, n-1$). Un exemplu de astfel de tabel este dat în figura următoare.

Din păcate, Atnoc a stropit cu apă minunatul său tabel și astfel o parte dintre numerele din tabel au devenit ilizibile.

~[tabel.png|width=30em]

# Cerință

Scrieți un program care să reconstituie toate datele din tabel.

# Date de intrare

Pe prima linie a fișierului text de intrare `tabel.in` se află două numere naturale $n$ și $m$, separate printr-un spațiu, ce reprezintă numărul de linii și respectiv numărul de coloane ale tabelului. Pe cea de a doua linie a fișierului de intrare se află un număr natural $p$ care reprezintă numărul de valori nedeteriorate din tabel. Pe fiecare dintre următoarele $p$ linii se află câte trei numere naturale, separate prin câte un spațiu $l \ c \ v$, unde $l$ este numărul liniei, $c$ este numărul coloanei și $v$ este valoarea elementului de pe linia $l$ și coloana $c$ din tabel.

# Date de ieșire

În fișierul text de ieșire `tabel.out` se va scrie tabelul reconstituit, pe $n$ linii câte $m$ valori separate prin câte un spațiu.

# Restricții și precizări

* $1 < n, m \leq 50$
* Valorile din tabel sunt numere naturale $< 32 \ 000$.
* În toate testele datele din tabel pot fi reconstituite.

---

Example:
`tabel.in`
```
3 4
10
1 1 2
1 2 5
1 3 7
1 4 14
2 2 6
2 4 23
3 1 13
3 2 11
3 3 13
3 4 37
```

`tabel.out`
```
2 5 7 14
11 6 6 23
13 11 13 37
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```python
import numpy as np

# Efficient function to read input from file and return values
def read_input(filename):
    with open(filename, "r") as file:
        n, m = map(int, file.readline().split())
        p = int(file.readline().strip())
        data = np.zeros((n, m), dtype=int)
        for _ in range(p):
            l, c, v = map(int, file.readline().split())
            data[l-1, c-1] = v  # Adjust for 0-based indexing
        return n, m, data

# Function to reconstruct the table
def reconstruct_table(n, m, table):
    # Use numpy to sum the values of row and columns
    for i in range(n-1):
        table[i, -1] = np.sum(table[i, :-1]) if table[i, -1] == 0 else table[i, -1]
    for j in range(m-1):
        table[-1, j] = np.sum(table[:-1, j]) if table[-1, j] == 0 else table[-1, j]

    # Calculate missing values based on the sums
    for i in range(n-1):
        for j in range(m-1):
            if table[i, j] == 0:
                row_sum = table[i, -1]
                col_sum = table[-1, j]
                table[i, j] = row_sum - np.sum(table[i, :j])
                table[i, j] = col_sum - np.sum(table[:i, j])

    return table

# Efficient function to write output to file
def write_output(filename, table):
    with open(filename, "w") as file:
        for row in table:
            file.write(' '.join(map(str, row)) + "\n")

# Main function to run the process
def main():
    n, m, table = read_input("tabel.in")
    completed_table = reconstruct_table(n, m, table)
    write_output("tabel.out", completed_table)

# Execute the main function
if __name__ == "__main__":
    main()
```
Please note that this script is designed to be memory-conscious, and uses numpy to optimize for time efficiency where possible, given the constraints listed.
---------- user ----------


Program exited with code 1.
stdout:
```

```
stderr:
```
Traceback (most recent call last):
  File "/app/app.py", line 1, in <module>
    import numpy as np
ModuleNotFoundError: No module named 'numpy'

```

Think of what has caused the exit code. Use the standard out and standard error to help you understand the issue.
Implement a solution to fix the program

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

It appears that the `numpy` module is not installed in the environment where the code was executed, which resulted in a `ModuleNotFoundError` exception.

Given that we have memory constraints and we're not allowed to use additional modules like `numpy`, we need to rewrite the solution using only built-in Python facilities. Here is the updated solution without using `numpy`:

```python
# Function to read input from file and return values
def read_input(filename):
    with open(filename, "r") as file:
        n, m = map(int, file.readline().split())
        p = int(file.readline().strip())
        data = [[0] * m for _ in range(n)]
        for _ in range(p):
            l, c, v = map(int, file.readline().split())
            data[l-1][c-1] = v  # Adjust for 0-based indexing
        return n, m, data

# Function to reconstruct the table
def reconstruct_table(n, m, table):
    # Fill in the sums for last row and column
    for i in range(n):
        for j in range(m):
            if i < n - 1 and j < m - 1:
                continue
            elif i == n - 1 and j < m - 1:  # Last row
                table[i][j] = sum(table[k][j] for k in range(n - 1))
            elif j == m - 1 and i < n - 1:  # Last column
                table[i][j] = sum(table[i][:m - 1])

    # Calculate missing values
    for i in range(n - 1):
        for j in range(m - 1):
            if table[i][j] == 0:
                table[i][j] = table[i][m-1] - sum(table[i][:j]) - sum(table[i][j+1:m-1])

    return table

# Function to write output to file
def write_output(filename, table):
    with open(filename, "w") as file:
        for row in table:
            file.write(' '.join(map(str, row)) + "\n")

# Main function to run the process
def main():
    n, m, table = read_input("tabel.in")
    completed_table = reconstruct_table(n, m, table)
    write_output("tabel.out", completed_table)

# Execute the main function
if __name__ == "__main__":
    main()
```

This solution uses list comprehensions and built-in functions to perform the necessary calculations, and should adhere to the memory constraints as it avoids loading unnecessary libraries and manipulating the data in a memory-efficient way.
---------- user ----------


Program result did not match expected result.
Input data:
```
3 4
10
1 1 2
1 2 5
1 3 7
1 4 14
2 2 6
2 4 23
3 1 13
3 2 11
3 3 13
3 4 37
```
Expected output:
```
2 5 7 14
11 6 6 23
13 11 13 37
```
Found output:
```
2 5 7 14
0 6 0 6
2 11 7 37
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The reason for the discrepancy between the expected and found results is that the calculation of the missing values in the inner cells is incorrect. Instead of calculating the remaining values by subtracting the known values from the sums, the code is subtracting values directly and not considering the interdependencies correctly.

To fix the bug, we need to ensure that we calculate the missing values in the inner cells properly. We know that the sum of each row (excluding the last cell) must equal the last cell of that row, and the sum of each column (excluding the last cell) must equal the last cell of that column. Hence, we can calculate the missing value in a cell by subtracting the sum of the known values in that row or column from the total sum of that row or column.

Here is the corrected solution:

```python
# Efficient function to read input from file and return values
def read_input(filename):
    with open(filename, "r") as file:
        n, m = map(int, file.readline().split())
        p = int(file.readline().strip())
        data = [[0] * m for _ in range(n)]
        for _ in range(p):
            l, c, v = map(int, file.readline().split())
            data[l-1][c-1] = v  # Adjust for 0-based indexing
        return n, m, data

# Function to reconstruct the table
def reconstruct_table(n, m, table):
    # Calculate the sums for the last column and last row
    for i in range(n - 1):
        table[i][m - 1] = sum(table[i][:-1])
    for j in range(m - 1):
        table[n - 1][j] = sum(table[i][j] for i in range(n - 1))
    
    # Calculate missing values for inner cells
    for i in range(n - 1):
        for j in range(m - 1):
            if table[i][j] == 0:
                table[i][j] = table[i][m - 1] - sum(table[i][:j]) - sum(table[i][j + 1:m - 1])
                table[n - 1][j] -= table[i][j]  # Adjust the sum for this column

    return table

# Efficient function to write output to file
def write_output(filename, table):
    with open(filename, "w") as file:
        for row in table:
            file.write(' '.join(map(str, row)) + "\n")

# Main function to run the process
def main():
    n, m, table = read_input("tabel.in")
    completed_table = reconstruct_table(n, m, table)
    write_output("tabel.out", completed_table)

# Execute the main function
if __name__ == "__main__":
    main()
```

This solution performs the sum calculation first for the last column and last row, then fills in the missing values for inner cells, ensuring that the row and column sums remain accurate. It should now produce the expected output.
---------- user ----------


Program result did not match expected result.
Input data:
```
3 4
10
1 1 2
1 2 5
1 3 7
1 4 14
2 2 6
2 4 23
3 1 13
3 2 11
3 3 13
3 4 37
```
Expected output:
```
2 5 7 14
11 6 6 23
13 11 13 37
```
Found output:
```
2 5 7 14
0 6 0 6
2 11 7 37
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
