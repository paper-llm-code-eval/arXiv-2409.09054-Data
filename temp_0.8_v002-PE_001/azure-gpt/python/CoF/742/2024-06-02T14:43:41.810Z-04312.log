---------- user ----------

Here is a programming challenge.
Please solve this problem efficiently, optimizing both time and memory usage.
Create the most efficient solution for this challenge in python. Utilize numpy and other highly efficient libraries whenever possible.
This problem has a memory limit of ~8MB so please be sensitive on using memory.Using unavoided memory may result in OOM.
The code must compile and be correct.
The solution must read from `tabel.in` and write to `tabel.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

După cum probabil știți, contabilii își țin datele sub formă de tabele și calculează tot felul de sume pe linii și pe coloane. Contabilul nostru Atnoc și-a organizat valorile sub forma unui tabel cu $n$ linii (numerotate de la $1$ la $n$) și $m$ coloane (numerotate de la $1$ la $m$). Elementele de pe ultima coloană sunt sumele elementelor de pe linii (mai exact, elementul de pe linia $i$ și coloana $m$ este egal cu suma elementelor de pe linia $i$ aflate pe coloanele $1, 2, \dots, m-1$), iar elementele de pe ultima linie sunt sumele elementelor de pe coloane (mai exact, elementul de pe linia $n$ și coloana $i$ este egal cu suma elementelor de pe coloana $i$ aflate pe liniile $1, 2, \dots, n-1$). Un exemplu de astfel de tabel este dat în figura următoare.

Din păcate, Atnoc a stropit cu apă minunatul său tabel și astfel o parte dintre numerele din tabel au devenit ilizibile.

~[tabel.png|width=30em]

# Cerință

Scrieți un program care să reconstituie toate datele din tabel.

# Date de intrare

Pe prima linie a fișierului text de intrare `tabel.in` se află două numere naturale $n$ și $m$, separate printr-un spațiu, ce reprezintă numărul de linii și respectiv numărul de coloane ale tabelului. Pe cea de a doua linie a fișierului de intrare se află un număr natural $p$ care reprezintă numărul de valori nedeteriorate din tabel. Pe fiecare dintre următoarele $p$ linii se află câte trei numere naturale, separate prin câte un spațiu $l \ c \ v$, unde $l$ este numărul liniei, $c$ este numărul coloanei și $v$ este valoarea elementului de pe linia $l$ și coloana $c$ din tabel.

# Date de ieșire

În fișierul text de ieșire `tabel.out` se va scrie tabelul reconstituit, pe $n$ linii câte $m$ valori separate prin câte un spațiu.

# Restricții și precizări

* $1 < n, m \leq 50$
* Valorile din tabel sunt numere naturale $< 32 \ 000$.
* În toate testele datele din tabel pot fi reconstituite.

---

Example:
`tabel.in`
```
3 4
10
1 1 2
1 2 5
1 3 7
1 4 14
2 2 6
2 4 23
3 1 13
3 2 11
3 3 13
3 4 37
```

`tabel.out`
```
2 5 7 14
11 6 6 23
13 11 13 37
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```markdown
```python
import numpy as np

# Read data from file
with open('tabel.in', 'r') as file:
    n, m = map(int, file.readline().split())
    p = int(file.readline())
    known_values = [list(map(int, file.readline().split())) for _ in range(p)]

# Initialize numpy array with zeros
table = np.zeros((n, m), dtype=int)

# Fill in the known values
for l, c, v in known_values:
    table[l-1, c-1] = v

# Reconstruct the table
for i in range(n-1):
    table[i, m-1] = np.sum(table[i, :m-1])

for j in range(m-1):
    table[n-1, j] = np.sum(table[:n-1, j])

# The bottom right cell is the sum of the last row or last column
table[n-1, m-1] = np.sum(table[n-1, :m-1])

# Write the reconstructed table to the output file
with open('tabel.out', 'w') as file:
    for row in table:
        file.write(' '.join(map(str, row)) + '\n')
```
```
---------- user ----------


Expected program to write result to `tabel.out` and read from `tabel.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

````markdown
```python
import numpy as np

def read_input(filename):
    with open(filename, 'r') as file:
        n, m = map(int, file.readline().split())
        p = int(file.readline())
        values = [tuple(map(int, file.readline().split())) for _ in range(p)]
    return n, m, values

def write_output(filename, table):
    with open(filename, 'w') as file:
        for row in table:
            file.write(' '.join(map(str, row)) + '\n')

def reconstruct_table(n, m, values):
    # Initialize a numpy array with zeros
    table = np.zeros((n, m), dtype=np.int32)

    # Fill in the known values
    for l, c, v in values:
        table[l-1, c-1] = v

    # Calculate sums for rows and columns
    for i in range(n-1):
        # If the value is unknown (zero), calculate it
        if table[i, m-1] == 0:
            table[i, m-1] = np.sum(table[i, :m-1])

    for j in range(m-1):
        # If the value is unknown (zero), calculate it
        if table[n-1, j] == 0:
            table[n-1, j] = np.sum(table[:n-1, j])

    # Calculate the missing values for the inner cells
    for i in range(n-1):
        for j in range(m-1):
            if table[i, j] == 0:
                table[i, j] = table[i, m-1] - np.sum(table[i, :j] + table[i, j+1:m-1])

    return table

# Main execution
n, m, values = read_input('tabel.in')
table = reconstruct_table(n, m, values)
write_output('tabel.out', table)
```
```
---------- user ----------


Expected program to write result to `tabel.out` and read from `tabel.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Read data from file 'tabel.in'
with open('tabel.in', 'r') as file:
    n, m = map(int, file.readline().split())
    p = int(file.readline())
    data = [list(map(int, file.readline().split())) for _ in range(p)]

# Create and initialize the table with zeros
table = np.zeros((n, m), dtype=int)

# Fill in the known values and track the sum for rows and columns
row_sums = np.zeros(n, dtype=int)
col_sums = np.zeros(m, dtype=int)
for l, c, v in data:
    table[l-1, c-1] = v
    row_sums[l-1] += v
    col_sums[c-1] += v

# Calculate missing values in the last row and column
for i in range(n - 1):
    table[i, -1] = row_sums[i]
for j in range(m - 1):
    table[-1, j] = col_sums[j]

# The last cell is the sum of the last row's or last column's known values
table[-1, -1] = max(row_sums[-1], col_sums[-1])

# Calculate the missing values inside the table
for i in range(n - 1):
    for j in range(m - 1):
        if table[i, j] == 0:
            table[i, j] = table[i, -1] - np.sum(table[i, 0:m-1])

# Write the reconstructed table to the output file 'tabel.out'
with open('tabel.out', 'w') as file:
    for i in range(n):
        file.write(' '.join(map(str, table[i])) + '\n')
```
```
---------- user ----------


Expected program to write result to `tabel.out` and read from `tabel.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Read data from file 'tabel.in'
with open('tabel.in', 'r') as file:
    n, m = map(int, file.readline().split())
    p = int(file.readline())
    values = [list(map(int, file.readline().split())) for _ in range(p)]

# Initialize and fill in the table with known values
table = np.zeros((n, m), dtype=int)
for l, c, v in values:
    table[l - 1][c - 1] = v

# Reconstruct the missing values for each row and column
for i in range(n - 1):
    table[i, -1] = sum(table[i, :m - 1])  # calculate row sum

for j in range(m - 1):
    table[-1, j] = sum(table[:n - 1, j])  # calculate column sum

# Determine the last missing cell (bottom right corner)
table[-1, -1] = sum(table[-1, :m - 1])

# Now solve for inner missing values assuming only one missing value per row/column
for i in range(n - 1):
    if 0 in table[i, :m - 1]:  # if there's a missing value in the row
        missing_idx = np.where(table[i, :m - 1] == 0)[0][0]
        table[i, missing_idx] = table[i, -1] - sum(table[i, :m - 1])

for j in range(m - 1):
    if 0 in table[:n - 1, j]:  # if there's a missing value in the column
        missing_idx = np.where(table[:n - 1, j] == 0)[0][0]
        table[missing_idx, j] = table[-1, j] - sum(table[:n - 1, j])

# Write the reconstructed table to the output file 'tabel.out'
with open('tabel.out', 'w') as file:
    for row in table:
        file.write(' '.join(map(str, row)) + '\n')
```
```
---------- user ----------


Expected program to write result to `tabel.out` and read from `tabel.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Read data from 'tabel.in'
with open('tabel.in', 'r') as file:
    n, m = map(int, file.readline().split())
    p = int(file.readline())
    entries = [tuple(map(int, file.readline().split())) for _ in range(p)]

# Initialize an empty matrix with the first (n-1)x(m-1) elements set to None
table = np.full((n, m), None, dtype=np.int32)

# Set the last row and column sums to zero
table[n - 1, :] = 0
table[:, m - 1] = 0

# Fill in the known values and update the sums
for l, c, v in entries:
    table[l - 1, c - 1] = v
    table[l - 1, m - 1] += v
    table[n - 1, c - 1] += v

# Compute the unknown values in the inner (n-1)x(m-1) matrix
for row in range(n - 1):
    for col in range(m - 1):
        if table[row, col] is None:
            table[row, col] = table[row, m - 1] - np.sum(
                [table[row, k] for k in range(m - 1) if table[row, k] is not None]
            )

# Compute the unknown values in the last row and column
for col in range(m - 1):
    if table[n - 1, col] == 0:
        table[n - 1, col] = np.sum(table[:-1, col])

for row in range(n - 1):
    if table[row, m - 1] == 0:
        table[row, m - 1] = np.sum(table[row, :-1])

# The bottom-right corner is the sum of the last row or last column
table[n - 1, m - 1] = np.sum(table[n - 1, :-1])  # or np.sum(table[:-1, m - 1])

# Write the table to 'tabel.out'
with open('tabel.out', 'w') as file:
    for row in table:
        file.write(' '.join(map(str, row)) + '\n')
```
```
---------- user ----------


Expected program to write result to `tabel.out` and read from `tabel.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

def solve_table(n, m, values):
    # Initialize the table with negative values to represent unknowns
    table = np.full((n, m), -1, dtype=int)
  
    # Place the known values into the table
    for l, c, v in values:
        table[l - 1, c - 1] = v

    # The last row and column are computed from the known values
    for i in range(n - 1):
        table[i, m - 1] = sum(table[i, j] if table[i, j] >= 0 else 0 for j in range(m - 1))

    for j in range(m - 1):
        table[n - 1, j] = sum(table[i, j] if table[i, j] >= 0 else 0 for i in range(n - 1))

    # Solve for the unknown values in the inner cells
    for i in range(n - 1):
        unknown_index = -1
        known_sum = 0
        for j in range(m - 1):
            if table[i, j] == -1:
                unknown_index = j
            else:
                known_sum += table[i, j]
        if unknown_index != -1:
            table[i, unknown_index] = table[i, m - 1] - known_sum

    for j in range(m - 1):
        unknown_index = -1
        known_sum = 0
        for i in range(n - 1):
            if table[i, j] == -1:
                unknown_index = i
            else:
                known_sum += table[i, j]
        if unknown_index != -1:
            table[unknown_index, j] = table[n - 1, j] - known_sum

    # Solve for the bottom right value if it's unknown
    if table[n - 1, m - 1] == -1:
        table[n - 1, m - 1] = sum(table[n - 1, j] if table[n - 1, j] >= 0 else 0 for j in range(m - 1))

    return table

# Read from input file
with open('tabel.in', 'r') as file:
    n, m = map(int, file.readline().split())
    p = int(file.readline())
    values = [tuple(map(int, file.readline().split())) for _ in range(p)]

# Solve the problem
table = solve_table(n, m, values)

# Write to output file
with open('tabel.out', 'w') as file:
    for row in table:
        file.write(' '.join(map(str, row)) + '\n')
```
```
---------- user ----------


Expected program to write result to `tabel.out` and read from `tabel.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Read data from 'tabel.in'
with open('tabel.in', 'r') as fin:
    n, m = map(int, fin.readline().split())
    p = int(fin.readline())
    values = [tuple(map(int, fin.readline().split())) for _ in range(p)]

# Initialize the table with zeros
table = np.zeros((n, m), dtype=int)

# Fill the known values
for l, c, v in values:
    table[l-1, c-1] = v

# Compute the sums for the last row and last column
for i in range(n-1):
    table[i, m-1] = np.sum(table[i, :m-1])
for j in range(m-1):
    table[n-1, j] = np.sum(table[:n-1, j])

# Compute the value for the bottom-right cell
table[n-1, m-1] = np.sum(table[n-1, :m-1])

# Deduce any missing values in the inner part of the table
for i in range(n-1):
    for j in range(m-1):
        if table[i, j] == 0:
            table[i, j] = table[i, m-1] - np.sum(table[i, :m-1])

# Write the reconstructed table to 'tabel.out'
with open('tabel.out', 'w') as fout:
    for row in table:
        fout.write(' '.join(map(str, row)) + '\n')
```
```
