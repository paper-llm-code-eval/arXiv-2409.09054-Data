---------- user ----------

Here is a programming challenge.
Please solve this problem efficiently, optimizing both time and memory usage.
Create the most efficient solution for this challenge in python. Utilize numpy and other highly efficient libraries whenever possible.
This problem has a memory limit of ~8MB so please be sensitive on using memory.Using unavoided memory may result in OOM.
The code must compile and be correct.
The solution must read from `tabel.in` and write to `tabel.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

După cum probabil știți, contabilii își țin datele sub formă de tabele și calculează tot felul de sume pe linii și pe coloane. Contabilul nostru Atnoc și-a organizat valorile sub forma unui tabel cu $n$ linii (numerotate de la $1$ la $n$) și $m$ coloane (numerotate de la $1$ la $m$). Elementele de pe ultima coloană sunt sumele elementelor de pe linii (mai exact, elementul de pe linia $i$ și coloana $m$ este egal cu suma elementelor de pe linia $i$ aflate pe coloanele $1, 2, \dots, m-1$), iar elementele de pe ultima linie sunt sumele elementelor de pe coloane (mai exact, elementul de pe linia $n$ și coloana $i$ este egal cu suma elementelor de pe coloana $i$ aflate pe liniile $1, 2, \dots, n-1$). Un exemplu de astfel de tabel este dat în figura următoare.

Din păcate, Atnoc a stropit cu apă minunatul său tabel și astfel o parte dintre numerele din tabel au devenit ilizibile.

~[tabel.png|width=30em]

# Cerință

Scrieți un program care să reconstituie toate datele din tabel.

# Date de intrare

Pe prima linie a fișierului text de intrare `tabel.in` se află două numere naturale $n$ și $m$, separate printr-un spațiu, ce reprezintă numărul de linii și respectiv numărul de coloane ale tabelului. Pe cea de a doua linie a fișierului de intrare se află un număr natural $p$ care reprezintă numărul de valori nedeteriorate din tabel. Pe fiecare dintre următoarele $p$ linii se află câte trei numere naturale, separate prin câte un spațiu $l \ c \ v$, unde $l$ este numărul liniei, $c$ este numărul coloanei și $v$ este valoarea elementului de pe linia $l$ și coloana $c$ din tabel.

# Date de ieșire

În fișierul text de ieșire `tabel.out` se va scrie tabelul reconstituit, pe $n$ linii câte $m$ valori separate prin câte un spațiu.

# Restricții și precizări

* $1 < n, m \leq 50$
* Valorile din tabel sunt numere naturale $< 32 \ 000$.
* În toate testele datele din tabel pot fi reconstituite.

---

Example:
`tabel.in`
```
3 4
10
1 1 2
1 2 5
1 3 7
1 4 14
2 2 6
2 4 23
3 1 13
3 2 11
3 3 13
3 4 37
```

`tabel.out`
```
2 5 7 14
11 6 6 23
13 11 13 37
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```markdown
```python
import numpy as np

# Reading the table sizes and number of visible entries from the input file
with open("tabel.in", "r") as file:
    n, m = map(int, file.readline().split())
    p = int(file.readline().strip())
    table = np.zeros((n, m), dtype=int)
    seen = np.zeros((n, m), dtype=bool)

    # Reading the visible entries and updating the table and seen arrays
    for _ in range(p):
        l, c, v = map(int, file.readline().split())
        table[l-1, c-1] = v
        seen[l-1, c-1] = True

# The last column and last row are sums of the previous ones
sum_cols = table[:-1, -1]  # Sum of columns (except the last one)
sum_rows = table[-1, :-1]  # Sum of rows (except the last one)

# Inferring missing values in the main area of the table
for i in range(n-1):
    for j in range(m-1):
        if not seen[i, j]:
            # Finding missing values by subtracting known elements from the sum
            table[i, j] = sum_cols[i] - np.sum(table[i, :m-1])
            table[j, i] = sum_rows[j] - np.sum(table[:n-1, j])

# Filling in the last cell, which is the sum of all previous cells in that row/col
table[-1, -1] = np.sum(table[-1, :m-1])
table[-1, -1] = np.sum(table[:n-1, -1])

# Writing the reconstituted table data to the output file
with open("tabel.out", "w") as file:
    for row in table:
        file.write(" ".join(map(str, row)) + "\n")
```
```
---------- user ----------


Expected program to write result to `tabel.out` and read from `tabel.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

def reconstitute_table(file_in, file_out):
    with open(file_in, "r") as f:
        n, m = map(int, f.readline().split())
        visible_count = int(f.readline().strip())
        visible_values = [tuple(map(int, f.readline().split())) for _ in range(visible_count)]

    # Initialize the table with zeros and flags for visibility
    table = np.zeros((n, m), dtype=int)
    visible = np.zeros((n, m), dtype=bool)
    
    # Apply visible values
    for l, c, v in visible_values:
        table[l-1, c-1] = v
        visible[l-1, c-1] = True

    # Infer missing values in the inner part of the table
    for i in range(n-1):
        for j in range(m-1):
            if not visible[i, j]:
                # Subtract the sum of known elements from the row/column total
                if j < m-1:
                    table[i, j] = table[i, m-1] - np.sum(table[i, :m-1][visible[i, :m-1]])
                if i < n-1:
                    table[i, j] = table[n-1, j] - np.sum(table[:n-1, j][visible[:n-1, j]])

    # Update the sums for the last row and last column
    table[:n-1, m-1] = np.sum(table[:n-1, :m-1], axis=1)  # Row sums
    table[n-1, :m-1] = np.sum(table[:n-1, :m-1], axis=0)  # Column sums
    table[n-1, m-1] = np.sum(table[n-1, :m-1])  # Bottom-right corner

    # Write the reconstituted table to the file
    with open(file_out, "w") as f:
        for row in table:
            f.write(' '.join(map(str, row)) + '\n')

# Call the function with the appropriate file names
reconstitute_table("tabel.in", "tabel.out")
```
```
---------- user ----------


Expected program to write result to `tabel.out` and read from `tabel.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Open the input file and read the dimensions and visible elements
with open('tabel.in', 'r') as file:
    n, m = map(int, file.readline().split())
    p = int(file.readline().strip())
    # Initialize a table with negative ones to denote unseen values
    table = -np.ones((n, m), dtype=int)
    for _ in range(p):
        l, c, v = map(int, file.readline().split())
        table[l-1][c-1] = v

# Create a mask to differentiate between seen and unseen values
seen = (table != -1)

# Calculate row and column totals
row_totals = np.where(seen[-1], table[-1], 0).sum()
col_totals = np.where(seen[:, -1], table[:, -1], 0).sum()

# Complete the last column and last row with sums
table[-1, :m-1] = row_totals - np.cumsum(np.where(seen[-1, :m-1], 0, table[-1, :m-1]))
table[:n-1, -1] = col_totals - np.cumsum(np.where(seen[:n-1, -1], 0, table[:n-1, -1]))

# Complete the inner cells
for i in range(n-1):
    for j in range(m-1):
        if not seen[i, j]:
            table[i, j] = table[i, -1] - table[i, :m-1].sum()

# Write the reconstituted table into the output file
with open('tabel.out', 'w') as file:
    for row in table:
        file.write(' '.join(map(str, row)) + '\n')
```
```
---------- user ----------


Expected program to write result to `tabel.out` and read from `tabel.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Open the input file and read the dimensions and visible elements
with open('tabel.in', 'r') as file:
    n, m = map(int, file.readline().split())
    p = int(file.readline().strip())
    # Initialize a table with zeros
    table = np.zeros((n, m), dtype=int)
    # Read the intact values from the file
    for _ in range(p):
        l, c, v = map(int, file.readline().split())
        table[l-1, c-1] = v

# Reconstruct the table
# Since we know the sums of the rows and columns, we can find the missing values
for i in range(n - 1):
    row_sum = table[i, m - 1]
    row_values_sum = table[i, :m - 1].sum()
    for j in range(m - 1):
        if table[i, j] == 0:
            table[i, j] = row_sum - row_values_sum
            break

for j in range(m - 1):
    col_sum = table[n - 1, j]
    col_values_sum = table[:n - 1, j].sum()
    for i in range(n - 1):
        if table[i, j] == 0:
            table[i, j] = col_sum - col_values_sum
            break

# Now we know the missing value in the bottom right corner as well
table[n - 1, m - 1] = table[:n - 1, m - 1].sum()

# Write the reconstituted table into the output file
with open('tabel.out', 'w') as file:
    for i in range(n):
        file.write(' '.join(map(str, table[i])) + '\n')
```
```
---------- user ----------


Expected program to write result to `tabel.out` and read from `tabel.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Define a function to solve the table puzzle
def solve_table_puzzle(n, m, values):
    # Create an array to hold the table's values, initialized with zeros
    table = np.zeros((n, m), dtype=np.int32)

    # Fill in the known values
    for l, c, v in values:
        table[l - 1, c - 1] = v

    # Solve for each row
    for i in range(n - 1):
        table[i, -1] -= np.sum(table[i, :-1])

    # Solve for each column
    for j in range(m - 1):
        table[-1, j] -= np.sum(table[:-1, j])

    # Now, fill in the missing values in the inner part
    for i in range(n - 1):
        for j in range(m - 1):
            if table[i, j] == 0:
                table[i, j] = table[i, -1] - np.sum(table[i, :-1])
                table[-1, j] -= table[i, j]

    # Fill in the missing value in the bottom-right corner
    table[-1, -1] = np.sum(table[-1, :-1])

    return table

# Read data from 'tabel.in'
with open('tabel.in', 'r') as file:
    n, m = map(int, file.readline().split())
    p = int(file.readline().strip())
    values = [tuple(map(int, file.readline().split())) for _ in range(p)]

# Solve the puzzle
table = solve_table_puzzle(n, m, values)

# Write the result to 'tabel.out'
with open('tabel.out', 'w') as file:
    for row in table:
        file.write(' '.join(map(str, row)) + '\n')
```
```
---------- user ----------


Expected program to write result to `tabel.out` and read from `tabel.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Initialize the numpy print options to write arrays to files without truncation
np.set_printoptions(threshold=np.inf, linewidth=np.inf)

# Read input from tabel.in
with open('tabel.in', 'r') as f:
    n, m = map(int, f.readline().split())  # read table dimensions
    p = int(f.readline().strip())  # read the number of provided values
    # Initialize an empty array and a mask for filled values
    table = np.zeros((n, m), dtype=int)
    filled_mask = np.zeros((n, m), dtype=bool)
    # Read the values and mark them as filled
    for _ in range(p):
        l, c, v = map(int, f.readline().split())
        table[l - 1, c - 1] = v
        filled_mask[l - 1, c - 1] = True

# Helper function to calculate the sums for last row and column
def calculate_sums(table, filled_mask, n, m):
    for i in range(n - 1):
        if not filled_mask[i, m - 1]:
            table[i, m - 1] = sum(table[i, :m - 1])
    for j in range(m - 1):
        if not filled_mask[n - 1, j]:
            table[n - 1, j] = sum(table[:n - 1, j])
    table[n - 1, m - 1] = sum(table[n - 1, :m - 1])

# Calculate sums using the helper function
calculate_sums(table, filled_mask, n, m)

# Now iterate to fill in the missing inner values
for i in range(n - 1):
    for j in range(m - 1):
        if not filled_mask[i, j]:
            table[i, j] = table[i, m - 1] - sum(table[i, :m - 1])

# Write output to tabel.out
with open('tabel.out', 'w') as f_out:
    for row in table:
        f_out.write(' '.join(map(str, row)) + '\n')
```
```
---------- user ----------


Expected program to write result to `tabel.out` and read from `tabel.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

def solve_table(n, m, clues):
    # Initialize table with zeros
    table = np.zeros((n, m), dtype=np.int32)

    # Place the known values in the table
    for l, c, v in clues:
        table[l-1, c-1] = v

    # The last row and column are sums of the elements before them
    for i in range(n-1):
        table[i, -1] = table[i, -1] - np.sum(table[i, :-1])
    for j in range(m-1):
        table[-1, j] = table[-1, j] - np.sum(table[:-1, j])

    # The last cell is the sum of all elements in the last column or row
    table[-1, -1] = np.sum(table[-1, :-1])

    return table

# Read the input data
with open('tabel.in', 'r') as fin:
    n, m = map(int, fin.readline().split())
    p = int(fin.readline())
    clues = [list(map(int, fin.readline().split())) for _ in range(p)]

# Solve the table
table = solve_table(n, m, clues)

# Write the output data
with open('tabel.out', 'w') as fout:
    for row in table:
        fout.write(' '.join(str(num) for num in row) + '\n')
```
```
