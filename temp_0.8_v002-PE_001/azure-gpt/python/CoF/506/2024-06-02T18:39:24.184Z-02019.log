---------- user ----------

Here is a programming challenge.
Please solve this problem efficiently, optimizing both time and memory usage.
Create the most efficient solution for this challenge in python. Utilize numpy and other highly efficient libraries whenever possible.
This problem has a memory limit of ~8MB so please be sensitive on using memory.Using unavoided memory may result in OOM.
The code must compile and be correct.
The solution must read from `fibosnek.in` and write to `fibosnek.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

~[fibosnek.png|align=right|width=25%]

Se consideră o matrice cu $n$ linii și $m$ coloane ce conține numere naturale nenule.
\
Se definește o parcurgere ***snek*** a matricei un șir de valori obținut astfel: se parcurg elementele matricei coloană cu coloană, de la prima până la ultima, și, în cadrul fiecărei coloane, de sus în jos de la elementul aflat pe prima linie, până la cel aflat pe ultima linie, ca în exemplu.
\
Șirul numerelor Fibonacci este definit mai jos unde $\text{fib}[k]$ reprezintă al $k$-lea număr Fibonacci:
* $fib[1] = 1, fib[2] = 1$;
* $fib[k] = fib[k - 1] + fib[k - 2]$, pentru orice $k \gt 2$;

Se numește secvență ***fibosnek*** un termen sau o succesiune de termeni aflați pe poziții consecutive în parcurgerea *snek*, cu proprietatea că fiecare dintre ei este număr Fibonacci. Similar, se numește secvență ***non-fibosnek*** un termen sau o succesiune de termeni aflați pe poziții consecutive în parcurgerea *snek*, cu proprietatea că niciunul dintre ei nu este număr Fibonacci. Lungimea secvenței este egală cu numărul termenilor săi. Suma secvenței este egală cu suma termenilor săi.

O secvență *non-fibosnek* poate fi transformată în una *fibosnek* prin înlocuirea fiecărui număr din secvență cu un număr Fibonacci aflat cel mai aproape de el în șirul numerelor Fibonacci. Dacă există două numere Fibonacci la fel de apropiate de numărul dat se va alege mereu cel mai mic. De exemplu, secvența ($4$) se transformă în secvența ($3$), iar secvența ($9, 11$) în secvența ($8, 13$).

# Cerințe

Fiind date elementele matricei cu $n$ linii și $m$ coloane să se determine:
1. numărul de numere Fibonacci din matricea dată inițial;
2. suma celei mai lungi secvențe *fibosnek* ce poate fi obținută, știind că se poate transforma **cel mult o secvență** *non-fibosnek* în una *fibosnek* folosind procedeul explicat mai sus. Dacă se pot obține mai multe astfel de secvențe de lungime maximă, se va alege prima întâlnită în parcurgerea *snek* a matricei.

# Date de intrare
Fișierul de intrare `fibosnek.in` conține pe prima linie numerele naturale $c$, $n$ și $m$, unde $c$ reprezintă cerința care trebuie rezolvată ($1$ sau $2$), iar $n$ și $m$ au semnificația din enunț, pe următoarele $n$ linii conține elementele matricei, parcurse în ordine, linie cu linie și în cadrul fiecărei linii, de la stânga la dreapta. Valorile aflate pe aceeași linie a fișierului sunt separate prin câte un spațiu.

# Date de ieșire
Fișierul de ieșire `fibosnek.out` conține fie doar numărul determinat pentru cerința $1$ (dacă $c = 1$), fie doar suma determinată pentru cerința $2$ (dacă $c = 2$).

# Restricții și precizări
* $c \in \{1, 2\}$;
* $1 \leq n, m \leq 1 \ 500$;
* Elementele matricei au valori în intervalul $[1, 2^{31}-1]$;
* Pentru $21$ de puncte, $c = 1$ și $n, m \leq 1 \ 000$;
* Pentru $20$ de puncte, $c = 2$ și $n, m \leq 100$;
* Pentru $44$ de puncte, $c = 2$ și $n, m \leq 1 \ 000$;
* Pentru $15$ puncte, $c = 2$ și nu există restricții suplimentare.

---

Example:
`fibosnek.in`
```
1 3 4
1 5 3 11
2 8 1 13
4 2 9 8
```

`fibosnek.out`
```
9
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```markdown
```python
import numpy as np

def read_matrix(filename):
    with open(filename, 'r') as file:
        c, n, m = map(int, file.readline().split())
        matrix = np.array([list(map(int, file.readline().split())) for _ in range(n)], dtype=np.int64)
    return c, matrix

def write_output(filename, result):
    with open(filename, 'w') as file:
        file.write(str(result))

def is_fibonacci(n, fibs):
    while fibs[-1] < n:
        fibs.append(fibs[-2] + fibs[-1])
    return n in fibs

def closest_fibonacci(n, fibs):
    while fibs[-1] < n:
        fibs.append(fibs[-2] + fibs[-1])
    idx = np.searchsorted(fibs, n)
    if fibs[idx] == n or idx == 0:
        return fibs[idx]
    else:
        if fibs[idx] - n < n - fibs[idx - 1]:
            return fibs[idx]
        else:
            return fibs[idx - 1]

def solve_task1(matrix, fibs):
    return np.sum(np.isin(matrix, fibs))

def solve_task2(matrix, fibs):
    flat_matrix = matrix.flatten()
    max_sum = current_sum = 0
    max_len = current_len = 0
    sequence_started = False
    for i in flat_matrix:
        if is_fibonacci(i, fibs):
            if not sequence_started:
                sequence_started = True
                current_sum = 0
                current_len = 0
            current_sum += i
            current_len += 1
        else:
            if sequence_started:
                sequence_started = False
                if current_len > max_len:
                    max_len = current_len
                    max_sum = current_sum
                elif current_len == max_len:
                    max_sum = max(max_sum, current_sum)
                current_sum = 0
                current_len = 0
            current_sum += closest_fibonacci(i, fibs)
            current_len += 1
    return max(max_sum, current_sum)

def main():
    c, matrix = read_matrix('fibosnek.in')
    fibs = [1, 1]  # Initial Fibonacci numbers
    if c == 1:
        result = solve_task1(matrix, fibs)
    else:  # c == 2
        result = solve_task2(matrix, fibs)
    write_output('fibosnek.out', result)

if __name__ == "__main__":
    main()
```
```
---------- user ----------


Expected program to write result to `fibosnek.out` and read from `fibosnek.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Read the matrix from file
def read_matrix(filename):
    with open(filename, 'r') as file:
        c, n, m = map(int, file.readline().split())
        matrix = np.fromiter((int(item) for line in file for item in line.split()), dtype=np.int64, count=n*m).reshape(n, m)
    return c, matrix

# Write the result to file
def write_result(filename, result):
    with open(filename, 'w') as file:
        file.write(str(result) + '\n')

# Check if a number is a Fibonacci number by generating Fibonacci numbers up to n
def generate_fibonacci(n):
    fibs = [0, 1]
    while fibs[-1] < n:
        fibs.append(fibs[-1] + fibs[-2])
    fibs_set = set(fibs)
    return fibs_set

# Find closest Fibonacci number, preferring the smaller one if equidistant
def closest_fibonacci(num, fibs):
    a, b = 0, 1
    while b < num:
        a, b = b, a + b
    return a if num - a <= b - num else b

# Count Fibonacci numbers in the matrix
def count_fibonacci(matrix, fibs):
    return np.sum(np.isin(matrix, fibs))

# Find the sum of the longest replaceable sequence
def longest_replaceable_sum(matrix, fibs):
    flat_matrix = matrix.flatten()
    max_sum = cur_sum = 0
    max_len = cur_len = 0
    is_fib = np.vectorize(lambda x: x in fibs)
    fib_mask = is_fib(flat_matrix)
    for i, is_fib_num in enumerate(fib_mask):
        if is_fib_num:
            cur_sum += flat_matrix[i]
            cur_len += 1
        else:
            if cur_len > max_len or (cur_len == max_len and cur_sum > max_sum):
                max_len = cur_len
                max_sum = cur_sum
            cur_sum = cur_len = 0
            flat_matrix[i] = closest_fibonacci(flat_matrix[i], fibs)
    # Check if the last sequence is the longest/most valuable
    if cur_len > max_len or (cur_len == max_len and cur_sum > max_sum):
        max_sum = cur_sum
    return max_sum + np.sum(flat_matrix[~fib_mask])

# Main function to solve the problem
def main():
    c, matrix = read_matrix('fibosnek.in')
    fibs = generate_fibonacci(np.max(matrix))
    if c == 1:
        result = count_fibonacci(matrix, fibs)
    else:  # c == 2
        result = longest_replaceable_sum(matrix, fibs)
    write_result('fibosnek.out', result)

if __name__ == "__main__":
    main()
```
```
---------- user ----------


Expected program to write result to `fibosnek.out` and read from `fibosnek.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

def generate_fibonacci(max_value):
    fibs = [0, 1]
    while fibs[-1] <= max_value:
        fibs.append(fibs[-1] + fibs[-2])
    return np.array(fibs[1:], dtype=np.int64)  # Ignore the first zero

def read_input(filename):
    with open(filename, 'r') as file:
        task, n, m = map(int, file.readline().split())
        matrix = np.array([list(map(int, file.readline().split())) for _ in range(n)], dtype=np.int64)
    return task, matrix

def write_output(filename, result):
    with open(filename, 'w') as file:
        file.write(str(result) + '\n')

def find_fibonacci_numbers(matrix, fibs):
    return np.isin(matrix, fibs).sum()

def transform_sequence(matrix, fibs):
    snek_order = matrix.flatten()
    fibs_set = set(fibs)
    closest_fib_cache = {}

    def closest_fib(num):
        if num in fibs_set:
            return num, True
        if num in closest_fib_cache:
            return closest_fib_cache[num], False
        idx = np.searchsorted(fibs, num)
        if idx == 0:
            closest = fibs[0]
        else:
            left, right = fibs[idx - 1], fibs[idx]
            closest = left if num - left <= right - num else right
        closest_fib_cache[num] = closest
        return closest, False

    max_fib_sum = 0
    current_fib_sum = 0
    max_non_fib_sum = 0
    current_non_fib_sum = 0
    max_non_fib_len = 0
    current_non_fib_len = 0
    for num in snek_order:
        closest, is_fib = closest_fib(num)
        if is_fib:
            current_fib_sum += num
            max_fib_sum = max(max_fib_sum, current_fib_sum)
            current_non_fib_len = 0
        else:
            current_fib_sum = 0
            current_non_fib_sum += closest
            current_non_fib_len += 1
            if current_non_fib_len > max_non_fib_len:
                max_non_fib_len = current_non_fib_len
                max_non_fib_sum = current_non_fib_sum
            elif current_non_fib_len == max_non_fib_len:
                max_non_fib_sum = max(max_non_fib_sum, current_non_fib_sum)

    return max(max_fib_sum, max_non_fib_sum)

def main():
    task, matrix = read_input('fibosnek.in')
    max_value = np.max(matrix)
    fibs = generate_fibonacci(max_value)

    if task == 1:
        result = find_fibonacci_numbers(matrix, fibs)
    elif task == 2:
        result = transform_sequence(matrix, fibs)
    else:
        raise ValueError("Invalid task number")

    write_output('fibosnek.out', result)

if __name__ == "__main__":
    main()
```
```
---------- user ----------


Expected program to write result to `fibosnek.out` and read from `fibosnek.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Efficiently generate a list of Fibonacci numbers up to a maximum value
def generate_fibonacci(max_value):
    fibs = [0, 1]
    while fibs[-1] < max_value:
        fibs.append(fibs[-2] + fibs[-1])
    return fibs[2:]  # Exclude 0 from the list

# Read matrix from file
def read_matrix():
    with open('fibosnek.in', 'r') as file:
        task, rows, cols = map(int, file.readline().strip().split())
        matrix = np.fromfile(file, dtype=int, sep=' ', count=rows * cols)
        matrix.shape = (rows, cols)
    return task, matrix

# Write result to file
def write_result(result):
    with open('fibosnek.out', 'w') as file:
        file.write(f"{result}\n")

# Find Fibonacci numbers in the matrix
def count_fibonacci_numbers(matrix, fibs):
    count = 0
    for number in np.nditer(matrix):
        if number in fibs:
            count += 1
    return count

# Convert nearest to Fibonacci
def convert_nearest_fibonacci(matrix, fibs):
    fibs_set = set(fibs)
    seq_len, max_seq_len, seq_sum, max_seq_sum = 0, 0, 0, 0
    max_converted_seq_sum = 0
    converted = False

    for number in matrix.flat:
        if number in fibs_set:
            if seq_len > max_seq_len or (seq_len == max_seq_len and seq_sum > max_seq_sum):
                max_seq_len, max_seq_sum = seq_len, seq_sum
            seq_len, seq_sum = 1, number
            if converted:
                converted = False
                max_converted_seq_sum = max(max_converted_seq_sum, seq_sum)
        else:
            closest_fib = min(fibs_set, key=lambda x: (abs(x - number), x))
            seq_len += 1
            seq_sum += closest_fib
            if not converted:
                converted = True
                max_converted_seq_sum = seq_sum
            else:
                max_converted_seq_sum = max(max_converted_seq_sum, seq_sum)

    if seq_len > max_seq_len or (seq_len == max_seq_len and seq_sum > max_seq_sum):
        max_seq_len, max_seq_sum = seq_len, seq_sum

    return max_seq_sum if not converted else max_converted_seq_sum

# Main function to run the program
def main():
    task, matrix = read_matrix()
    max_value = np.max(matrix)
    fibs = generate_fibonacci(max_value)
    result = count_fibonacci_numbers(matrix, fibs) if task == 1 else convert_nearest_fibonacci(matrix, fibs)
    write_result(result)

# Entry point of the script
if __name__ == "__main__":
    main()
```
```
---------- user ----------


Expected program to write result to `fibosnek.out` and read from `fibosnek.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Generate Fibonacci series up to the largest number in the matrix
def generate_fibonacci(max_num):
    fib_series = [1, 1]
    while fib_series[-1] <= max_num:
        fib_series.append(fib_series[-1] + fib_series[-2])
    return set(fib_series)

# Find the closest Fibonacci number to the given number
def closest_fib(num, fib_series):
    for i in range(len(fib_series)):
        if num < fib_series[i]:
            if i == 0:
                return fib_series[i]
            return fib_series[i] if fib_series[i] - num < num - fib_series[i-1] else fib_series[i-1]
    return fib_series[-1]

# Task 1: Count the number of Fibonacci numbers in the matrix
def count_fibonacci(matrix, fib_series):
    return np.sum(np.isin(matrix, list(fib_series)))

# Task 2: Find the sum of the longest fibosnek sequence
def longest_fibosnek_sum(matrix, fib_series):
    fibo_snek = matrix.flatten()
    max_fib_sum = 0
    current_sum = 0
    max_len = 0
    current_len = 0
    for num in fibo_snek:
        if num in fib_series:
            current_sum += num
            current_len += 1
        else:
            if current_len > max_len or (current_len == max_len and current_sum > max_fib_sum):
                max_len = current_len
                max_fib_sum = current_sum
            current_sum = closest_fib(num, fib_series)
            current_len = 1
    if current_len > max_len or (current_len == max_len and current_sum > max_fib_sum):
        max_fib_sum = current_sum
    return max_fib_sum

# Main function to read input, process data and write output
def main():
    with open('fibosnek.in', 'r') as file:
        task, n, m = map(int, file.readline().split())
        matrix = np.array([list(map(int, file.readline().split())) for _ in range(n)])
    
    max_num = np.max(matrix)
    fib_series = generate_fibonacci(max_num)
    
    if task == 1:
        result = count_fibonacci(matrix, fib_series)
    else:
        result = longest_fibosnek_sum(matrix, fib_series)
    
    with open('fibosnek.out', 'w') as file:
        file.write(str(result))

if __name__ == '__main__':
    main()
```
```
---------- user ----------


Expected program to write result to `fibosnek.out` and read from `fibosnek.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

def read_input():
    with open('fibosnek.in', 'r') as file:
        c, n, m = map(int, file.readline().split())
        matrix = np.loadtxt(file, dtype=np.int32, ndmin=2)
    return c, matrix

def write_output(result):
    with open('fibosnek.out', 'w') as file:
        file.write(str(result))

def is_fibonacci(num, fibs):
    while fibs[-1] < num:
        fibs.append(fibs[-1] + fibs[-2])
    return num in fibs

def closest_fib(num, fibs):
    while fibs[-1] < num:
        fibs.append(fibs[-1] + fibs[-2])
    idx = np.searchsorted(fibs, num, side="left")
    if idx == 0 or fibs[idx] == num:
        return fibs[idx]
    elif idx == len(fibs):
        return fibs[-1]
    else:
        return fibs[idx - 1] if num - fibs[idx - 1] <= fibs[idx] - num else fibs[idx]

def solve(c, matrix):
    fibs = [0, 1]
    if c == 1:
        return np.sum([is_fibonacci(x, fibs) for x in matrix.flatten()])
    else:
        max_sequence_sum = 0
        sequence_sum = 0
        non_fib_sequence_len = 0
        for x in matrix.flatten():
            if is_fibonacci(x, fibs):
                sequence_sum += x
                non_fib_sequence_len = 0
            else:
                non_fib_sequence_len += 1
                if non_fib_sequence_len == 1:
                    sequence_sum += closest_fib(x, fibs)
                else:
                    sequence_sum = closest_fib(x, fibs)
                    non_fib_sequence_len = 1
            max_sequence_sum = max(max_sequence_sum, sequence_sum)
        return max_sequence_sum

def main():
    c, matrix = read_input()
    result = solve(c, matrix)
    write_output(result)

if __name__ == '__main__':
    main()
```
```
---------- user ----------


Expected program to write result to `fibosnek.out` and read from `fibosnek.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Function to read the input from the file
def read_input():
    with open('fibosnek.in', 'r') as file:
        lines = file.readlines()
    c, n, m = map(int, lines[0].split())
    matrix = np.array([[int(num) for num in line.split()] for line in lines[1:]], dtype=np.int64)
    return c, matrix

# Function to write the output to the file
def write_output(result):
    with open('fibosnek.out', 'w') as file:
        file.write(str(result) + '\n')

# Function to generate Fibonacci numbers up to the maximum possible matrix element
def generate_fibonacci(max_num):
    fib = [1, 1]
    while fib[-1] <= max_num:
        fib.append(fib[-1] + fib[-2])
    return set(fib)

# Function to solve the task 1: Count the number of Fibonacci numbers in the matrix
def count_fibonacci(matrix, fib_set):
    return np.isin(matrix, list(fib_set)).sum()

# Function to solve the task 2: Find the sum of the longest sequence that can be made into a fibosnek sequence
def longest_fibosnek_sum(matrix, fib_set):
    max_sum = 0
    current_sum = 0
    longest_fib_sequence = []
    current_fib_sequence = []
    for element in matrix.flatten():
        if element in fib_set:
            current_fib_sequence.append(element)
            current_sum += element
        else:
            if len(current_fib_sequence) > len(longest_fib_sequence) or \
               (len(current_fib_sequence) == len(longest_fib_sequence) and current_sum > max_sum):
                longest_fib_sequence = current_fib_sequence.copy()
                max_sum = current_sum
            current_fib_sequence = []
            current_sum = 0
    if len(current_fib_sequence) > len(longest_fib_sequence) or \
       (len(current_fib_sequence) == len(longest_fib_sequence) and current_sum > max_sum):
        max_sum = current_sum
    return max_sum

# Main function to run the program
def main():
    c, matrix = read_input()
    max_element = np.max(matrix)
    fib_set = generate_fibonacci(max_element)
    if c == 1:
        result = count_fibonacci(matrix, fib_set)
    else:
        result = longest_fibosnek_sum(matrix, fib_set)
    write_output(result)

# Entry point for the script
if __name__ == '__main__':
    main()
```
```
