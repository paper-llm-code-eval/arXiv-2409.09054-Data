---------- user ----------

Here is a programming challenge.
Please solve this problem efficiently, optimizing both time and memory usage.
Create the most efficient solution for this challenge in python. Utilize numpy and other highly efficient libraries whenever possible.
This problem has a memory limit of ~8MB so please be sensitive on using memory.Using unavoided memory may result in OOM.
The code must compile and be correct.
The solution must read from `nr.in` and write to `nr.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Se generează un şir de numere naturale ai cărui primi termeni sunt, în această ordine: 

$1$, $2$, $3$, $5$, $8$, $3$, $1$, $4$, $5$, $9$, $4$, $3$, $7$, $0$, $7$, $7$, $4$,...	 

# Cerință

Deduceţi regula după care sunt generaţi termenii şirului şi scrieţi un program care să citească numerele naturale $n$, $k$ şi $p$ şi care să determine:

1.	suma tuturor numerelor prime aflate printre primii $n$ termeni ai şirului din enunţ; 
2.	numărul de apariţii ale cifrei $k$ printre primii $n$ termeni ai şirului din enunţ;
3.	cel de-al $p$-lea termen al şirului din enunţ.


# Date de intrare


Fişierul `nr.in` conţine o singură linie pe care sunt scrise trei numere naturale $n$, $k$ şi $p$, separate prin câte un spaţiu.


# Date de ieșire

Fişierul de ieşire `nr.out` va conţine $3$ linii: 

1. pe prima linie, un număr natural reprezentând suma tuturor numerelor prime aflate printre primii $n$ termeni ai şirului din enunţ  
2. pe a doua linie, numărul de apariţii ale cifrei $k$ printre primii $n$ termeni ai şirului din enunţ
3. pe a treia linie se va afişa cel de-al $p$-lea termen al şirului din enunţ



# Restricții și precizări

* $3 \leq n \leq 100$;
* $0 \leq k \leq 9$;
* $1 \leq p \leq 2 \cdot 10^9$;
* Pentru rezolvarea cerinţei 1) se acordă 40% din punctaj, pentru cerinţa 2) 20% din punctaj şi pentru cerinţa 3) 40% din punctaj.
* Pentru teste în valoare de $50$ de puncte, $p \leq 10^7$;

---

Example:
`nr.in`
```
19 5 26
```

`nr.out`
```
47
3
8
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```markdown
```python
# Python code to solve the given challenge
import numpy as np
from sympy import isprime

def generate_sequence(n):
    seq = [1, 2, 3, 5]
    while len(seq) < n:
        seq.append((seq[-1] + seq[-4]) % 10)
    return np.array(seq[:n])

def sum_of_primes(seq):
    prime_filter = np.vectorize(isprime)
    return np.sum(seq[prime_filter(seq)])

def count_digit(seq, k):
    return np.sum(seq == k)

def nth_term(p):
    base_seq = np.array([1, 2, 3, 5])
    return base_seq[(p - 1) % 4]

def main():
    # Read from input file
    with open('nr.in', 'r') as file:
        n, k, p = map(int, file.readline().strip().split())

    # Generate the sequence
    seq = generate_sequence(n)

    # Compute the sum of primes
    sum_primes = sum_of_primes(seq)

    # Count the digit k
    k_count = count_digit(seq, k)

    # Get the p-th term
    pth_term = nth_term(p)

    # Write to output file
    with open('nr.out', 'w') as file:
        file.write(f"{sum_primes}\n")
        file.write(f"{k_count}\n")
        file.write(f"{pth_term}\n")

if __name__ == "__main__":
    main()
```
```
---------- user ----------


Expected program to write result to `nr.out` and read from `nr.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np
from sympy import primerange

# Check if a number is prime
def is_prime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def generate_sequence(n):
    seq = [1, 2, 3, 5, 8, 3, 1, 4, 5, 9, 4, 3, 7, 0, 7, 7, 4]
    if n <= len(seq):
        return np.array(seq[:n])
    for _ in range(n - len(seq)):
        next_val = (seq[-16] + seq[-4]) % 10
        seq.append(next_val)
    return np.array(seq)

def sum_of_primes(n):
    primes = [2, 3, 5, 7]
    seq = generate_sequence(n)
    return np.sum([x for x in seq if x in primes])

def count_digit(seq, k):
    return np.sum(seq == k)

def nth_term(p):
    # Since the sequence is periodic every 16 terms, we only need to compute the sequence up to 16 terms
    seq = generate_sequence(16)
    # Use the modulo operator to find the position in the period
    index = (p - 1) % 16
    return seq[index]

def read_input(file_path):
    with open(file_path, 'r') as file:
        n, k, p = map(int, file.readline().strip().split())
    return n, k, p

def write_output(file_path, sum_primes, k_count, pth_term):
    with open(file_path, 'w') as file:
        file.write(f"{sum_primes}\n{k_count}\n{pth_term}\n")

# Main function to control the flow of the program
def main():
    n, k, p = read_input('nr.in')
    seq = generate_sequence(n)
    sum_primes = sum_of_primes(n)
    k_count = count_digit(seq, k)
    pth_term = nth_term(p)
    write_output('nr.out', sum_primes, k_count, pth_term)

# Execute the main function
if __name__ == "__main__":
    main()
```
```
---------- user ----------


Expected program to write result to `nr.out` and read from `nr.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Auxiliary function to check if a number is prime
def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False
    return True

# Pre-calculated sequence and primes for the first 16 terms
SEQUENCE = np.array([1, 2, 3, 5, 8, 3, 1, 4, 5, 9, 4, 3, 7, 0, 7, 7, 4])
PRIMES = np.array([el for el in SEQUENCE if is_prime(el)])

# Function to calculate the sum of primes
def sum_of_primes(n):
    repeats, remainder = divmod(n, 16)
    return np.sum(PRIMES) * repeats + np.sum(PRIMES[:remainder])

# Function to count the digit occurrences
def count_digit(k, n):
    counts = np.array([str(i).count(str(k)) for i in SEQUENCE])
    repeats, remainder = divmod(n, 16)
    return np.sum(counts) * repeats + np.sum(counts[:remainder])

# Function to find the nth term
def nth_term(p):
    return SEQUENCE[(p - 1) % 16]

# Read from nr.in and write to nr.out
with open('nr.in', 'r') as f_in:
    n, k, p = map(int, f_in.readline().split())

# Computing required values
sum_primes = sum_of_primes(n)
k_count = count_digit(k, n)
p_term = nth_term(p)

# Writing the results to nr.out
with open('nr.out', 'w') as f_out:
    f_out.write(f'{sum_primes}\n')
    f_out.write(f'{k_count}\n')
    f_out.write(f'{p_term}\n')
```
```
---------- user ----------


Expected program to write result to `nr.out` and read from `nr.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Since the constraints are small, we can precompute the sequence and primes
sequence = [1, 2, 3, 5, 8, 3, 1, 4, 5, 9, 4, 3, 7, 0, 7, 7, 4]
primes = [2, 3, 5, 7]

def calculate_sum_of_primes(n):
    sum_primes = 0
    for i in range(n):
        if sequence[i % len(sequence)] in primes:
            sum_primes += sequence[i % len(sequence)]
    return sum_primes

def count_digit(k, n):
    count = 0
    for i in range(n):
        if sequence[i % len(sequence)] == k:
            count += 1
    return count

def get_nth_term(p):
    return sequence[(p - 1) % len(sequence)]

# Read from 'nr.in'
with open('nr.in', 'r') as f:
    n, k, p = map(int, f.readline().split())

# Calculate the required results
sum_primes = calculate_sum_of_primes(n)
k_count = count_digit(k, n)
nth_term = get_nth_term(p)

# Write to 'nr.out'
with open('nr.out', 'w') as f:
    f.write(f"{sum_primes}\n")
    f.write(f"{k_count}\n")
    f.write(f"{nth_term}\n")
```
```
---------- user ----------


Expected program to write result to `nr.out` and read from `nr.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
# Python code to efficiently solve the challenge
import numpy as np

# Function to check if a number is prime
def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False
    return True

# Function to generate the sequence
def generate_sequence(n):
    seq = [1, 2, 3, 5, 8, 3, 1, 4, 5, 9, 4, 3, 7, 0, 7, 7, 4]
    for _ in range(n - len(seq)):
        seq.append((seq[-4] + seq[-1]) % 10)
    return seq

# Function to calculate the sum of primes in the sequence
def sum_of_primes(seq):
    return sum(filter(is_prime, seq))

# Function to calculate the number of occurrences of k in the sequence
def count_k_occurrences(seq, k):
    return seq.count(k)

# Function to get the p-th term of the sequence
def get_pth_term(p):
    # As the sequence repeats every 16 numbers, we can use modulo to find the p-th term
    base_seq = generate_sequence(16)
    return base_seq[(p - 1) % 16]

# Read the input from 'nr.in'
with open('nr.in', 'r') as file:
    n, k, p = map(int, file.readline().split())

# Generate the sequence
sequence = generate_sequence(n)

# Calculate the sum of primes
sum_primes = sum_of_primes(sequence)

# Count the occurrences of k
k_occurrences = count_k_occurrences(sequence, k)

# Get the p-th term
p_term = get_pth_term(p)

# Write the output to 'nr.out'
with open('nr.out', 'w') as file:
    file.write(f"{sum_primes}\n{k_occurrences}\n{p_term}\n")
```
```
---------- user ----------


Expected program to write result to `nr.out` and read from `nr.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
# Program to solve the problem with given memory constraints

import numpy as np

# Efficient prime checking for small numbers
def is_prime(num):
    if num < 2:
        return False
    max_divisor = int(np.sqrt(num)) + 1
    for d in range(2, max_divisor):
        if num % d == 0:
            return False
    return True

# Generating the sequence up to the nth term
def generate_sequence(n):
    # Start with the given sequence pattern
    sequence = [1, 2, 3, 5, 8, 3, 1, 4, 5, 9, 4, 3, 7, 0, 7, 7, 4]
    # Make use of the observed periodicity in the sequence
    sequence_length = 16
    if n <= sequence_length:
        return sequence[:n]
    else:
        # Extend the sequence minimally as needed
        for i in range(sequence_length, n):
            next_val = (sequence[i - sequence_length] + sequence[i - 4]) % 10
            sequence.append(next_val)
    return sequence

# Read from nr.in
with open('nr.in', 'r') as file:
    n, k, p = map(int, file.readline().split())

# Generate the necessary part of the sequence
sequence = generate_sequence(n)

# Calculate sum of primes within the first n terms
prime_sum = sum(filter(is_prime, sequence))

# Count the occurrences of the digit k in the first n terms
digit_count = sequence.count(k)

# Find the p-th term in the sequence
p_th_term = sequence[(p - 1) % 16]  # Exploit the periodicity of length 16

# Write to nr.out
with open('nr.out', 'w') as file:
    file.write(f"{prime_sum}\n")
    file.write(f"{digit_count}\n")
    file.write(f"{p_th_term}\n")
```
```
---------- user ----------


Expected program to write result to `nr.out` and read from `nr.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
# Required Libraries
import numpy as np

# Constants
SEQUENCE_LENGTH = 16

# Fast prime checker for our use case
def is_prime(n):
    if n == 2 or n == 3:
        return True
    if n < 2 or n % 2 == 0:
        return False
    for i in range(3, int(n**0.5) + 1, 2):
        if n % i == 0:
            return False
    return True

# Vectorized prime check for numpy arrays
vec_is_prime = np.vectorize(is_prime)

# Read the input from 'nr.in'
with open('nr.in', 'r') as file:
    n, k, p = map(int, file.readline().strip().split())

# Calculate the first 16 terms (since the sequence is periodic with period of 16)
sequence = np.array([1, 2, 3, 5, 8, 3, 1, 4, 5, 9, 4, 3, 7, 0, 7, 7, 4][:SEQUENCE_LENGTH], dtype=np.int8)
# For sum of primes and count k, consider the sequence up to n terms
if n > SEQUENCE_LENGTH:
    # Extend the sequence to the required length for sum of primes and count k
    terms_needed = (n - 1) // SEQUENCE_LENGTH * SEQUENCE_LENGTH + SEQUENCE_LENGTH
    extended_sequence = np.resize(sequence, terms_needed)
else:
    extended_sequence = sequence[:n]

# Calculate sum of primes in the first n terms
primes_in_sequence = vec_is_prime(extended_sequence)
sum_primes = np.sum(extended_sequence[primes_in_sequence])

# Count occurrences of digit k in the first n terms
k_count = np.sum(extended_sequence == k)

# Calculate the p-th term (which is p modulo the period 16)
p_th_term = sequence[(p - 1) % SEQUENCE_LENGTH]

# Write the results to 'nr.out'
with open('nr.out', 'w') as file:
    file.write(f"{sum_primes}\n{k_count}\n{p_th_term}\n")
```
```
