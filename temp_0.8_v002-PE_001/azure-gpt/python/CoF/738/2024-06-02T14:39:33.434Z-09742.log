---------- user ----------

Here is a programming challenge.
Please solve this problem efficiently, optimizing both time and memory usage.
Create the most efficient solution for this challenge in python. Utilize numpy and other highly efficient libraries whenever possible.
This problem has a memory limit of ~8MB so please be sensitive on using memory. Using too much memory may result in OOM.
The code must compile and be correct.
The solution must read from `ucif.in` and write to `ucif.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Fie $n$ un număr natural și $s = 1^1 + 2^2 + 3^3 + \dots + n^n$.

# Cerință

Scrieți un program care să afișeze ultima cifră a lui $s$.

# Date de intrare


De pe prima linie a fișierului de intrare `ucif.in` se citește numărul $n$.


# Date de ieșire


Pe prima linie a fișierului de ieșire `ucif.out` se va afișa numai ultima cifră a lui $s$.


# Restricții și precizări

* $1 \leq n \leq 100$

---

Example:
`ucif.in`
```
3
```

`ucif.out`
```
2
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```markdown
```python
import numpy as np

def compute_last_digit(n):
    # Since we only care about the last digit, we can reduce large powers by considering
    # that (a^b) % 10 = ((a % 10)^b) % 10. Also, note that for b >= 4, (a^b) % 10 
    # cycles every 4 due to Euler's theorem.
    last_digit_sums = np.zeros(10, dtype=np.int64)
    # Pre-compute the last digit of the powers 0^0, 1^1, ..., 9^9
    for i in range(10):
        last_digit_sums[i] = pow(i, i, 10)
    # Use memoization to avoid re-computing powers
    memo = last_digit_sums.copy()
    # Compute the last digit of the sum
    last_digit = 0
    for i in range(1, n+1):
        last_digit = (last_digit + memo[i % 10]) % 10
        # Update memo for next cycle of 10, for i >= 10
        if i >= 10:
            memo[i % 10] = (memo[i % 10] * last_digit_sums[i % 10]) % 10
    
    return last_digit

# Read the input from 'ucif.in'
with open('ucif.in', 'r') as infile:
    n = int(infile.readline().strip())

# Compute the last digit of the sum
last_digit = compute_last_digit(n)

# Write the output to 'ucif.out'
with open('ucif.out', 'w') as outfile:
    outfile.write(f'{last_digit}\n')
```
```
---------- user ----------


Expected program to write result to `ucif.out` and read from `ucif.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
# Utilize numpy for efficient computation
import numpy as np

# Read the value of n from 'ucif.in'
with open('ucif.in', 'r') as file:
    n = int(file.read().strip())

# Create an array to store the last digit of i^i for i in [0,9],
# as they will repeat for every i congruent modulo 10.
last_digits = np.arange(10, dtype=np.int64)
last_digits = np.power(last_digits, last_digits, dtype=np.int64) % 10

# Initialize the sum with the last digit of 1^1
sum_of_last_digits = last_digits[1] if n >= 1 else 0

# The last digit of powers repeat in cycles when the exponent is 4 or more (Euler's theorem)
# So we only need to compute it for the first few numbers and then use the cyclic property
for i in range(2, n + 1):
    sum_of_last_digits += last_digits[i % 10]
    sum_of_last_digits %= 10  # We only care about the last digit

# Write the last digit of the sum to 'ucif.out'
with open('ucif.out', 'w') as file:
    file.write(f'{sum_of_last_digits}')
```
---------- user ----------


Expected program to write result to `ucif.out` and read from `ucif.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

def last_digit_of_series(n):
    last_digits = [pow(i, i, 10) for i in range(10)]
    result = 0
    for i in range(1, n + 1):
        result = (result + last_digits[i % 10]) % 10
    return result

# Read input from 'ucif.in'
with open('ucif.in', 'r') as input_file:
    n = int(input_file.readline().strip())

# Compute the last digit of the sum
last_digit = last_digit_of_series(n)

# Write the output to 'ucif.out'
with open('ucif.out', 'w') as output_file:
    output_file.write(str(last_digit))
```
```
---------- user ----------


Expected program to write result to `ucif.out` and read from `ucif.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Function to compute the last digit of the sum
def compute_last_digit(n):
    last_digit = 0
    # Loop over the range 1 to n (inclusive)
    for i in range(1, n + 1):
        # Compute the last digit of i^i using modulus
        last_digit = (last_digit + pow(i, i, 10)) % 10
    return last_digit

# Read the input from 'ucif.in'
with open('ucif.in', 'r') as infile:
    n = int(infile.readline().strip())

# Compute the last digit of the sum s
last_digit = compute_last_digit(n)

# Write the output to 'ucif.out'
with open('ucif.out', 'w') as outfile:
    outfile.write(f'{last_digit}\n')
```
```
---------- user ----------


Expected program to write result to `ucif.out` and read from `ucif.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
# Efficient computation using numpy and minimal memory usage
import numpy as np

# Function to compute the last digit of the sum
def compute_last_digit(n):
    # Array to hold the last digits of powers from 1^1 to 9^9
    # Using dtype=int8 for memory efficiency as we only need to store digits 0-9
    last_digits = np.array([pow(i, i, 10) for i in range(10)], dtype=np.int8)
    sum_last_digit = 0
    for i in range(1, n + 1):
        # Only add the last digit of i^i to the sum
        sum_last_digit = (sum_last_digit + last_digits[i % 10]) % 10
    return sum_last_digit

# Read the input number n from 'ucif.in'
with open('ucif.in', 'r') as f:
    n = int(f.readline())

# Compute the last digit of the sum
last_digit = compute_last_digit(n)

# Write the last digit to 'ucif.out'
with open('ucif.out', 'w') as f:
    f.write(f'{last_digit}')
```
```
---------- user ----------


Expected program to write result to `ucif.out` and read from `ucif.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
# Efficient computation with minimal memory usage
# Numpy is not required for this solution as the memory constraint is strict

def last_digit_of_self_power(n):
    # The last digit of a number raised to its own power forms a pattern every 10 numbers
    # Pre-compute this pattern to avoid large exponentiations and to save memory
    pattern = [(i ** i) % 10 for i in range(10)]
    # Initialize the sum of the last digits
    sum_last_digit = 0
    # Loop through each number from 1 to n and add the corresponding pattern value
    for i in range(1, n + 1):
        sum_last_digit = (sum_last_digit + pattern[i % 10]) % 10
    return sum_last_digit

# Read the input number n from 'ucif.in'
with open('ucif.in', 'r') as file:
    n = int(file.readline())

# Calculate the last digit of the sum of self powers up to n
last_digit = last_digit_of_self_power(n)

# Write the last digit to 'ucif.out'
with open('ucif.out', 'w') as file:
    file.write(f'{last_digit}')
```
```
---------- user ----------


Expected program to write result to `ucif.out` and read from `ucif.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
# Efficient computation without numpy and with minimal memory usage

# Function to compute the last digit of i^i for i from 1 to n
def last_digit_of_series(n):
    sum_last_digit = 0
    for i in range(1, n + 1):
        # Compute the last digit of i^i using exponentiation by squaring, modulo 10
        last_digit_i_i = 1
        for _ in range(i):
            last_digit_i_i = (last_digit_i_i * i) % 10
        sum_last_digit = (sum_last_digit + last_digit_i_i) % 10
    return sum_last_digit

# Read the input number n from 'ucif.in'
with open('ucif.in', 'r') as infile:
    n = int(infile.readline())

# Calculate the last digit of the sum of self powers up to n
last_digit = last_digit_of_series(n)

# Write the last digit to 'ucif.out'
with open('ucif.out', 'w') as outfile:
    outfile.write(str(last_digit))
```
```
