---------- user ----------

Here is a programming challenge.
Please solve this problem efficiently, optimizing both time and memory usage.
Create the most efficient solution for this challenge in python. Utilize numpy and other highly efficient libraries whenever possible.
This problem has a memory limit of ~8MB so please be sensitive on using memory. Using too much memory may result in OOM.
The code must compile and be correct.
The solution must read from `adunscad.in` and write to `adunscad.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Considerăm un număr întreg $N$ și un șir de $M$ cifre zecimale nenule. Să se determine dacă numărul $N$ poate fi rezultatul unei expresii aritmetice simple (fără paranteze), formată exclusiv din cifrele șirului citit și din operatorii aritmetici desemnați pentru operațiile de adunare și scădere ($+, -$).

# Cerință

Scrieți un program care citește numerele $N$ și $M$ de pe prima linie a fișierului de intrare și șirul de $M$ cifre de pe linia următoare și determină și afișează expresia găsită sau valoarea 0 în cazul în care nu există soluție.

# Date de intrare

Fișierul de intrare `adunscad.in` conține pe prima linie numerele întregi $N \ M$, separate printr-un spațiu, reprezentând valoarea ce trebuie obținută la evaluarea expresiei și numărul de cifre din șir. Linia a doua a fișierului de intrare conține șirul celor $M$ cifre nenule, separate prin câte un spațiu.

# Date de ieșire

În fișierul de ieșire `adunscad.out` va conține pe prima linie expresia determinată, în cazul în care există soluție, sau valoarea $0$ în cazul în care nu există soluție.

# Restricții și precizări

* $-180 \leq N \leq 180$;
* $2 \leq M \leq 20$;
* În șirul citit cifrele se pot repeta.
* Toate cifrele din șir trebuie să apară și în expresia aritmetică, în aceeași ordine în care au fost citite.
* În expresia aritmetică, orice cifră trebuie să fie precedată de un operator; în cazul în care prima cifră este precedată de operatorul + acesta nu se pune în expresie. În expresia aritmetică nu există spații.
* În cazul în care soluția nu este unică se va afișa o soluție corectă.

---

Example:
`adunscad.in`
```
21 4
3 9 1 8
```

`adunscad.out`
```
3+9+1+8
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```python
import numpy as np

# Read from the input file
with open('adunscad.in', 'r') as f:
    N, M = map(int, f.readline().split())
    digits = list(map(int, f.readline().split()))

# This function generates all possible expressions using the digits
def generate_expressions(digits):
    operators = ['+', '-']
    expression = [str(digits[0])]
    
    for digit in digits[1:]:
        new_expressions = []
        for expr in expression:
            for operator in operators:
                new_expressions.append(expr + operator + str(digit))
        expression = new_expressions
    return expression

# Find an expression that evaluates to N, if it exists
def find_expression(digits, target):
    for expr in generate_expressions(digits):
        if eval(expr) == target:
            return expr
    return '0'

# Use the function to find the expression
expression = find_expression(digits, N)

# Write to the output file
with open('adunscad.out', 'w') as f:
    f.write(expression + '\n')
```

This code will generate all possible expressions which can be massive and not fit in the memory limit. We need to optimize the function to generate expressions. Let's rewrite it to use a more efficient approach.

```python
def efficient_expression(digits, target):
    expr = str(digits[0])
    # Use a dynamic programming approach to compute the sum iteratively
    current_sum = digits[0]
    for digit in digits[1:]:
        # Try adding the digit
        if current_sum + digit <= target:
            expr += '+' + str(digit)
            current_sum += digit
        # If adding the digit exceeds the target, try subtracting it
        elif current_sum - digit >= -target:
            expr += '-' + str(digit)
            current_sum -= digit
        else:
            return '0'
    return expr if current_sum == target else '0'

# Write the efficient function to find the expression
expression = efficient_expression(digits, N)

# Write to the output file
with open('adunscad.out', 'w') as f:
    f.write(expression + '\n')
```

The above code is a more efficient version, but it does not necessarily find the correct expression for every case as it simply tries to add or subtract each digit in sequence. It is also not recursive and does not backtrack, which may be necessary for certain test cases. Also, the efficient version assumes that the order of digits in the input array is the order in which they must appear in the expression, which limits its ability to find some valid expressions. 

To optimize the space and time complexity, we need to backtrack and try different combinations without generating all possible expressions at once. Let's try a different approach with backtracking.
---------- user ----------


Program exited with code 1.
stdout:
```

```
stderr:
```
Traceback (most recent call last):
  File "/app/app.py", line 1, in <module>
    import numpy as np
ModuleNotFoundError: No module named 'numpy'

```

Think of what has caused the exit code. Use the standard out and standard error to help you understand the issue.
Implement a solution to fix the program

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The error message indicates that the `numpy` module is not available, but after reviewing the requirements, it is clear that `numpy` is not necessary for this problem. I will therefore remove the import statement for `numpy` and rewrite the solution without using any external libraries.

Here is the corrected solution:

```python
# This function will use backtracking to find the correct expression
def find_expression(target, digits, current_sum=0, index=0, expression=''):
    # If we have used all digits and current sum equals the target, solution found
    if index == len(digits) and current_sum == target:
        return expression
    # If all digits have been used but no solution, return None
    if index == len(digits):
        return None
    
    # Try to add the current digit
    expr_add = find_expression(target, digits, current_sum + digits[index], index + 1,
                               expression + ('+' if index > 0 else '') + str(digits[index]))
    if expr_add is not None:
        return expr_add
    
    # Try to subtract the current digit
    expr_subtract = find_expression(target, digits, current_sum - digits[index], index + 1,
                                    expression + '-' + str(digits[index]))
    if expr_subtract is not None:
        return expr_subtract
    
    # If both adding and subtracting the current digit don't lead to a solution, return None
    return None

# Read from the input file
with open('adunscad.in', 'r') as f:
    N, M = map(int, f.readline().split())
    digits = list(map(int, f.readline().split()))

# Find the expression using the backtracking function
expression = find_expression(N, digits)

# If no expression found, write 0 to the output file
with open('adunscad.out', 'w') as f:
    f.write(expression if expression is not None else '0')
```

By removing the `numpy` import and rewriting the implementation without it, we avoid the `ModuleNotFoundError`. The rewritten solution uses a backtracking approach, which should be both time and memory efficient for the given problem constraints. The solution also ensures that all digits appear in the resulting arithmetic expression in the same order they are read from the input file.
