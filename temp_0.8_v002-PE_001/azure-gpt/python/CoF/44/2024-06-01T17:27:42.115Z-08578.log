---------- user ----------

Here is a programming challenge.
Please solve this problem efficiently, optimizing both time and memory usage.
Create the most efficient solution for this challenge in python. Utilize numpy and other highly efficient libraries whenever possible.
This problem has a memory limit of ~8MB so please be sensitive on using memory. Using too much memory may result in OOM.
The code must compile and be correct.
The solution must read from `pm.in` and write to `pm.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

La o firmă de software se lucrează la un mare proiect. Proiectul constă în executarea a $n$ ($n \in \N$) faze de dezvoltare, numerotate cu numerele $1, 2, ..., n$. Unele faze pot fi executate în paralel (în acelaşi timp), însă executarea altor faze nu poate fi începută până când nu se finalizează executarea anumitor faze.

# Cerinţă
Să se scrie un program care să se determine:
a) timpul minim $t$ în care se poate finaliza executarea proiectului
b) pentru fiecare fază $k$ ($k \in \{1, 2, ..., n\}$), momentul de timp $c_k$ la care poate începe faza $k$ cel mai devreme, respectiv momentul de timp $d_k$ la care poate începe faza $k$ cel mai târziu, fără a influenţa durata totală de executare a proiectului.

# Date de intrare
Fişierul de intrare `pm.in`  conţine:
- pe prima linie, un număr natural $n$, reprezentând numărul fazelor proiectului
- pe a doua linie, $n$ numere naturale, separate prin câte un spaţiu, reprezentând timpul necesar finalizării fiecărei faze  
- pe fiecare linie $k$ dintre următoarele $n$ linii, un număr natural $m_k$ şi un şir $a$ format din $m_k$ numere naturale: $a_1, a_2, ..., a_{m_k}$, cele $m_{k+1}$ numere din linie fiind separate prin câte un spaţiu, $m_k$ reprezentând numărul de faze ce trebuie finalizate înaintea începerii fazei $k$, iar numerele din şirul $a$ reprezentând numerele de ordine ale fazelor ce trebuie finalizate înaintea începerii fazei $k$. 

# Date de ieşire
Fişierul de ieşire `pm.out` va conţine $n + 1$ linii. Pe prima linie se va scrie numărul natural $t$, iar pe fiecare linie $k$ dintre următoarele $n$ linii, se vor scrie cele două numere naturale $c_k$ şi $d_k$, separate prin câte un spaţiu. 

# Restricţii şi precizări
* $0 ≤ n ≤ 100$; $n \in \N$
* Timpul necesar finalizării executării oricărei faze nu va depăşi $1\ 000\ 000$
* Se consideră că executarea proiectului începe la momentul de timp $0$
* Nu vor exista dependenţe circulare (proiectul întotdeauna se poate finaliza)
* Pentru rezolvarea cerinţei a) se acordă $40%$ din punctaj, iar pentru cerinţa b) $30%$ pentru prima valoare respectiv $30%$ din punctaj pentru a doua valoare.

---

Example:
`pm.in`
```
7
2 3 5 3 3 3 2
0
0
1 2
1 1
1 1
3 3 4 5
1 3
```

`pm.out`
```
11
0 3
0 0
3 3 
2 5
2 5
8 8
8 9
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```markdown
```python
import numpy as np

# Function to perform topological sorting and finding earliest and latest start times
def schedule_tasks(num_tasks, durations, dependencies):
    # Initialize arrays to store in-degrees, earliest and latest start times
    in_degrees = np.zeros(num_tasks, dtype=int)
    earliest_start = np.zeros(num_tasks, dtype=int)
    latest_start = np.zeros(num_tasks, dtype=int)
    latest_start.fill(float('inf'))
    
    # Create a list to represent the graph and populate in-degrees
    graph = [[] for _ in range(num_tasks)]
    for i, deps in enumerate(dependencies):
        in_degrees[i] = len(deps)
        for dep in deps:
            graph[dep-1].append(i)
    
    # Perform topological sorting using Kahn's algorithm and calculate earliest start times
    queue = []
    for i in range(num_tasks):
        if in_degrees[i] == 0:
            queue.append(i)
    
    while queue:
        cur_task = queue.pop(0)
        for next_task in graph[cur_task]:
            in_degrees[next_task] -= 1
            if in_degrees[next_task] == 0:
                queue.append(next_task)
            # Update the earliest start time for next_task
            earliest_start[next_task] = max(earliest_start[next_task], earliest_start[cur_task] + durations[cur_task])
    
    # Calculate latest start times (backwards)
    max_time = max(earliest_start + durations)
    for i in range(num_tasks):
        if not graph[i]:
            latest_start[i] = max_time - durations[i]
    
    for task in range(num_tasks-1, -1, -1):
        for next_task in graph[task]:
            latest_start[task] = min(latest_start[task], latest_start[next_task] - durations[task])
    
    latest_start[latest_start == float('inf')] = 0  # Fix the inf values for tasks with no dependencies
    
    return max_time, earliest_start, latest_start

# Read input
with open('pm.in', 'r') as f:
    num_tasks = int(f.readline().strip())
    durations = np.array(f.readline().split(), dtype=int)
    dependencies = [list(map(int, f.readline().split()[1:])) for _ in range(num_tasks)]

# Process tasks and write output
max_time, earliest_start, latest_start = schedule_tasks(num_tasks, durations, dependencies)
with open('pm.out', 'w') as f:
    f.write(f"{max_time}\n")
    for c_k, d_k in zip(earliest_start, latest_start):
        f.write(f"{c_k} {d_k}\n")
```
```
---------- user ----------


Expected program to write result to `pm.out` and read from `pm.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

def find_earliest_latest_starts(n, durations, dependencies):
    earliest_start = np.zeros(n, dtype=int)
    latest_start = np.zeros(n, dtype=np.int32)
    latest_start.fill(np.iinfo(np.int32).max)  # Fill with max int32 value
    in_degree = np.zeros(n, dtype=int)
    for deps in dependencies:
        for dep in deps:
            in_degree[dep - 1] += 1

    queue = [i for i in range(n) if in_degree[i] == 0]    
    for node in queue:
        for dep in dependencies[node]:
            in_degree[dep - 1] -= 1
            if in_degree[dep - 1] == 0:
                queue.append(dep - 1)
            earliest_start[dep - 1] = max(earliest_start[dep - 1], earliest_start[node] + durations[node])

    max_duration = max(earliest_start + durations)
    for node in reversed(queue):
        if not dependencies[node]:
            latest_start[node] = max_duration - durations[node]
        for dep in dependencies[node]:
            latest_start[node] = min(latest_start[node], latest_start[dep - 1] - durations[node])
    
    # Set the latest starts that were not updated from max int to 0
    latest_start[latest_start == np.iinfo(np.int32).max] = 0

    return earliest_start, latest_start, max_duration

# Read from pm.in
with open('pm.in', 'r') as file:
    n = int(file.readline().strip())
    durations = np.array(file.readline().strip().split(), dtype=int)
    dependencies = [[] for _ in range(n)]
    for i in range(n):
        line = list(map(int, file.readline().strip().split()))
        if line[0] > 0:
            dependencies[i].extend(line[1:])

# Calculate earliest and latest starts
earliest_start, latest_start, max_duration = find_earliest_latest_starts(n, durations, dependencies)

# Write to pm.out
with open('pm.out', 'w') as file:
    file.write(f"{max_duration}\n")
    for c, d in zip(earliest_start, latest_start):
        file.write(f"{c} {d}\n")
```
```
---------- user ----------


Expected program to write result to `pm.out` and read from `pm.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

def calculate_project_schedule(n, task_durations, task_dependencies):
    earliest_start_times = np.zeros(n, dtype=int)
    latest_start_times = np.zeros(n, dtype=int)
    in_degrees = np.zeros(n, dtype=int)

    for i in range(n):
        for dep in task_dependencies[i]:
            in_degrees[dep - 1] += 1

    queue = [i for i in range(n) if in_degrees[i] == 0]

    while queue:
        current_task = queue.pop(0)
        for dependent_task in task_dependencies[current_task]:
            in_degrees[dependent_task - 1] -= 1
            if in_degrees[dependent_task - 1] == 0:
                queue.append(dependent_task - 1)
            earliest_start_times[dependent_task - 1] = max(
                earliest_start_times[dependent_task - 1],
                earliest_start_times[current_task] + task_durations[current_task]
            )

    total_project_time = max(earliest_start_times + task_durations)
    latest_start_times.fill(total_project_time)

    for task in range(n - 1, -1, -1):
        if not task_dependencies[task]:
            latest_start_times[task] -= task_durations[task]
        for dependent_task in task_dependencies[task]:
            latest_start_times[dependent_task - 1] = min(
                latest_start_times[dependent_task - 1],
                latest_start_times[task] - task_durations[dependent_task - 1]
            )

    return total_project_time, earliest_start_times, latest_start_times

# Reading from 'pm.in'
with open('pm.in', 'r') as file:
    n = int(file.readline().strip())
    task_durations = np.fromstring(file.readline().strip(), dtype=int, sep=' ')
    task_dependencies = []
    for _ in range(n):
        line = file.readline().strip().split()
        m = int(line[0])
        dependencies = [int(x) - 1 for x in line[1:]] if m > 0 else []
        task_dependencies.append(dependencies)

total_project_time, earliest_start_times, latest_start_times = calculate_project_schedule(n, task_durations, task_dependencies)

# Writing to 'pm.out'
with open('pm.out', 'w') as file:
    file.write(f'{total_project_time}\n')
    for earliest, latest in zip(earliest_start_times, latest_start_times):
        file.write(f'{earliest} {latest}\n')
```
```
---------- user ----------


Expected program to write result to `pm.out` and read from `pm.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

def read_input(file_path):
    with open(file_path, 'r') as file:
        n = int(file.readline())
        durations = np.fromstring(file.readline(), dtype=int, sep=' ')
        dependencies = [list(map(int, line.split()[1:])) for line in file]
    return n, durations, dependencies

def write_output(file_path, project_time, earliest_starts, latest_starts):
    with open(file_path, 'w') as file:
        file.write(f"{project_time}\n")
        for c_k, d_k in zip(earliest_starts, latest_starts):
            file.write(f"{c_k} {d_k}\n")

def find_critical_path(n, durations, dependencies):
    earliest = np.zeros(n, dtype=int)
    latest = np.full(n, -1, dtype=int)
    indegree = np.zeros(n, dtype=int)
    for i in range(n):
        for dep in dependencies[i]:
            indegree[dep-1] += 1
    stack = [i for i in range(n) if indegree[i] == 0]
    while stack:
        node = stack.pop()
        for next_node in dependencies[node]:
            indegree[next_node-1] -= 1
            if indegree[next_node-1] == 0:
                stack.append(next_node-1)
            earliest[next_node-1] = max(earliest[next_node-1], earliest[node] + durations[node])
    project_time = max(earliest + durations)
    latest[earliest == project_time - durations] = project_time - durations[earliest == project_time - durations]
    
    for node in reversed(stack):
        if latest[node] == -1:
            latest[node] = project_time - durations[node]
        for next_node in dependencies[node]:
            if latest[next_node-1] == -1 or latest[next_node-1] > latest[node] - durations[next_node-1]:
                latest[next_node-1] = latest[node] - durations[next_node-1]
    latest[latest == -1] = 0
    return project_time, earliest, latest

n, durations, dependencies = read_input('pm.in')
project_time, earliest_starts, latest_starts = find_critical_path(n, durations, dependencies)
write_output('pm.out', project_time, earliest_starts, latest_starts)
```
```
---------- user ----------


Expected program to write result to `pm.out` and read from `pm.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Reading from 'pm.in'
with open('pm.in', 'r') as file:
    n = int(file.readline().strip())
    durations = np.array(file.readline().strip().split(), dtype=int)
    dependencies = [[] for _ in range(n)]
    for i in range(n):
        line = file.readline().strip().split()
        if len(line) > 1:
            dependencies[i] = list(map(lambda x: int(x) - 1, line[1:]))

earliest_start = np.zeros(n, dtype=int)
latest_start = np.full(n, -1, dtype=int)
in_degree = np.zeros(n, dtype=int)
for i in range(n):
    for dep in dependencies[i]:
        in_degree[dep] += 1

# Topological Sort (Kahn's Algorithm)
queue = [i for i in range(n) if in_degree[i] == 0]
for task in queue:
    for dep in dependencies[task]:
        in_degree[dep] -= 1
        if in_degree[dep] == 0:
            queue.append(dep)
        earliest_start[dep] = max(earliest_start[dep], earliest_start[task] + durations[task])

# Calculate the total time to finish the project
project_total_time = max(earliest_start + durations)

# Calculate the latest start time
for task in reversed(queue):
    if len(dependencies[task]) == 0:
        latest_start[task] = project_total_time - durations[task]
    else:
        min_latest_start = min([latest_start[d] for d in dependencies[task]])
        latest_start[task] = min_latest_start - durations[task]

# If not set, the latest start is the same as the earliest
for i in range(n):
    if latest_start[i] == -1:
        latest_start[i] = earliest_start[i]

# Writing to 'pm.out'
with open('pm.out', 'w') as file:
    file.write(f"{project_total_time}\n")
    for e, l in zip(earliest_start, latest_start):
        file.write(f"{e} {l}\n")
```
```
---------- user ----------


Expected program to write result to `pm.out` and read from `pm.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

def calculate_scheduling(n, durations, predecessors):
    # Initialize earliest and latest start times
    earliest_start = np.zeros(n, dtype=int)
    latest_start = np.full(n, np.iinfo(np.int32).max, dtype=int)  # Set to max int initially

    # Calculate in-degrees
    in_degree = np.zeros(n, dtype=int)
    for deps in predecessors:
        for dep in deps:
            in_degree[dep] += 1

    # Topological sort
    stack = [i for i in range(n) if in_degree[i] == 0]

    while stack:
        node = stack.pop()
        for next_node in predecessors[node]:
            in_degree[next_node] -= 1
            if in_degree[next_node] == 0:
                stack.append(next_node)
            earliest_start[next_node] = max(earliest_start[next_node], earliest_start[node] + durations[node])

    # Calculate total project duration
    project_duration = max(earliest_start + durations)

    # Calculate latest start times
    for node in reversed(stack):
        if not predecessors[node]:
            latest_start[node] = project_duration - durations[node]
        for pred in predecessors[node]:
            latest_start[pred] = min(latest_start[pred], latest_start[node] - durations[pred])

    # Any tasks that still have max int as latest start time can start at their earliest time
    latest_start[latest_start == np.iinfo(np.int32).max] = earliest_start[latest_start == np.iinfo(np.int32).max]

    return project_duration, earliest_start, latest_start

# Read input from 'pm.in'
with open('pm.in', 'r') as file_input:
    n = int(file_input.readline())
    durations = np.fromstring(file_input.readline(), sep=' ', dtype=int)
    predecessors = [[] for _ in range(n)]
    for i in range(n):
        line = file_input.readline().strip().split()
        if len(line) > 1:
            predecessors[i] = [int(x) - 1 for x in line[1:]]

# Calculate scheduling
project_duration, earliest_start, latest_start = calculate_scheduling(n, durations, predecessors)

# Write output to 'pm.out'
with open('pm.out', 'w') as file_output:
    file_output.write(f'{project_duration}\n')
    for es, ls in zip(earliest_start, latest_start):
        file_output.write(f'{es} {ls}\n')
```
```
---------- user ----------


Expected program to write result to `pm.out` and read from `pm.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Read data from file
with open('pm.in', 'r') as f:
    n = int(f.readline())
    durations = np.array(f.readline().split(), dtype=int)
    dependencies = [[] for _ in range(n)]
    for i in range(n):
        line = f.readline().split()
        dependencies[i] = [int(dep) - 1 for dep in line[1:]]

# Helper arrays for the processing phase
incoming = np.zeros(n, dtype=int)
earliest_start = np.zeros(n, dtype=int)
latest_start = np.zeros(n, dtype=int)
for i, deps in enumerate(dependencies):
    for dep in deps:
        incoming[dep] += 1

# Kahn's algorithm for topological sorting
top_order = []
queue = [i for i in range(n) if incoming[i] == 0]
while queue:
    node = queue.pop(0)
    top_order.append(node)
    for m in dependencies[node]:
        incoming[m] -= 1
        if incoming[m] == 0:
            queue.append(m)
        # Calculate the earliest start time
        earliest_start[m] = max(earliest_start[m], earliest_start[node] + durations[node])

# Calculate the total project time
total_time = max(earliest_start + durations)

# Calculate the latest start time
latest_start.fill(total_time - durations)
for node in reversed(top_order):
    for m in dependencies[node]:
        latest_start[node] = min(latest_start[node], latest_start[m] - durations[node])

# Write data to file
with open('pm.out', 'w') as f:
    f.write(str(total_time) + '\n')
    for c, d in zip(earliest_start, latest_start):
        f.write(f'{c} {d}\n')
```
```
