---------- user ----------

Here is a programming challenge.
Please solve this problem efficiently, optimizing both time and memory usage.
Create the most efficient solution for this challenge in python. Utilize numpy and other highly efficient libraries whenever possible.
This problem has a memory limit of ~8MB so please be sensitive on using memory. Using too much memory may result in OOM.
The code must compile and be correct.
The solution must read from `tablou.in` and write to `tablou.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Se consideră un tablou cu N linii și N coloane (numerotate de la $1$ la $N$) care conține valoarea $1$ în fiecare dintre cele $N \ cdot N$ celule. Valorile din tablou pot fi modificate prin aplicarea a două operații codificate astfel:

* $L \ nr$, prin care se schimbă simultan toate semnele numerelor din linia cu numărul $nr$.
* $C \ nr$, prin care se schimbă simultan toate semnele numerelor din coloana cu numărul $nr$.

# Cerință
1. Dându-se o succesiune de $K$ operații ($L \ nr$ sau $C \ nr$) asupra liniilor/coloanelor tabloului inițial (în care toate celulele conțin valoarea $1$) să se determine numărul valorilor pozitive din tablou la finalul executării celor $K$ operații.
2. Să se determine numărul minim de operații $L \ nr$ sau $C \ nr$, care, aplicate tabloului inițial, îl modifică astfel încât tabloul obținut să conțină exact $Z$ valori negative.

# Date de intrare

Fișierul de intrare `tablou.in` conține pe prima linie numărul $p = 1$ sau $p = 2$, reprezentând numărul cerinței ce trebuie rezolvată.

* Dacă $p = 1$ atunci linia a doua a fișierului de intrare conține numerele $N$ și $K$, separate printr-un spațiu, iar următoarele $K$ linii conțin fiecare câte o literă mare ($L$ sau $C$) și un număr $nr$, separate printr-un spațiu, reprezentând codificarea uneia dintre cele două operații ($L \ nr$ sau $C \ nr$).
* Dacă $p = 2$ atunci linia a doua a fișierului de intrare conține numerele $N$ și $Z$, separate printr-un spațiu.

# Date de ieșire

* Dacă $p = 1$, atunci fișierul de ieșire `tablou.out` conține pe prima linie un număr natural, reprezentând numărul valorilor pozitive din tabloul obținut la finalul executării celor $K$ operații asupra tabloului inițial (răspunsul la cerința $1$).
* Dacă $p = 2$, atunci fișierul de ieșire `tablou.out` conține pe prima linie un număr natural reprezentând numărul minim de operații $L \ nr$ sau $C \ nr$, care, aplicate tabloului inițial, îl modifică astfel încât tabloul obținut să conțină exact $Z$ valori negative (răspunsul la cerința $2$). Dacă prin aplicarea de operații $L \ nr$ sau $C \ nr$ tabloului inițial nu se poate obține un tablou cu $Z$ valori negative, atunci, fișierul va conține pe prima linie valoarea $0$ (zero).

# Restricții și precizări

* $N, K, Z$ și $nr$ sunt numere naturale
* $3 \leq N \leq 20 \ 000$; $1 \leq K \leq 43 \ 000$; $1 \leq Z \leq N \cdot N$; $1 \leq nr \leq N$;
* Prin schimbare de semn, valoarea $-1$ se transformă în $1$ și valoarea $1$ se transformă în $-1$
* Se acordă $10$ puncte din oficiu și câte $45$ de puncte pentru rezolvarea corectă a fiecărei cerințe.

---

Example:
`tablou.in`
```
1
4 4
L 1
L 3
C 1
L 1
```

`tablou.out`
```
10
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```markdown
```python
import numpy as np

def read_input(file_name):
    with open(file_name, 'r') as file:
        lines = file.readlines()
    return lines

def write_output(file_name, result):
    with open(file_name, 'w') as file:
        file.write(str(result) + '\n')

def problem_type_1(N, K, operations):
    # Initialize arrays to keep track of flips for rows and columns
    rows = np.zeros(N, dtype=int)
    cols = np.zeros(N, dtype=int)
    
    # Apply operations
    for op, idx in operations:
        idx -= 1  # Convert to 0-indexed
        if op == 'L':
            rows[idx] ^= 1
        elif op == 'C':
            cols[idx] ^= 1
    
    # Count positive values
    pos_count = np.sum((rows[:, None] ^ cols) == 0)
    return pos_count

def problem_type_2(N, Z):
    # The minimum number of operations to make Z cells negative can be found by 
    # flipping the smallest number of rows or columns that cover Z cells.
    # We can always achieve any Z from 1 to N*N.
    
    # If Z is larger than half of the total cells, it's more efficient to flip the
    # entire matrix and count the positive cells instead.
    total_cells = N * N
    if Z > total_cells // 2:
        Z = total_cells - Z 
    
    # Try flipping rows or columns greedily
    rows_or_cols_to_flip = 0
    cells_covered = 0
    for i in range(1, N + 1):
        new_cells_covered = cells_covered + 2*i - 1
        if new_cells_covered >= Z:
            rows_or_cols_to_flip = i
            break
        cells_covered = new_cells_covered

    return rows_or_cols_to_flip

def main():
    lines = read_input('tablou.in')
    p = int(lines[0])
    N, second_param = map(int, lines[1].split())
    
    if p == 1:
        operations = [line.split() for line in lines[2:]]
        operations = [(op[0], int(op[1])) for op in operations]
        result = problem_type_1(N, second_param, operations)
    elif p == 2:
        result = problem_type_2(N, second_param)
    
    write_output('tablou.out', result)

if __name__ == "__main__":
    main()
```
```
---------- user ----------


Expected program to write result to `tablou.out` and read from `tablou.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

def problem_type_1(N, operations):
    # Initialize arrays to keep track of flips for rows and columns
    row_flips = np.zeros(N, dtype=int)
    col_flips = np.zeros(N, dtype=int)
    
    # Apply operations
    for op, idx in operations:
        if op == 'L':
            row_flips[idx - 1] ^= 1
        elif op == 'C':
            col_flips[idx - 1] ^= 1
    
    # Calculate the number of positive values after all operations
    # For each cell, it is positive if the number of flips on its row and column is even
    positive_cells = (N - np.sum(row_flips)) * np.sum(col_flips) + np.sum(row_flips) * (N - np.sum(col_flips))
    return positive_cells

def problem_type_2(N, Z):
    # If Z is greater than half the matrix, it's better to count the non-flipped cells
    if Z > N * N // 2:
        Z = N * N - Z
        
    # A full row or column flip affects N cells
    # To find the number of operations, we can divide Z by N and round up
    operations = (Z + N - 1) // N  # This is equivalent to ceil(Z / N)
    
    return operations

def main():
    # Read input
    with open('tablou.in', 'r') as f:
        p = int(f.readline().strip())
        N, K_or_Z = map(int, f.readline().strip().split())
        if p == 1:
            operations = [tuple(line.strip().split()) for line in f.readlines()]
            operations = [(op, int(nr)) for op, nr in operations]
    
    # Solve the problem
    if p == 1:
        result = problem_type_1(N, operations)
    elif p == 2:
        result = problem_type_2(N, K_or_Z)
    
    # Write output
    with open('tablou.out', 'w') as f:
        f.write(str(result) + '\n')

if __name__ == "__main__":
    main()
```
```

---------- user ----------


Expected program to write result to `tablou.out` and read from `tablou.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Function to calculate the number of positive values after operations
def calculate_positive_values(N, row_changes, col_changes):
    # Count how many times each row and column has been flipped
    row_flips = np.zeros(N, dtype=int)
    col_flips = np.zeros(N, dtype=int)
    for change_type, idx in row_changes + col_changes:
        if change_type == 'L':
            row_flips[idx - 1] ^= 1
        elif change_type == 'C':
            col_flips[idx - 1] ^= 1

    # Calculate the number of positives by determining the parity of flips
    positive_count = np.count_nonzero(row_flips[:, None] == col_flips)
    return positive_count

# Function to calculate the minimum number of operations to get Z negative values
def calculate_min_operations(N, Z):
    # Since flipping a row or column twice is a no-op, we cannot have more than 2N flips
    if Z > N*N or Z < 0:
        return 0  # It's impossible to get Z negative values

    # Count the number of negatives in each row and column
    negatives_per_row = min(Z // N, N)
    remaining_negatives = Z - negatives_per_row * N

    # If we need more negatives, we flip the necessary number of columns
    min_operations = negatives_per_row + (1 if remaining_negatives > 0 else 0)
    return min_operations

# Read input
with open('tablou.in', 'r') as file:
    problem_type = int(file.readline().strip())
    N, second_value = map(int, file.readline().strip().split())

    if problem_type == 1:
        operations = [file.readline().strip().split() for _ in range(second_value)]
        operations = [(op, int(nr)) for op, nr in operations]
        row_changes = [(op, nr) for op, nr in operations if op == 'L']
        col_changes = [(op, nr) for op, nr in operations if op == 'C']
        result = calculate_positive_values(N, row_changes, col_changes)
    elif problem_type == 2:
        result = calculate_min_operations(N, second_value)

# Write output
with open('tablou.out', 'w') as file:
    file.write(str(result) + '\n')
```
```

---------- user ----------


Expected program to write result to `tablou.out` and read from `tablou.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
# Import the numpy library for efficient array operations
import numpy as np

# Main function to handle both problem types
def main():
    # Open the input file and read the problem type and other parameters
    with open('tablou.in', 'r') as file:
        p = int(file.readline().strip())
        N, second_value = map(int, file.readline().strip().split())
        if p == 1:
            operations = [tuple(file.readline().strip().split()) for _ in range(second_value)]

    if p == 1:
        # Initialize counters for row and column inversions
        row_inversions = np.zeros(N, dtype=int)
        col_inversions = np.zeros(N, dtype=int)
        
        # Apply each operation by flipping the corresponding row or column counter
        for op_type, index in operations:
            index = int(index) - 1 # Convert to zero-based index
            if op_type == 'L':
                row_inversions[index] ^= 1
            elif op_type == 'C':
                col_inversions[index] ^= 1
        
        # Count the number of positive values by analyzing the parity of the inversions
        positive_count = N * N - np.sum(row_inversions) * N - np.sum(col_inversions) * N + 2 * np.sum(row_inversions) * np.sum(col_inversions)
        result = positive_count
    else: # p == 2
        # Start with zero operations and incrementally add operations while tracking the number of negative cells
        operations = 0
        negative_cells = 0
        while negative_cells < second_value and operations < N:
            operations += 1
            negative_cells += min(N, second_value - negative_cells)
        
        # If we have not reached the desired number of negative cells, it's impossible
        if negative_cells != second_value:
            result = 0
        else:
            result = operations

    # Write the result to the output file
    with open('tablou.out', 'w') as file:
        file.write(str(result) + '\n')

# Call the main function to execute the program
if __name__ == '__main__':
    main()
```
```

---------- user ----------


Expected program to write result to `tablou.out` and read from `tablou.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

def solve_problem_1(N, operations):
    # Initialize row and column masks
    row_mask = np.zeros(N, dtype=bool)
    col_mask = np.zeros(N, dtype=bool)

    # Apply operations
    for op, idx in operations:
        if op == 'L':
            row_mask[idx - 1] = ~row_mask[idx - 1]
        elif op == 'C':
            col_mask[idx - 1] = ~col_mask[idx - 1]

    # Calculate final positive values
    positive_values = N * N - np.sum(row_mask) * N - np.sum(col_mask) * N + 2 * np.sum(row_mask) * np.sum(col_mask)
    return positive_values

def solve_problem_2(N, Z):
    # If we need more negative values than half the matrix, it's easier to flip everything and subtract
    if Z > N * N // 2:
        Z = N * N - Z

    # Find minimum number of operations
    # Flip the entire rows or columns if needed
    operations = min(Z // N, N)
    Z -= operations * N

    # Flip individual rows/columns if some negatives still needed
    if Z > 0:
        operations += 1

    return operations

def read_input_and_solve():
    # Read input
    with open('tablou.in', 'r') as file:
        p = int(file.readline())
        N, second_param = map(int, file.readline().split())
        if p == 1:
            operations = [tuple(file.readline().split()) for _ in range(second_param)]

    # Solve based on the problem type
    if p == 1:
        result = solve_problem_1(N, operations)
    else:  # p == 2
        result = solve_problem_2(N, second_param)

    # Write output
    with open('tablou.out', 'w') as file:
        file.write(str(result))

# Run the program
read_input_and_solve()
```
```
---------- user ----------


Expected program to write result to `tablou.out` and read from `tablou.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Read the input from the file
with open('tablou.in', 'r') as f:
    p = int(f.readline())
    N, second_param = map(int, f.readline().split())
    operations = [f.readline().split() for _ in range(second_param)] if p == 1 else []

# Initialize the numpy arrays to keep track of the operations
row_flips = np.zeros(N, dtype=int)
col_flips = np.zeros(N, dtype=int)

# Depending on the problem type, process the operations or calculate the result
if p == 1:
    for operation in operations:
        op_type, index = operation
        index = int(index) - 1  # Adjust index to be zero-based
        if op_type == 'L':
            row_flips[index] ^= 1
        elif op_type == 'C':
            col_flips[index] ^= 1
    # Calculate the number of positive values remaining in the table
    result = np.count_nonzero(row_flips[:, None] ^ col_flips == 0)
else:
    # For problem type 2, calculate the minimum number of operations to get the desired number of negative values
    Z = second_param
    row_ops = min(Z // N, N)  # Maximum number of row operations that can be used
    col_ops = min(Z % N, N)   # Maximum number of column operations that can be used
    # If the entire matrix needs to be flipped, one operation is removed
    total_ops = row_ops + (col_ops if col_ops else (-1 if row_ops == N else 0))
    result = total_ops

# Write the output to the file
with open('tablou.out', 'w') as f:
    f.write(str(result) + '\n')
```
```
---------- user ----------


Expected program to write result to `tablou.out` and read from `tablou.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

def main():
    with open('tablou.in', 'r') as file:
        p = int(file.readline().strip())
        N, K_or_Z = map(int, file.readline().strip().split())
        
        if p == 1:
            K = K_or_Z
            row_changes = np.zeros(N, dtype=bool)
            col_changes = np.zeros(N, dtype=bool)
            
            for _ in range(K):
                operation, index = file.readline().strip().split()
                index = int(index) - 1  # Convert to zero-based index
                
                if operation == 'L':
                    row_changes[index] = not row_changes[index]
                elif operation == 'C':
                    col_changes[index] = not col_changes[index]
            
            # Compute the number of positive values in the matrix
            result = np.count_nonzero(row_changes) * np.count_nonzero(~col_changes) \
                     + np.count_nonzero(~row_changes) * np.count_nonzero(col_changes)
            result = N * N - result  # Subtract from total to get positives
        else:
            Z = K_or_Z
            # Compute the minimum number of operations to have exactly Z negative values
            if Z > N * N:
                result = 0
            else:
                row_operations = min(Z // N, N)
                col_operations = 0 if row_operations == N else Z % N
                result = row_operations + (1 if col_operations > 0 else 0)

    with open('tablou.out', 'w') as file:
        file.write(str(result) + '\n')

if __name__ == '__main__':
    main()
```
```
