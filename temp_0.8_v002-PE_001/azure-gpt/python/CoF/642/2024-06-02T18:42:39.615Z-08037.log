---------- user ----------

Here is a programming challenge.
Please solve this problem efficiently, optimizing both time and memory usage.
Create the most efficient solution for this challenge in python. Utilize numpy and other highly efficient libraries whenever possible.
This problem has a memory limit of ~8MB so please be sensitive on using memory.Using unavoided memory may result in OOM.
The code must compile and be correct.
The solution must read from `oneout.in` and write to `oneout.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Definim un număr ***liber de pătrate*** ca fiind un număr natural care nu are ca divizor niciun pătrat perfect mai mare ca $1$. Prin convenție, $1$ este considerat *liber de pătrate*.

Așadar, șirul numerelor *libere de pătrate* este: $1, 2, 3, 5, 6, 7, 10, 11, 13, 14, 15, 17, \dots$

Se consideră un șir de $N$ numere naturale $X_i$, $1 \leq i \leq N$, unde $N$ este un număr natural.

Definim o ***bisecvență*** ca un subșir nevid obținut prin eliminarea dintr-o secvență a unui număr care nu este la începutul sau la sfârșitul secvenței.

# Cerințe
1) Să se determine câte numere *libere de pătrate* conține șirul dat.
2) Să se determine cea mai lungă *bisecvență* din șir formată din numere *libere de pătrate*, obținută prin eliminarea unui număr care **nu** este *liber de pătrate*.

# Date de intrare
Fișierul de intrare `oneout.in` conține pe prima linie un număr natural $C$, care poate fi doar $1$ sau $2$, reprezentând cerința, pe a doua linie numărul natural $N$ iar pe a treia linie $N$ numere naturale, separate prin câte un spațiu, cu semnificația de mai sus.

# Date de ieșire
Dacă $C$ este egal cu $1$, în fișierul de ieșire `oneout.out` se va scrie numărul de numere *libere de pătrate* din șir.

Dacă $C$ este egal cu $2$:
- Pe prima linie a fișierului de ieșire `oneout.out` se vor scrie două numere $L$ și $K$ despărțite printr-un spațiu, unde $L$ reprezintă lungimea maximă a unei *bisecvențe* cu proprietățile cerute, iar $K$ reprezintă numărul de *bisecvențe* de lungime maximă existente în șir.
- Pe următoarele $K$ linii se vor scrie indicii de început și de sfârșit ai fiecărei *bisecvențe* de lungime maximă găsite, în ordinea crescătoare a indicelui de start, despărțite printr-un spațiu.
- Dacă șirul nu conține nicio *bisecvență* cu proprietățile cerute, în fișierul de ieșire se va scrie `-1`.

# Restricții și precizări
- $3 \leq N \leq 10^6$
- $2 \leq X_i \leq 10^6$, $1 \leq i \leq N$
- Lungimea unei *bisecvențe* reprezintă numărul de numere din aceasta.
- Pentru teste în valoare de 37 de puncte $C = 1$, din care pentru teste în valoare de 24 de puncte $3 \leq N \leq 25$.
- Pentru teste în valoare de 63 de puncte $C = 2$, din care pentru teste în valoare de 23 de puncte $3 \leq N \leq 101$.

---

Example:
`oneout.in`
```
1
6
10 2 12 7 8 15
```

`oneout.out`
```
4
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```markdown
```python
import numpy as np

# Utility function to find all square-free numbers up to the given limit
def find_square_free_numbers(limit):
    is_square_free = np.ones(limit + 1, dtype=bool)
    is_square_free[:2] = False
    for i in range(2, int(limit**0.5) + 1):
        square = i * i
        if square <= limit:
            is_square_free[square::square] = False
    return is_square_free

# Read problem parameters from input file
with open('oneout.in', 'r') as file:
    C = int(file.readline())
    N = int(file.readline())
    X = np.fromstring(file.readline(), dtype=int, sep=' ')

# Find all square-free numbers up to the max value in X
limit = X.max()
is_square_free = find_square_free_numbers(limit)

# Solve the problem based on the requirement C
if C == 1:
    # Count square-free numbers in the input sequence
    square_free_count = is_square_free[X].sum()
    # Write the result to the output file
    with open('oneout.out', 'w') as file:
        file.write(str(square_free_count))

elif C == 2:
    # Mark each number in the input sequence if it's square-free or not
    square_free_mask = is_square_free[X]

    # Initialize variables for the longest bisubsequence search
    max_len = 0
    bisubsequences = []

    # Perform the search for the longest bisubsequence
    start = 0
    for i in range(N):
        if not square_free_mask[i]:
            length = i - start
            if length > max_len:
                max_len = length
                bisubsequences = [(start + 1, i)]
            elif length == max_len:
                bisubsequences.append((start + 1, i))
            start = i + 1

    # Check the tail of the sequence
    length = N - start
    if length > max_len:
        bisubsequences = [(start + 1, N)]
    elif length == max_len and max_len != 0:
        bisubsequences.append((start + 1, N))

    # Write the results to the output file
    with open('oneout.out', 'w') as file:
        if max_len == 0:
            file.write('-1')
        else:
            file.write(f"{max_len} {len(bisubsequences)}\n")
            for bisub in bisubsequences:
                file.write(f"{bisub[0]} {bisub[1]}\n")
```
```
---------- user ----------


Expected program to write result to `oneout.out` and read from `oneout.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Utility function to find all square-free numbers up to the given limit
def find_square_free_numbers(limit):
    is_square_free = np.ones(limit + 1, dtype=bool)
    is_square_free[:2] = False
    for i in range(2, int(limit**0.5) + 1):
        square = i * i
        if square <= limit:
            is_square_free[square::square] = False
    return is_square_free

# Read problem parameters from input file
with open('oneout.in', 'r') as file:
    C = int(file.readline())
    N = int(file.readline())
    X = list(map(int, file.readline().split()))

# Find all square-free numbers up to the max value in X
limit = max(X)
is_square_free = find_square_free_numbers(limit)

# Solve the problem based on the requirement C
if C == 1:
    # Count square-free numbers in the input sequence
    square_free_count = sum(is_square_free[x] for x in X)
    # Write the result to the output file
    with open('oneout.out', 'w') as file:
        file.write(str(square_free_count) + '\n')

elif C == 2:
    # Initialize variables for the longest bisubsequence search
    max_len = 0
    bisubsequences = []

    # Perform the search for the longest bisubsequence
    start = 0
    for i in range(N):
        if not is_square_free[X[i]]:
            length = i - start
            if length > max_len:
                max_len = length
                bisubsequences = [(start + 1, i)]
            elif length == max_len and max_len > 0:
                bisubsequences.append((start + 1, i))
            start = i + 1

    # Check the tail of the sequence
    length = N - start
    if length > max_len:
        bisubsequences = [(start + 1, N)]
    elif length == max_len and max_len > 0:
        bisubsequences.append((start + 1, N))

    # Write the results to the output file
    with open('oneout.out', 'w') as file:
        if max_len == 0:
            file.write('-1\n')
        else:
            file.write(f"{max_len} {len(bisubsequences)}\n")
            for bisub in bisubsequences:
                file.write(f"{bisub[0]} {bisub[1]}\n")
```
```
---------- user ----------


Expected program to write result to `oneout.out` and read from `oneout.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Read input data from file
with open('oneout.in') as f:
    C = int(f.readline().strip())
    N = int(f.readline().strip())
    nums = np.fromfile(f, dtype=int, sep=' ', count=N)

# Helper function to check if a number is square-free
def is_square_free(n, squares):
    for square in squares:
        if square > n:
            break
        if n % square == 0:
            return False
    return True

# Precompute square numbers up to the largest number in the input
max_num = np.max(nums)
squares = np.array([i**2 for i in range(2, int(np.sqrt(max_num)) + 1)])

# Process the input based on the value of C
if C == 1:
    count = sum(is_square_free(num, squares) for num in nums)
    with open('oneout.out', 'w') as f:
        f.write(str(count) + '\n')

elif C == 2:
    square_free_sequence = [is_square_free(num, squares) for num in nums]

    max_length = 0
    max_count = 0
    current_length = 0
    bisubsequences = []
    
    for idx, is_free in enumerate(square_free_sequence):
        if is_free:
            current_length += 1
        else:
            if current_length > max_length:
                max_length = current_length
                max_count = 1
                bisubsequences = [(idx - current_length + 1, idx)]
            elif current_length == max_length and max_length > 0:
                max_count += 1
                bisubsequences.append((idx - current_length + 1, idx))
            current_length = 0

    # Check for the last sequence if it was not interrupted by a non-free number
    if current_length == max_length:
        max_count += 1
        bisubsequences.append((N - current_length + 1, N))
    elif current_length > max_length:
        max_length = current_length
        max_count = 1
        bisubsequences = [(N - current_length + 1, N)]

    with open('oneout.out', 'w') as f:
        if max_length == 0:
            f.write('-1\n')
        else:
            f.write(f'{max_length} {max_count}\n')
            for start, end in bisubsequences:
                f.write(f'{start} {end}\n')
```
```
---------- user ----------


Expected program to write result to `oneout.out` and read from `oneout.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Function to determine if a number is square-free
def is_square_free(num):
    if num < 2:
        return True
    for i in range(2, int(np.sqrt(num)) + 1):
        if num % (i * i) == 0:
            return False
    return True

# Function to find the longest bisubsequence of square-free numbers
def longest_bisubsequence(nums, is_square_free):
    max_len = 0
    current_len = 0
    start_idx = 0
    bisubsequences = []
    for i, num in enumerate(nums):
        if is_square_free(num):
            current_len += 1
        else:
            if current_len > max_len:
                bisubsequences = [(start_idx + 1, i)]
                max_len = current_len
            elif current_len == max_len:
                bisubsequences.append((start_idx + 1, i))
            current_len = 0
            start_idx = i + 1
    # Check for the last sequence
    if current_len > max_len:
        bisubsequences = [(start_idx + 1, len(nums))]
        max_len = current_len
    elif current_len == max_len and max_len > 0:
        bisubsequences.append((start_idx + 1, len(nums)))
    return max_len, bisubsequences

# Read input data from file
with open('oneout.in', 'rb') as file:
    C = int(file.readline())
    N = int(file.readline())
    nums = np.fromfile(file, dtype=np.int32, count=N, sep=' ')

# Process request based on the value of C
if C == 1:
    # Count square-free numbers in the input sequence
    count_square_free = np.vectorize(is_square_free)
    count = np.sum(count_square_free(nums))
    with open('oneout.out', 'w') as file:
        file.write(str(count))
elif C == 2:
    # Find the longest bisubsequence of square-free numbers
    max_len, bisubsequences = longest_bisubsequence(nums, is_square_free)
    with open('oneout.out', 'w') as file:
        if not bisubsequences:
            file.write('-1')
        else:
            file.write(f"{max_len} {len(bisubsequences)}\n")
            for start, end in bisubsequences:
                file.write(f"{start} {end}\n")
```
```
---------- user ----------


Expected program to write result to `oneout.out` and read from `oneout.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Utility function to generate a boolean array marking square-free numbers
def sieve_square_free(max_num):
    # Initially assume all numbers are square-free (True)
    is_square_free = np.ones(max_num + 1, dtype=bool)
    # Mark 0 and 1 as not square-free
    is_square_free[:2] = False
    # Start marking multiples of squares as not square-free
    for i in range(2, int(np.sqrt(max_num)) + 1):
        is_square_free[i * i::i * i] = False
    return is_square_free

# Read input data
with open('oneout.in', 'r') as file:
    C = int(file.readline().strip())
    N = int(file.readline().strip())
    X = np.array(file.readline().split(), dtype=int)

# Generate a sieve for square-free numbers up to the maximum number in X
max_val_in_X = np.max(X)
square_free_sieve = sieve_square_free(max_val_in_X)

# Task 1: Count square-free numbers in the sequence
if C == 1:
    count = np.sum(square_free_sieve[X])
    with open('oneout.out', 'w') as file:
        file.write(str(count))

# Task 2: Find the longest bisubsequence of square-free numbers
elif C == 2:
    # Initialize variables
    max_length = 0
    bisubsequences = []
    current_start = 0
    current_length = 0

    # Calculate the square-free status of all numbers in the sequence
    square_free_status = square_free_sieve[X]

    # Iterate over the sequence to find all bisubsequences
    for i in range(N):
        if square_free_status[i]:
            current_length += 1
        else:
            if current_length > max_length:
                max_length = current_length
                bisubsequences = [(current_start + 1, i)]
            elif current_length == max_length and current_length > 0:
                bisubsequences.append((current_start + 1, i))
            current_start = i + 1
            current_length = 0

    # Check for a bisubsequence at the end of the sequence
    if current_length > max_length:
        max_length = current_length
        bisubsequences = [(current_start + 1, N)]

    # Write the results
    with open('oneout.out', 'w') as file:
        if bisubsequences:
            file.write(f"{max_length} {len(bisubsequences)}\n")
            for start, end in bisubsequences:
                file.write(f"{start} {end}\n")
        else:
            file.write("-1")
```
```
---------- user ----------


Expected program to write result to `oneout.out` and read from `oneout.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Function to check if a number is square-free
def is_square_free(num, prime_squares):
    for ps in prime_squares:
        if ps > num:
            break
        if num % ps == 0:
            return False
    return True

# Function to precompute square-free flags for a given range of numbers
def precompute_square_free(max_value):
    prime_squares = [i**2 for i in range(2, int(np.sqrt(max_value)) + 1)]
    square_free_flags = np.array([is_square_free(i, prime_squares) for i in range(max_value + 1)])
    return square_free_flags

# Read input data from file
with open('oneout.in') as file:
    C = int(file.readline())
    N = int(file.readline())
    X = np.array(file.readline().split(), dtype=int)

# Precompute square-free flags up to the maximum value in X
max_value_in_X = np.max(X)
square_free_flags = precompute_square_free(max_value_in_X)

# Process the first requirement
if C == 1:
    square_free_count = np.sum(square_free_flags[X])
    with open('oneout.out', 'w') as file:
        file.write(str(square_free_count) + '\n')

# Process the second requirement
elif C == 2:
    # Initialize variables for determining the longest bisubsequence
    square_free_sequence = square_free_flags[X]
    max_len = -1
    max_sequences = []
    
    # Scan the sequence to find the longest bisubsequences
    i = 0
    while i < N:
        if square_free_sequence[i]:
            start = i
            while i < N and square_free_sequence[i]:
                i += 1
            length = i - start
            if length > max_len:
                max_len = length
                max_sequences = [(start + 1, i)]
            elif length == max_len:
                max_sequences.append((start + 1, i))
        i += 1

    # Write the results to the output file
    with open('oneout.out', 'w') as file:
        if max_len == -1:
            file.write('-1\n')
        else:
            file.write(f"{max_len} {len(max_sequences)}\n")
            for start, end in max_sequences:
                file.write(f"{start} {end}\n")
```
```
---------- user ----------


Expected program to write result to `oneout.out` and read from `oneout.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Function to check if a number is square-free. It must return an array of boolean values.
def is_square_free(numbers):
    max_val = np.max(numbers)
    sieve = np.ones(max_val + 1, dtype=bool)
    for i in range(2, int(np.sqrt(max_val)) + 1):
        sieve[i*i:max_val + 1:i*i] = False
    return sieve[numbers]

# Function to find the longest bisubsequence of square-free numbers
def find_longest_bisubsequence(square_free):
    max_len = 0
    current_len = 0
    max_sequences = []
    start = 0

    for i, is_free in enumerate(square_free):
        if is_free:
            current_len += 1
        else:
            if current_len > max_len:
                max_len = current_len
                max_sequences = [(start + 1, i)]
            elif current_len == max_len:
                max_sequences.append((start + 1, i))
            start = i + 1
            current_len = 0

    if current_len > max_len:
        max_len = current_len
        max_sequences = [(start + 1, len(square_free))]
    elif current_len == max_len and max_len > 0:
        max_sequences.append((start + 1, len(square_free)))

    return max_len, max_sequences

# Read input data
with open('oneout.in', 'r') as file:
    C = int(file.readline())
    N = int(file.readline())
    nums = np.array(file.readline().strip().split(), dtype=int)

# Determine if the numbers are square-free
square_free = is_square_free(nums)

# Solve the problem based on C and write the results
with open('oneout.out', 'w') as file:
    if C == 1:
        # Count the square-free numbers and write the result
        count = np.count_nonzero(square_free)
        file.write(f"{count}\n")
    elif C == 2:
        # Find the longest bisubsequence
        max_len, sequences = find_longest_bisubsequence(square_free)
        if max_len == 0:
            file.write("-1\n")
        else:
            # Write the length and the number of such sequences
            file.write(f"{max_len} {len(sequences)}\n")
            # Write each bisubsequence's start and end indices
            for start, end in sequences:
                file.write(f"{start} {end}\n")
```
