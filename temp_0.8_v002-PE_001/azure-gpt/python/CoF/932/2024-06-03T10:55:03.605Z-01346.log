---------- user ----------

Here is a programming challenge.
Please solve this problem efficiently, optimizing both time and memory usage.
Create the most efficient solution for this challenge in python. Utilize numpy and other highly efficient libraries whenever possible.
This problem has a memory limit of ~8MB so please be sensitive on using memory. Using too much memory may result in OOM.
The code must compile and be correct.
The solution must read from `formula1.in` and write to `formula1.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

La o cursă de Formula 1, fiecare echipă participantă își construiește propria mașină cu care va concura. Numerotarea mașinilor în concurs este realizată de organizatori cu ajutorul unor stegulețe pătrate ce conțin alternativ, pe fiecare rând (pe orizontală și verticală), pătrățele albe și negre de dimensiuni identice. În figura următoare sunt prezentate, în ordine, stegulețele primelor 4 mașini din concurs. Observăm că fiecare steguleț are cu două rânduri (pe orizontală și verticală) mai mult decât stegulețul precedent, iar în toate cele patru colțuri ale oricărui steguleț se află un pătrățel negru.

~[formula1.jpg]

# Cerință

Scrieți un program care citește două numere naturale $K$ și $N$ și determină:

1. Câte pătrățele albe și negre sunt în total pe stegulețul mașinii cu numărul $K$;
2. Notând cu $A$ numărul total de pătrățele albe de pe stegulețele primelor $N$ mașini din concurs, câte pătrățele albe și negre sunt în total pe cel mai mare steguleț care conține cel mult $A$ pătrățele albe.

# Date de intrare

Fișierul de intrare `formula1.in` conține pe prima linie un număr natural $C$. Pentru toate testele de intrare, numărul $C$ poate avea doar valoarea $1$ sau valoarea $2$ și reprezintă numărul cerinței care trebuie rezolvată. Pe a doua linie a fișierului `formula1.in` se găsesc, în ordine, numerele naturale $K$ și $N$.

# Date de ieșire

Dacă $C = 1$, se va rezolva cerința $1$. În acest caz, fișierul de ieșire `formula1.out` va conține pe prima linie un număr natural reprezentând numărul total de pătrățele existente pe stegulețul mașinii cu numărul $K$.
Dacă $C = 2$, se va rezolva cerința $2$. În acest caz, fișierul de ieșire `formula1.out` va conține pe prima linie un număr natural reprezentând numărul total de pătrățele existente pe cel mai mare steguleț ce conține cel mult $A$ pătrățele albe.

# Restricții și precizări

* $1 \leq K \leq 100 \ 000$;
* $1 \leq N \leq 500 \ 000$;
* Pentru rezolvarea corectă a primei cerințe se obțin $20$ de puncte, iar pentru rezolvarea corectă a celei de a doua cerințe se obțin $80$ de puncte.

---

Example:
`formula1.in`
```
1
3 4
```

`formula1.out`
```
25
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```markdown
```python
import numpy as np

def compute_white_black_squares(k):
    side_length = k*2 + 2
    total_squares = side_length ** 2
    white_squares = (side_length // 2) ** 2 * 2
    if side_length % 2 == 1:
        white_squares += side_length // 2
    black_squares = total_squares - white_squares
    return white_squares, black_squares

def compute_max_flag_size(a):
    # Initial size (2x2 flag)
    side_length = 2
    # The number of white squares in a 2x2 flag
    white_squares = 1
    while True:
        # Calculate the number of white squares for the next flag size
        next_side_length = side_length + 2
        next_white_squares = (next_side_length // 2) ** 2 * 2
        if next_side_length % 2 == 1:
            next_white_squares += next_side_length // 2
        if next_white_squares > a:
            break
        white_squares = next_white_squares
        side_length = next_side_length
    return side_length ** 2

def read_input():
    with open('formula1.in', 'r') as file:
        c = int(file.readline().strip())
        k, n = map(int, file.readline().strip().split())
    return c, k, n

def write_output(result):
    with open('formula1.out', 'w') as file:
        file.write(str(result) + '\n')

def solve_challenge():
    c, k, n = read_input()
    if c == 1:
        _, black_squares = compute_white_black_squares(k)
        total_squares = (k*2 + 2) ** 2
        write_output(total_squares)
    elif c == 2:
        a = sum(compute_white_black_squares(i)[0] for i in range(1, n+1))
        result = compute_max_flag_size(a)
        write_output(result)

# Run the solution
solve_challenge()
```
```
---------- user ----------


Expected program to write result to `formula1.out` and read from `formula1.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
# Import numpy for efficient array computations (if needed)
import numpy as np

def compute_white_black_squares(k):
    side_length = k*2 + 2
    total_squares = side_length ** 2
    white_squares = (side_length // 2) ** 2
    white_squares *= 2
    if side_length % 2 != 0:
        white_squares += side_length // 2
    black_squares = total_squares - white_squares
    return white_squares, black_squares

def compute_white_squares_total(n):
    # The formula for the sum of white squares in first n flags is derived from the pattern observed in the sequence.
    # Since the first flag has 1 white square, the second flag has 5, the third flag has 13 and so on,
    # we can infer the general term formula for the number of white squares in the k-th flag:
    # white_squares(k) = k^2 + (k-1)^2, which gives us the sequence: 1, 5, 13, 25, 41...
    # The sum of white squares up to the n-th term of the sequence can be computed by summing up the first n terms.
    return n**2 + (n-1)**2

def find_max_flag_with_white_squares(a):
    # To find the largest flag with at most 'a' white squares, we can use the inverse formula
    # derived from the white_squares function, and check for the largest k such that k^2 + (k-1)^2 <= a
    # This is a simple quadratic equation in terms of k, which can be solved to get the range of k.
    # However, we are only interested in the integral part of k, so we'll return the floor of the solution.
    # The equation is as follows: k^2 + (k-1)^2 = a => 2k^2 - 2k + 1 - a = 0, which is a quadratic in terms of k.
    # Solving for k using the quadratic formula, and considering only the positive root as the solution.
    k = int(np.floor((1 + np.sqrt(1 + 4 * 2 * a)) / 4))
    # Check if the computed k produces a sum of white squares more than a, if so, decrement k to get the correct number.
    if compute_white_squares_total(k) > a:
        k -= 1
    # The total number of squares in the flag is simply the side length squared.
    return (k*2 + 2)**2

def read_input(filename):
    with open(filename, 'r') as file:
        c = int(file.readline().strip())
        k, n = map(int, file.readline().strip().split())
    return c, k, n

def write_output(filename, result):
    with open(filename, 'w') as file:
        file.write(str(result) + '\n')

def main():
    c, k, n = read_input('formula1.in')
    if c == 1:
        total_squares = (k*2 + 2) ** 2
        write_output('formula1.out', total_squares)
    elif c == 2:
        total_white_squares = compute_white_squares_total(n)
        result = find_max_flag_with_white_squares(total_white_squares)
        write_output('formula1.out', result)

if __name__ == '__main__':
    main()
```
```
---------- user ----------


Expected program to write result to `formula1.out` and read from `formula1.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
def compute_squares(k):
    # Total squares on the k-th flag (each side has k*2 + 2 squares)
    total_squares = (k * 2 + 2) ** 2
    # Half the squares, minus the center if the flag size is odd
    white_squares = total_squares // 2 - (1 if (k * 2 + 2) % 2 == 1 else 0)
    return white_squares, total_squares - white_squares

def compute_max_flag_size(a, max_n):
    # Initial side length for the largest flag is 0
    side_length = 0
    # Initial number of white squares is 0
    total_white_squares = 0
    # Incrementally check larger flag sizes until we exceed the number of white squares 'a'
    for n in range(1, max_n + 1):
        white, _ = compute_squares(n)
        total_white_squares += white
        if total_white_squares <= a:
            side_length = n * 2 + 2
    # Return the total number of squares for the largest flag within 'a' white squares
    return side_length ** 2

def main():
    # Read task and numbers from 'formula1.in'
    with open('formula1.in', 'r') as input_file:
        c = int(input_file.readline().strip())
        k, n = map(int, input_file.readline().strip().split())

    # Perform the computation based on the task
    if c == 1:
        # Count squares for the k-th flag
        _, black_squares = compute_squares(k)
        result = (k * 2 + 2) ** 2
    else:
        # Compute the number of white squares for the first n flags
        result = compute_max_flag_size(compute_squares(n)[0], n)

    # Write the result to 'formula1.out'
    with open('formula1.out', 'w') as output_file:
        output_file.write(str(result) + '\n')

if __name__ == '__main__':
    main()
```
```
---------- user ----------


Expected program to write result to `formula1.out` and read from `formula1.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
def task1(k):
    # Formula to compute the total number of squares for a given flag number (k)
    return (k * 2 + 2) ** 2

def task2(n):
    # Formula to compute the sum of white squares for the first n flags
    white_squares = (n * (n + 1) // 2) ** 2
    # Find the largest flag size that contains at most this many white squares
    # Start with the n-th flag and decrease until we the condition is satisfied
    max_flag_size = 0
    for i in range(n, 0, -1):
        # Calculate the side length of the i-th flag
        side_length = i * 2 + 2
        # Calculate the number of white squares in the i-th flag
        flag_white_squares = (side_length // 2) ** 2
        flag_white_squares += (side_length // 2 - 1) ** 2
        if side_length % 2 != 0:  # If the side length is odd, add the middle squares
            flag_white_squares += side_length // 2
        # If this flag has fewer or equal white squares to the sum of the first n flags, it's the largest possible
        if flag_white_squares <= white_squares:
            max_flag_size = side_length ** 2
            break
    return max_flag_size

# Read from 'formula1.in'
with open('formula1.in', 'r') as fin:
    c = int(fin.readline().strip())
    k, n = map(int, fin.readline().strip().split())

# Solve the problem based on the value of c
if c == 1:
    result = task1(k)
else:
    result = task2(n)

# Write to 'formula1.out'
with open('formula1.out', 'w') as fout:
    fout.write(f"{result}\n")
```
---------- user ----------


Expected program to write result to `formula1.out` and read from `formula1.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
def calculate_squares(k):
    # Calculate the total number of squares for a flag with number k
    side = k * 2 + 2  # Calculate the side length of the flag
    total_squares = side * side  # Total squares
    white_squares = (side // 2) ** 2 + ((side + 1) // 2) ** 2  # Total white squares
    return total_squares, white_squares

def calculate_max_flag(a):
    # Find the maximum size of a flag that has at most a white squares
    k = 1
    while True:
        # Calculate the total number of white squares for a flag of size k
        _, white_squares = calculate_squares(k)
        if white_squares > a:
            break
        k += 1
    # Subtract one because the loop exits when k is one more than needed
    k -= 1
    # Calculate the total number of squares for the maximum flag size
    total_squares, _ = calculate_squares(k)
    return total_squares

# Read input from file
with open('formula1.in', 'r') as file:
    c = int(file.readline().strip())
    k, n = map(int, file.readline().strip().split())

# Compute the result based on the value of c
if c == 1:
    # Calculate the total number of squares for the k-th flag
    result, _ = calculate_squares(k)
else:
    # Calculate the total number of white squares for the first n flags
    white_squares = sum(calculate_squares(i)[1] for i in range(1, n + 1))
    # Calculate the size of the largest flag with at most that many white squares
    result = calculate_max_flag(white_squares)

# Write output to file
with open('formula1.out', 'w') as file:
    file.write(f'{result}\n')
```
```
---------- user ----------


Expected program to write result to `formula1.out` and read from `formula1.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
def calculate_squares(k):
    total_squares = (2 * k + 1) ** 2
    white_squares = (k + 1) ** 2 + k ** 2
    black_squares = total_squares - white_squares
    return white_squares, black_squares

def sum_of_squares(n):
    return (2 * n + 1) * (n + 1) * n // 3

def calculate_max_flag(white_squares, k, n):
    left, right = k, n
    max_flag_size = 0
    while left <= right:
        mid = (left + right) // 2
        mid_white, _ = calculate_squares(mid)
        if mid_white <= white_squares:
            max_flag_size = mid
            left = mid + 1
        else:
            right = mid - 1
    return (2 * max_flag_size + 1) ** 2

with open('formula1.in', 'r') as file:
    c = int(file.readline().strip())
    k, n = map(int, file.readline().strip().split())

if c == 1:
    result = calculate_squares(k)[0] + calculate_squares(k)[1]
else:
    A = sum_of_squares(n)
    result = calculate_max_flag(A, 1, n)

with open('formula1.out', 'w') as file:
    file.write(f'{result}\n')
```
```
---------- user ----------


Expected program to write result to `formula1.out` and read from `formula1.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
def calculate_white_black_squares(k):
    # Formula to calculate number of white squares in the k-th flag
    white_squares = k * k + (k + 1) * (k + 1)
    # Total squares are on the flag of size (2k + 3)
    total_squares = (2 * k + 3) * (2 * k + 3)
    # Black squares are total squares minus white squares
    black_squares = total_squares - white_squares
    return white_squares, black_squares

def solve_first_task(k):
    _, black_squares = calculate_white_black_squares(k)
    total_squares = black_squares + (k * k + (k + 1) * (k + 1))
    return total_squares

def solve_second_task(n):
    total_white_squares = sum(calculate_white_black_squares(i)[0] for i in range(n))
    # Start guessing the maximum k starting from n
    k = n
    # Decrease k until the total white squares of the k-th flag is less than or equals to total_white_squares
    while True:
        white_squares, _ = calculate_white_black_squares(k)
        if white_squares <= total_white_squares:
            break
        k -= 1
    # The total number of squares in the largest flag with at most total_white_squares white squares
    total_squares = (2 * k + 3) * (2 * k + 3)
    return total_squares

# Read the problem type and values from "formula1.in"
with open('formula1.in', 'r') as file:
    c = int(file.readline().strip())
    k, n = map(int, file.readline().strip().split())

# Compute the answer based on the problem type
if c == 1:
    answer = solve_first_task(k)
else:
    answer = solve_second_task(n)

# Write the answer to "formula1.out"
with open('formula1.out', 'w') as file:
    file.write(f'{answer}\n')
```
```
