---------- user ----------

Here is a programming challenge.
Please solve this problem efficiently, optimizing both time and memory usage.
Create the most efficient solution for this challenge in python. Utilize numpy and other highly efficient libraries whenever possible.
This problem has a memory limit of ~8MB so please be sensitive on using memory. Using too much memory may result in OOM.
The code must compile and be correct.
The solution must read from `cetate.in` and write to `cetate.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Cetatea Vizima din regatul Temeria poate fi reprezentată printr-o matrice cu $N$ linii și $M$ coloane, numerotate începând cu $1$. Vizima este o cetate înfloritoare, fapt datorat numărului mare de negustori și meșteri prezenți. Din acest motiv, fiecărei celule îi este atribuit un profit corespunzător zonei respective. Regele Foltest dorește să reconstruiască zidurile cetății, dar cum războiul cu Imperiul Nilfgaard bate la ușă și resursele regatului sunt limitate, el trebuie să aleagă o porțiune pe care să o poată apăra, reprezentată ca o submatrice. O submatrice este identificată printr-o **configurație** de patru numere $(i_1, j_1, i_2, j_2)$ ($1 \leq i_1 \leq i_2 \leq N$, $1 \leq j_1 \leq j_2 \leq M$), în această ordine, și este formată din elementele situate pe liniile consecutive $i_1, i_1+1, \ldots, i_2$ și pe coloanele consecutive $j_1, j_1+1, \ldots, j_2$ ale matricei prin care este reprezentată cetatea. **Laturile** submatricei sunt egale cu numărul de linii, respectiv de coloane din care a preluat elemente, iar **profitul** submatricei este suma valorilor din celulele sale.

# Cerințe
Scrieți un program care, cunoscând matricea cetății și o valoare $K$, determină:
1) profitul maxim al unei submatrice cu laturile egale cu $K$, precum și configurația prin care se identifică ea.
2) profitul maxim al unei submatrice cu laturile cel mult egale cu $K$, precum și configurația prin care se identifică ea.

# Date de intrare
Fișierul de intrare `cetate.in` conține pe primul rând o valoare $c$ egală cu $1$ sau $2$, reprezentând cerința ce urmează a fi rezolvată. Următoarea linie conține în ordine $N$, $M$ și $K$, cu semnificația din enunț, iar pe următoarele $N$ linii se află câte $M$ numere, reprezentând valorile din matricea dată. Numerele aflate pe aceeași linie a fișierului sunt separate prin câte un spațiu.

# Date de ieșire
Fișierul de ieșire `cetate.out` va conține pe prima linie profitul maxim cerut, conform cerinței, iar pe a doua linie va conține 4 numere naturale, reprezentând configurația prin care se identifică submatricea obținută. Dacă există mai multe submatrice conform cerinței, se va lua în considerare cea pentru care configurația formată din cele 4 numere de mai sus este minim lexicografică.

# Restricții și precizări
- $1 \leq N,M \leq 400$
- $1 \leq K \leq min(N,M)$
- Valorile date pentru matricea cetății se află în intervalul $[-10^9, 10^9]$.
- Pentru teste în valoare de 20 de puncte, $c=1$, iar pentru restul testelor, în valoare de 70 de puncte, $c=2$. Pentru teste în valoare de 8 puncte, $c=1$ și $1 \leq N,M \leq 70$. Pentru teste în valoare de 25 de puncte, $c=2$ și $1 \leq N,M \leq 70$.
- Configurația $(x_1, x_2, x_3, x_4)$ este mai mică din punct de vedere lexicografic decât configurația $(y_1, y_2, y_3, y_4)$ dacă există $p$ astfel încât $x_p < y_p$ și $x_1 = y_1$, $x_2 = y_2$, $\dots$, $x_{p-1} = y_{p-1}$.

---

Example:
`cetate.in`
```
1
3 4 3
-1 -1 -1 -1
-1 2 -1 -1
-1 -1 -1 -1
```

`cetate.out`
```
-6
1 1 3 3
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```markdown
```python
import numpy as np

def compute_max_submatrix_sum(matrix, K, exact_size=False):
    N, M = matrix.shape
    max_sum = None
    max_config = None
    
    # Pre-compute prefix sums
    prefix_sum = np.zeros((N+1, M+1), dtype=np.int64)
    prefix_sum[1:, 1:] = matrix.cumsum(axis=0).cumsum(axis=1)
    
    for i1 in range(N - K + 1):
        for j1 in range(M - K + 1):
            for i2 in range(i1 + K, (N + 1) if not exact_size else i1 + K + 1):
                for j2 in range(j1 + K, (M + 1) if not exact_size else j1 + K + 1):
                    # Calculate submatrix sum using prefix sums
                    submatrix_sum = prefix_sum[i2, j2] - prefix_sum[i1, j2] - prefix_sum[i2, j1] + prefix_sum[i1, j1]
                    if max_sum is None or submatrix_sum > max_sum:
                        max_sum = submatrix_sum
                        max_config = (i1 + 1, j1 + 1, i2, j2)
                    elif submatrix_sum == max_sum:
                        current_config = (i1 + 1, j1 + 1, i2, j2)
                        if current_config < max_config:
                            max_config = current_config
    return max_sum, max_config

def solve_cetate():
    with open('cetate.in', 'r') as infile:
        c = int(infile.readline().strip())
        N, M, K = map(int, infile.readline().strip().split())
        matrix = np.array([list(map(int, infile.readline().strip().split())) for _ in range(N)], dtype=np.int64)
    
    if c == 1:
        max_sum, max_config = compute_max_submatrix_sum(matrix, K, exact_size=True)
    else:
        max_sum, max_config = compute_max_submatrix_sum(matrix, K, exact_size=False)
    
    with open('cetate.out', 'w') as outfile:
        outfile.write(f"{max_sum}\n")
        outfile.write(' '.join(map(str, max_config)) + '\n')

solve_cetate()
```
```
This solution reads from the input file `cetate.in`, determines the required maximum profit and configuration, and writes the results to the output file `cetate.out`. It uses NumPy to efficiently calculate and handle matrix operations, which helps to optimize both time and memory usage. It also pre-computes the prefix sums to avoid repeated summation of submatrices, further optimizing the code. The code is designed to stay within the 8MB memory limit.
---------- user ----------


Expected program to write result to `cetate.out` and read from `cetate.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Function to calculate the prefix sum matrix
def prefix_sum_matrix(matrix):
    N, M = matrix.shape
    prefix_sum = np.zeros((N + 1, M + 1), dtype=matrix.dtype)
    prefix_sum[1:, 1:] = matrix.cumsum(axis=0).cumsum(axis=1)
    return prefix_sum

# Function to find the maximum profit submatrix with exact or at most K size
def max_profit_submatrix(prefix_sum, N, M, K, exact_size):
    max_profit = -np.inf
    max_config = (0, 0, 0, 0)
    
    for i1 in range(1, N + 1):
        for j1 in range(1, M + 1):
            # Determine the bottom right corner based on exact size or at most K
            i2_range = range(i1 + K - 1, i1 + K) if exact_size else range(i1 + K - 1, min(i1 + K, N + 1))
            j2_range = range(j1 + K - 1, j1 + K) if exact_size else range(j1 + K - 1, min(j1 + K, M + 1))
            for i2 in i2_range:
                for j2 in j2_range:
                    if 1 <= i2 <= N and 1 <= j2 <= M:
                        # Calculate the profit for the current submatrix
                        profit = prefix_sum[i2, j2] - prefix_sum[i1 - 1, j2] - prefix_sum[i2, j1 - 1] + prefix_sum[i1 - 1, j1 - 1]
                        # Update max profit and configuration if necessary
                        if profit > max_profit or (profit == max_profit and (i1, j1, i2, j2) < max_config):
                            max_profit = profit
                            max_config = (i1, j1, i2, j2)
    
    return max_profit, max_config

# Main function to solve the problem and read/write files
def solve_cetate():
    with open('cetate.in', 'r') as infile:
        c = int(infile.readline().strip())
        N, M, K = map(int, infile.readline().strip().split())
        matrix = np.array([list(map(int, infile.readline().strip().split())) for _ in range(N)])

    # Calculate the prefix sum matrix
    prefix_sum = prefix_sum_matrix(matrix)

    # Find the solution based on the problem type
    if c == 1:
        max_profit, max_config = max_profit_submatrix(prefix_sum, N, M, K, exact_size=True)
    else:
        max_profit, max_config = max_profit_submatrix(prefix_sum, N, M, K, exact_size=False)

    # Write the solution to the output file
    with open('cetate.out', 'w') as outfile:
        outfile.write(f"{max_profit}\n")
        outfile.write(' '.join(map(str, max_config)) + '\n')

# Execute the main function
solve_cetate()
```
```
This revised solution removes any use of `input()` or `print()`, strictly adhering to file I/O with 'cetate.in' and 'cetate.out'. The function calculates the prefix sum of the matrix once to quickly compute the sum of any submatrix. The `max_profit_submatrix` function is then used to find the maximum profit according to the problem statement, considering either exact K or at most K size submatrices.
---------- user ----------


Expected program to write result to `cetate.out` and read from `cetate.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Function to compute the prefix sum of the matrix for constant-time submatrix sum retrieval
def compute_prefix_sum(matrix):
    N, M = matrix.shape
    prefix_sum = np.zeros((N + 1, M + 1))
    prefix_sum[1:, 1:] = matrix.cumsum(axis=0).cumsum(axis=1)
    return prefix_sum

# Function to find the profit and configuration of the submatrix with given constraints
def find_max_profit_submatrix(prefix_sum, N, M, K, task):
    max_profit = None
    max_config = None
    for i in range(N - K + 1):
        for j in range(M - K + 1):
            i2 = i + K
            j2 = j + K
            current_profit = prefix_sum[i2, j2] - prefix_sum[i, j2] - prefix_sum[i2, j] + prefix_sum[i, j]
            if max_profit is None or current_profit > max_profit:
                max_profit = current_profit
                max_config = (i + 1, j + 1, i2, j2)
            if task == 2:
                # For task 2, also consider smaller submatrices within the KxK boundary
                for sub_i in range(i + 1, i2):
                    for sub_j in range(j + 1, j2):
                        sub_profit = prefix_sum[sub_i, sub_j] - prefix_sum[i, sub_j] - prefix_sum[sub_i, j] + prefix_sum[i, j]
                        if sub_profit > max_profit:
                            max_profit = sub_profit
                            max_config = (i + 1, j + 1, sub_i, sub_j)
    return max_profit, max_config

# Main function to solve the problem
def solve_cetate():
    with open('cetate.in', 'r') as infile:
        task = int(infile.readline().strip())
        N, M, K = map(int, infile.readline().strip().split())
        matrix_values = []
        for _ in range(N):
            matrix_values.append(list(map(int, infile.readline().strip().split())))
        matrix = np.array(matrix_values)

    # Compute the prefix sum matrix for efficient submatrix sum calculation
    prefix_sum = compute_prefix_sum(matrix)

    # Find the max profit submatrix based on the task
    max_profit, max_config = find_max_profit_submatrix(prefix_sum, N, M, K, task)

    # Write output to the file
    with open('cetate.out', 'w') as outfile:
        outfile.write(f"{max_profit}\n")
        outfile.write(" ".join(map(str, max_config)))

# Execute the function
solve_cetate()
```
```
This solution respects the constraints of the problem, using file I/O to read from 'cetate.in' and write to 'cetate.out' without using `input()` or `print()`. It includes functions to compute the prefix sum of a matrix for constant-time submatrix sum retrieval and to find the maximum profit submatrix according to the task. The solution is optimized for both time and memory usage, making use of numpy arrays and efficient computations.
---------- user ----------


Expected program to write result to `cetate.out` and read from `cetate.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Function to calculate the prefix sums
def prefix_sums(matrix):
    N, M = matrix.shape
    P = np.zeros((N + 1, M + 1))
    for i in range(1, N + 1):
        for j in range(1, M + 1):
            P[i][j] = matrix[i - 1][j - 1] + P[i - 1][j] + P[i][j - 1] - P[i - 1][j - 1]
    return P

# Function to find the maximum profit submatrix of a specific size or at most K size
def max_profit_submatrix(P, N, M, K, exact_size):
    max_profit = None
    max_config = (0, 0, 0, 0)
    for i in range(N - K + 1):
        for j in range(M - K + 1):
            for i2 in range(i + K, (N + 1) if not exact_size else i + K + 1):
                for j2 in range(j + K, (M + 1) if not exact_size else j + K + 1):
                    sum_submatrix = P[i2][j2] - P[i][j2] - P[i2][j] + P[i][j]
                    if max_profit is None or sum_submatrix > max_profit:
                        max_profit = sum_submatrix
                        max_config = (i + 1, j + 1, i2, j2)
                    elif sum_submatrix == max_profit:
                        current_config = (i + 1, j + 1, i2, j2)
                        if current_config < max_config:
                            max_config = current_config
    return max_profit, max_config

# Main function to solve the problem based on the requirements
def solve_cetate():
    with open('cetate.in', 'r') as fin:
        task = int(fin.readline())
        N, M, K = map(int, fin.readline().split())
        matrix = np.zeros((N, M), dtype=int)
        for i in range(N):
            matrix[i] = np.array(fin.readline().split(), dtype=int)
    
    P = prefix_sums(matrix)
    
    if task == 1:
        max_profit, max_config = max_profit_submatrix(P, N, M, K, exact_size=True)
    else:  # task == 2
        max_profit, max_config = max_profit_submatrix(P, N, M, K, exact_size=False)
    
    with open('cetate.out', 'w') as fout:
        fout.write("{}\n".format(max_profit))
        fout.write("{} {} {} {}\n".format(*max_config))

solve_cetate()
```
```
The updated solution avoids using `input()` or `print()` for I/O operations. It reads the input from 'cetate.in' and writes the output to 'cetate.out'. The solution uses numpy arrays for matrix manipulation and calculates the prefix sums for efficient submatrix sum calculation. It identifies the maximum profit submatrix with either an exact size of K or at most K for both tasks, as required by the problem statement.
---------- user ----------


Expected program to write result to `cetate.out` and read from `cetate.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Function to calculate the sum of all submatrices of size K x K
def submatrix_sums(matrix, K):
    # Compute cumulative sums
    N, M = matrix.shape
    cumulative = matrix.cumsum(axis=0).cumsum(axis=1)
    # Prepare a padded version of cumulative sums to simplify the calculation of submatrix sums
    padded_cumulative = np.pad(cumulative, ((K, 0), (K, 0)), mode='constant', constant_values=0)
    # Calculate submatrix sums
    sums = padded_cumulative[K:, K:] - padded_cumulative[:-K, K:] - padded_cumulative[K:, :-K] + padded_cumulative[:-K, :-K]
    return sums

# Function to find the maximum profit submatrix with exact size or at most size K
def find_max_profit_submatrix(matrix, sums, K, exact_size):
    N, M = matrix.shape
    max_profit = None
    max_config = None
    for i in range(N - K + 1):
        for j in range(M - K + 1):
            profit = sums[i, j]
            if max_profit is None or profit > max_profit:
                max_profit = profit
                max_config = (i + 1, j + 1, i + K, j + K)
            if not exact_size: 
                # If we are looking for submatrices with size at most K, check all smaller sizes
                for p in range(i, i + K):
                    for q in range(j, j + K):
                        profit = sums[p, q] - (sums[i, q] if p > i else 0) - (sums[p, j] if q > j else 0) + (sums[i, j] if p > i and q > j else 0)
                        if profit > max_profit:
                            max_profit = profit
                            max_config = (i + 1, j + 1, p + 1, q + 1)
    return max_profit, max_config

# Main function to read from 'cetate.in' and write to 'cetate.out'
def main():
    with open('cetate.in', 'r') as f:
        task = int(f.readline().strip())
        N, M, K = map(int, f.readline().split())
        matrix = np.array([list(map(int, f.readline().split())) for _ in range(N)])

    # Calculate the sum of all submatrices of size K x K
    sums = submatrix_sums(matrix, K)
    # Depending on the task, find the maximum profit submatrix
    if task == 1:
        max_profit, max_config = find_max_profit_submatrix(matrix, sums, K, True)
    else:
        max_profit, max_config = find_max_profit_submatrix(matrix, sums, K, False)

    with open('cetate.out', 'w') as f:
        f.write(f"{max_profit}\n{' '.join(map(str, max_config))}\n")

# Execute the program
main()
```
```
In this solution, we ensure all I/O is performed with files, as specified. We use numpy to efficiently handle the matrix operations. The `submatrix_sums` function computes the sum of all submatrices of size K x K using the cumulative sums technique. Then, the `find_max_profit_submatrix` function finds the submatrix with the maximum profit based on the task requirements. Finally, the results are written to 'cetate.out'.
---------- user ----------


Expected program to write result to `cetate.out` and read from `cetate.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

def read_input(filename):
    with open(filename, 'r') as file:
        lines = file.readlines()
    task, N, M, K = map(int, lines[1].split())
    matrix = np.array([list(map(int, line.split())) for line in lines[2:]], dtype=int)
    return task, N, M, K, matrix

def write_output(filename, max_profit, max_config):
    with open(filename, 'w') as file:
        file.write(f"{max_profit}\n")
        file.write(f"{' '.join(map(str, max_config))}\n")

def max_submatrix_sum(matrix, K, exact=False):
    N, M = matrix.shape
    max_sum = -np.inf
    top_left = (0, 0)
    # Calculate prefix sums
    prefix_sum = np.pad(matrix, ((1, 0), (1, 0)), mode='constant').cumsum(axis=0).cumsum(axis=1)
    
    # Iterate through matrix to find the max sum submatrix
    for i in range(N - K + 1):
        for j in range(M - K + 1):
            for sub_i in range(i, min(i + K, N)) if not exact else [i + K - 1]:
                for sub_j in range(j, min(j + K, M)) if not exact else [j + K - 1]:
                    curr_sum = prefix_sum[sub_i + 1, sub_j + 1] - prefix_sum[sub_i + 1, j] - prefix_sum[i, sub_j + 1] + prefix_sum[i, j] 
                    if curr_sum > max_sum:
                        max_sum = curr_sum
                        top_left = (i+1, j+1)
                        bottom_right = (sub_i+1, sub_j+1)
    return max_sum, top_left + bottom_right

# Main function
def solve_cetate():
    task, N, M, K, matrix = read_input('cetate.in')
    if task == 1:
        max_sum, max_config = max_submatrix_sum(matrix, K, exact=True)
    else:
        max_sum, max_config = max_submatrix_sum(matrix, K, exact=False)
    write_output('cetate.out', max_sum, max_config)

solve_cetate()
```
```
This solution reads the input from the file 'cetate.in' and writes the output to the file 'cetate.out', avoiding the use of `input()` and `print()` for I/O operations as required by the problem statement. The code uses NumPy for efficient array manipulation and calculates maximum sum submatrices using prefix sums.

The `max_submatrix_sum` function calculates the maximum sum of submatrices with exact size K or with sizes up to K, depending on the task. It iterates over all possible top-left corners of a submatrix of size K (or smaller if the task is not exact) and uses the prefix sum to calculate the submatrix sum efficiently.

Finally, the `solve_cetate` function orchestrates the reading of the input, the calculation of the maximum sum submatrix based on the task, and the writing of the output to the file.
---------- user ----------


Expected program to write result to `cetate.out` and read from `cetate.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Load data from the input file
with open('cetate.in', 'r') as f:
    c = int(f.readline().strip())
    N, M, K = map(int, f.readline().split())
    matrix = np.array([list(map(int, f.readline().split())) for _ in range(N)])

# Function to compute the prefix sum array
def compute_prefix_sum(matrix):
    prefix_sum = np.pad(matrix, ((1, 0), (1, 0)), 'constant')
    return prefix_sum.cumsum(axis=0).cumsum(axis=1)

# Function to find the maximum profit and configuration
def find_maximum(matrix, K, exact_size):
    prefix_sum = compute_prefix_sum(matrix)
    best_profit = -np.inf
    best_config = ()

    for i in range(N - K + 1):
        for j in range(M - K + 1):
            i2 = i + K
            j2 = j + K
            profit = prefix_sum[i2][j2] - prefix_sum[i2][j] - prefix_sum[i][j2] + prefix_sum[i][j]
            if profit > best_profit or (profit == best_profit and (i+1, j+1, i2, j2) < best_config):
                best_profit = profit
                best_config = (i+1, j+1, i2, j2)

            if not exact_size:
                for ii in range(i, i + K):
                    for jj in range(j, j + K):
                        profit = prefix_sum[ii + 1][jj + 1] - prefix_sum[ii + 1][j] - prefix_sum[i][jj + 1] + prefix_sum[i][j]
                        if profit > best_profit or (profit == best_profit and (i+1, j+1, ii+1, jj+1) < best_config):
                            best_profit = profit
                            best_config = (i+1, j+1, ii+1, jj+1)

    return best_profit, best_config

# Solve the problem based on the task
if c == 1:
    max_profit, max_config = find_maximum(matrix, K, True)
else:
    max_profit, max_config = find_maximum(matrix, K, False)

# Write to the output file
with open('cetate.out', 'w') as f:
    f.write(f"{max_profit}\n")
    f.write(" ".join(map(str, max_config)))
```
