---------- user ----------

Here is a programming challenge.
Please solve this problem efficiently, optimizing both time and memory usage.
Create the most efficient solution for this challenge in python. Utilize numpy and other highly efficient libraries whenever possible.
This problem has a memory limit of ~8MB so please be sensitive on using memory.Using unavoided memory may result in OOM.
The code must compile and be correct.
The solution must read from `ruleta.in` and write to `ruleta.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Nicușor este elev în clasa a VI-a și s-a gândit că este suficient de mare ca să inventeze un joc nou. Are doar o foaie de hârtie și un pix. Scrie mai întâi $n$ numere naturale în cerc. Acestea formează ***Ruleta numerelor***. Jocul se desfășoară după următoarele reguli:

* se parcurge șirul numerelor în sensul deplasării acelor de ceasornic;
* se pornește de fiecare dată de la același element;
* se execută de fiecare dată o rotație completă;
* fiecare element nenul se scade din elementul imediat următor doar dacă este mai mic sau egal cu acesta și nenul;

**Exemplu.** Dacă notăm cu $R_1, R_2, R_3, R_4, R_5, R_6, R_7, R8$ șirul numerelor ce formează ruleta din figura $1$, atunci, o rotație completă realizează următoarele modificări asupra numerelor din listă:

~[ruleta1.png|width=35em] ~[ruleta2.png|width=23em]

* ruleta se oprește atunci când execută o rotație completă și nu se modifică nici o valoare din șirul elementelor.

**Exemplu.** Pentru ruleta din figura $1$ se execută $4$ rotații (dintre care $3$ în care se fac modificări):

~[ruleta3.png]

# Cerință

Scrieți un program care să determine, pentru un șir de $n$ numere naturale care indică starea inițială a ruletei, numărul $r$ de rotații complete efectuate respectând regulile jocului până la încheierea acestuia și numărul $t$ al elementelor nenule aflate în șir la încheierea jocului.

# Date de intrare

Fișierul de intrare `ruleta.in` conține pe prima linie numărul $n$ de numere naturale așezate în cerc iar pe linia a doua, separate prin câte un spațiu, cele $n$ valori, în ordinea deplasării, începând cu elementul de la care pornește ruleta.

# Date de ieșire

Fișierul de ieșire `ruleta.out` conține pe prima linie, separate printr-un spațiu, valorile $r$ și $t$ (în această ordine).

# Restricții și precizări

* $2 \leq n \leq 10 \ 000$;
* Numerele de pe ruletă sunt numere naturale mai mici sau cel mult egale cu $30 \ 000$.
* pentru aflarea corectă a numărului $r$ de rotaţii se acordă 70% din punctajul pe test; punctajul integral se acordă dacă ambele valori afişate sunt corecte.

---

Example:
`ruleta.in`
```
8
1 2 3 4 3 2 3 1
```

`ruleta.out`
```
4 3
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```markdown
```python
import numpy as np

def process_ruleta(ruleta):
    n = len(ruleta)
    rotations = 0
    while True:
        changes = False
        for i in range(n):
            if ruleta[i] != 0 and ruleta[i] <= ruleta[(i + 1) % n]:
                ruleta[(i + 1) % n] -= ruleta[i]
                changes = True
        rotations += 1
        if not changes:
            break
    return rotations, np.count_nonzero(ruleta)

def read_and_process_input(file_path):
    with open(file_path, 'r') as file:
        n = int(file.readline().strip())
        ruleta = np.array(list(map(int, file.readline().strip().split())), dtype=np.int32)
    return process_ruleta(ruleta)

def write_output(file_path, result):
    with open(file_path, 'w') as file:
        file.write(f"{result[0]} {result[1]}\n")

# Paths to the input/output files
input_path = 'ruleta.in'
output_path = 'ruleta.out'

# Process the input file and get the result
result = read_and_process_input(input_path)

# Write the result to the output file
write_output(output_path, result)
```
```
---------- user ----------


Expected program to write result to `ruleta.out` and read from `ruleta.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

def process_ruleta(ruleta):
    n = len(ruleta)
    rotations = 0
    while True:
        changes = False
        original_ruleta = np.copy(ruleta)
        for i in range(n):
            if original_ruleta[i] != 0 and original_ruleta[i] <= ruleta[(i + 1) % n]:
                ruleta[(i + 1) % n] -= original_ruleta[i]
                changes = True
        rotations += 1
        if not changes:
            break
    return rotations, np.count_nonzero(ruleta)

def read_and_process_input(file_path):
    with open(file_path, 'r') as file:
        n = int(file.readline().strip())
        ruleta = np.fromstring(file.readline().strip(), dtype=int, sep=' ')
    return process_ruleta(ruleta)

def write_output(file_path, result):
    with open(file_path, 'w') as file:
        file.write(f"{result[0]} {result[1]}\n")

# Paths to the input/output files
input_path = 'ruleta.in'
output_path = 'ruleta.out'

# Process the input file and get the result
result = read_and_process_input(input_path)

# Write the result to the output file
write_output(output_path, result)
```
```
---------- user ----------


Expected program to write result to `ruleta.out` and read from `ruleta.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Function to process the ruleta numbers
def process_ruleta(ruleta):
    n = len(ruleta)
    rotations = 0
    while True:
        # Flag to check if any rotation happened
        changes = False
        # Perform a single rotation
        for i in range(n):
            if ruleta[i] != 0 and ruleta[i] <= ruleta[(i + 1) % n]:
                ruleta[(i + 1) % n] -= ruleta[i]
                changes = True
        rotations += 1
        if not changes:
            break
    # Count non-zero elements after the game is finished
    non_zero_elements = np.count_nonzero(ruleta)
    return rotations, non_zero_elements

# Read and process the input file
def read_and_process_input(file_path):
    with open(file_path, 'r') as file:
        n = int(file.readline().strip())
        ruleta = np.array(file.readline().strip().split(), dtype=np.int32)
    return process_ruleta(ruleta)

# Write the result to the output file
def write_output(file_path, result):
    with open(file_path, 'w') as file:
        file.write(f"{result[0]} {result[1]}\n")

# Main execution
if __name__ == "__main__":
    input_path = 'ruleta.in'
    output_path = 'ruleta.out'

    # Process the input file and get the result
    result = read_and_process_input(input_path)

    # Write the result to the output file
    write_output(output_path, result)
```
```
---------- user ----------


Expected program to write result to `ruleta.out` and read from `ruleta.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

def perform_rotations(ruleta):
    rotations = 0
    while True:
        changes = False
        for i in range(len(ruleta)):
            if ruleta[i] > 0 and ruleta[i] <= ruleta[(i + 1) % len(ruleta)]:
                ruleta[(i + 1) % len(ruleta)] -= ruleta[i]
                changes = True
        rotations += 1
        if not changes:
            break
    return rotations, np.count_nonzero(ruleta)

def main():
    with open('ruleta.in', 'r') as file:
        n = int(file.readline())
        ruleta = np.array(file.readline().split(), dtype=int)
    
    rotations, non_zero_count = perform_rotations(ruleta)
    
    with open('ruleta.out', 'w') as file:
        file.write(f"{rotations} {non_zero_count}\n")

if __name__ == "__main__":
    main()
```
```
---------- user ----------


Expected program to write result to `ruleta.out` and read from `ruleta.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

def simulate_ruleta(ruleta):
    n = ruleta.size
    rotations = 0
    while True:
        prev_ruleta = ruleta.copy()
        for i in range(n):
            if ruleta[i] > 0 and ruleta[i] <= ruleta[(i + 1) % n]:
                ruleta[(i + 1) % n] -= ruleta[i]
        if np.array_equal(ruleta, prev_ruleta):
            break
        rotations += 1
    remaining_non_zero = np.count_nonzero(ruleta)
    return rotations, remaining_non_zero

def main():
    with open('ruleta.in', 'r') as file:
        n = int(file.readline())
        ruleta_values = np.fromstring(file.readline().strip(), dtype=int, sep=' ')
    
    rotations, remaining_non_zero = simulate_ruleta(ruleta_values)
    
    with open('ruleta.out', 'w') as file:
        file.write(f"{rotations} {remaining_non_zero}\n")

if __name__ == "__main__":
    main()
```
```
---------- user ----------


Expected program to write result to `ruleta.out` and read from `ruleta.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

def process_ruleta(ruleta_array):
    changes = True
    rotations = 0
    n = len(ruleta_array)
    
    while changes:
        changes = False
        prev_val = ruleta_array[-1]
        for i in range(n):
            current_val = ruleta_array[i]
            if prev_val and prev_val <= current_val:
                ruleta_array[i] -= prev_val
                changes = True
            prev_val = current_val
        rotations += 1
    
    # Subtract one rotation since the last rotation doesn't change anything
    rotations -= 1
    non_zero_elements = np.count_nonzero(ruleta_array)
    
    return rotations, non_zero_elements

# Main function to orchestrate the input/output operations
def main():
    with open('ruleta.in', 'r') as input_file:
        n = int(input_file.readline().strip())
        ruleta_array = np.array(input_file.readline().strip().split(), dtype=int)
        
    rotations, non_zero_elements = process_ruleta(ruleta_array)
    
    with open('ruleta.out', 'w') as output_file:
        output_file.write(f"{rotations} {non_zero_elements}\n")

# Execute main function
if __name__ == "__main__":
    main()
```
```
---------- user ----------


Expected program to write result to `ruleta.out` and read from `ruleta.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
import numpy as np

# Function to simulate the ruleta game and count the rotations and remaining numbers
def simulate_ruleta(ruleta):
    rotations = 0
    while True:
        changed = False
        original_ruleta = ruleta.copy()
        for i in range(len(ruleta)):
            if ruleta[i] != 0 and ruleta[i] <= original_ruleta[(i + 1) % len(ruleta)]:
                ruleta[(i + 1) % len(ruleta)] -= ruleta[i]
                changed = True
        rotations += 1
        if not changed:
            break
    non_zero_elements = np.count_nonzero(ruleta)
    return rotations - 1, non_zero_elements  # subtract one rotation as the last does not change anything

# Main function to orchestrate the file reading and writing
def main():
    with open('ruleta.in', 'r') as file_in:
        n = int(file_in.readline().strip())
        ruleta_numbers = np.array(file_in.readline().strip().split(), dtype=int)
        result = simulate_ruleta(ruleta_numbers)
    
    with open('ruleta.out', 'w') as file_out:
        file_out.write(f"{result[0]} {result[1]}\n")

# Run the main function
if __name__ == "__main__":
    main()
```
```
