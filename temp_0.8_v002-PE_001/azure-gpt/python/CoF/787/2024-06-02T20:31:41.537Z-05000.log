---------- user ----------

Here is a programming challenge.
Please solve this problem efficiently, optimizing both time and memory usage.
Create the most efficient solution for this challenge in python. Utilize numpy and other highly efficient libraries whenever possible.
This problem has a memory limit of ~8MB so please be sensitive on using memory.Using unavoided memory may result in OOM.
The code must compile and be correct.
The solution must read from `ruleta.in` and write to `ruleta.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Nicușor este elev în clasa a VI-a și s-a gândit că este suficient de mare ca să inventeze un joc nou. Are doar o foaie de hârtie și un pix. Scrie mai întâi $n$ numere naturale în cerc. Acestea formează ***Ruleta numerelor***. Jocul se desfășoară după următoarele reguli:

* se parcurge șirul numerelor în sensul deplasării acelor de ceasornic;
* se pornește de fiecare dată de la același element;
* se execută de fiecare dată o rotație completă;
* fiecare element nenul se scade din elementul imediat următor doar dacă este mai mic sau egal cu acesta și nenul;

**Exemplu.** Dacă notăm cu $R_1, R_2, R_3, R_4, R_5, R_6, R_7, R8$ șirul numerelor ce formează ruleta din figura $1$, atunci, o rotație completă realizează următoarele modificări asupra numerelor din listă:

~[ruleta1.png|width=35em] ~[ruleta2.png|width=23em]

* ruleta se oprește atunci când execută o rotație completă și nu se modifică nici o valoare din șirul elementelor.

**Exemplu.** Pentru ruleta din figura $1$ se execută $4$ rotații (dintre care $3$ în care se fac modificări):

~[ruleta3.png]

# Cerință

Scrieți un program care să determine, pentru un șir de $n$ numere naturale care indică starea inițială a ruletei, numărul $r$ de rotații complete efectuate respectând regulile jocului până la încheierea acestuia și numărul $t$ al elementelor nenule aflate în șir la încheierea jocului.

# Date de intrare

Fișierul de intrare `ruleta.in` conține pe prima linie numărul $n$ de numere naturale așezate în cerc iar pe linia a doua, separate prin câte un spațiu, cele $n$ valori, în ordinea deplasării, începând cu elementul de la care pornește ruleta.

# Date de ieșire

Fișierul de ieșire `ruleta.out` conține pe prima linie, separate printr-un spațiu, valorile $r$ și $t$ (în această ordine).

# Restricții și precizări

* $2 \leq n \leq 10 \ 000$;
* Numerele de pe ruletă sunt numere naturale mai mici sau cel mult egale cu $30 \ 000$.
* pentru aflarea corectă a numărului $r$ de rotaţii se acordă 70% din punctajul pe test; punctajul integral se acordă dacă ambele valori afişate sunt corecte.

---

Example:
`ruleta.in`
```
8
1 2 3 4 3 2 3 1
```

`ruleta.out`
```
4 3
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:Below is the Python code for the given challenge. This code uses NumPy for efficiency, and it reads from `ruleta.in` and writes to `ruleta.out` as required.

```python
import numpy as np

def execute_rotations(numbers):
    n = len(numbers)
    rotations = 0
    while True:
        rotations += 1
        changes = False
        for i in range(n):
            if numbers[i] != 0 and numbers[i] <= numbers[(i + 1) % n]:
                changes = True
                numbers[(i + 1) % n] -= numbers[i]
        if not changes:
            break
    non_zero_elements = np.count_nonzero(numbers)
    return rotations, non_zero_elements

def main():
    with open('ruleta.in', 'r') as f:
        n = int(f.readline().strip())
        numbers = np.array(list(map(int, f.readline().strip().split())), dtype=np.int32)
    
    rotations, non_zero_elements = execute_rotations(numbers)
    
    with open('ruleta.out', 'w') as f:
        f.write(f'{rotations} {non_zero_elements}\n')

if __name__ == "__main__":
    main()
```

This code reads the number of elements and the sequence of numbers from the file `ruleta.in`, then performs the required rotations according to the rules described in the challenge. After the rotations are complete, it counts the number of non-zero elements and writes both the number of complete rotations and the count of non-zero elements to the file `ruleta.out`. The use of NumPy arrays allows for a more efficient handling of large sequences of numbers, and the `dtype=np.int32` assures that the memory footprint is minimized to stay within the 8MB limit.
---------- user ----------


Program exited with code 1.
stdout:
```

```
stderr:
```
Traceback (most recent call last):
  File "/app/app.py", line 1, in <module>
    import numpy as np
ModuleNotFoundError: No module named 'numpy'

```

Think of what has caused the exit code. Use the standard out and standard error to help you understand the issue.
Implement a solution to fix the program

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

It appears that the environment where the solution is being executed does not have the NumPy library installed, or it is not available. Since NumPy usage is restricted due to the environment, I will need to rewrite the solution without using NumPy or any other external libraries, relying solely on built-in Python functionality to handle the data efficiently.

Below is the revised solution, which does not use NumPy or any other external libraries:

```python
def execute_rotations(numbers):
    n = len(numbers)
    rotations = 0
    while True:
        rotations += 1
        changes = False
        for i in range(n):
            if numbers[i] != 0 and numbers[i] <= numbers[(i + 1) % n]:
                changes = True
                numbers[(i + 1) % n] -= numbers[i]
        if not changes:
            break
    non_zero_elements = sum(1 for num in numbers if num != 0)
    return rotations, non_zero_elements

def main():
    with open('ruleta.in', 'r') as f:
        n = int(f.readline().strip())
        numbers = list(map(int, f.readline().strip().split()))
    
    rotations, non_zero_elements = execute_rotations(numbers)
    
    with open('ruleta.out', 'w') as f:
        f.write(f'{rotations} {non_zero_elements}\n')

if __name__ == "__main__":
    main()
```

This code should now work as intended without any external dependencies. It reads from `ruleta.in`, performs the rotations, counts the non-zero elements, and writes the results to `ruleta.out` while respecting the memory constraints. The revised solution uses built-in Python data structures and functions to ensure compatibility with the execution environment.
