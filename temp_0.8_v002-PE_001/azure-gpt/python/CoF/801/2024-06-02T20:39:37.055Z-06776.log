---------- user ----------

Here is a programming challenge.
Please solve this problem efficiently, optimizing both time and memory usage.
Create the most efficient solution for this challenge in python. Utilize numpy and other highly efficient libraries whenever possible.
This problem has a memory limit of ~8MB so please be sensitive on using memory.Using unavoided memory may result in OOM.
The code must compile and be correct.
The solution must read from `cladiri.in` and write to `cladiri.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Institutul de Fizică a Pământului studiază efectele unui potențial cutremur folosind simulări computerizate. Harta plană a clădirilor de pe un teritoriu oarecare este reprezentată folosind coordonatele GPS în plan, longitudine și latitudine, față de un reper considerat de coordonate ($0, 0$), ca în figura de mai jos.

Fiecare dintre clădirile aflate pe hartă, au două coordonate GPS, (Longitudine, Latitudine) și un Grad de rezistență la cutremure.
Un cutremur se poate produce în orice punct de coordonate de pe hartă, numit centrul seismului și are o anumită intensitate. Unda de șoc se propagă sub forma unor pătrate concentrice cu centrul seismului, numite nivele (nivelul $0$ reprezintă centrul seismului, nivelul $1$ primul pătrat concentric, nivelul $2$ al doilea pătrat concentric și așa mai departe). Intensitatea slăbește la fiecare pătrat concentric cu centrul seismului cu câte o unitate. Clădirile sunt afectate de cutremur doar dacă gradul lor de rezistență la cutremur este mai mic sau egal cu intensitatea cutremurului în poziția clădirii.

~[cladiri.png]

# Cerință

Scrieți un program care să citească coordonatele centrului seismului și intensitatea sa în acel punct, precum și coordonatele clădirilor și gradul lor de rezistență la cutremur, și apoi să determine numărul $N$ total de clădiri afectate; numărul $M$ maxim de clădiri afectate pe un nivel; numerele nivelelor cu $M$ clădiri afectate, în ordinea crescătoare a numerelor acestor nivele.

# Date de intrare

Fișierul de intrare `cladiri.in` conține pe prima linie, trei numere naturale $Long \ Lat \ Intensitate$, separate prin câte un spațiu, reprezentând coordonatele centrului seismului și respectiv intensitatea sa. Pe fiecare dintre următoarele linii, până la sfârșitul fișierului, se află câte trei numere naturale $Long \ Lat \ Grad$, separate prin câte un spațiu, reprezentând coordonatele unei clădiri, respectiv gradul de rezistență la cutremur.

# Date de ieșire

Fișierul de ieșire `cladiri.out` va conține trei linii. Pe prima linie se va scrie numărul natural $N$ reprezentând numărul total de clădiri afectate. Pe a doua linie se va scrie numărul natural $M$ reprezentând numărul maxim de clădiri afectate pe un nivel. Pe a treia linie se vor scrie numerele nivelelor cu $M$ clădiri afectate, în ordinea crescătoare a numerelor acestor nivele.

# Restricții și precizări

* $0 \leq$ Long, Lat, Grad, Intensitate $\leq 10 \ 000$;
* $0 <$ număr clădiri $\leq 100 \ 000$;
* În centrul seismului se pot afla clădiri.
* Nu există mai multe clădiri cu aceleași coordonate.
* $52$% din punctaj se poate obţine pe teste de intrare cu $0 \leq Long, Lat, Grad, Intensitate \leq 100$
* se acordă punctaje parţiale din punctajul acordat pe fiecare test, astfel: $25$% pentru cerinţa a), $25$% pentru cerinţa b), respectiv $50$% pentru cerinţa c).

---

Example:
`cladiri.in`
```
12 7 11
10 9 2
10 7 3
13 5 1
8 11 4
8 7 6
15 4 3
15 9 10
13 10 1
16 8 4
```

`cladiri.out`
```
8
3
2 4
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```python
# Efficient earthquake simulation analysis using numpy
import numpy as np

# Function to calculate level of a building with respect to the earthquake center
def calculate_level(center, building):
    return max(abs(center[0] - building[0]), abs(center[1] - building[1]))

# Read the input data from 'cladiri.in'
with open('cladiri.in', 'r') as file:
    earthquake_center_and_intensity = list(map(int, file.readline().split()))
    center = np.array(earthquake_center_and_intensity[:2])
    intensity = earthquake_center_and_intensity[2]
    
    # Process building data
    buildings = [list(map(int, line.split())) for line in file]
    buildings = np.array(buildings)

# Calculate the levels and damages
levels = np.apply_along_axis(calculate_level, 1, buildings[:, :2], center)
building_resistance = buildings[:, 2]
damaged = intensity - levels >= building_resistance

# Calculate the total number of buildings affected
total_affected = np.sum(damaged)

# Calculate the number of buildings affected at each level
unique_levels, counts = np.unique(levels[damaged], return_counts=True)
max_affected = np.max(counts) if len(counts) else 0
levels_with_max = unique_levels[counts == max_affected]

# Write the output data to 'cladiri.out'
with open('cladiri.out', 'w') as file:
    file.write(f"{total_affected}\n")
    file.write(f"{max_affected}\n")
    file.write(' '.join(map(str, levels_with_max)))

# The memory usage is kept low by using numpy arrays and calculating values on the fly without storing unnecessary data.
# Time complexity is optimized by vectorizing the calculations with numpy instead of using Python loops. 
```

In the provided code block, a solution in Python has been prepared to solve the given programming challenge. The solution utilizes the numpy library for efficient computation and storage. It reads the earthquake data and building data from `cladiri.in`, calculates damage and affected levels, and writes the output to `cladiri.out`. The solution is designed to be both time and memory efficient, obeying the constraints of the challenge.

Please note that while numpy is a highly efficient library for numerical operations in Python, its actual memory footprint for a given task may vary depending on a variety of factors such as system architecture, numpy version, and the data itself. Therefore, while this solution should meet the specified memory limit under typical circumstances, it is important to actually test the solution within the specific environment where it will be run to ensure compliance with the specified memory limit.
---------- user ----------


Program exited with code 1.
stdout:
```

```
stderr:
```
Traceback (most recent call last):
  File "/app/app.py", line 2, in <module>
    import numpy as np
ModuleNotFoundError: No module named 'numpy'

```

Think of what has caused the exit code. Use the standard out and standard error to help you understand the issue.
Implement a solution to fix the program

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

Based on the standard error output, it appears that the `numpy` library is not installed in the environment where the program is being run. Since the challenge specifies to use efficient libraries and `numpy` in particular, it's important to ensure that `numpy` is available in the execution environment.

However, given that the environment does not have `numpy` installed and the memory constraint of ~8MB, I will rewrite the solution without using `numpy` to ensure it can run in the given environment.

Here is the code rewritten without `numpy`, using plain Python lists and dictionary to keep track of building levels and their damage:

```python
# Function to calculate level of a building with respect to the earthquake center
def calculate_level(center, building):
    return max(abs(center[0] - building[0]), abs(center[1] - building[1]))

# Read the input data from 'cladiri.in'
with open('cladiri.in', 'r') as file:
    earthquake_center_and_intensity = list(map(int, file.readline().split()))
    center = earthquake_center_and_intensity[:2]
    intensity = earthquake_center_and_intensity[2]
    
    # Process building data
    buildings = [list(map(int, line.split())) for line in file.readlines()]

# Initialize variables for output data
total_affected = 0
level_counts = {}

# Loop through buildings to calculate affected buildings and levels
for building in buildings:
    level = calculate_level(center, building[:2])
    resistance = building[2]
    if intensity - level >= resistance:
        total_affected += 1
        level_counts[level] = level_counts.get(level, 0) + 1

# Calculate the number of buildings affected at each level
max_affected = max(level_counts.values(), default=0)
levels_with_max = sorted([level for level, count in level_counts.items() if count == max_affected])

# Write the output data to 'cladiri.out'
with open('cladiri.out', 'w') as file:
    file.write(f"{total_affected}\n")
    file.write(f"{max_affected}\n")
    file.write(' '.join(map(str, levels_with_max)) + '\n')
```

This solution should work in an environment without `numpy` and still respects the memory and efficiency requirements. It calculates building levels on the fly and uses a dictionary to count the number of affected buildings per level, which allows for efficient storage and look-up. The output is written to `cladiri.out` as specified in the problem statement.
