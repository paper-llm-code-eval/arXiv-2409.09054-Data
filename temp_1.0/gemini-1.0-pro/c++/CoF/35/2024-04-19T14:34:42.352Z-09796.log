---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `biperm.in` and write to `biperm.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Pentru un număr natural nenul `n`, să considerăm toate numerele naturale nenule mai mici sau egale cu `n`, luând fiecare număr de câte două ori: `1, 1, 2, 2, 3, 3, ... , n, n`. Aceste numere le amestecăm aleator, şi le aranjăm pe două linii a câte `n` elemente. Structura astfel obţinută o vom numi o bipermutare. În figurile `1, 2` şi `3` avem câte un exemplu de bipermutare pentru `n=5`. 

O bipermutare este perfectă, dacă ambele linii ale structurii reprezintă câte o permutare (vezi figurile `2` şi `3`).

Prin mutare pe poziţia `p`, înţelegem interschimbarea elementelor de pe aceeaşi coloană `p`. În exemplele de mai jos, bipermutarea perfectă din figura `2` s-a obţinut din bipermutarea din figura `1`, aplicând o mutare pe poziţa `2`. Bipermutarea perfectă din figura `3` s-a obţinut din bipermutarea din figura `1`, aplicând mutări pe poziţiile `1, 2, 4` şi `5`.

~[biperm.png]

# Cerinţe
Cunoscând o bipermutare, determinaţi:
* numărul bipermutărilor perfecte distincte ce se pot obţine prin mutări;
* numărul minim de mutări prin care se poate obţine o bipermutare perfectă;
* o bipermutare perfectă obţinută din bipermutarea iniţială.

# Date de intrare
Fişierul de intrare `biperm.in` conţine pe prima linie valoarea lui `n`. Următoarele două linii conţin, fiecare, câte `n` elemente separate prin câte un spaţiu, formând o bipermutare.

# Date de ieşire
Fişierul de ieşire `biperm.out` va conţine:
* pe prima linie două numere naturale separate printr-un spaţiu, reprezentând  numărul bipermutărilor perfecte distincte ce se pot obţine din bipermutarea dată, respectiv numărul minim de mutări prin care se poate obţine o bipermutare perfectă; 
* pe următoarele două linii se vor tipări câte n numere separate prin spaţiu, reprezentând o bipermutare perfectă obţinută din bipermutarea dată. 

# Restricţii şi precizări
* `2 < n ≤ 10 000`;
* calculul corect al numărului bipermutărilor perfecte distincte valorează `30%` din punctaj;
* calculul corect al numărului minim de mutări valorează `10%` din punctaj;
* tipărirea unei bipermutări perfecte valorează `60%` din punctaj. Pot exista mai multe soluţii, se va admite orice soluţie corectă;
* se garantează că numărul bipermutărilor perfecte distincte nu depăşeşte `2 000 000 000` pentru niciun test.
* acordarea punctajului la un răspuns corect este condiţionată de existenţa răspunsurilor anterioare, indiferent de corectitudinea lor;
* pentru `40%` din teste `n ≤ 20` 
* pentru `40%` din teste `20 < n ≤ 400`
* pentru `20%` din teste `400 < n ≤ 10 000`

---

Example:
`biperm.in`
```
5
1 5 5 3 4
3 2 2 4 1
```

`biperm.out`
```
4 1
1 2 5 3 4
3 5 2 4 1
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```cpp
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

using namespace std;
using namespace __gnu_pbds;

template<typename T>
using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

const int NMAX = 10005;
int n,v[NMAX],d[NMAX],aux[NMAX];
vector<int> sol;

struct pozitie{
    int x,y;
};

ordered_set<pozitie> Set,inv;

inline void check(int a,int b)
{
    if(inv.count({v[a],v[b]}))
        Set.erase({v[a],v[b]});
    else
        Set.insert({v[a],v[b]});
    if(inv.count({v[b],v[a]}))
        Set.erase({v[b],v[a]});
    else
        Set.insert({v[b],v[a]});
}
int main()
{
    ifstream f("biperm.in");
    ofstream g("biperm.out");

    f >> n;
    for(int i = 1;i <= n << 1;++ i)
        f >> v[i];
    for(int i = 1;i <= n << 1;++ i)
        aux[i] = v[i];

    int nr = 0;
    for(int i = n << 1;i >= 1;-- i)
        d[aux[i]] = i,aux[i] = 0;

    for(int i = 1;i <= n << 1;++ i)
        if(aux[i])
            Set.insert({aux[i],v[i]});

    for(int i = 1;i <= n;++ i)
        inv.insert({v[i],aux[i]}),inv.insert({aux[i],v[i]});

    for(int i = 1;i <= n;++ i)
    {
        check(i,d[i]);
        if(Set.size() == 0)
            ++ nr,sol.push_back(i);
    }

    g << nr << ' ';
    if(nr == 0)
        g << -1 << '\n';
    else
    {
        g << sol.size() - 1 << '\n';
        for(int i = 1;i < (int)sol.size();++ i)
        {
            g << sol[i - 1] << ' ' << sol[i] << '\n';
            check(sol[i - 1],d[sol[i]]);
            check(sol[i - 1],sol[i]);
            check(sol[i],d[sol[i]]);
            check(sol[i],sol[i - 1]);
        }
        g << sol.back() << ' ';
        for(int i = (int)sol.size() - 1;i >= 0;-- i)
            g << sol[i] << ' ';
        g << '\n';
    }

    return 0;
}
```
