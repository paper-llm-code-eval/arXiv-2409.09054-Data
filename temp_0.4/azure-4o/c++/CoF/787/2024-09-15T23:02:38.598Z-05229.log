---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `ruleta.in` and write to `ruleta.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Nicușor este elev în clasa a VI-a și s-a gândit că este suficient de mare ca să inventeze un joc nou. Are doar o foaie de hârtie și un pix. Scrie mai întâi $n$ numere naturale în cerc. Acestea formează ***Ruleta numerelor***. Jocul se desfășoară după următoarele reguli:

* se parcurge șirul numerelor în sensul deplasării acelor de ceasornic;
* se pornește de fiecare dată de la același element;
* se execută de fiecare dată o rotație completă;
* fiecare element nenul se scade din elementul imediat următor doar dacă este mai mic sau egal cu acesta și nenul;

**Exemplu.** Dacă notăm cu $R_1, R_2, R_3, R_4, R_5, R_6, R_7, R8$ șirul numerelor ce formează ruleta din figura $1$, atunci, o rotație completă realizează următoarele modificări asupra numerelor din listă:

~[ruleta1.png|width=35em] ~[ruleta2.png|width=23em]

* ruleta se oprește atunci când execută o rotație completă și nu se modifică nici o valoare din șirul elementelor.

**Exemplu.** Pentru ruleta din figura $1$ se execută $4$ rotații (dintre care $3$ în care se fac modificări):

~[ruleta3.png]

# Cerință

Scrieți un program care să determine, pentru un șir de $n$ numere naturale care indică starea inițială a ruletei, numărul $r$ de rotații complete efectuate respectând regulile jocului până la încheierea acestuia și numărul $t$ al elementelor nenule aflate în șir la încheierea jocului.

# Date de intrare

Fișierul de intrare `ruleta.in` conține pe prima linie numărul $n$ de numere naturale așezate în cerc iar pe linia a doua, separate prin câte un spațiu, cele $n$ valori, în ordinea deplasării, începând cu elementul de la care pornește ruleta.

# Date de ieșire

Fișierul de ieșire `ruleta.out` conține pe prima linie, separate printr-un spațiu, valorile $r$ și $t$ (în această ordine).

# Restricții și precizări

* $2 \leq n \leq 10 \ 000$;
* Numerele de pe ruletă sunt numere naturale mai mici sau cel mult egale cu $30 \ 000$.
* pentru aflarea corectă a numărului $r$ de rotaţii se acordă 70% din punctajul pe test; punctajul integral se acordă dacă ambele valori afişate sunt corecte.

---

Example:
`ruleta.in`
```
8
1 2 3 4 3 2 3 1
```

`ruleta.out`
```
4 3
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:To solve this problem efficiently, we need to simulate the rotations of the numbers on the roulette until no more changes occur. Here's a step-by-step breakdown of the approach:

1. **Read Input**: We will read the input from the file `ruleta.in`.
2. **Simulate Rotations**: We will simulate the rotations as described:
   - Traverse the list of numbers.
   - For each number, if it is non-zero and less than or equal to the next number (considering the circular nature), subtract it from the next number.
   - Track if any changes were made during the rotation.
3. **Count Rotations**: Continue the rotations until a full rotation occurs without any changes.
4. **Count Non-zero Elements**: After the rotations stop, count the number of non-zero elements in the list.
5. **Write Output**: Write the results to the file `ruleta.out`.

Here's the C++ code implementing this approach:

```cpp
#include <fstream>
#include <vector>

int main() {
    std::ifstream fin("ruleta.in");
    std::ofstream fout("ruleta.out");

    int n;
    fin >> n;

    std::vector<int> roulette(n);
    for (int i = 0; i < n; ++i) {
        fin >> roulette[i];
    }

    int rotations = 0;
    bool changed;
    
    do {
        changed = false;
        for (int i = 0; i < n; ++i) {
            int next = (i + 1) % n;
            if (roulette[i] != 0 && roulette[i] <= roulette[next]) {
                roulette[next] -= roulette[i];
                changed = true;
            }
        }
        rotations++;
    } while (changed);

    int non_zero_count = 0;
    for (int i = 0; i < n; ++i) {
        if (roulette[i] != 0) {
            non_zero_count++;
        }
    }

    fout << rotations << " " << non_zero_count << "\n";

    return 0;
}
```

### Explanation:

1. **Input Reading**:
   - We read the number of elements `n` and the elements of the roulette into a vector.
   
2. **Simulation of Rotations**:
   - We use a `do-while` loop to ensure at least one rotation is performed.
   - For each element, we check if it can be subtracted from the next element (considering the circular nature using modulo).
   - If any subtraction occurs, we set `changed` to `true`.

3. **Termination Condition**:
   - The loop continues until a full rotation occurs without any changes (`changed` remains `false`).

4. **Counting Non-zero Elements**:
   - After rotations stop, we count the number of non-zero elements in the vector.

5. **Output**:
   - We write the number of rotations and the count of non-zero elements to the output file.

This solution ensures that we efficiently simulate the rotations and count the required values, adhering to the constraints and requirements of the problem.
