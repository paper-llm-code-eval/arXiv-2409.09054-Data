---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `primprim.in` and write to `primprim.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Pentru un număr natural `a` definim *costul* ca fiind valoarea absolută (modulul) diferenței dintre `a` și numărul prim cel mai apropiat de `a`. Asupra unui șir de $n$ numere naturale, situate pe poziții numerotate de la $1$ la $n$, se aplică, în ordine, o succesiune de $q$ operații. O operație constă dintr-o înlocuire și o afișare și este descrisă sub forma `i x p`, cu semnificația:
* mai întâi înlocuim cu $x$ elementul din șir de pe poziția $i$;
* apoi afișăm suma minimă totală a costurilor unor elemente convenabil selectate de pe $p$ poziții distincte din șir.

# Cerință

Cunoscând $n$ și cele $n$ elemente ale șirului, scrieți un program care să determine:
1. suma costurilor tuturor elementelor din șirul dat;
2. rezultatele afișate în urma aplicării fiecăreia dintre cele $q$ operații, date în forma precizată.

# Date de intrare

Fișierul de intrare `primprim.in` va conține pe prima linie un număr natural $C$, reprezentând cerința care trebuie să fie rezolvată ($1$ sau $2$), pe a doua linie numărul natural $n$, cu semnificația din enunț, iar pe a treia linie cele $n$ elemente din șir, în ordinea din șir. 
Dacă $C = 2$, pe a patra linie se află numărul natural $q$, reprezentând numărul de operații, iar pe următoarele $q$ linii se află cele $q$ operații, câte o operație pe linie, în forma descrisă în enunț. Numerele scrise pe aceeași linie sunt separate prin câte un spațiu.

# Date de ieșire
Dacă $C = 1$, fișierul de ieșire `primprim.out` va conține o singură linie pe care va fi afișată suma costurilor tuturor elementelor din șir. 
Dacă $C = 2$, fișierul de ieșire `primprim.out` va conține $q$ linii, pe linia $i$ fiind scris rezultatul afișat după executarea celei de a $i$-a operații din fișierul de intrare.

# Restricții și precizări
* $1 \leq q \leq 2 * 10^5$;
* $1 \leq i,p \leq n \leq 10^6$; $1 \leq x \leq 10^6$;
* Elementele șirului sunt numere naturale nenule $\leq 10^6$;
* Pentru $20$ de puncte, $C = 1$, $n = 1$;
* Pentru $22$ de puncte, $C = 1$, $1 \lt n \leq 1 \ 000$;
* Pentru $28$ de puncte, $C = 2$, $n \leq 1 \ 000$, $q \leq 10$;
* Pentru $30$ de puncte, $C = 2$ și nu există restricții suplimentare.

---

Example:
`primprim.in`
```
1
5
8 1 3 5 9
```

`primprim.out`
```
4
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:Sure, let's break down the solution step by step before diving into the C++ implementation.

### Steps to Solve the Problem

1. **Prime Number Calculation**:
   - We need to calculate the nearest prime for each number up to 1,000,000. This can be done using the Sieve of Eratosthenes to find all prime numbers up to 1,000,000.
   - Once we have all the primes, we can create a lookup table to quickly find the nearest prime for any given number.

2. **Cost Calculation**:
   - For each number in the array, calculate the cost as the absolute difference between the number and its nearest prime.

3. **Handling Operations**:
   - For each operation, update the array with the new value and then calculate the minimum sum of costs for the specified number of positions.

### Implementation

Here is the C++ code that implements the above logic:

```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <algorithm>
#include <cmath>
#include <set>

const int MAXN = 1000000;

std::vector<bool> is_prime(MAXN + 1, true);
std::vector<int> nearest_prime(MAXN + 1);

void sieve() {
    is_prime[0] = is_prime[1] = false;
    for (int i = 2; i * i <= MAXN; ++i) {
        if (is_prime[i]) {
            for (int j = i * i; j <= MAXN; j += i) {
                is_prime[j] = false;
            }
        }
    }
    std::vector<int> primes;
    for (int i = 2; i <= MAXN; ++i) {
        if (is_prime[i]) {
            primes.push_back(i);
        }
    }
    for (int i = 0; i <= MAXN; ++i) {
        int best_dist = MAXN;
        for (int prime : primes) {
            int dist = std::abs(i - prime);
            if (dist < best_dist) {
                best_dist = dist;
                nearest_prime[i] = prime;
            }
            if (prime > i) break;
        }
    }
}

int main() {
    sieve();
    std::ifstream infile("primprim.in");
    std::ofstream outfile("primprim.out");

    int C, n;
    infile >> C >> n;
    std::vector<int> arr(n);
    for (int i = 0; i < n; ++i) {
        infile >> arr[i];
    }

    if (C == 1) {
        int total_cost = 0;
        for (int i = 0; i < n; ++i) {
            total_cost += std::abs(arr[i] - nearest_prime[arr[i]]);
        }
        outfile << total_cost << std::endl;
    } else {
        int q;
        infile >> q;
        std::vector<int> results;
        for (int k = 0; k < q; ++k) {
            int i, x, p;
            infile >> i >> x >> p;
            --i; // Convert to 0-based index
            arr[i] = x;

            std::vector<int> costs;
            for (int j = 0; j < n; ++j) {
                costs.push_back(std::abs(arr[j] - nearest_prime[arr[j]]));
            }
            std::sort(costs.begin(), costs.end());

            int min_sum = 0;
            for (int j = 0; j < p; ++j) {
                min_sum += costs[j];
            }
            results.push_back(min_sum);
        }
        for (int result : results) {
            outfile << result << std::endl;
        }
    }

    infile.close();
    outfile.close();
    return 0;
}
```

### Explanation

1. **Prime Number Calculation**:
   - The `sieve` function uses the Sieve of Eratosthenes to mark non-prime numbers.
   - It then creates a list of primes and calculates the nearest prime for each number up to 1,000,000.

2. **Cost Calculation**:
   - For each number in the array, the cost is calculated as the absolute difference between the number and its nearest prime.

3. **Handling Operations**:
   - For each operation, the array is updated with the new value.
   - The costs are recalculated, sorted, and the minimum sum of the specified number of positions is computed.

This solution should be efficient enough to handle the given constraints.
---------- user ----------


Program exited with code 137.
stdout:
```

```
stderr:
```

```

Think of what has caused the exit code. Use the standard out and standard error to help you understand the issue.
Implement a solution to fix the program

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The exit code 137 typically indicates that the program was terminated by the operating system, often due to excessive memory usage. Given the constraints of the problem, the memory usage might have been too high due to the way the nearest prime lookup table was constructed and used.

To optimize the solution, we need to ensure that we handle memory more efficiently and avoid unnecessary computations. Here's an improved version of the solution:

1. **Prime Number Calculation**:
   - Use the Sieve of Eratosthenes to find all prime numbers up to 1,000,000.
   - Create a more efficient way to find the nearest prime for any given number using two arrays: one for the nearest smaller or equal prime and one for the nearest larger or equal prime.

2. **Cost Calculation**:
   - For each number in the array, calculate the cost as the absolute difference between the number and its nearest prime.

3. **Handling Operations**:
   - For each operation, update the array with the new value and then calculate the minimum sum of costs for the specified number of positions.

Here is the optimized C++ code:

```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <algorithm>
#include <cmath>
#include <set>

const int MAXN = 1000000;

std::vector<bool> is_prime(MAXN + 1, true);
std::vector<int> nearest_prime(MAXN + 1);

void sieve() {
    is_prime[0] = is_prime[1] = false;
    for (int i = 2; i * i <= MAXN; ++i) {
        if (is_prime[i]) {
            for (int j = i * i; j <= MAXN; j += i) {
                is_prime[j] = false;
            }
        }
    }
}

int nearestPrime(int x) {
    if (is_prime[x]) return x;
    int lower = x, upper = x;
    while (lower >= 2 && !is_prime[lower]) --lower;
    while (upper <= MAXN && !is_prime[upper]) ++upper;
    if (lower < 2) return upper;
    if (upper > MAXN) return lower;
    return (x - lower <= upper - x) ? lower : upper;
}

int main() {
    sieve();
    std::ifstream infile("primprim.in");
    std::ofstream outfile("primprim.out");

    int C, n;
    infile >> C >> n;
    std::vector<int> arr(n);
    for (int i = 0; i < n; ++i) {
        infile >> arr[i];
    }

    if (C == 1) {
        int total_cost = 0;
        for (int i = 0; i < n; ++i) {
            total_cost += std::abs(arr[i] - nearestPrime(arr[i]));
        }
        outfile << total_cost << std::endl;
    } else {
        int q;
        infile >> q;
        std::vector<int> results;
        for (int k = 0; k < q; ++k) {
            int i, x, p;
            infile >> i >> x >> p;
            --i; // Convert to 0-based index
            arr[i] = x;

            std::vector<int> costs;
            for (int j = 0; j < n; ++j) {
                costs.push_back(std::abs(arr[j] - nearestPrime(arr[j])));
            }
            std::nth_element(costs.begin(), costs.begin() + p, costs.end());

            int min_sum = 0;
            for (int j = 0; j < p; ++j) {
                min_sum += costs[j];
            }
            results.push_back(min_sum);
        }
        for (int result : results) {
            outfile << result << std::endl;
        }
    }

    infile.close();
    outfile.close();
    return 0;
}
```

### Explanation of Changes

1. **Efficient Prime Lookup**:
   - The `nearestPrime` function now efficiently finds the nearest prime by checking both lower and upper bounds from the given number. This avoids the need for a large lookup table, reducing memory usage.

2. **Cost Calculation**:
   - The cost calculation remains the same but is now more memory-efficient.

3. **Handling Operations**:
   - The `std::nth_element` function is used to find the smallest `p` costs efficiently without fully sorting the array, which improves performance.

This optimized solution should handle the constraints better and avoid excessive memory usage.
