---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `tabel.in` and write to `tabel.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

După cum probabil știți, contabilii își țin datele sub formă de tabele și calculează tot felul de sume pe linii și pe coloane. Contabilul nostru Atnoc și-a organizat valorile sub forma unui tabel cu $n$ linii (numerotate de la $1$ la $n$) și $m$ coloane (numerotate de la $1$ la $m$). Elementele de pe ultima coloană sunt sumele elementelor de pe linii (mai exact, elementul de pe linia $i$ și coloana $m$ este egal cu suma elementelor de pe linia $i$ aflate pe coloanele $1, 2, \dots, m-1$), iar elementele de pe ultima linie sunt sumele elementelor de pe coloane (mai exact, elementul de pe linia $n$ și coloana $i$ este egal cu suma elementelor de pe coloana $i$ aflate pe liniile $1, 2, \dots, n-1$). Un exemplu de astfel de tabel este dat în figura următoare.

Din păcate, Atnoc a stropit cu apă minunatul său tabel și astfel o parte dintre numerele din tabel au devenit ilizibile.

~[tabel.png|width=30em]

# Cerință

Scrieți un program care să reconstituie toate datele din tabel.

# Date de intrare

Pe prima linie a fișierului text de intrare `tabel.in` se află două numere naturale $n$ și $m$, separate printr-un spațiu, ce reprezintă numărul de linii și respectiv numărul de coloane ale tabelului. Pe cea de a doua linie a fișierului de intrare se află un număr natural $p$ care reprezintă numărul de valori nedeteriorate din tabel. Pe fiecare dintre următoarele $p$ linii se află câte trei numere naturale, separate prin câte un spațiu $l \ c \ v$, unde $l$ este numărul liniei, $c$ este numărul coloanei și $v$ este valoarea elementului de pe linia $l$ și coloana $c$ din tabel.

# Date de ieșire

În fișierul text de ieșire `tabel.out` se va scrie tabelul reconstituit, pe $n$ linii câte $m$ valori separate prin câte un spațiu.

# Restricții și precizări

* $1 < n, m \leq 50$
* Valorile din tabel sunt numere naturale $< 32 \ 000$.
* În toate testele datele din tabel pot fi reconstituite.

---

Example:
`tabel.in`
```
3 4
10
1 1 2
1 2 5
1 3 7
1 4 14
2 2 6
2 4 23
3 1 13
3 2 11
3 3 13
3 4 37
```

`tabel.out`
```
2 5 7 14
11 6 6 23
13 11 13 37
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:To solve this challenge, we need to reconstruct a table where some values are missing, but we have enough information to infer the missing values. Here's a step-by-step approach to achieve this:

1. **Read Input Data**: Read the dimensions of the table (n, m), the number of known values (p), and the known values themselves.
2. **Initialize the Table**: Create a 2D array to represent the table and initialize it with -1 or some sentinel value to indicate missing values.
3. **Fill Known Values**: Populate the table with the known values from the input.
4. **Calculate Missing Values**: Use the properties of the table (sum of rows and columns) to infer the missing values. Since the last column and the last row are sums of the preceding elements, we can use these sums to fill in the missing values.
5. **Output the Table**: Write the reconstructed table to the output file.

Here is the C++ code to implement this approach:

```cpp
#include <iostream>
#include <fstream>
#include <vector>

int main() {
    std::ifstream fin("tabel.in");
    std::ofstream fout("tabel.out");

    int n, m, p;
    fin >> n >> m >> p;

    std::vector<std::vector<int>> table(n, std::vector<int>(m, -1));

    for (int i = 0; i < p; ++i) {
        int l, c, v;
        fin >> l >> c >> v;
        table[l - 1][c - 1] = v;
    }

    // Fill in the sums for rows and columns
    for (int i = 0; i < n - 1; ++i) {
        int rowSum = 0;
        for (int j = 0; j < m - 1; ++j) {
            if (table[i][j] != -1) {
                rowSum += table[i][j];
            }
        }
        table[i][m - 1] = rowSum;
    }

    for (int j = 0; j < m - 1; ++j) {
        int colSum = 0;
        for (int i = 0; i < n - 1; ++i) {
            if (table[i][j] != -1) {
                colSum += table[i][j];
            }
        }
        table[n - 1][j] = colSum;
    }

    // Fill in the last element (bottom-right corner)
    int totalSum = 0;
    for (int i = 0; i < n - 1; ++i) {
        if (table[i][m - 1] != -1) {
            totalSum += table[i][m - 1];
        }
    }
    table[n - 1][m - 1] = totalSum;

    // Output the table
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            fout << table[i][j];
            if (j < m - 1) fout << " ";
        }
        fout << "\n";
    }

    return 0;
}
```

### Explanation:

1. **Reading Input**: We read the dimensions of the table (n, m) and the number of known values (p). Then, we read the known values and store them in the table.
2. **Initializing Table**: We initialize the table with -1 to indicate missing values.
3. **Filling Known Values**: We populate the table with the known values from the input.
4. **Calculating Missing Values**:
   - For each row (except the last one), we calculate the sum of the known values and store it in the last column.
   - For each column (except the last one), we calculate the sum of the known values and store it in the last row.
   - The bottom-right corner of the table is the sum of the last column values.
5. **Outputting the Table**: We write the reconstructed table to the output file.

This approach ensures that we efficiently reconstruct the table while adhering to the constraints and properties provided.
---------- user ----------


Program result did not match expected result.
Input data:
```
3 4
10
1 1 2
1 2 5
1 3 7
1 4 14
2 2 6
2 4 23
3 1 13
3 2 11
3 3 13
3 4 37
```
Expected output:
```
2 5 7 14
11 6 6 23
13 11 13 37
```
Found output:
```
2 5 7 14
-1 6 -1 6
2 11 7 20
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The issue with the previous solution is that it does not correctly handle the reconstruction of the table when some values are missing. Specifically, it doesn't properly calculate the sums for rows and columns when not all values are known. 

To fix this, we need to:
1. Properly handle the missing values when calculating the sums.
2. Ensure that the sums are only calculated when all required values are known.

Here's the corrected approach:

1. **Read Input Data**: Read the dimensions of the table (n, m), the number of known values (p), and the known values themselves.
2. **Initialize the Table**: Create a 2D array to represent the table and initialize it with -1 or some sentinel value to indicate missing values.
3. **Fill Known Values**: Populate the table with the known values from the input.
4. **Iteratively Calculate Missing Values**: Use the properties of the table (sum of rows and columns) to iteratively infer the missing values until no more changes can be made.
5. **Output the Table**: Write the reconstructed table to the output file.

Here is the corrected C++ code:

```cpp
#include <iostream>
#include <fstream>
#include <vector>

int main() {
    std::ifstream fin("tabel.in");
    std::ofstream fout("tabel.out");

    int n, m, p;
    fin >> n >> m >> p;

    std::vector<std::vector<int>> table(n, std::vector<int>(m, -1));

    for (int i = 0; i < p; ++i) {
        int l, c, v;
        fin >> l >> c >> v;
        table[l - 1][c - 1] = v;
    }

    bool changed = true;
    while (changed) {
        changed = false;
        // Calculate row sums
        for (int i = 0; i < n - 1; ++i) {
            int rowSum = 0, unknowns = 0, lastUnknownIndex = -1;
            for (int j = 0; j < m - 1; ++j) {
                if (table[i][j] != -1) {
                    rowSum += table[i][j];
                } else {
                    unknowns++;
                    lastUnknownIndex = j;
                }
            }
            if (unknowns == 1) {
                table[i][lastUnknownIndex] = table[i][m - 1] - rowSum;
                changed = true;
            }
        }

        // Calculate column sums
        for (int j = 0; j < m - 1; ++j) {
            int colSum = 0, unknowns = 0, lastUnknownIndex = -1;
            for (int i = 0; i < n - 1; ++i) {
                if (table[i][j] != -1) {
                    colSum += table[i][j];
                } else {
                    unknowns++;
                    lastUnknownIndex = i;
                }
            }
            if (unknowns == 1) {
                table[lastUnknownIndex][j] = table[n - 1][j] - colSum;
                changed = true;
            }
        }
    }

    // Output the table
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            fout << table[i][j];
            if (j < m - 1) fout << " ";
        }
        fout << "\n";
    }

    return 0;
}
```

### Explanation:

1. **Reading Input**: We read the dimensions of the table (n, m) and the number of known values (p). Then, we read the known values and store them in the table.
2. **Initializing Table**: We initialize the table with -1 to indicate missing values.
3. **Filling Known Values**: We populate the table with the known values from the input.
4. **Iteratively Calculating Missing Values**:
   - We iteratively calculate the sums for rows and columns.
   - If there is exactly one unknown value in a row or column, we can deduce its value from the sum.
   - We repeat this process until no more changes can be made.
5. **Outputting the Table**: We write the reconstructed table to the output file.

This approach ensures that we correctly reconstruct the table while handling the missing values properly.
