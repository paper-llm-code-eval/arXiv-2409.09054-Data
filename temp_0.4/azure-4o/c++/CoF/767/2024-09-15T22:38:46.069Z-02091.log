---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `dreptc.in` and write to `dreptc.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Se consideră $N$ puncte colorate dispuse în plan. Ele sunt identificate prin coordontele lor întregi, pe axele OX și OY. Fiecare punct are asociat un număr natural între $1$ și $C$ reprezentând codul culorii lui. Un dreptunghi se numește *corect* dacă îndeplinește simultan următoarele condiții:

* toate cele patru vârfuri se regăsesc printre cele N puncte date;
* are laturile paralele cu axele OX, OY;
* are vârfurile colorate în aceeași culoare.

# Cerință

Să se determine numărul maxim de dreptunghiuri *corecte* care se pot forma cu cele $N$ puncte din plan.

# Date de intrare

Pe prima linie a fișierul text `dreptc.in` se găsesc două numere $N, MaxC$ reprezentând numărul de puncte din plan și numărul de culori asociate punctelor. Pe următoarele $N$ linii se citesc câte trei numere $x \ y \ c$ reprezentând în ordine coordonata pe axa OX (abscisa), coordonata pe axa OY (ordonata) și codul culorii asociate punctului.

# Date de ieșire

Pe prima linie a fișierul text `dreptc.out` se va scrie un singur număr cu semnificația numărul maxim de dreptunghiuri corecte.

# Restricții și precizări

* $1 \leq N \leq 1 \ 000$;
* $1 \leq C \leq 5$;
* $-1 \ 000 \leq x, y \leq 1 \ 000$;
* Nu există două puncte cu aceleași coordonate
* $40$% din teste vor avea $N \leq 100$;

---

Example:
`dreptc.in`
```
9 2
3 10 1
3 8 2
3 6 1
3 4 1
3 0 1
6 0 1
6 4 1
6 8 2
6 10 1
```

`dreptc.out`
```
3
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:To solve this problem efficiently, we need to consider the following steps:

1. **Read Input Efficiently**: We'll use file I/O to read the input data.
2. **Organize Points by Color**: Since we need to form rectangles with points of the same color, we'll store points in a map where the key is the color and the value is a vector of points.
3. **Find Rectangles**: For each color, we'll check all pairs of points to see if they can form the diagonal of a rectangle. If they can, we'll check if the other two points needed to form the rectangle exist.
4. **Count Rectangles**: We'll count the number of valid rectangles for each color and keep track of the maximum count.

Here's the C++ code implementing this approach:

```cpp
#include <fstream>
#include <vector>
#include <unordered_map>
#include <unordered_set>
#include <algorithm>

struct Point {
    int x, y;
};

int main() {
    std::ifstream fin("dreptc.in");
    std::ofstream fout("dreptc.out");

    int N, MaxC;
    fin >> N >> MaxC;

    std::unordered_map<int, std::vector<Point>> color_points;
    for (int i = 0; i < N; ++i) {
        int x, y, c;
        fin >> x >> y >> c;
        color_points[c].push_back({x, y});
    }

    int max_rectangles = 0;

    for (const auto& color_pair : color_points) {
        const auto& points = color_pair.second;
        std::unordered_set<long long> point_set;
        for (const auto& p : points) {
            point_set.insert(static_cast<long long>(p.x) << 32 | p.y);
        }

        int count = 0;
        for (size_t i = 0; i < points.size(); ++i) {
            for (size_t j = i + 1; j < points.size(); ++j) {
                if (points[i].x != points[j].x && points[i].y != points[j].y) {
                    long long p1 = static_cast<long long>(points[i].x) << 32 | points[j].y;
                    long long p2 = static_cast<long long>(points[j].x) << 32 | points[i].y;
                    if (point_set.count(p1) && point_set.count(p2)) {
                        ++count;
                    }
                }
            }
        }
        max_rectangles = std::max(max_rectangles, count / 2);
    }

    fout << max_rectangles << std::endl;

    return 0;
}
```

### Explanation:

1. **Reading Input**:
   - We use `std::ifstream` to read from `dreptc.in`.
   - We read the number of points `N` and the maximum number of colors `MaxC`.
   - We read each point's coordinates and color, storing them in a map `color_points` where the key is the color and the value is a vector of `Point` structures.

2. **Organizing Points by Color**:
   - We store each point in a map where the key is the color and the value is a vector of points of that color.

3. **Finding Rectangles**:
   - For each color, we use a set `point_set` to store the points for quick lookup.
   - We iterate over all pairs of points and check if they can form the diagonal of a rectangle.
   - If they can, we check if the other two points needed to form the rectangle exist in the set.

4. **Counting Rectangles**:
   - We count the number of valid rectangles for each color and keep track of the maximum count.
   - Since each rectangle is counted twice (once for each diagonal), we divide the count by 2.

5. **Output the Result**:
   - We use `std::ofstream` to write the result to `dreptc.out`.

This approach ensures that we efficiently find and count the rectangles, leveraging the properties of sets for quick lookups.
