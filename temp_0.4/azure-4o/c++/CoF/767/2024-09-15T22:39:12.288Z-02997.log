---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `dreptc.in` and write to `dreptc.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Se consideră $N$ puncte colorate dispuse în plan. Ele sunt identificate prin coordontele lor întregi, pe axele OX și OY. Fiecare punct are asociat un număr natural între $1$ și $C$ reprezentând codul culorii lui. Un dreptunghi se numește *corect* dacă îndeplinește simultan următoarele condiții:

* toate cele patru vârfuri se regăsesc printre cele N puncte date;
* are laturile paralele cu axele OX, OY;
* are vârfurile colorate în aceeași culoare.

# Cerință

Să se determine numărul maxim de dreptunghiuri *corecte* care se pot forma cu cele $N$ puncte din plan.

# Date de intrare

Pe prima linie a fișierul text `dreptc.in` se găsesc două numere $N, MaxC$ reprezentând numărul de puncte din plan și numărul de culori asociate punctelor. Pe următoarele $N$ linii se citesc câte trei numere $x \ y \ c$ reprezentând în ordine coordonata pe axa OX (abscisa), coordonata pe axa OY (ordonata) și codul culorii asociate punctului.

# Date de ieșire

Pe prima linie a fișierul text `dreptc.out` se va scrie un singur număr cu semnificația numărul maxim de dreptunghiuri corecte.

# Restricții și precizări

* $1 \leq N \leq 1 \ 000$;
* $1 \leq C \leq 5$;
* $-1 \ 000 \leq x, y \leq 1 \ 000$;
* Nu există două puncte cu aceleași coordonate
* $40$% din teste vor avea $N \leq 100$;

---

Example:
`dreptc.in`
```
9 2
3 10 1
3 8 2
3 6 1
3 4 1
3 0 1
6 0 1
6 4 1
6 8 2
6 10 1
```

`dreptc.out`
```
3
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:To solve this problem efficiently, we need to follow these steps:

1. **Read Input**: Read the input values from the file `dreptc.in`.
2. **Organize Points by Color**: Store points in a map where the key is the color and the value is a vector of points.
3. **Find Rectangles**: For each color, find all possible rectangles that can be formed using the points of that color.
4. **Count Rectangles**: Count the number of valid rectangles for each color.
5. **Output Result**: Write the result to the file `dreptc.out`.

Here's the C++ code that implements this approach:

```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <unordered_map>
#include <set>

struct Point {
    int x, y;
};

int main() {
    std::ifstream infile("dreptc.in");
    std::ofstream outfile("dreptc.out");

    int N, MaxC;
    infile >> N >> MaxC;

    std::unordered_map<int, std::vector<Point>> colorPoints;

    for (int i = 0; i < N; ++i) {
        int x, y, c;
        infile >> x >> y >> c;
        colorPoints[c].emplace_back(Point{x, y});
    }

    int maxRectangles = 0;

    for (auto &entry : colorPoints) {
        auto &points = entry.second;
        std::set<std::pair<int, int>> pointSet;
        for (auto &p : points) {
            pointSet.insert({p.x, p.y});
        }

        int count = 0;
        for (size_t i = 0; i < points.size(); ++i) {
            for (size_t j = i + 1; j < points.size(); ++j) {
                if (points[i].x != points[j].x && points[i].y != points[j].y) {
                    if (pointSet.count({points[i].x, points[j].y}) && pointSet.count({points[j].x, points[i].y})) {
                        ++count;
                    }
                }
            }
        }
        maxRectangles += count / 2;
    }

    outfile << maxRectangles << std::endl;

    infile.close();
    outfile.close();
    return 0;
}
```

### Explanation:

1. **Reading Input**: The input is read from `dreptc.in` using `ifstream`.
2. **Organize Points by Color**: We use an unordered map where the key is the color and the value is a vector of points of that color.
3. **Finding Rectangles**:
   - For each color, we store the points in a set for quick lookup.
   - We then iterate over all pairs of points. For each pair, if they form the diagonal of a rectangle (i.e., they have different x and y coordinates), we check if the other two points needed to form the rectangle are present in the set.
4. **Counting Rectangles**: Each valid rectangle is counted twice (once for each diagonal), so we divide the count by 2.
5. **Output Result**: The result is written to `dreptc.out` using `ofstream`.

This approach ensures that we efficiently count the number of valid rectangles for each color and sum them up to get the final result.
