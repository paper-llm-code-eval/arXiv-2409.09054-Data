---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `interesant.in` and write to `interesant.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Se consideră o mulțime $S$ care conține $N$ șiruri de caractere formate din litere mici ale alfabetului englezesc.  

Un șir de caractere se numește _interesant_ în raport cu celelalte șiruri ale mulțimii, dacă nu există un alt șir în mulțime care să-l conțină ca subșir. De exemplu, dacă mulțimea $S$ conține șirurile `abc`, `bde` și `abcdef`, atunci singurul șir *interesant* este `abcdef` deoarece `abc` și `bde` nu îl conțin ca subșir. Mai mult, `abc` și `bde` sunt subșiruri în `abcdef`, deci nu sunt *interesante*.

# Cerințe

Fiind dată o mulțime $S$ formată din $N$ șiruri de caractere se cere:

1. Să se determine cel mai lung șir. Dacă sunt mai multe șiruri având aceeași lungime maximă, se cere cel mai mic din punct de vedere lexicografic.
2. Să se determine toate șirurile _interesante_ din  mulțimea $S$.

# Date de intrare


Fișierul de intrare `interesant.in` conține pe prima linie două numere naturale $p$ și $N$, despărțite prin spațiu. Pentru toate testele de intrare, numărul $p$ poate avea doar valoarea $1$ sau valoarea $2$. Pe următoarele $N$ linii, se găsesc șirurile de caractere, câte unul pe linie.


# Date de ieșire


Dacă valoarea lui $p$ este $1$, **se va rezolva numai cerința $1$**.

În acest caz, în fișierul de ieșire `interesant.out` se va scrie cel mai lung șir dintre cele citite. Dacă există mai multe șiruri de aceeași lungime, se va scrie cel mai mic din punct de vedere lexicografic.

Dacă valoarea lui $p$ este $2$, **se va rezolva numai cerința $2$**.

În acest caz, fișierul de ieșire `interesant.out` va conține pe prima linie o valoare $K$ ce reprezintă numărul de șiruri _interesante_, iar pe următoarele $K$ linii, șirurile *interesante* **în ordinea în care apar în fișierul de intrare**.


# Restricții și precizări

* $2 \leq N \leq 200$
* Lungimea unui șir va fi cuprinsă între $1$ și $5 \ 000$.
* Un subșir al șirului de caractere $C_0 C_1 C_2 \dots C_k$ se definește ca fiind o succesiune de caractere $C_{i_1} C_{i_2} C_{i_3} \dots C_{i_k}$, unde $0 \leq i_1 < i_2 < i_3 < \dots < i_k \leq k$.
* Fișierul de intrare **NU conține șiruri identice**.

| $p$ | Punctaj |
| - | ------- |
| $1$ | 20      |
| $2$ | 80      |

---

Example:
`interesant.in`
```
1 5
abcacaaz
ad
abcacaad
acd
zyt
```

`interesant.out`
```
abcacaad
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <algorithm>

bool isSubsequence(const std::string& s1, const std::string& s2) {
    int m = s1.size(), n = s2.size();
    int j = 0; // For index of s1 (or subsequence)
    for (int i = 0; i < n && j < m; i++)
        if (s1[j] == s2[i])
            j++;
    return (j == m);
}

int main() {
    std::ifstream infile("interesant.in");
    std::ofstream outfile("interesant.out");

    int p, N;
    infile >> p >> N;
    infile.ignore(); // Ignore the newline character after N

    std::vector<std::string> strings(N);
    for (int i = 0; i < N; ++i) {
        std::getline(infile, strings[i]);
    }

    if (p == 1) {
        // Find the longest string, if ties, the lexicographically smallest
        std::string longest = strings[0];
        for (int i = 1; i < N; ++i) {
            if (strings[i].length() > longest.length() || 
                (strings[i].length() == longest.length() && strings[i] < longest)) {
                longest = strings[i];
            }
        }
        outfile << longest << "\n";
    } else if (p == 2) {
        // Find all interesting strings
        std::vector<std::string> interesting;
        for (int i = 0; i < N; ++i) {
            bool isInteresting = true;
            for (int j = 0; j < N; ++j) {
                if (i != j && isSubsequence(strings[i], strings[j])) {
                    isInteresting = false;
                    break;
                }
            }
            if (isInteresting) {
                interesting.push_back(strings[i]);
            }
        }
        outfile << interesting.size() << "\n";
        for (const auto& str : interesting) {
            outfile << str << "\n";
        }
    }

    infile.close();
    outfile.close();
    return 0;
}
```

### Explanation:

1. **Reading Input:**
   - The input is read from the file `interesant.in`.
   - The first line contains the values `p` and `N`.
   - The next `N` lines contain the strings.

2. **Processing for `p = 1`:**
   - We need to find the longest string. If there are multiple strings with the same maximum length, the lexicographically smallest one is chosen.
   - We iterate through all strings, comparing their lengths and lexicographical order to find the required string.

3. **Processing for `p = 2`:**
   - We need to find all "interesting" strings.
   - A string is interesting if it is not a subsequence of any other string in the set.
   - We check each string against every other string to see if it is a subsequence.
   - If a string is not a subsequence of any other string, it is added to the list of interesting strings.

4. **Writing Output:**
   - For `p = 1`, the longest string is written to the output file `interesant.out`.
   - For `p = 2`, the number of interesting strings is written first, followed by each interesting string on a new line.

### Example Verification:

Given the example in the problem statement:
- For `p = 1`, the longest string is `abcacaad`.
- For `p = 2`, the interesting strings are those which are not subsequences of any other string.

This solution efficiently handles the constraints and ensures correct results by leveraging string comparison and subsequence checking.
