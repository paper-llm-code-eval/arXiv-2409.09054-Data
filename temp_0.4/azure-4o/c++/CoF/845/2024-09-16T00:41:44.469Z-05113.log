---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `munte.in` and write to `munte.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Se consideră un șir $x_1, x_2, \dots, x_n$ format din $n$ numere naturale distincte. O secvență de număr maxim de elemente vecine în șir, de forma $x_i, x_{i+1}, \dots, x_{k-1}, x_k, x_{k+1}, \dots, x_j$ ($1 \leq i < k < j \leq n$) cu proprietatea că $x_i < x_{i+1} < \dots < x_{k-1} < x_k > x_{k+1} > \dots > x_j$, se numește *munte* cu vârful $x_k$. Două secvențe munte au maxim un element comun în șir. O secvență munte are cel puțin $3$ elemente. Un exemplu de șir format cu valorile $3 \ 4 \ 6 \ 8$ nu conține nicio secvență munte, iar unul format cu valorile $3 \ 4 \ 8 \ 1 \ 2 \ 5 \ 0$ conține $2$ secvențe munte: $3 \ 4 \ 8 \ 1$ și $1 \ 2 \ 5 \ 0$.

După determinarea tuturor secvențelor munte și a vârfurilor acestora, se elimină din șir vârfurile secvențelor munte și procedura continuă repetat cu determinarea noilor secvențe munte și a vârfurilor lor din șirul nou obținut. Procedura se oprește în momentul în care în șir nu mai există nicio secvență munte.

# Cerință

Scrieți un program care citește numerele $n, x_1, x_2, \dots, x_n$ și apoi determină:

1. numărul de secvențe munte din șirul inițial;
2. numărul total de secvențe munte obținute pornind de la șirul inițial până la cel care nu mai conține nicio secvență munte;
3. numărul de elemente din șirul final care nu mai conține secvențe munte.

# Date de intrare

Fișierul de intrare `munte.in` conține pe prima linie numărul $n$, iar pe următoarea linie numerele naturale $x_1, x_2, \dots, x_n$ separate două câte două prin câte un spațiu.

# Date de ieșire

Fișierul de ieșire `munte.out` va conține pe prima linie un număr natural conform cerinței $1$, pe a doua linie un număr natural conform cerinței $2$, pe a treia linie un număr natural conform cerinței $3$.

# Restricții și precizări

* $3 \leq n \leq 100$;
* $0 \leq x_i \leq 100 \ 000$;
* Pentru rezolvarea corectă a cerinței $1$ se obține $20$% din punctaj.
* Pentru rezolvarea corectă a cerinței $2$ se obține $40$% din punctaj.
* Pentru rezolvarea corectă a cerinței $3$ se obține $40$% din punctaj.
* Pentru testele date se asigură că șirul de numere dat inițial conține cel puțin o secvență munte.

---

Example:
`munte.in`
```
8
1 2 5 0 6 9 3 4
```

`munte.out`
```
2
4
4
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```cpp
#include <fstream>
#include <vector>
#include <algorithm>

using namespace std;

vector<int> find_peaks(const vector<int>& arr) {
    vector<int> peaks;
    int n = arr.size();
    for (int i = 1; i < n - 1; ++i) {
        if (arr[i] > arr[i - 1] && arr[i] > arr[i + 1]) {
            peaks.push_back(i);
        }
    }
    return peaks;
}

int main() {
    ifstream fin("munte.in");
    ofstream fout("munte.out");

    int n;
    fin >> n;
    vector<int> arr(n);
    for (int i = 0; i < n; ++i) {
        fin >> arr[i];
    }

    int initial_mountains = 0;
    int total_mountains = 0;

    while (true) {
        vector<int> peaks = find_peaks(arr);
        if (peaks.empty()) break;

        total_mountains += peaks.size();
        if (initial_mountains == 0) initial_mountains = peaks.size();

        for (int peak : peaks) {
            arr[peak] = -1; // Mark peak as removed
        }

        // Remove marked elements
        arr.erase(remove(arr.begin(), arr.end(), -1), arr.end());
    }

    fout << initial_mountains << "\n";
    fout << total_mountains << "\n";
    fout << arr.size() << "\n";

    return 0;
}
```

### Explanation:

1. **Reading Input:**
   - The program reads the input from the file `munte.in` which contains the number of elements `n` and the sequence of numbers.

2. **Finding Peaks:**
   - The function `find_peaks` identifies all the peaks in the current sequence. A peak is defined as an element that is greater than its neighbors.

3. **Processing Peaks:**
   - The main loop continues until no more peaks are found in the sequence.
   - For each iteration, it finds the peaks and removes them from the sequence.
   - The count of initial mountains and total mountains is updated accordingly.

4. **Output Results:**
   - The program writes the results to the file `munte.out`:
     - The number of initial mountain sequences.
     - The total number of mountain sequences found.
     - The size of the final sequence that contains no mountain sequences.

### Efficiency:
- The solution efficiently processes the sequence by iterating over it to find peaks and then removing those peaks.
- The use of `erase-remove` idiom ensures that the sequence is compacted after removing peaks, maintaining efficiency.
