---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `sir.in` and write to `sir.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Se dă un șir format din $N$ numere naturale nenule. Elementele șirului sunt numerotate de la stânga la dreapta începând cu poziția $1$.

# Cerință

Scrieți un program care să determine răspunsul pentru întrebări de următoarele tipuri:

1. Care este cea mai din stânga poziție care conține o valoare strict mai mare decât toate cele din dreapta sa? – întrebare de tipul $1$
2. Care sunt pozițiile care conțin valori strict mai mari decât toate cele din stânga lor? – întrebare de tipul $2$
3. Dacă fiecărui element aflat între prima și ultima apariție a maximului i-am mări valoarea pentru a ajunge egal cu maximul, care este suma totală a valorilor adăugate? – întrebare de tipul $3$

# Date de intrare

Fișierul de intrare `sir.in` conține pe prima linie un număr $C$ (care poate fi $1$, $2$ sau $3$), indicând tipul întrebării. Pe linia a doua se află un număr natural $N$, reprezentând numărul de elemente din șir. Pe a treia linie a fișierului de intrare se află $N$ numere naturale, reprezentând elementele șirului, date de la stânga la dreapta (cel mai din stânga are poziția $1$ și cel mai din dreapta are poziția $N$). Numerele de pe această linie sunt separate prin câte un spațiu.

# Date de ieșire

Dacă $C = 1$, fișierul de ieșire `sir.out` trebuie să conțină un număr natural ce reprezintă răspunsul la o întrebare de tipul $1$. Dacă $C = 2$, fișierul de ieșire trebuie să conțină, separați prin câte un spațiu și în ordine crescătoare, indicii determinați ca răspuns la o întrebare de tipul $2$. Dacă $C = 3$, fișierul de ieșire trebuie să conțină un număr ce reprezintă răspunsul la o întrebare de tipul $3$.

# Restricții și precizări

* $1 \leq C \leq 3$;
* $1 \leq N \leq 100 \ 000$;
* Numerele din șirul dat sunt cuprinse între $1$ și $10 \ 000$ inclusiv.
* Pentru teste în valoare de $24$ de puncte avem $C = 1$.
* Pentru teste în valoare de $32$ de puncte avem $C = 2$.
* Pentru teste în valoare de $44$ de puncte avem $C = 3$.

---

Example:
`sir.in`
```
1
7
3 2 2 5 3 5 4
```

`sir.out`
```
6
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <algorithm>

int main() {
    std::ifstream fin("sir.in");
    std::ofstream fout("sir.out");

    int C, N;
    fin >> C >> N;

    std::vector<int> sir(N);
    for (int i = 0; i < N; ++i) {
        fin >> sir[i];
    }

    if (C == 1) {
        // Question type 1: Find the leftmost position with a value greater than all to its right
        int max_right = -1;
        int position = -1;
        for (int i = N - 1; i >= 0; --i) {
            if (sir[i] > max_right) {
                max_right = sir[i];
                position = i + 1;
            }
        }
        fout << position << "\n";
    } else if (C == 2) {
        // Question type 2: Find positions with values greater than all to their left
        std::vector<int> positions;
        int max_left = -1;
        for (int i = 0; i < N; ++i) {
            if (sir[i] > max_left) {
                max_left = sir[i];
                positions.push_back(i + 1);
            }
        }
        for (size_t i = 0; i < positions.size(); ++i) {
            fout << positions[i];
            if (i < positions.size() - 1) {
                fout << " ";
            }
        }
        fout << "\n";
    } else if (C == 3) {
        // Question type 3: Calculate the sum of values added to make all elements between the first and last max equal to max
        int max_value = *std::max_element(sir.begin(), sir.end());
        int first_max = -1, last_max = -1;
        for (int i = 0; i < N; ++i) {
            if (sir[i] == max_value) {
                if (first_max == -1) {
                    first_max = i;
                }
                last_max = i;
            }
        }
        int sum_added = 0;
        for (int i = first_max; i <= last_max; ++i) {
            sum_added += (max_value - sir[i]);
        }
        fout << sum_added << "\n";
    }

    fin.close();
    fout.close();
    return 0;
}
```

### Explanation:

1. **Reading Input:**
   - The program reads the input from `sir.in` using `std::ifstream`.
   - It reads the type of question `C`, the number of elements `N`, and the sequence of numbers into a vector `sir`.

2. **Handling Question Type 1:**
   - The program iterates from right to left, keeping track of the maximum value encountered so far (`max_right`).
   - It identifies the leftmost position where the current value is greater than `max_right`.

3. **Handling Question Type 2:**
   - The program iterates from left to right, keeping track of the maximum value encountered so far (`max_left`).
   - It collects positions where the current value is greater than `max_left`.

4. **Handling Question Type 3:**
   - The program finds the maximum value in the sequence (`max_value`).
   - It identifies the first and last positions where this maximum value occurs.
   - It calculates the sum of values needed to make all elements between the first and last occurrence of the maximum equal to `max_value`.

5. **Writing Output:**
   - The results are written to `sir.out` using `std::ofstream`.

This solution is efficient and should handle the given constraints well.
