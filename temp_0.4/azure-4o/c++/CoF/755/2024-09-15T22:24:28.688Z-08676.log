---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `elfi.in` and write to `elfi.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Marele vrăjitor Prospero are o grădină minunată îngrijită de o sumedenie de spiriduși care n-au altă sarcină decât să zboare la orele dimineții de-a lungul aleilor și să stropească plantele din vasele ornamentale de piatră aflate pe margine. Există un havuz chiar la capătul grădinii și o alee principală ce pornește de la havuz și duce până la intrare. Din aleea principală se desprind alei secundare ce formează ronduri alungite revenind, în același loc, la aleea principală.

Se știe că există $n$ spiriduși, numerotați de la $1$ la $n$, fiecare pentru câte una dintre aleile secundare. Toți pornesc de la havuz la ora $5:00:00$ dimineața cu câte un vas cu apă pregătit de cu seară, străbat aleea principală până la rondul lor, apoi parcurg aleea rondului propriu, revin în aleea principală, se întorc la havuz pentru a se alimenta cu apă și o iau de la capăt la fel, până la ora $9:00:00$ când se retrag la umbră pentru somn. Se știe că toți spiridușii zboară fără încetare, cu aceeași viteză, pe toată durata celor exact $4$ ore. Se cunosc, pentru fiecare spiriduș, numărul de secunde necesare pentru a ajunge de la havuz la rondul propriu și numărul de secunde necesare pentru a parcurge în întregime rondul propriu. Orice spiriduș care ajunge la havuz își umple vasul în exact o secundă, de la un robinet aflat pe marginea havuzului. De exemplu, dacă spiridușul care se ocupă de rondul $5$ din figură are nevoie de $2$ secunde pentru a ajunge la rondul său și de $15$ secunde pentru a parcurge rondul $5$, atunci va reveni la havuz pentru a-și umple vasul la orele $5:00:19$ ($2 + 15 + 2$), își umple vasul și pornește iar la ora $5:00:20$, revine iar la $5:00:39$ și pleacă iar la ora $5:00:40$ etc.

Doi spiriduși nu își pot umple vasul în același moment de la același robinet.

~[elfi.png]

# Cerință

Se cere să se determine numărul minim de robinete cu care trebuie să fie prevăzut havuzul astfel încât nici un spiriduş, în nici un moment, să nu fie nevoit să aştepte pentru a-şi putea umple vasul cu apă.

# Date de intrare

Din fișierul de intrare `elfi.in` se citesc:

* $n$, numărul de spiriduși, de pe primul rând;
* $n$ perechi de forma $c_i \ p_i$ reprezentând numărul de secunde de la havuz la rondul propriu și respectiv numărul de secunde necesar pentru parcurgerea rondului propriu, de pe următoarele $n$ linii ale fișierului.

# Date de ieșire

În fișierul de ieșire `elfi.out` se scrie o singura linie cu un singur număr reprezentând numărul minim de robinete necesare.

# Restricții și precizări

* $2 \leq n \leq 5 \ 000$;
* $1 \leq c_i \leq 100$;
* $1 \leq p_i \leq 100$;

---

Example:
`elfi.in`
```
5
7 4
7 8
4 5
7 6
2 15
```

`elfi.out`
```
4
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:To solve this problem efficiently, we need to determine the number of taps required to ensure that no two elves need to wait to refill their water vessels. Here's a step-by-step approach to achieve this:

1. **Understanding the Problem**: Each elf has a cycle time which includes the time to reach their round trip (to and from their round), the time to complete the round, and the time to refill the vessel (1 second). We need to calculate the exact moments when each elf will be at the fountain to refill their vessel.

2. **Reading Input**: We will read the input from the file `elfi.in`.

3. **Calculating Refill Times**:
    - For each elf, compute the total cycle time: `2 * c_i + p_i + 1`.
    - Determine all the moments within the 4-hour window (14400 seconds) when each elf will be at the fountain.

4. **Tracking Refill Moments**:
    - Use a map or an array to count how many elves are at the fountain at each second.
    - The maximum count at any second will give the number of taps needed.

5. **Writing Output**: Write the result to `elfi.out`.

Here is the C++ code implementing the above logic:

```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <algorithm>
#include <map>

int main() {
    std::ifstream infile("elfi.in");
    std::ofstream outfile("elfi.out");

    int n;
    infile >> n;
    
    std::vector<int> c(n), p(n);
    for (int i = 0; i < n; ++i) {
        infile >> c[i] >> p[i];
    }

    std::map<int, int> refill_times;
    const int total_time = 14400; // 4 hours in seconds

    for (int i = 0; i < n; ++i) {
        int cycle_time = 2 * c[i] + p[i] + 1;
        for (int t = cycle_time; t <= total_time; t += cycle_time) {
            refill_times[t]++;
        }
    }

    int max_taps = 0;
    for (const auto& entry : refill_times) {
        max_taps = std::max(max_taps, entry.second);
    }

    outfile << max_taps << std::endl;

    return 0;
}
```

### Explanation of the Code:
- **Reading Input**: We read the number of elves `n` and the pairs of integers `c_i` and `p_i` from the input file.
- **Calculating Refill Times**: For each elf, we compute the cycle time and then determine all the moments within the 4-hour period when the elf will be at the fountain.
- **Tracking Refill Moments**: We use a map to count the number of elves refilling at each second.
- **Finding Maximum Taps Needed**: The maximum value in the map gives the number of taps required.
- **Writing Output**: The result is written to the output file.

This solution ensures that we efficiently determine the number of taps required without any unnecessary computations, making it suitable for the input size constraints.
