---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `bete.in` and write to `bete.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Ana și Bogdan au găsit la bunicul lor o cutie cu $N$ bețe de aceeași lungime. După câteva minute de joacă urmează cearta. Bunicul le-a propus să rupă cele $N$ bețe și apoi Ana să primească fragmentele din mâna stângă, iar Bogdan fragmentele din mâna dreaptă. Zis și făcut. Copiii au luat fragmentele, le-au numerotat fiecare cu numere de la $1$ la $N$, le-au măsurat și acum își doresc să lipească fragmentele primite, dar mai au nevoie de câteva informații.

# Cerință

Cunoscând $N$ numărul de bețe, $A_1$, $A_2$, ..., $A_N$ lungimile fragmentelor primite de Ana și $B_1$, $B_2$, ..., $B_N$ lungimile fragmentelor primite de Bogdan, să se scrie un program care să determine:

* lungimea inițială a bețelor;
* lungimea celui mai lung băț care se poate obține prin lipirea unui fragment aparținând Anei cu un fragment care aparține lui Bogdan;
* numărul bețelor de lungime maximă care se pot obține prin lipirea unui fragment aparținând Anei cu un fragment care aparține lui Bogdan.

# Date de intrare


Fișierul de intrare `bete.in` conține pe prima linie numărul natural $N$ reprezentând numărul de bețe. Pe a doua linie sunt $N$ numere naturale $A_1$, $A_2$, ..., $A_N$ reprezentând lungimile fragmentelor primite de Ana și pe a treia linie sunt $N$ numere naturale $B_1$, $B_2$, ..., $B_N$ reprezentând lungimile fragmentelor primite de Bogdan.


# Date de ieșire

Fișierul de ieșire `bete.out` va conține trei linii. Pe prima linie se va scrie numărul natural $L$ reprezentând lungimea inițială a bețelor, pe a doua linie se va scrie numărul natural $K$ reprezentând lungimea celui mai lung băț care se poate obține prin lipirea unui fragment aparținând Anei cu un fragment care aparține lui Bogdan, iar pe a treia linie se va scrie numărul natural $P$ reprezentând numărul bețelor de lungime maximă care se pot obține prin lipirea unui fragment aparținând Anei cu un fragment care aparține lui Bogdan.


# Restricții și precizări

* $1 \leq N \leq 1 \ 000$;
* $1 \leq A_i \leq 10 \ 000$;
* $1 \leq B_i \leq 10 \ 000$;
* $1 \leq L \leq 20 \ 000$;
* $1 \leq K \leq 20 \ 000$;
* $1 \leq P \leq 1 \ 000$;
* Odată lipite două fragmente, acestea nu se pot dezlipi.
* Pentru determinarea corectă a valorii L se acordă 30% din punctaj, pentru determinarea corectă a valorii K se acordă 30% din punctaj, iar pentru determinarea corectă a valorii P se acordă 40% din punctaj.

---

Example:
`bete.in`
```
6
2 6 7 1 3 5
5 4 7 8 9 3
```

`bete.out`
```
10
16
1
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:To solve this problem efficiently, we need to follow these steps:

1. **Read Input Efficiently**: We will read the input from the file `bete.in` using file I/O operations.
2. **Compute Initial Length (L)**: The initial length of each stick can be computed as the sum of corresponding elements from the two lists.
3. **Compute Maximum Length (K)**: We need to find the maximum sum of any pair of elements from the two lists.
4. **Count Maximum Length Occurrences (P)**: We need to count how many times this maximum sum occurs.

Let's implement this in C++:

```cpp
#include <fstream>
#include <vector>
#include <algorithm>

int main() {
    std::ifstream infile("bete.in");
    std::ofstream outfile("bete.out");

    int N;
    infile >> N;

    std::vector<int> A(N), B(N);
    for (int i = 0; i < N; ++i) {
        infile >> A[i];
    }
    for (int i = 0; i < N; ++i) {
        infile >> B[i];
    }

    // Compute the initial length L
    int L = 0;
    for (int i = 0; i < N; ++i) {
        L += A[i] + B[i];
    }
    L /= N;

    // Compute the maximum length K and its occurrences P
    int K = 0, P = 0;
    for (int i = 0; i < N; ++i) {
        for (int j = 0; j < N; ++j) {
            int sum = A[i] + B[j];
            if (sum > K) {
                K = sum;
                P = 1;
            } else if (sum == K) {
                ++P;
            }
        }
    }

    // Write the results to the output file
    outfile << L << "\n" << K << "\n" << P << "\n";

    return 0;
}
```

### Explanation:

1. **Reading Input**:
   - We use `std::ifstream` to read from `bete.in`.
   - We read the number of sticks `N`.
   - We read the lengths of fragments received by Ana and Bogdan into vectors `A` and `B`.

2. **Computing Initial Length (L)**:
   - We sum up all the lengths from both vectors `A` and `B`.
   - The initial length of each stick is the average of these sums.

3. **Computing Maximum Length (K) and its Occurrences (P)**:
   - We iterate through all pairs of fragments from `A` and `B`.
   - We keep track of the maximum sum found (`K`) and count how many times this maximum sum occurs (`P`).

4. **Writing Output**:
   - We use `std::ofstream` to write the results to `bete.out`.

This solution ensures efficient reading and writing of data and performs the necessary computations in a straightforward manner. The nested loop for finding `K` and `P` operates in O(N^2) time, which is acceptable given the constraints (N ≤ 1000).
