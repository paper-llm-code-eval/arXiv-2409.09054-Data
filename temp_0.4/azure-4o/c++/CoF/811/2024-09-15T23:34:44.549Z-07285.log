---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `grupe.in` and write to `grupe.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Se consideră un tablou bidimensional cu $m$ linii, $n$ coloane și elemente numere naturale. Pentru fiecare element se determină numărul de divizori pozitivi. Se formează apoi grupe cu elementele tabloului care au același număr de divizori, grupe notate $G_1, G_2, \dots, G_k$. Se ordonează descrescător grupele după numărul de elemente ce le conțin. Se știe că o grupă $G_1$ se află în fața unei alte grupe $G_2$ dacă $G_1$ are mai multe elemente decât $G_2$ sau, în cazul în care cele două grupe conțin același număr de elemente, numărul de divizori ai elementelor din grupa $G_1$ este mai mare decât numărul de divizori ai elementelor din grupa $G_2$. După ordonarea descrescătoare a grupelor, notăm prima grupă cu $A$ și a doua grupă cu $B$. În cazul în care toate elementele vor avea același număr de divizori, va exista o singură grupă, grupa $A$.

# Cerință

Scrieți un program care citește $m$, $n$, elementele tabloului și afișează:
* numărul de divizori pozitivi pentru grupa $A$, numărul de elemente din grupă și cea mai mare valoare din grupă;
* numărul de divizori pozitivi pentru grupa $B$, numărul de elemente din grupă și cea mai mare valoare din grupă; în cazul în care nu există grupa a doua, se va afișa de trei ori valoarea $0$

# Date de intrare

Fișierul `grupe.in` conține pe prima linie valorile lui $m$ și $n$ separate printr-un spațiu, iar pe celelalte $m$ linii câte $n$ elemente separate două câte două printr-un spațiu, reprezentând elementele tabloului.

# Date de ieșire

Fișierul `grupe.out` va conține:
- pe prima linie valoarea numărului de divizori pozitivi din grupa $A$, numărul de elemente din grupa $A$ și cea mai mare valoare din grupa $A$, valori separate două câte două printr-un singur spațiu;
- pe a doua linie valoarea numărului de divizori pozitivi din grupa $B$, numărul de elemente din grupa $B$ și cea mai mare valoare din grupa $B$, valori separate două câte două printr-un singur spațiu.

# Restricții și precizări

* $1 \leq m, n \leq 100$
* elementele tabloului bidimensional inițial sunt mai mici sau egale decât $100 \ 000$ și mai mari decât $1$;
* grupă poate fi compusă dintr-un singur element
* se acordă $50\%$ din punctaj pentru afișarea corectă a fiecărei linii

---

Example:
`grupe.in`
```
2 3
16 2 4
10 6 5
```

`grupe.out`
```
4 2 10
2 2 5
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```cpp
#include <fstream>
#include <vector>
#include <unordered_map>
#include <algorithm>
#include <cmath>

// Function to calculate the number of divisors of a given number
int countDivisors(int num) {
    int count = 0;
    int sqrtNum = static_cast<int>(std::sqrt(num));
    for (int i = 1; i <= sqrtNum; ++i) {
        if (num % i == 0) {
            if (i == num / i) {
                count += 1; // Perfect square
            } else {
                count += 2; // Pair of divisors
            }
        }
    }
    return count;
}

int main() {
    std::ifstream infile("grupe.in");
    std::ofstream outfile("grupe.out");

    int m, n;
    infile >> m >> n;

    std::vector<std::vector<int>> matrix(m, std::vector<int>(n));
    std::unordered_map<int, std::vector<int>> divisorGroups;

    // Read the matrix and group elements by their number of divisors
    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            infile >> matrix[i][j];
            int divisors = countDivisors(matrix[i][j]);
            divisorGroups[divisors].push_back(matrix[i][j]);
        }
    }

    // Create a vector of pairs to sort the groups
    std::vector<std::pair<int, std::vector<int>>> groups;
    for (auto& group : divisorGroups) {
        groups.emplace_back(group.first, group.second);
    }

    // Sort the groups by the number of elements and then by the number of divisors
    std::sort(groups.begin(), groups.end(), [](const auto& a, const auto& b) {
        if (a.second.size() == b.second.size()) {
            return a.first > b.first;
        }
        return a.second.size() > b.second.size();
    });

    // Output the results for group A
    int groupADivisors = groups[0].first;
    int groupASize = groups[0].second.size();
    int groupAMax = *std::max_element(groups[0].second.begin(), groups[0].second.end());
    outfile << groupADivisors << " " << groupASize << " " << groupAMax << "\n";

    // Output the results for group B if it exists
    if (groups.size() > 1) {
        int groupBDivisors = groups[1].first;
        int groupBSize = groups[1].second.size();
        int groupBMax = *std::max_element(groups[1].second.begin(), groups[1].second.end());
        outfile << groupBDivisors << " " << groupBSize << " " << groupBMax << "\n";
    } else {
        outfile << "0 0 0\n";
    }

    return 0;
}
```

### Explanation

1. **Reading Input**: The program reads the matrix dimensions `m` and `n` from the input file `grupe.in`, followed by the matrix elements.

2. **Counting Divisors**: For each element in the matrix, it calculates the number of positive divisors using the `countDivisors` function. The function iterates up to the square root of the number to efficiently count divisors.

3. **Grouping Elements**: Elements are grouped by their number of divisors using an `unordered_map`, where the key is the number of divisors and the value is a vector of elements having that number of divisors.

4. **Sorting Groups**: The groups are sorted in descending order first by the size of the group and then by the number of divisors if the sizes are equal.

5. **Outputting Results**: The program outputs the number of divisors, the size of the group, and the maximum element for the first group (group A). If a second group exists, it outputs the same information for group B; otherwise, it outputs `0 0 0`.

This solution ensures efficient computation and sorting, adhering to the constraints and requirements of the problem.
