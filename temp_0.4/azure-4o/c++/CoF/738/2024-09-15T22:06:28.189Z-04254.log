---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `ucif.in` and write to `ucif.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Fie $n$ un număr natural și $s = 1^1 + 2^2 + 3^3 + \dots + n^n$.

# Cerință

Scrieți un program care să afișeze ultima cifră a lui $s$.

# Date de intrare


De pe prima linie a fișierului de intrare `ucif.in` se citește numărul $n$.


# Date de ieșire


Pe prima linie a fișierului de ieșire `ucif.out` se va afișa numai ultima cifră a lui $s$.


# Restricții și precizări

* $1 \leq n \leq 100$

---

Example:
`ucif.in`
```
3
```

`ucif.out`
```
2
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:To solve this challenge, we need to compute the sum \( s = 1^1 + 2^2 + 3^3 + \dots + n^n \) and then find the last digit of this sum. Given the constraints, we can efficiently compute this by focusing only on the last digit of each term and summing them up.

Here's the step-by-step plan:
1. Read the integer \( n \) from the input file `ucif.in`.
2. Compute each term \( i^i \) modulo 10 to get the last digit of each term.
3. Sum these last digits.
4. Output the last digit of the sum to the output file `ucif.out`.

The code below implements this approach in C++:

```cpp
#include <fstream>
#include <cmath>

int main() {
    std::ifstream fin("ucif.in");
    std::ofstream fout("ucif.out");

    int n;
    fin >> n;

    int last_digit_sum = 0;

    for (int i = 1; i <= n; ++i) {
        int last_digit = 1;
        for (int j = 0; j < i; ++j) {
            last_digit = (last_digit * i) % 10;
        }
        last_digit_sum = (last_digit_sum + last_digit) % 10;
    }

    fout << last_digit_sum << std::endl;

    fin.close();
    fout.close();

    return 0;
}
```

### Explanation:
1. **Reading Input:**
   - We use `std::ifstream` to read the integer \( n \) from the file `ucif.in`.

2. **Computing Last Digits:**
   - For each integer \( i \) from 1 to \( n \), we compute \( i^i \) modulo 10. This is done by multiplying \( i \) by itself \( i \) times and taking the result modulo 10 at each step to keep the number small and manageable.

3. **Summing Last Digits:**
   - We maintain a running sum of these last digits and take the sum modulo 10 to ensure we only keep the last digit of the sum.

4. **Writing Output:**
   - Finally, we write the last digit of the sum to the file `ucif.out`.

This approach ensures that we never work with large numbers directly, keeping the computation efficient and within the constraints.
