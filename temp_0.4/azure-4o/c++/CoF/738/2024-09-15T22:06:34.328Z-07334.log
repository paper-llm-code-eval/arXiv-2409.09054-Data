---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `ucif.in` and write to `ucif.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Fie $n$ un număr natural și $s = 1^1 + 2^2 + 3^3 + \dots + n^n$.

# Cerință

Scrieți un program care să afișeze ultima cifră a lui $s$.

# Date de intrare


De pe prima linie a fișierului de intrare `ucif.in` se citește numărul $n$.


# Date de ieșire


Pe prima linie a fișierului de ieșire `ucif.out` se va afișa numai ultima cifră a lui $s$.


# Restricții și precizări

* $1 \leq n \leq 100$

---

Example:
`ucif.in`
```
3
```

`ucif.out`
```
2
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:To solve this challenge, we need to compute the last digit of the sum \( s = 1^1 + 2^2 + 3^3 + \dots + n^n \). Given the constraints, we can optimize our approach by focusing on computing only the last digit of each term in the sum and then summing those last digits.

Here's the step-by-step approach:

1. **Read the input value \( n \) from the file `ucif.in`.**
2. **Compute the last digit of each term \( i^i \) for \( i \) from 1 to \( n \).**
3. **Sum these last digits and compute the last digit of the resulting sum.**
4. **Write the last digit to the file `ucif.out`.**

The following C++ code implements this approach efficiently:

```cpp
#include <fstream>
#include <cmath>

int main() {
    std::ifstream infile("ucif.in");
    std::ofstream outfile("ucif.out");

    int n;
    infile >> n;

    int last_digit_sum = 0;

    for (int i = 1; i <= n; ++i) {
        int last_digit = 1;
        for (int j = 0; j < i; ++j) {
            last_digit = (last_digit * i) % 10;
        }
        last_digit_sum = (last_digit_sum + last_digit) % 10;
    }

    outfile << last_digit_sum << std::endl;

    return 0;
}
```

### Explanation

1. **Reading Input:**
   - We use `std::ifstream` to read the input value \( n \) from `ucif.in`.

2. **Computing Last Digits:**
   - For each \( i \) from 1 to \( n \), we compute \( i^i \) modulo 10 to get the last digit of \( i^i \).
   - This is done using a loop that multiplies \( i \) by itself \( i \) times, taking the result modulo 10 at each step to keep the numbers small and manageable.

3. **Summing Last Digits:**
   - We keep a running total of the last digits, again taking the result modulo 10 at each step to ensure we only keep the last digit of the sum.

4. **Writing Output:**
   - Finally, we write the last digit of the sum to `ucif.out` using `std::ofstream`.

This approach ensures that we handle the calculations efficiently and only focus on the last digits, which is crucial for performance given the constraints.
