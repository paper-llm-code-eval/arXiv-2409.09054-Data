---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `ucif.in` and write to `ucif.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Fie $n$ un număr natural și $s = 1^1 + 2^2 + 3^3 + \dots + n^n$.

# Cerință

Scrieți un program care să afișeze ultima cifră a lui $s$.

# Date de intrare


De pe prima linie a fișierului de intrare `ucif.in` se citește numărul $n$.


# Date de ieșire


Pe prima linie a fișierului de ieșire `ucif.out` se va afișa numai ultima cifră a lui $s$.


# Restricții și precizări

* $1 \leq n \leq 100$

---

Example:
`ucif.in`
```
3
```

`ucif.out`
```
2
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:To solve this problem efficiently, we need to focus on calculating the last digit of the sum \( s = 1^1 + 2^2 + 3^3 + \dots + n^n \). Given the constraints \( 1 \leq n \leq 100 \), we can use modular arithmetic to keep our calculations efficient and within bounds.

Here is the step-by-step approach:

1. **Read the input value \( n \)** from the file `ucif.in`.
2. **Initialize a variable** to store the sum of the last digits.
3. **Iterate from 1 to \( n \)**, compute \( i^i \) for each \( i \), and keep track of the last digit by taking modulo 10.
4. **Sum up the last digits** and take the modulo 10 of the sum to get the last digit of the total sum.
5. **Write the result** to the output file `ucif.out`.

Here is the C++ code implementing the above logic:

```cpp
#include <fstream>
#include <cmath>

int main() {
    std::ifstream infile("ucif.in");
    std::ofstream outfile("ucif.out");

    int n;
    infile >> n;

    int last_digit_sum = 0;

    for (int i = 1; i <= n; ++i) {
        int last_digit = 1;
        for (int j = 0; j < i; ++j) {
            last_digit = (last_digit * i) % 10;
        }
        last_digit_sum = (last_digit_sum + last_digit) % 10;
    }

    outfile << last_digit_sum << std::endl;

    infile.close();
    outfile.close();

    return 0;
}
```

### Explanation:
1. **Reading Input**: We use `std::ifstream` to read the input value `n` from `ucif.in`.
2. **Initialization**: We initialize `last_digit_sum` to 0 to keep track of the sum of the last digits.
3. **Loop Through Numbers**: For each number from 1 to `n`, we calculate the last digit of \( i^i \) using a nested loop and modular arithmetic.
4. **Summing Last Digits**: We add the last digit of each \( i^i \) to `last_digit_sum` and take modulo 10 to ensure it remains a single digit.
5. **Writing Output**: We write the final result to `ucif.out` using `std::ofstream`.

This approach ensures that we efficiently compute the last digit of the sum without dealing with large numbers directly, leveraging the properties of modular arithmetic.
