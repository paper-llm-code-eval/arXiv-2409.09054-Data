---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `stdin` and write to `stdout`.
The solution must use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

~[polihroniade.png|align=right]

O matrice pătratică de dimensiuni `N × N` cu `N` par și elemente din mulțimea `{0, 1}` se numește **tablă de șah** dacă oricare două celule vecine pe o linie sau pe o coloană au valori diferite (cu alte cuvinte, dacă nu există două valori egale alăturate).

De ziua ei, Victor i-a cumpărat Elisabetei o astfel de matrice `A`, care nu este *neapărat* tablă de șah. Aflând despre pasiunea ei, acesta vrea acum să transforme matricea `A` într-o tablă de șah. Timpul fiind limitat, el poate efectua doar următoarele tipuri de operații asupra matricii:

- Interschimbă liniile `i` și `j` din `A` (celelalte linii rămân neschimbate, iar valorile din interiorul liniilor `i` și `j` rămân neschimbate și își păstrează ordinea). Operația are sens pentru `1 ≤ i, j ≤ N`.
- Interschimbă coloanele `i` și `j` din `A` (celelalte coloane rămân neschimbate, iar valorile din interiorul coloanelor `i` și `j` rămân neschimbate și își păstrează ordinea). Operația are sens pentru `1 ≤ i, j ≤ N`.

Dorind să o impresioneze pe Elisabeta, Victor apelează la voi, programatori renumiți, să îl ajutați în a transforma matricea `A` într-o tablă de șah. Pentru aceasta, Victor are nevoie de următoarele informații:
- Poate fi transformată matricea `A` în tablă de șah?
- Care este numărul minim de operații necesare pentru a duce la îndeplinire acest scop?
- Care ar fi o succesiune de operații care transformă matricea `A` într-o tablă de șah?

În cazul ultimei cerințe, pentru a intra în grațiile lui Victor va trebui ca numărul de operații efectuate să fie minim. Totuși, chiar și un număr neminim de operații va fi răsplătit, însă nu într-atât de mult.

Vi se dau două numere `P, T` și `T` matrici `A`, reprezentând mai multe instanțe ale problemei. Pentru fiecare matrice `A` dintre cele `T` va trebui să rezolvați cerința cu numărul `P ∈ {1, 2, 3}` dintre cele listate mai sus.

# Date de intrare
Pe prima linie se găsesc două numere întregi pozitive `P` și `T`, reprezentând numarul cerinței de rezolvat și, respectiv, numărul de scenarii pentru care va trebui să rezolvați problema.
Urmează cele `T` instanțe ale problemei, fiecare fiind compusă din `N + 1` linii: pe prima linie se va afla numărul `N`, iar pe următoarele `N` linii câte `N` cifre binare **neseparate** prin spații, reprezentând câte o linie a matricii `A`.

# Date de ieșire
Pentru fiecare dintre cele `T` instanțe se va afișa răspunsul, începând de la o linie nouă, după cum urmează:

1. Dacă `P = 1`, atunci se va afișa pe o singură linie `1` dacă matricea `A` poate fi transformată în tablă de șah, și `0` altfel.
2. Dacă `P = 2`, atunci se va afișa pe o singură linie un întreg reprezentând numărul minim de interschimbări de linii și/sau coloane necesare pentru a transforma matricea `A` în tablă de șah.
3. Dacă `P = 3`, atunci se va afișa pe o linie un număr `X`. Apoi, pe fiecare dintre următoarele `X` linii se va afișa câte o interschimbare de linii sau coloane, după următorul format: `L i j` are semnificația că liniile `i` și `j` se interschimbă, iar `C i j` are semnificația că coloanele `i` și `j` se interschimbă. Matricea obținută după aplicarea celor `X` operații asupra lui `A` în ordinea dată trebuie să fie o tablă de șah.

# Restricții și precizări
* `1 ≤ T ≤ 350`
* `1 ≤ N ≤ 1 000`
* `N` este par.
* Pentru cerințele de tip `P = 2` și `P = 3` se garantează că matricea `A` poate fi transformată în tablă de șah folosind interschimbări de linii și/sau coloane.
* Suma valorilor `N` pentru cele `T` scenarii nu depășește `2 000`.

## Pentru 40 de puncte
* `P = 1`
## Pentru alte 34 de puncte
* `P = 2`
## Pentru alte 26 de puncte
* `P = 3`
* Dacă există mai multe soluții, oricare este considerată corectă.
* Dacă numărul `X` de operații folosite nu este minim, atunci se acordă `50%` din punctajul pe test.

---

Example:
`stdin`
```
1 3
2
11
11
4
1100
1100
0011
0011
2
10
01
```

`stdout`
```
0
1
1
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:Here is the C++ solution for the given problem. This solution reads from `stdin` and writes to `stdout` using `cin` and `cout`. The solution is designed to handle all three types of queries (`P = 1`, `P = 2`, and `P = 3`).

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

bool isChessboard(const vector<vector<int>> &A, int N) {
    for (int i = 0; i < N; ++i) {
        for (int j = 0; j < N; ++j) {
            if (i > 0 && A[i][j] == A[i-1][j]) return false;
            if (j > 0 && A[i][j] == A[i][j-1]) return false;
        }
    }
    return true;
}

int minSwapsToChessboard(vector<vector<int>> &A, int N) {
    vector<int> rowSwaps(N, 0), colSwaps(N, 0);
    for (int i = 0; i < N; ++i) {
        for (int j = 0; j < N; ++j) {
            if ((i + j) % 2 != A[i][j]) {
                rowSwaps[i]++;
                colSwaps[j]++;
            }
        }
    }
    int rowSwapCount = min(count(rowSwaps.begin(), rowSwaps.end(), 0), count(rowSwaps.begin(), rowSwaps.end(), N));
    int colSwapCount = min(count(colSwaps.begin(), colSwaps.end(), 0), count(colSwaps.begin(), colSwaps.end(), N));
    return (rowSwapCount + colSwapCount) / 2;
}

vector<pair<char, pair<int, int>>> getSwapOperations(vector<vector<int>> &A, int N) {
    vector<pair<char, pair<int, int>>> operations;
    for (int i = 0; i < N; ++i) {
        if (i % 2 != A[i][0]) {
            for (int j = i + 1; j < N; ++j) {
                if (i % 2 == A[j][0]) {
                    swap(A[i], A[j]);
                    operations.push_back({'L', {i + 1, j + 1}});
                    break;
                }
            }
        }
    }
    for (int j = 0; j < N; ++j) {
        if (j % 2 != A[0][j]) {
            for (int k = j + 1; k < N; ++k) {
                if (j % 2 == A[0][k]) {
                    for (int i = 0; i < N; ++i) {
                        swap(A[i][j], A[i][k]);
                    }
                    operations.push_back({'C', {j + 1, k + 1}});
                    break;
                }
            }
        }
    }
    return operations;
}

int main() {
    int P, T;
    cin >> P >> T;
    while (T--) {
        int N;
        cin >> N;
        vector<vector<int>> A(N, vector<int>(N));
        for (int i = 0; i < N; ++i) {
            string row;
            cin >> row;
            for (int j = 0; j < N; ++j) {
                A[i][j] = row[j] - '0';
            }
        }
        if (P == 1) {
            cout << (isChessboard(A, N) ? 1 : 0) << endl;
        } else if (P == 2) {
            cout << minSwapsToChessboard(A, N) << endl;
        } else if (P == 3) {
            vector<pair<char, pair<int, int>>> operations = getSwapOperations(A, N);
            cout << operations.size() << endl;
            for (const auto &op : operations) {
                cout << op.first << " " << op.second.first << " " << op.second.second << endl;
            }
        }
    }
    return 0;
}
```

### Explanation:
1. **isChessboard Function**:
   - This function checks if a given matrix is already a chessboard.
   - It iterates through the matrix and checks if any two adjacent cells have the same value.

2. **minSwapsToChessboard Function**:
   - This function calculates the minimum number of swaps needed to transform the matrix into a chessboard.
   - It counts the number of mismatches for rows and columns and determines the minimum swaps required.

3. **getSwapOperations Function**:
   - This function generates the sequence of swap operations to transform the matrix into a chessboard.
   - It first fixes the rows and then the columns by swapping them to match the chessboard pattern.

4. **main Function**:
   - Reads input values and matrix data.
   - Depending on the value of `P`, it calls the appropriate function and prints the result.
---------- user ----------


Program result did not match expected result.
Input data:
```
1 3
2
11
11
4
1100
1100
0011
0011
2
10
01
```
Expected output:
```
0
1
1
```
Found output:
```
0
0
1
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

Let's analyze the differences between the expected and found results:

1. For the first test case, both the expected and found results are `0`, which is correct.
2. For the second test case, the expected result is `1`, but the found result is `0`. This indicates a discrepancy in the logic for determining if the matrix can be transformed into a chessboard.
3. For the third test case, both the expected and found results are `1`, which is correct.

The discrepancy in the second test case suggests that the logic for determining the minimum number of swaps is incorrect. Let's re-evaluate the approach and correct the implementation.

### Revised Approach

1. **Check if the matrix can be transformed into a chessboard**:
   - For a matrix to be transformable into a chessboard, the number of rows and columns with an odd number of `1`s should be even.
   
2. **Calculate the minimum number of swaps**:
   - To transform the matrix into a chessboard, we need to count the number of swaps required to make rows and columns alternate between `0` and `1`.

3. **Generate the sequence of operations**:
   - Track the swaps performed to transform the matrix into a chessboard.

### Corrected Implementation

Here is the corrected C++ solution:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

bool canBeChessboard(const vector<vector<int>> &A, int N) {
    int rowSum = 0, colSum = 0;
    for (int i = 0; i < N; ++i) {
        int rowCount = 0, colCount = 0;
        for (int j = 0; j < N; ++j) {
            rowCount += A[i][j];
            colCount += A[j][i];
        }
        rowSum += (rowCount % 2);
        colSum += (colCount % 2);
    }
    return (rowSum % 2 == 0 && colSum % 2 == 0);
}

int minSwapsToChessboard(vector<vector<int>> &A, int N) {
    vector<int> rowSwaps(N, 0), colSwaps(N, 0);
    int rowSwapCount = 0, colSwapCount = 0;
    
    for (int i = 0; i < N; ++i) {
        for (int j = 0; j < N; ++j) {
            if ((i + j) % 2 != A[i][j]) {
                rowSwaps[i]++;
                colSwaps[j]++;
            }
        }
    }
    
    for (int i = 0; i < N; ++i) {
        rowSwapCount += min(rowSwaps[i], N - rowSwaps[i]);
        colSwapCount += min(colSwaps[i], N - colSwaps[i]);
    }
    
    return (rowSwapCount + colSwapCount) / 2;
}

vector<pair<char, pair<int, int>>> getSwapOperations(vector<vector<int>> &A, int N) {
    vector<pair<char, pair<int, int>>> operations;
    
    for (int i = 0; i < N; ++i) {
        if (i % 2 != A[i][0]) {
            for (int j = i + 1; j < N; ++j) {
                if (i % 2 == A[j][0]) {
                    swap(A[i], A[j]);
                    operations.push_back({'L', {i + 1, j + 1}});
                    break;
                }
            }
        }
    }
    
    for (int j = 0; j < N; ++j) {
        if (j % 2 != A[0][j]) {
            for (int k = j + 1; k < N; ++k) {
                if (j % 2 == A[0][k]) {
                    for (int i = 0; i < N; ++i) {
                        swap(A[i][j], A[i][k]);
                    }
                    operations.push_back({'C', {j + 1, k + 1}});
                    break;
                }
            }
        }
    }
    
    return operations;
}

int main() {
    int P, T;
    cin >> P >> T;
    while (T--) {
        int N;
        cin >> N;
        vector<vector<int>> A(N, vector<int>(N));
        for (int i = 0; i < N; ++i) {
            string row;
            cin >> row;
            for (int j = 0; j < N; ++j) {
                A[i][j] = row[j] - '0';
            }
        }
        if (P == 1) {
            cout << (canBeChessboard(A, N) ? 1 : 0) << endl;
        } else if (P == 2) {
            cout << minSwapsToChessboard(A, N) << endl;
        } else if (P == 3) {
            vector<pair<char, pair<int, int>>> operations = getSwapOperations(A, N);
            cout << operations.size() << endl;
            for (const auto &op : operations) {
                cout << op.first << " " << op.second.first << " " << op.second.second << endl;
            }
        }
    }
    return 0;
}
```

### Explanation of Fixes:
1. **canBeChessboard Function**:
   - This function now correctly checks if the matrix can be transformed into a chessboard by ensuring that the number of rows and columns with an odd number of `1`s is even.

2. **minSwapsToChessboard Function**:
   - The function now correctly calculates the minimum number of swaps required to transform the matrix into a chessboard by counting mismatches and determining the minimum swaps needed.

3. **getSwapOperations Function**:
   - This function generates the sequence of swap operations to transform the matrix into a chessboard by fixing rows and columns.

This revised solution should now produce the correct results for all test cases.
---------- user ----------


Program result did not match expected result.
Input data:
```
1 3
2
11
11
4
1100
1100
0011
0011
2
10
01
```
Expected output:
```
0
1
1
```
Found output:
```
1
1
1
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The discrepancy in the results indicates that the logic for determining if a matrix can be transformed into a chessboard is incorrect. Specifically, the `canBeChessboard` function is producing incorrect results for certain cases.

Let's re-evaluate the logic and correct the implementation:

### Correct Approach

1. **Check if the matrix can be transformed into a chessboard**:
   - For a matrix to be transformable into a chessboard, the number of `1`s and `0`s in each row and column should be balanced.
   - Additionally, the patterns of rows and columns should match one of the two possible chessboard patterns.

2. **Calculate the minimum number of swaps**:
   - To transform the matrix into a chessboard, we need to count the number of swaps required to make rows and columns alternate between `0` and `1`.

3. **Generate the sequence of operations**:
   - Track the swaps performed to transform the matrix into a chessboard.

### Corrected Implementation

Here is the corrected C++ solution:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

bool canBeChessboard(const vector<vector<int>> &A, int N) {
    int rowSum = 0, colSum = 0;
    int rowPattern1 = 0, rowPattern2 = 0;
    int colPattern1 = 0, colPattern2 = 0;

    for (int i = 0; i < N; ++i) {
        int rowCount = 0, colCount = 0;
        for (int j = 0; j < N; ++j) {
            rowCount += A[i][j];
            colCount += A[j][i];
        }
        if (rowCount != N / 2 && rowCount != (N + 1) / 2) return false;
        if (colCount != N / 2 && colCount != (N + 1) / 2) return false;

        rowPattern1 += (A[i][0] == i % 2);
        rowPattern2 += (A[i][0] != i % 2);
        colPattern1 += (A[0][i] == i % 2);
        colPattern2 += (A[0][i] != i % 2);
    }

    if (rowPattern1 % 2 != 0 && rowPattern2 % 2 != 0) return false;
    if (colPattern1 % 2 != 0 && colPattern2 % 2 != 0) return false;

    return true;
}

int minSwapsToChessboard(vector<vector<int>> &A, int N) {
    int rowSwaps = 0, colSwaps = 0;

    for (int i = 0; i < N; ++i) {
        if (A[i][0] != i % 2) rowSwaps++;
        if (A[0][i] != i % 2) colSwaps++;
    }

    rowSwaps = min(rowSwaps, N - rowSwaps);
    colSwaps = min(colSwaps, N - colSwaps);

    return (rowSwaps + colSwaps) / 2;
}

vector<pair<char, pair<int, int>>> getSwapOperations(vector<vector<int>> &A, int N) {
    vector<pair<char, pair<int, int>>> operations;

    for (int i = 0; i < N; ++i) {
        if (A[i][0] != i % 2) {
            for (int j = i + 1; j < N; ++j) {
                if (A[j][0] == i % 2) {
                    swap(A[i], A[j]);
                    operations.push_back({'L', {i + 1, j + 1}});
                    break;
                }
            }
        }
    }

    for (int i = 0; i < N; ++i) {
        if (A[0][i] != i % 2) {
            for (int j = i + 1; j < N; ++j) {
                if (A[0][j] == i % 2) {
                    for (int k = 0; k < N; ++k) {
                        swap(A[k][i], A[k][j]);
                    }
                    operations.push_back({'C', {i + 1, j + 1}});
                    break;
                }
            }
        }
    }

    return operations;
}

int main() {
    int P, T;
    cin >> P >> T;
    while (T--) {
        int N;
        cin >> N;
        vector<vector<int>> A(N, vector<int>(N));
        for (int i = 0; i < N; ++i) {
            string row;
            cin >> row;
            for (int j = 0; j < N; ++j) {
                A[i][j] = row[j] - '0';
            }
        }
        if (P == 1) {
            cout << (canBeChessboard(A, N) ? 1 : 0) << endl;
        } else if (P == 2) {
            cout << minSwapsToChessboard(A, N) << endl;
        } else if (P == 3) {
            vector<pair<char, pair<int, int>>> operations = getSwapOperations(A, N);
            cout << operations.size() << endl;
            for (const auto &op : operations) {
                cout << op.first << " " << op.second.first << " " << op.second.second << endl;
            }
        }
    }
    return 0;
}
```

### Explanation of Fixes:
1. **canBeChessboard Function**:
   - This function now correctly checks if the matrix can be transformed into a chessboard by ensuring that the number of `1`s and `0`s in each row and column is balanced and that the patterns match one of the two possible chessboard patterns.

2. **minSwapsToChessboard Function**:
   - The function now correctly calculates the minimum number of swaps required to transform the matrix into a chessboard by counting mismatches and determining the minimum swaps needed.

3. **getSwapOperations Function**:
   - This function generates the sequence of swap operations to transform the matrix into a chessboard by fixing rows and columns.

This revised solution should now produce the correct results for all test cases.
