---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `multimi.in` and write to `multimi.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Se consideră $n$ mulțimi. Fiecare mulțime conține numai numere naturale consecutive. Pentru a indica o astfel de mulțime este suficient să dăm primul și ultimul element din ea.

# Cerință

Scrieți un program care să determine elementele intersecției celor $n$ mulțimi.

# Date de intrare

De pe prima linie a fișierului de intrare `multimi.in` se citește numărul $n$. Apoi, de pe fiecare din cele $n$ linii următoare, se citesc perechi de numere, câte o pereche pe linie, separate prin câte un spațiu, care reprezintă cel mai mic, respectiv cel mai mare element din fiecare mulțime.


# Date de ieșire

Pe prima linie a fișierului de ieșire `multimi.out` se vor afișa elementele intersecției cu câte un spațiu între ele. În cazul în care intersecția nu are nici un element se va afișa mesajul `multimea vida`.


# Restricții și precizări

* $1 \leq n \leq 30$
* Elementele mulțimilor sunt numere naturale $\leq 30 \ 000$.

---

Example:
`multimi.in`
```
3
5 10
4 11
2 9
```

`multimi.out`
```
5 6 7 8 9
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:To solve the problem of finding the intersection of multiple sets of consecutive natural numbers, we need to determine the common range that exists in all given sets. Here's a step-by-step approach:

1. **Read Input:** Read the number of sets and the ranges for each set from the input file `multimi.in`.
2. **Determine Intersection:** For each set, update the common range by finding the maximum of the lower bounds and the minimum of the upper bounds.
3. **Output the Result:** If the common range is valid (i.e., the lower bound is less than or equal to the upper bound), output the numbers in this range. Otherwise, output "multimea vida".

Here's the C++ code that implements this approach:

```cpp
#include <fstream>
#include <algorithm>

int main() {
    std::ifstream fin("multimi.in");
    std::ofstream fout("multimi.out");

    int n;
    fin >> n;

    int global_min = 0, global_max = 30000;

    for (int i = 0; i < n; ++i) {
        int local_min, local_max;
        fin >> local_min >> local_max;
        global_min = std::max(global_min, local_min);
        global_max = std::min(global_max, local_max);
    }

    if (global_min <= global_max) {
        for (int i = global_min; i <= global_max; ++i) {
            fout << i << " ";
        }
    } else {
        fout << "multimea vida";
    }

    fin.close();
    fout.close();

    return 0;
}
```

### Explanation:

1. **Reading Input:**
   - We use `std::ifstream` to read from `multimi.in`.
   - The first value read is the number of sets `n`.
   - For each set, read the lower and upper bounds.

2. **Finding Intersection:**
   - Initialize `global_min` to 0 and `global_max` to 30000 (the maximum possible value).
   - For each set, update `global_min` to be the maximum of the current `global_min` and the set's lower bound.
   - Similarly, update `global_max` to be the minimum of the current `global_max` and the set's upper bound.

3. **Outputting the Result:**
   - If `global_min` is less than or equal to `global_max`, it means there is a valid intersection range. We output all numbers in this range.
   - Otherwise, output "multimea vida" indicating that there is no intersection.

This approach ensures that the solution is efficient and handles the constraints effectively. The use of `std::max` and `std::min` functions helps in maintaining the intersection range correctly.
