---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `exponent.in` and write to `exponent.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Se dă un număr natural $n$ și o cifră $k$ din mulțimea $\{2, 3, 5, 7\}$.

# Cerință

Se cere să se afișeze exponentul lui $k$ în descompunerea în factori primi a produsului $1 \cdot 2 \cdot 3 \cdot \ldots \cdot n$.

# Date de intrare

Fișierul de intrare `exponent.in` conține pe prima linie $n$ și $k$.


# Date de ieșire

În fișierul de ieșire `exponent.out` se va scrie un singur număr natural, adică exponentul cerut de problemă.


# Restricții și precizări

* $1 \leq n \leq 100$;
* $k = \{2, 3, 5, 7\}$;

---

Example:
`exponent.in`
```
6 3
```

`exponent.out`
```
2
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:To solve this problem, we need to determine the exponent of a given prime number \( k \) in the prime factorization of the factorial of \( n \) (i.e., \( n! \)). The factorial of \( n \) is the product of all integers from 1 to \( n \).

To find the exponent of \( k \) in \( n! \), we can use the following formula:
\[ \text{exponent} = \left\lfloor \frac{n}{k} \right\rfloor + \left\lfloor \frac{n}{k^2} \right\rfloor + \left\lfloor \frac{n}{k^3} \right\rfloor + \ldots \]
where \( \left\lfloor x \right\rfloor \) is the floor function, which gives the greatest integer less than or equal to \( x \).

This formula works because it counts how many multiples of \( k \), \( k^2 \), \( k^3 \), etc., are in the range from 1 to \( n \).

Now, let's implement this in C++.

```cpp
#include <fstream>
#include <cmath>

int main() {
    std::ifstream infile("exponent.in");
    std::ofstream outfile("exponent.out");

    int n, k;
    infile >> n >> k;

    int exponent = 0;
    for (int power = k; power <= n; power *= k) {
        exponent += n / power;
    }

    outfile << exponent << std::endl;

    infile.close();
    outfile.close();
    return 0;
}
```

### Explanation:
1. **Reading Input**: We read the input values \( n \) and \( k \) from the file `exponent.in`.
2. **Calculating the Exponent**: We initialize the exponent to 0. We then iterate over powers of \( k \) (i.e., \( k, k^2, k^3, \ldots \)) and for each power, we add the integer division of \( n \) by that power to the exponent.
3. **Writing Output**: We write the calculated exponent to the file `exponent.out`.

This solution efficiently calculates the exponent by leveraging the properties of prime factorization and avoids the need to compute the factorial directly, which would be computationally expensive for larger values of \( n \).
