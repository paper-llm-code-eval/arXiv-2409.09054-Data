---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `gardul.in` and write to `gardul.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Doi copii vopsesc un gard alcătuit din $n$ scânduri pe care le vom numerota de la $1$ la $n$ astfel: primul ia o cutie de vopsea roșie cu care vopsește scândurile cu numărul $p$, $2 \cdot p$, $3 \cdot p$, etc. Al doilea procedează la fel, începe de la același capăt al gardului, dar ia o cutie de vopsea albastră și vopsește din $q$ în $q$ scânduri. Astfel, când vor termina de vopsit, gardul va avea multe scânduri nevopsite, unele scânduri vopsite în roșu, altele în albastru, iar altele în violet (cele care au fost vopsite și cu roșu și cu albastru).

# Cerință

Cunoscând numerele $n, p$ și $q$ afișați:

1. câte scânduri rămân nevopsite
2. câte scânduri sunt vopsite în roșu
3. câte scânduri sunt vopsite în albastru
4. câte scânduri sunt vopsite în violet

# Date de intrare

De pe prima linie a fișierului de intrare `gardul.in` se citește valoarea $n$, reprezentând numărul de scânduri din gard. De pe cea de a doua linie a fișierului de intrare se citesc valorile $p$ și $q$ separate de un spațiu.

# Date de ieșire

În fișierul de ieșire `gardul.out` se vor afișa, în ordine, cele patru numere naturale cerute, câte unul pe un rând, ca în exemplu.

# Restricții și precizări

* $1 \leq n \leq 100 \ 000$;
* $1 \leq p, q \leq 40 \ 000$;

---

Example:
`gardul.in`
```
25
4 6
```

`gardul.out`
```
17
4
2
2
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:To solve this problem efficiently, we can use a mathematical approach to count the number of boards painted in each color category without explicitly iterating through all the boards. Here's the detailed plan:

1. **Count the Total Boards Painted by Each Child**:
   - The first child paints every `p`-th board, so the total number of boards painted by the first child is `n / p`.
   - The second child paints every `q`-th board, so the total number of boards painted by the second child is `n / q`.

2. **Count the Overlapping Boards Painted by Both Children**:
   - Boards that are painted by both children are those that are multiples of both `p` and `q`, i.e., multiples of the least common multiple (LCM) of `p` and `q`. The number of such boards is `n / lcm(p, q)`.

3. **Calculate the Number of Boards in Each Category**:
   - Boards painted in red only: `n / p - n / lcm(p, q)`.
   - Boards painted in blue only: `n / q - n / lcm(p, q)`.
   - Boards painted in violet: `n / lcm(p, q)`.
   - Boards that remain unpainted: `n - (boards painted in red only + boards painted in blue only + boards painted in violet)`.

4. **Output the Results**.

Here's the C++ code implementing this logic:

```cpp
#include <iostream>
#include <fstream>
#include <algorithm>

using namespace std;

// Function to compute the greatest common divisor (GCD)
int gcd(int a, int b) {
    while (b != 0) {
        int t = b;
        b = a % b;
        a = t;
    }
    return a;
}

// Function to compute the least common multiple (LCM)
int lcm(int a, int b) {
    return a / gcd(a, b) * b;
}

int main() {
    ifstream fin("gardul.in");
    ofstream fout("gardul.out");

    int n, p, q;
    fin >> n >> p >> q;

    int total_red = n / p;
    int total_blue = n / q;
    int total_violet = n / lcm(p, q);

    int red_only = total_red - total_violet;
    int blue_only = total_blue - total_violet;
    int unpainted = n - (red_only + blue_only + total_violet);

    fout << unpainted << endl;
    fout << red_only << endl;
    fout << blue_only << endl;
    fout << total_violet << endl;

    fin.close();
    fout.close();

    return 0;
}
```

### Explanation:
1. **Reading Input**: We read the values of `n`, `p`, and `q` from the file `gardul.in`.
2. **Calculating Total Painted Boards**: We calculate the number of boards painted by each child and the overlapping boards using the LCM.
3. **Calculating Each Category**: We derive the number of boards in each category based on the total counts.
4. **Writing Output**: We write the results to the file `gardul.out`.

This approach ensures that we handle the problem efficiently without iterating through each board, making it suitable for large values of `n` up to 100,000.
