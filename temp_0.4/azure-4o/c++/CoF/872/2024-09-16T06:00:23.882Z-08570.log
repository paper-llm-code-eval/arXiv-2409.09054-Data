---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `arma.in` and write to `arma.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

În anul $2214$ a izbucnit primul război interstelar. Pământul a fost atacat de către $n$ civilizații extraterestre, pe care le vom numerota pentru simplicitate de la $1$ la $n$.

Pentru a se apăra, pământenii au inventat o armă specială ce poate fi încărcată cu proiectile de diferite greutăți, fabricate dintr-un material special denumit narun. Dacă arma este programată la nivelul $p$, atunci un proiectil de greutate $k$ va ajunge exact la distanța $k^p$ km ($k$ la puterea $p$) față de Pământ și dacă în acel punct se află cartierul general al unui atacator, acesta va fi distrus. De exemplu, dacă arma este programată la nivelul $2$, un proiectil de greutate 10 va distruge cartierul general al extratereștrilor situat la distanța $10^2 = 100$ km de Pământ.
Arma poate fi încărcată cu proiectile de diferite greutăți, dar cum narunul este un material foarte rar și foarte scump, pământenii vor să folosească proiectile cât mai ușoare pentru a distruge cartierele generale inamice.

# Cerință

Cunoscându-se $n$, numărul atacatorilor, precum și cele $n$ distanțe până la cartierele generale ale acestora, să se scrie un program care determină:

1. Cantitatea minimă de narun necesară pentru a distruge toate cartierele generale inamice;
2. Nivelurile la care trebuie programată arma, pentru a distruge fiecare cartier general inamic cu o cantitate minimă de narun.

# Date de intrare

Fișierul de intrare `arma.in` conține pe prima linie un număr natural $c$ reprezentând cerința care trebuie să fie rezolvată ($1$ sau $2$). Pe cea de a doua linie se află numărul natural $n$, reprezentând numărul atacatorilor. Pe următoarele $n$ linii se află $n$ numere naturale, câte un număr pe o linie; pe cea de a $i$-a linie dintre cele $n$ se află distanța față de Pământ a cartierului general al celei de a $i$-a civilizații extraterestre

# Date de ieșire

Dacă cerința $c = 1$, atunci pe prima linie a fișierului `arma.out` va fi scris un număr natural reprezentând cantitatea minimă de narun necesară distrugerii tuturor cartierelor generale inamice.

Dacă cerința este $c = 2$, atunci fișierul de ieșire `arma.out` va conține $n$ linii. Pe a $i$-a linie se va scrie nivelul la care trebuie programată arma pentru a distruge cartierul general al celei de a $i$-a civilizații extraterestre.

# Restricții și precizări

* $1 \leq n \leq 10 \ 000$;
* Distanțele până la cartierele generale inamice sunt numere naturale nenule $\leq 2 \cdot 10^9$;
* Pentru $50$% dintre teste cerința este $1$.

---

Example:
`arma.in`
```
1
5
100
97
625
40353607
81
```

`arma.out`
```
122
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:To solve this problem efficiently, we need to consider the following steps for both requirements:

1. **Reading the Input:**
   - We will read the input from the file `arma.in`.
   - The first value will determine the requirement (`c`).
   - The second value will be the number of attackers (`n`).
   - The next `n` values will be the distances of the headquarters of the attackers.

2. **Requirement 1 (c = 1):**
   - For each distance, we need to find the minimum weight `k` such that `k^p = distance`.
   - We iterate over possible values of `p` starting from 1 and find the smallest `k` such that `k^p` is equal to the given distance.
   - Sum these minimum weights to get the total amount of narun needed.

3. **Requirement 2 (c = 2):**
   - For each distance, we need to determine the level `p` such that the weight `k` is minimized.
   - We iterate over possible values of `p` starting from 1 and find the smallest `k` such that `k^p` is equal to the given distance.
   - Output these levels for each distance.

Let's implement the solution in C++:

```cpp
#include <iostream>
#include <fstream>
#include <cmath>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    ifstream infile("arma.in");
    ofstream outfile("arma.out");

    int c, n;
    infile >> c >> n;

    vector<long long> distances(n);
    for (int i = 0; i < n; ++i) {
        infile >> distances[i];
    }

    if (c == 1) {
        long long total_narun = 0;
        for (long long distance : distances) {
            long long min_k = LLONG_MAX;
            for (int p = 1; p <= 31; ++p) { // 31 because 2^31 is more than 2*10^9
                long long k = pow(distance, 1.0 / p);
                while (pow(k, p) < distance) ++k;
                while (pow(k, p) > distance) --k;
                if (pow(k, p) == distance) {
                    min_k = min(min_k, k);
                }
            }
            total_narun += min_k;
        }
        outfile << total_narun << endl;
    } else if (c == 2) {
        for (long long distance : distances) {
            int best_p = 1;
            long long min_k = LLONG_MAX;
            for (int p = 1; p <= 31; ++p) { // 31 because 2^31 is more than 2*10^9
                long long k = pow(distance, 1.0 / p);
                while (pow(k, p) < distance) ++k;
                while (pow(k, p) > distance) --k;
                if (pow(k, p) == distance) {
                    if (k < min_k) {
                        min_k = k;
                        best_p = p;
                    }
                }
            }
            outfile << best_p << endl;
        }
    }

    infile.close();
    outfile.close();
    return 0;
}
```

### Explanation:
- **Reading Input:** We read the input values from the file `arma.in`.
- **Requirement 1:** For each distance, we iterate over possible values of `p` from 1 to 31 (since `2^31` exceeds `2 * 10^9`). We calculate the weight `k` such that `k^p` equals the distance and keep track of the minimum `k`. We sum these minimum weights to get the total amount of narun.
- **Requirement 2:** For each distance, we again iterate over possible values of `p` from 1 to 31. We find the smallest `k` for each `p` and keep track of the best `p` that minimizes `k`. We output these levels for each distance.

This solution ensures that we efficiently find the required values while adhering to the constraints.
---------- user ----------


Failed to compile the program.
```
main.cpp: In function 'int main()':
main.cpp:24:31: error: 'LLONG_MAX' was not declared in this scope
   24 |             long long min_k = LLONG_MAX;
      |                               ^~~~~~~~~
main.cpp:6:1: note: 'LLONG_MAX' is defined in header '<climits>'; did you forget to '#include <climits>'?
    5 | #include <algorithm>
  +++ |+#include <climits>
    6 | 
main.cpp:39:31: error: 'LLONG_MAX' was not declared in this scope
   39 |             long long min_k = LLONG_MAX;
      |                               ^~~~~~~~~
main.cpp:39:31: note: 'LLONG_MAX' is defined in header '<climits>'; did you forget to '#include <climits>'?

```

Evaluate the error message. Think of a solution to fix the program and return the entire source code with the fix.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The error message indicates that the macro `LLONG_MAX` is not recognized because the `<climits>` header is missing. We need to include this header to use `LLONG_MAX`.

Let's fix the program by including the `<climits>` header and rewriting the entire source code:

```cpp
#include <iostream>
#include <fstream>
#include <cmath>
#include <vector>
#include <algorithm>
#include <climits> // Include this header for LLONG_MAX

using namespace std;

int main() {
    ifstream infile("arma.in");
    ofstream outfile("arma.out");

    int c, n;
    infile >> c >> n;

    vector<long long> distances(n);
    for (int i = 0; i < n; ++i) {
        infile >> distances[i];
    }

    if (c == 1) {
        long long total_narun = 0;
        for (long long distance : distances) {
            long long min_k = LLONG_MAX;
            for (int p = 1; p <= 31; ++p) { // 31 because 2^31 is more than 2*10^9
                long long k = pow(distance, 1.0 / p);
                while (pow(k, p) < distance) ++k;
                while (pow(k, p) > distance) --k;
                if (pow(k, p) == distance) {
                    min_k = min(min_k, k);
                }
            }
            total_narun += min_k;
        }
        outfile << total_narun << endl;
    } else if (c == 2) {
        for (long long distance : distances) {
            int best_p = 1;
            long long min_k = LLONG_MAX;
            for (int p = 1; p <= 31; ++p) { // 31 because 2^31 is more than 2*10^9
                long long k = pow(distance, 1.0 / p);
                while (pow(k, p) < distance) ++k;
                while (pow(k, p) > distance) --k;
                if (pow(k, p) == distance) {
                    if (k < min_k) {
                        min_k = k;
                        best_p = p;
                    }
                }
            }
            outfile << best_p << endl;
        }
    }

    infile.close();
    outfile.close();
    return 0;
}
```

### Explanation:
- **Include `<climits>`:** This header is necessary to use the `LLONG_MAX` macro which represents the maximum value for a `long long` integer.
- **Rest of the Code:** The logic remains the same, ensuring that we find the minimum weight `k` for each distance and the corresponding level `p` for the second requirement.

This should resolve the compilation error and allow the program to run correctly.
