---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `betasah.in` and write to `betasah.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Jocul **betasah** se joacă folosindu-se doar piese asemănătoare damelor clasicului șah, numite tot *dame*. Suprafața de joc are o formă triunghiulară și este formată din $N \cdot (N+1) / 2$ pătrate identice dispuse pe $N$ rânduri și $N$ coloane. Rândurile se numerotează de sus in jos, de la $1$ la $N$. Coloanele se numerotează de la stânga la dreapta, de la $1$ la $N$. Primul rând conține un singur pătrat, al doilea rând conține două pătrate alăturate, $\dots$, al $N$-lea rând conține $N$ pâtrate alăturate, ca în suprafețele de joc cu $N=6$ din figurile de mai jos. Din cele $N \cdot (N+1) / 2$ pătrate, $K$ sunt gri, iar restul sunt albe. Poziția fiecărui pătrat de pe suprafața de joc este dată de rândul și coloana în care acesta este situat.

~[betasah.png]

Pe suprafața de joc sunt așezate $D$ dame în $D$ pătrate albe distincte, ocupându-le. Într-un pătrat alb **poate fi așezată o singură damă**, iar într-un pătrat gri **nu poate fi așezată nicio damă**. Poziția unei dame pe suprafața de joc este dată de poziția pătratului alb în care este așezată damă.
Damele pot accesa orice pătrat alb neocupat situat pe direcțiile: verticală, orizontală sau diagonală, numerotate de la $1$ la $8$ în **figura $b$)**. Accesul pe o direcție se face trecând din pătrat alb în pătrat alb (doar pătrate albe neocupate) până la întâlnirea unui pătrat gri sau a unui pătrat alb ocupat de o altă damă sau până la terminarea suprafeței de joc.
Numim **pătrat accesibil** orice pătrat alb neocupat (de pe suprafața de joc) care ar putea fi accesat de cel puțin una din cele $D$ dame.
De exemplu, pentru suprafața de joc din **figura $c$)** numărul de pătrate accesibile (marcate cu $X$) de pe suprafață este $11$; pentru suprafața de joc cu $N=6, D=3$ și $K=4$ din **figura $d$)** numărul de pătrate accesibile de pe suprafață este $13$. În figura $e$) sunt marcate cu $X$ pătratele accesibile fiecărei dame de pe suprafața de joc din figura $d$).

~[betasah2.png]

# Cerință

Scrieți un program care să citească numerele naturale $N \ D \ K$, pozițiile damelor și ale pătratelor gri pe suprafața de joc și care să determine:

* numărul maxim $M$ de pătrate albe conținute de un rând al suprafeței de joc;
* numărul $P$ de pătrate accesibile de pe suprafața de joc.

# Date de intrare


Fișierul de intrare `betasah.in` conține:

* pe prima linie cele trei numere naturale $N \ D \ K$, separate prin câte un spațiu, cu semnificația din enunț;
* pe linia $i+1$ două numere naturale nenule $x_i \ y_i$, separate prin câte un spațiu, reprezentând poziția damei $i$ pe suprafața de joc (rândul $x_i$ și coloana $y_i$), pentru $i = 1,2,3,\dots,D$;
* pe linia $D+1+j$ două numere naturale nenule $z_j \ t_j$, separate printr-un singur spațiu, reprezentând poziția pătratului gri $j$ pe suprafața de joc (rândul $x_i$ și coloana $y_i$), pentru $j = 1, 2, 3, \dots , K$.


# Date de ieșire


Fișierul de ieșire `betasah.out` va conține pe prima linie numărul natural $M$ și pe a doua linie numărul natural $P$, cu semnificația din enunț.

# Restricții și precizări

* $2 \leq N \leq 1 \ 000$;
* $1 \leq D \leq 100$;
* $1 \leq K \leq 50$;
* $D + K \leq N \cdot (N+1) / 2$;
* $1 \leq y_i \leq xi \leq N$;
* $1 \leq t_j \leq zj \leq N$;
* numărul $M$ se va scrie obligatoriu pe prima linie a fișierului de ieșire `betasah.in`.
* numărul $P$ se va scrie obligatoriu pe a doua linie a fișierului de ieșire `betasah.out`.
* pentru rezolvarea corectă a cerinței $1$) se acordă $20$% din punctaj, iar pentru rezolvarea corectă a cerinței $2$) se acordă $80$% din punctaj.

---

Example:
`betasah.in`
```
6 3 4
3 2
5 2
5 4
3 1
4 3
6 4
1 1
```

`betasah.out`
```
5
13
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:To solve the problem efficiently, we need to follow these steps:

1. **Read Input**: Read the values of \( N \), \( D \), and \( K \) from the input file. Then, read the positions of the queens and the grey squares.
2. **Initialize the Board**: Create a triangular board representation where we can mark the positions of the queens and grey squares.
3. **Calculate Maximum White Squares in a Row**: For each row, count the number of white squares and find the maximum.
4. **Determine Accessible Squares**: For each queen, mark all accessible squares by moving in all 8 possible directions until a grey square, another queen, or the edge of the board is encountered.
5. **Count Accessible Squares**: Count the total number of unique accessible white squares.

Here's the C++ code implementing the above logic:

```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <set>

using namespace std;

const int directions[8][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}, {-1, -1}, {-1, 1}, {1, -1}, {1, 1}};

int main() {
    ifstream fin("betasah.in");
    ofstream fout("betasah.out");

    int N, D, K;
    fin >> N >> D >> K;

    vector<vector<char>> board(N + 1, vector<char>(N + 1, 'W')); // W for white, G for grey, Q for queen

    vector<pair<int, int>> queens(D);
    for (int i = 0; i < D; ++i) {
        int x, y;
        fin >> x >> y;
        board[x][y] = 'Q';
        queens[i] = {x, y};
    }

    for (int i = 0; i < K; ++i) {
        int z, t;
        fin >> z >> t;
        board[z][t] = 'G';
    }

    // Calculate M
    int M = 0;
    for (int i = 1; i <= N; ++i) {
        int whiteCount = 0;
        for (int j = 1; j <= i; ++j) {
            if (board[i][j] == 'W') {
                ++whiteCount;
            }
        }
        if (whiteCount > M) {
            M = whiteCount;
        }
    }

    // Calculate P
    set<pair<int, int>> accessibleSquares;
    for (const auto& queen : queens) {
        int x = queen.first;
        int y = queen.second;
        for (int d = 0; d < 8; ++d) {
            int nx = x + directions[d][0];
            int ny = y + directions[d][1];
            while (nx >= 1 && ny >= 1 && nx <= N && ny <= nx && board[nx][ny] == 'W') {
                accessibleSquares.insert({nx, ny});
                nx += directions[d][0];
                ny += directions[d][1];
            }
        }
    }

    int P = accessibleSquares.size();

    fout << M << '\n' << P << '\n';

    return 0;
}
```

### Explanation:
1. **Reading Input**:
   - We read \( N \), \( D \), and \( K \) from the input file.
   - We read the positions of the queens and grey squares and update the board accordingly.

2. **Initializing the Board**:
   - We create a 2D vector `board` initialized to 'W' (white).
   - We mark the positions of the queens with 'Q' and the grey squares with 'G'.

3. **Calculating Maximum White Squares in a Row (M)**:
   - For each row, we count the number of white squares and keep track of the maximum.

4. **Determining Accessible Squares**:
   - For each queen, we explore all 8 directions and mark accessible squares until we hit a grey square, another queen, or the edge of the board.

5. **Counting Accessible Squares (P)**:
   - We use a set to keep track of unique accessible squares and count them.

This approach ensures that the solution is efficient and meets the problem constraints.
