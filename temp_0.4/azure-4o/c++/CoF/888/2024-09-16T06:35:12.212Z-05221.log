---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `rover.in` and write to `rover.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

NASA plănuiește o nouă misiune Rover pe Marte în anul 2020. Principalul obiectiv al acestei misiuni este de a determina, cu ajutorul unui nou Rover, dacă a existat în trecut viață pe Marte. Până când va fi lansată misiunea, Roverul este supus la tot felul de teste în laboratoarele NASA. Într-unul din teste, Roverul trebuie să parcurgă o suprafață de forma unui caroiaj cu $N$ linii și $N$ coloane. Acesta pornește din zona de coordonate $(1,1)$ și trebuie să ajungă în zona de coordonate $(N,N)$, la fiecare pas putându-se deplasa din zona în care se află într-una din zonele învecinate la nord, sud, est sau vest. Pentru fiecare zonă de coordonate $(i,j)$ se cunoaște $A_{ij}$, stabilitatea terenului din acea zonă. Știind că Roverul are o greutate $G$, o zonă cu stabilitatea terenului cel puțin egală cu $G$ se consideră o zonă sigură pentru deplasarea Roverului, iar o zonă cu stabilitatea terenului mai mică decât $G$ se consideră o zonă periculoasă pentru Rover.

# Cerințe

1. Determinați numărul minim posibil de zone periculoase pe care le traversează Roverul pentru a ajunge din zona $(1,1)$ în zona $(N,N)$.
2. Determinați greutatea maximă pe care o poate avea un Rover care să ajungă din zona $(1,1)$ în zona $(N,N)$, fără a traversa nicio zonă periculoasă pentru el.

# Date de intrare


Pe prima linie a fișierului de intrare `rover.in`  se găsește numărul natural $V$ a cărui valoare poate fi doar $1$ sau $2$. Dacă $V$ este $1$, pe a doua linie a fișierului de intrare se găsesc două numere naturale $N$ și $G$ cu semnificația din enunț, iar dacă $V$ este $2$, pe a doua linie a fișierului de intrare se află doar numărul $N$.
Pe următoarele $N$ linii se află câte $N$ numere $A_{i,j}$, reprezentând stabilitatea terenului din zona $(i,j)$. 

# Date de ieșire


Fișierul de ieșire este `rover.out`.

Dacă valoarea lui $V$ este $1$, atunci fișierul de ieșire va conține pe prima linie un număr natural reprezentând numărul minim de zone periculoase pe care trebuie să le traverseze Roverul de greutate $G$.

Dacă valoarea lui $V$ este $2$, atunci fișierul de ieșire va conține pe prima linie un număr natural reprezentând greutatea maximă a unui Rover care poate ajunge din zona $(1,1)$ în zona $(N,N)$ fără a traversa zone periculoase pentru el.


# Restricții și precizări

* $1 \leq N \leq 500$
* $1 \leq G \leq 5 \ 000$
* $1 \leq A_{ij} \leq 10 \ 000$
* Zonele de coordonate $(1,1)$ și $(N,N)$ nu sunt zone periculoase pentru Rover.
* Roverul nu va trece de mai multe ori prin aceeași zonă.


| $V$ | Punctaj |
| - | ------- |
| $1$ | 45      |
| $2$ | 45      |

---

Example:
`rover.in`
```
1
5 5
5 1 3 4 7
5 2 1 8 5
2 9 5 3 3
4 1 1 1 9
5 1 6 1 8
```

`rover.out`
```
3
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:To solve this problem efficiently, we need to consider two different cases based on the value of `V`:

1. **When `V` is 1**: We need to find the minimum number of dangerous zones the rover must traverse to get from the top-left corner to the bottom-right corner.
2. **When `V` is 2**: We need to determine the maximum weight `G` such that the rover can traverse from the top-left corner to the bottom-right corner without entering any dangerous zones.

For both cases, we can use graph traversal techniques. Specifically, we can use a modified Breadth-First Search (BFS) algorithm to handle the grid traversal efficiently.

### Case 1: Minimum Dangerous Zones
We can use a BFS where each cell in the grid is a node, and edges exist between adjacent nodes. We will maintain a count of dangerous zones traversed and use a priority queue to always expand the path with the least number of dangerous zones first.

### Case 2: Maximum Safe Weight
We can use binary search to determine the maximum weight `G` such that there exists a path from the top-left to the bottom-right corner without entering any dangerous zones. For each candidate weight `G`, we can use BFS to check if such a path exists.

Here is the complete C++ code implementing the solution:

```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <queue>
#include <algorithm>

using namespace std;

const int INF = 1e9;
const int dx[] = {-1, 1, 0, 0};
const int dy[] = {0, 0, -1, 1};

struct Cell {
    int x, y, danger;
    bool operator<(const Cell& other) const {
        return danger > other.danger;
    }
};

int main() {
    ifstream fin("rover.in");
    ofstream fout("rover.out");

    int V;
    fin >> V;

    int N, G;
    if (V == 1) {
        fin >> N >> G;
    } else {
        fin >> N;
    }

    vector<vector<int>> A(N, vector<int>(N));
    for (int i = 0; i < N; ++i) {
        for (int j = 0; j < N; ++j) {
            fin >> A[i][j];
        }
    }

    if (V == 1) {
        vector<vector<int>> danger(N, vector<int>(N, INF));
        priority_queue<Cell> pq;
        pq.push({0, 0, 0});
        danger[0][0] = 0;

        while (!pq.empty()) {
            Cell current = pq.top();
            pq.pop();

            if (current.x == N - 1 && current.y == N - 1) {
                fout << current.danger << endl;
                return 0;
            }

            for (int i = 0; i < 4; ++i) {
                int nx = current.x + dx[i];
                int ny = current.y + dy[i];

                if (nx >= 0 && nx < N && ny >= 0 && ny < N) {
                    int newDanger = current.danger + (A[nx][ny] < G ? 1 : 0);
                    if (newDanger < danger[nx][ny]) {
                        danger[nx][ny] = newDanger;
                        pq.push({nx, ny, newDanger});
                    }
                }
            }
        }
    } else if (V == 2) {
        int left = 1, right = 10000, bestG = 1;

        auto isValid = [&](int G) {
            vector<vector<bool>> visited(N, vector<bool>(N, false));
            queue<pair<int, int>> q;
            q.push({0, 0});
            visited[0][0] = true;

            while (!q.empty()) {
                auto [x, y] = q.front();
                q.pop();

                if (x == N - 1 && y == N - 1) {
                    return true;
                }

                for (int i = 0; i < 4; ++i) {
                    int nx = x + dx[i];
                    int ny = y + dy[i];

                    if (nx >= 0 && nx < N && ny >= 0 && ny < N && !visited[nx][ny] && A[nx][ny] >= G) {
                        visited[nx][ny] = true;
                        q.push({nx, ny});
                    }
                }
            }
            return false;
        };

        while (left <= right) {
            int mid = (left + right) / 2;
            if (isValid(mid)) {
                bestG = mid;
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }

        fout << bestG << endl;
    }

    return 0;
}
```

### Explanation:
- **Reading Input**: The input is read from `rover.in` using `ifstream`.
- **Case 1 (Minimum Dangerous Zones)**:
  - A priority queue is used to always expand the path with the least number of dangerous zones first.
  - The BFS algorithm is modified to count the number of dangerous zones traversed.
- **Case 2 (Maximum Safe Weight)**:
  - Binary search is used to find the maximum weight `G` such that a path exists without entering dangerous zones.
  - For each candidate weight, BFS is used to check if such a path exists.

This solution ensures efficient traversal and checks, adhering to the constraints and requirements of the problem.
