---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `adunscad.in` and write to `adunscad.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Considerăm un număr întreg $N$ și un șir de $M$ cifre zecimale nenule. Să se determine dacă numărul $N$ poate fi rezultatul unei expresii aritmetice simple (fără paranteze), formată exclusiv din cifrele șirului citit și din operatorii aritmetici desemnați pentru operațiile de adunare și scădere ($+, -$).

# Cerință

Scrieți un program care citește numerele $N$ și $M$ de pe prima linie a fișierului de intrare și șirul de $M$ cifre de pe linia următoare și determină și afișează expresia găsită sau valoarea 0 în cazul în care nu există soluție.

# Date de intrare

Fișierul de intrare `adunscad.in` conține pe prima linie numerele întregi $N \ M$, separate printr-un spațiu, reprezentând valoarea ce trebuie obținută la evaluarea expresiei și numărul de cifre din șir. Linia a doua a fișierului de intrare conține șirul celor $M$ cifre nenule, separate prin câte un spațiu.

# Date de ieșire

În fișierul de ieșire `adunscad.out` va conține pe prima linie expresia determinată, în cazul în care există soluție, sau valoarea $0$ în cazul în care nu există soluție.

# Restricții și precizări

* $-180 \leq N \leq 180$;
* $2 \leq M \leq 20$;
* În șirul citit cifrele se pot repeta.
* Toate cifrele din șir trebuie să apară și în expresia aritmetică, în aceeași ordine în care au fost citite.
* În expresia aritmetică, orice cifră trebuie să fie precedată de un operator; în cazul în care prima cifră este precedată de operatorul + acesta nu se pune în expresie. În expresia aritmetică nu există spații.
* În cazul în care soluția nu este unică se va afișa o soluție corectă.

---

Example:
`adunscad.in`
```
21 4
3 9 1 8
```

`adunscad.out`
```
3+9+1+8
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:To solve this problem efficiently, we need to explore all possible combinations of the given digits with the arithmetic operators `+` and `-` to see if we can form an expression that evaluates to the given number `N`. Given the constraints, we can use a recursive approach to generate all possible expressions and evaluate them.

Here is the step-by-step solution in C++:

1. **Reading Input**: We will read the input from the file `adunscad.in`.
2. **Generating Expressions**: We will use a recursive function to generate all possible expressions using the given digits and operators.
3. **Evaluating Expressions**: For each generated expression, we will evaluate it to see if it matches the target number `N`.
4. **Outputting Result**: If a valid expression is found, we will write it to the file `adunscad.out`. If no valid expression is found, we will write `0`.

Here is the C++ implementation:

```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <cstdlib>

using namespace std;

// Function to evaluate the expression
int evaluateExpression(const string& expr) {
    int result = 0;
    int currentNumber = 0;
    char currentOp = '+';

    for (char ch : expr) {
        if (isdigit(ch)) {
            currentNumber = currentNumber * 10 + (ch - '0');
        } else if (ch == '+' || ch == '-') {
            if (currentOp == '+') {
                result += currentNumber;
            } else {
                result -= currentNumber;
            }
            currentOp = ch;
            currentNumber = 0;
        }
    }

    if (currentOp == '+') {
        result += currentNumber;
    } else {
        result -= currentNumber;
    }

    return result;
}

// Recursive function to generate all possible expressions
bool generateExpressions(const vector<int>& digits, int target, string expr, int index, ofstream& fout) {
    if (index == digits.size()) {
        if (evaluateExpression(expr) == target) {
            fout << expr << endl;
            return true;
        }
        return false;
    }

    // Try adding the next digit with a '+' operator
    if (generateExpressions(digits, target, expr + '+' + to_string(digits[index]), index + 1, fout)) {
        return true;
    }

    // Try adding the next digit with a '-' operator
    if (generateExpressions(digits, target, expr + '-' + to_string(digits[index]), index + 1, fout)) {
        return true;
    }

    return false;
}

int main() {
    ifstream fin("adunscad.in");
    ofstream fout("adunscad.out");

    int N, M;
    fin >> N >> M;

    vector<int> digits(M);
    for (int i = 0; i < M; ++i) {
        fin >> digits[i];
    }

    // Start generating expressions from the first digit
    if (!generateExpressions(digits, N, to_string(digits[0]), 1, fout)) {
        fout << "0" << endl;
    }

    fin.close();
    fout.close();

    return 0;
}
```

### Explanation:

1. **Reading Input**: We read the integers `N` and `M` and then the sequence of `M` digits from the input file `adunscad.in`.
2. **Generating Expressions**: The `generateExpressions` function recursively generates all possible expressions by trying both `+` and `-` operators between the digits.
3. **Evaluating Expressions**: The `evaluateExpression` function evaluates a given expression string to see if it matches the target number `N`.
4. **Outputting Result**: If a valid expression is found, it is written to the output file `adunscad.out`. If no valid expression is found, `0` is written to the file.

This solution ensures that all possible combinations are explored efficiently, and it stops as soon as a valid expression is found.
---------- user ----------


Program result did not match expected result.
Input data:
```
-1 4
1 2 3 5
```
Expected output:
```
-1+2+3-5
```
Found output:
```
0
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The issue with the previous solution is that it does not correctly handle the case where the target number `N` is negative. Additionally, the solution does not correctly generate expressions that start with a `-` sign when needed. 

To fix this, we need to ensure that the recursive function can handle the initial digit being preceded by a `-` sign and that it correctly evaluates the expression for both positive and negative target values.

Here is the revised solution:

```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <cstdlib>

using namespace std;

// Function to evaluate the expression
int evaluateExpression(const string& expr) {
    int result = 0;
    int currentNumber = 0;
    char currentOp = '+';

    for (char ch : expr) {
        if (isdigit(ch)) {
            currentNumber = currentNumber * 10 + (ch - '0');
        } else if (ch == '+' || ch == '-') {
            if (currentOp == '+') {
                result += currentNumber;
            } else {
                result -= currentNumber;
            }
            currentOp = ch;
            currentNumber = 0;
        }
    }

    if (currentOp == '+') {
        result += currentNumber;
    } else {
        result -= currentNumber;
    }

    return result;
}

// Recursive function to generate all possible expressions
bool generateExpressions(const vector<int>& digits, int target, string expr, int index, ofstream& fout) {
    if (index == digits.size()) {
        if (evaluateExpression(expr) == target) {
            fout << expr << endl;
            return true;
        }
        return false;
    }

    // Try adding the next digit with a '+' operator
    if (generateExpressions(digits, target, expr + '+' + to_string(digits[index]), index + 1, fout)) {
        return true;
    }

    // Try adding the next digit with a '-' operator
    if (generateExpressions(digits, target, expr + '-' + to_string(digits[index]), index + 1, fout)) {
        return true;
    }

    return false;
}

int main() {
    ifstream fin("adunscad.in");
    ofstream fout("adunscad.out");

    int N, M;
    fin >> N >> M;

    vector<int> digits(M);
    for (int i = 0; i < M; ++i) {
        fin >> digits[i];
    }

    // Start generating expressions from the first digit
    if (!generateExpressions(digits, N, to_string(digits[0]), 1, fout)) {
        // Try starting with a negative sign if the first attempt fails
        if (!generateExpressions(digits, N, "-" + to_string(digits[0]), 1, fout)) {
            fout << "0" << endl;
        }
    }

    fin.close();
    fout.close();

    return 0;
}
```

### Explanation:

1. **Reading Input**: We read the integers `N` and `M` and then the sequence of `M` digits from the input file `adunscad.in`.
2. **Generating Expressions**: The `generateExpressions` function recursively generates all possible expressions by trying both `+` and `-` operators between the digits.
3. **Evaluating Expressions**: The `evaluateExpression` function evaluates a given expression string to see if it matches the target number `N`.
4. **Outputting Result**: If a valid expression is found, it is written to the output file `adunscad.out`. If no valid expression is found, `0` is written to the file.

This solution ensures that all possible combinations are explored efficiently, and it stops as soon as a valid expression is found. Additionally, it correctly handles the case where the target number `N` is negative by trying to start the expression with a `-` sign if necessary.
