---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `numere.in` and write to `numere.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Gigel este un mare pasionat al cifrelor. Orice moment liber şi-l petrece jucându-se cu numere. Jucându-se astfel, într-o zi a scris pe hârtie $10$ numere distincte de câte două cifre şi a observat că printre acestea există două submulţimi disjuncte de sumă egală. Desigur, Gigel a crezut că este o întâmplare şi a scris alte $10$ numere distincte de câte două cifre şi spre surpriza lui, după un timp a găsit din nou două submulţimi disjuncte de sumă egală.

# Cerinţă
Date $10$ numere distincte de câte două cifre, determinaţi numărul de perechi de submulţimi **disjuncte** de sumă egală care se pot forma cu numere din cele date, precum şi una dintre aceste perechi pentru care suma numerelor din fiecare dintre cele două submulţimi este maximă.

# Date de intrare
Fişierul de intrare `numere.in` conţine pe prima linie $10$ numere naturale distincte separate prin câte un spaţiu $x_1$, $x_2$, $\dots$, $x_{10}$.

# Date de ieşire
Fişierul de ieşire `numere.out` conţine trei linii. Pe prima linie se află numărul de perechi de submulţimi de sumă egală şi suma maximă obţinută, separate printr-un spaţiu. Pe linia a doua se află elementele primei submulţimi separate prin câte un spațiu, iar pe linia a treia se află elementele celei de a doua submulţimi separate prin câte un spaţiu.

# Restricţii şi precizări
- $10 \leq x_i, y_i \leq 99$, pentru $1 \leq i \leq 10$
- $1 \leq k, p \leq 9$
- Ordinea submulţimilor în perechi nu contează.
- Perechea de submulţimi determinată nu este obligatoriu unică.

---

Example:
`numere.in`
```
60 49 86 78 23 97 69 71 32 10
```

`numere.out`
```
65 276
78 97 69 32
60 49 86 71 10
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <unordered_map>
#include <algorithm>

using namespace std;

// Function to find all subsets of a given set
void findSubsets(vector<int>& nums, int index, vector<int>& current, vector<vector<int>>& subsets) {
    if (index == nums.size()) {
        subsets.push_back(current);
        return;
    }
    findSubsets(nums, index + 1, current, subsets);
    current.push_back(nums[index]);
    findSubsets(nums, index + 1, current, subsets);
    current.pop_back();
}

int main() {
    ifstream infile("numere.in");
    ofstream outfile("numere.out");

    vector<int> nums(10);
    for (int i = 0; i < 10; ++i) {
        infile >> nums[i];
    }

    vector<vector<int>> subsets;
    vector<int> current;
    findSubsets(nums, 0, current, subsets);

    unordered_map<int, vector<vector<int>>> sumMap;
    for (const auto& subset : subsets) {
        int sum = 0;
        for (int num : subset) {
            sum += num;
        }
        sumMap[sum].push_back(subset);
    }

    int maxSum = 0;
    vector<int> subset1, subset2;
    int pairCount = 0;

    for (const auto& entry : sumMap) {
        const auto& subsetList = entry.second;
        if (subsetList.size() > 1) {
            for (size_t i = 0; i < subsetList.size(); ++i) {
                for (size_t j = i + 1; j < subsetList.size(); ++j) {
                    unordered_map<int, int> countMap;
                    for (int num : subsetList[i]) {
                        countMap[num]++;
                    }
                    bool disjoint = true;
                    for (int num : subsetList[j]) {
                        if (countMap[num] > 0) {
                            disjoint = false;
                            break;
                        }
                    }
                    if (disjoint) {
                        pairCount++;
                        if (entry.first > maxSum) {
                            maxSum = entry.first;
                            subset1 = subsetList[i];
                            subset2 = subsetList[j];
                        }
                    }
                }
            }
        }
    }

    outfile << pairCount << " " << maxSum << endl;
    for (int num : subset1) {
        outfile << num << " ";
    }
    outfile << endl;
    for (int num : subset2) {
        outfile << num << " ";
    }
    outfile << endl;

    return 0;
}
```

### Explanation:
1. **Reading Input**: The code reads 10 distinct two-digit numbers from the file `numere.in`.
2. **Finding Subsets**: The function `findSubsets` generates all possible subsets of the given 10 numbers.
3. **Mapping Subsets by Sum**: For each subset, the sum is calculated and subsets are stored in a map where the key is the sum.
4. **Finding Disjoint Subsets**: For each sum, the code checks pairs of subsets to see if they are disjoint (no common elements). If they are, it checks if their sum is the maximum found so far.
5. **Output**: The number of such pairs and the maximum sum are written to `numere.out`, along with one pair of disjoint subsets having the maximum sum.

This approach ensures that all possible subsets are considered and the solution is efficient given the constraints.
---------- user ----------


Program result did not match expected result.
Input data:
```
60 49 86 78 23 97 69 71 32 10
```
Expected output:
```
65 276
78 97 69 32
60 49 86 71 10
```
Found output:
```
65 276
78 97 69 32 
60 49 86 71 10
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The discrepancy between the expected and found outputs is not due to a logical error in the code but rather due to an issue with formatting or whitespace in the output. However, to ensure the solution is both correct and optimal, let's reimplement it with a focus on clarity and efficiency.

We'll use a bitmask approach to generate all possible subsets and their sums. This approach is efficient given the constraints and ensures that we can easily check for disjoint subsets.

Here's the revised solution:

```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <unordered_map>
#include <algorithm>

using namespace std;

// Function to check if two subsets are disjoint
bool areDisjoint(const vector<int>& subset1, const vector<int>& subset2) {
    unordered_map<int, int> countMap;
    for (int num : subset1) {
        countMap[num]++;
    }
    for (int num : subset2) {
        if (countMap[num] > 0) {
            return false;
        }
    }
    return true;
}

int main() {
    ifstream infile("numere.in");
    ofstream outfile("numere.out");

    vector<int> nums(10);
    for (int i = 0; i < 10; ++i) {
        infile >> nums[i];
    }

    unordered_map<int, vector<vector<int>>> sumMap;

    // Generate all subsets using bitmasking
    int n = nums.size();
    for (int mask = 1; mask < (1 << n); ++mask) {
        vector<int> subset;
        int sum = 0;
        for (int i = 0; i < n; ++i) {
            if (mask & (1 << i)) {
                subset.push_back(nums[i]);
                sum += nums[i];
            }
        }
        sumMap[sum].push_back(subset);
    }

    int maxSum = 0;
    vector<int> subset1, subset2;
    int pairCount = 0;

    for (const auto& entry : sumMap) {
        const auto& subsetList = entry.second;
        if (subsetList.size() > 1) {
            for (size_t i = 0; i < subsetList.size(); ++i) {
                for (size_t j = i + 1; j < subsetList.size(); ++j) {
                    if (areDisjoint(subsetList[i], subsetList[j])) {
                        pairCount++;
                        if (entry.first > maxSum) {
                            maxSum = entry.first;
                            subset1 = subsetList[i];
                            subset2 = subsetList[j];
                        }
                    }
                }
            }
        }
    }

    outfile << pairCount << " " << maxSum << endl;
    for (int num : subset1) {
        outfile << num << " ";
    }
    outfile << endl;
    for (int num : subset2) {
        outfile << num << " ";
    }
    outfile << endl;

    return 0;
}
```

### Explanation:
1. **Reading Input**: The code reads 10 distinct two-digit numbers from the file `numere.in`.
2. **Generating Subsets**: Using bitmasking, all possible subsets of the given 10 numbers are generated.
3. **Mapping Subsets by Sum**: For each subset, the sum is calculated and subsets are stored in a map where the key is the sum.
4. **Finding Disjoint Subsets**: For each sum, the code checks pairs of subsets to see if they are disjoint (no common elements). If they are, it checks if their sum is the maximum found so far.
5. **Output**: The number of such pairs and the maximum sum are written to `numere.out`, along with one pair of disjoint subsets having the maximum sum.

This approach ensures that all possible subsets are considered and the solution is efficient given the constraints. The use of bitmasking simplifies the subset generation process and ensures that we can easily check for disjoint subsets.
---------- user ----------


Program result did not match expected result.
Input data:
```
60 49 86 78 23 97 69 71 32 10
```
Expected output:
```
65 276
78 97 69 32
60 49 86 71 10
```
Found output:
```
65 276
78 97 69 32 
60 49 86 71 10
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The discrepancy between the expected and found outputs is due to an extra trailing space in the output lines. This can be corrected by ensuring that the trailing space is removed when writing the subsets to the output file.

Let's reimplement the solution while ensuring the correct formatting of the output.

```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <unordered_map>
#include <algorithm>

using namespace std;

// Function to check if two subsets are disjoint
bool areDisjoint(const vector<int>& subset1, const vector<int>& subset2) {
    unordered_map<int, int> countMap;
    for (int num : subset1) {
        countMap[num]++;
    }
    for (int num : subset2) {
        if (countMap[num] > 0) {
            return false;
        }
    }
    return true;
}

int main() {
    ifstream infile("numere.in");
    ofstream outfile("numere.out");

    vector<int> nums(10);
    for (int i = 0; i < 10; ++i) {
        infile >> nums[i];
    }

    unordered_map<int, vector<vector<int>>> sumMap;

    // Generate all subsets using bitmasking
    int n = nums.size();
    for (int mask = 1; mask < (1 << n); ++mask) {
        vector<int> subset;
        int sum = 0;
        for (int i = 0; i < n; ++i) {
            if (mask & (1 << i)) {
                subset.push_back(nums[i]);
                sum += nums[i];
            }
        }
        sumMap[sum].push_back(subset);
    }

    int maxSum = 0;
    vector<int> subset1, subset2;
    int pairCount = 0;

    for (const auto& entry : sumMap) {
        const auto& subsetList = entry.second;
        if (subsetList.size() > 1) {
            for (size_t i = 0; i < subsetList.size(); ++i) {
                for (size_t j = i + 1; j < subsetList.size(); ++j) {
                    if (areDisjoint(subsetList[i], subsetList[j])) {
                        pairCount++;
                        if (entry.first > maxSum) {
                            maxSum = entry.first;
                            subset1 = subsetList[i];
                            subset2 = subsetList[j];
                        }
                    }
                }
            }
        }
    }

    outfile << pairCount << " " << maxSum << endl;

    // Output the first subset
    for (size_t i = 0; i < subset1.size(); ++i) {
        outfile << subset1[i];
        if (i < subset1.size() - 1) {
            outfile << " ";
        }
    }
    outfile << endl;

    // Output the second subset
    for (size_t i = 0; i < subset2.size(); ++i) {
        outfile << subset2[i];
        if (i < subset2.size() - 1) {
            outfile << " ";
        }
    }
    outfile << endl;

    return 0;
}
```

### Explanation:
1. **Reading Input**: The code reads 10 distinct two-digit numbers from the file `numere.in`.
2. **Generating Subsets**: Using bitmasking, all possible subsets of the given 10 numbers are generated.
3. **Mapping Subsets by Sum**: For each subset, the sum is calculated and subsets are stored in a map where the key is the sum.
4. **Finding Disjoint Subsets**: For each sum, the code checks pairs of subsets to see if they are disjoint (no common elements). If they are, it checks if their sum is the maximum found so far.
5. **Output**: The number of such pairs and the maximum sum are written to `numere.out`, along with one pair of disjoint subsets having the maximum sum. The output ensures that there are no trailing spaces at the end of each line.

This revised solution ensures correct formatting of the output, adhering to the expected result format.
