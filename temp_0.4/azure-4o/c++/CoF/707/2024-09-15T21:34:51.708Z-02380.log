---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `sir.in` and write to `sir.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Se consideră următorul şir, construit astfel încât fiecare element al lui, cu excepţia primului, se obţine din cel precedent: $1, 11, 21, 1211, 111221, \dots$
Termenii din şir sunt numerotaţi începând cu $1$.

# Cerință

Dat $n$, un număr natural, să se determine cel de-al $n$-lea termen din şirul dat.

# Date de intrare

Pe prima linie a fișierului de intrare `sir.in` se găseste numarul $n$.

# Date de ieșire

Pe prima linie a fișierului de ieșire `sir.out` se va găsi un singur număr întreg, al $n$-lea termen al sirului.

# Restricții și precizări

* $4 \leq n \leq 35$;
* numărul de cifre ale unui termen nu depăşeşte $17 \ 000$.

---

Example:
`sir.in`
```
4
```

`sir.out`
```
1211
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:Here is the C++ solution for the given problem. This solution reads from the file `sir.in`, computes the n-th term of the sequence, and writes the result to `sir.out`.

```cpp
#include <iostream>
#include <fstream>
#include <string>

std::string getNextTerm(const std::string& term) {
    std::string result;
    int count = 1;
    char currentChar = term[0];

    for (size_t i = 1; i < term.size(); ++i) {
        if (term[i] == currentChar) {
            ++count;
        } else {
            result += std::to_string(count) + currentChar;
            currentChar = term[i];
            count = 1;
        }
    }
    result += std::to_string(count) + currentChar;

    return result;
}

std::string getNthTerm(int n) {
    std::string term = "1";
    for (int i = 1; i < n; ++i) {
        term = getNextTerm(term);
    }
    return term;
}

int main() {
    std::ifstream inputFile("sir.in");
    std::ofstream outputFile("sir.out");

    if (!inputFile.is_open() || !outputFile.is_open()) {
        return 1;
    }

    int n;
    inputFile >> n;

    std::string result = getNthTerm(n);
    outputFile << result;

    inputFile.close();
    outputFile.close();

    return 0;
}
```

### Explanation:

1. **getNextTerm Function**:
    - This function takes a string `term` and generates the next term in the sequence.
    - It iterates through the characters of the input term, counting consecutive characters and appending the count followed by the character to the result string.

2. **getNthTerm Function**:
    - This function generates the n-th term of the sequence by iteratively applying the `getNextTerm` function starting from the initial term "1".

3. **main Function**:
    - It opens the input file `sir.in` and reads the integer `n`.
    - It then computes the n-th term using the `getNthTerm` function.
    - Finally, it writes the result to the output file `sir.out`.

### Example:
For the input file `sir.in` containing:
```
4
```
The output file `sir.out` will contain:
```
1211
```

This solution is efficient for the given constraints and should perform well within the provided limits.
