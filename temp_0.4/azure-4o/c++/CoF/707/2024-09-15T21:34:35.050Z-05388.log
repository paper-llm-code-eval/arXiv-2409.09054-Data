---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `sir.in` and write to `sir.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Se consideră următorul şir, construit astfel încât fiecare element al lui, cu excepţia primului, se obţine din cel precedent: $1, 11, 21, 1211, 111221, \dots$
Termenii din şir sunt numerotaţi începând cu $1$.

# Cerință

Dat $n$, un număr natural, să se determine cel de-al $n$-lea termen din şirul dat.

# Date de intrare

Pe prima linie a fișierului de intrare `sir.in` se găseste numarul $n$.

# Date de ieșire

Pe prima linie a fișierului de ieșire `sir.out` se va găsi un singur număr întreg, al $n$-lea termen al sirului.

# Restricții și precizări

* $4 \leq n \leq 35$;
* numărul de cifre ale unui termen nu depăşeşte $17 \ 000$.

---

Example:
`sir.in`
```
4
```

`sir.out`
```
1211
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:To solve this challenge, we need to generate the nth term of the "look-and-say" sequence. The sequence starts with "1", and each subsequent term is generated by describing the previous term in terms of consecutive digits.

Here's the step-by-step approach:

1. **Read Input**: Read the integer `n` from the file `sir.in`.
2. **Generate Sequence**: Starting from the first term "1", generate each subsequent term until the nth term.
3. **Write Output**: Write the nth term to the file `sir.out`.

The most efficient way to handle this is by using string manipulation to generate each term. Given the constraints (4 ≤ n ≤ 35), we need to ensure our solution can handle large strings efficiently.

Here's the C++ code to achieve this:

```cpp
#include <fstream>
#include <string>

std::string getNextTerm(const std::string& current) {
    std::string next;
    int length = current.length();
    for (int i = 0; i < length; ) {
        char digit = current[i];
        int count = 0;
        while (i < length && current[i] == digit) {
            ++count;
            ++i;
        }
        next += std::to_string(count) + digit;
    }
    return next;
}

int main() {
    std::ifstream inputFile("sir.in");
    std::ofstream outputFile("sir.out");

    int n;
    inputFile >> n;

    std::string term = "1";
    for (int i = 1; i < n; ++i) {
        term = getNextTerm(term);
    }

    outputFile << term;

    inputFile.close();
    outputFile.close();

    return 0;
}
```

### Explanation:
1. **Reading Input**:
   - We use `std::ifstream` to read the integer `n` from the file `sir.in`.
   
2. **Generating the Sequence**:
   - We start with the initial term `term = "1"`.
   - For each iteration from 1 to `n-1`, we generate the next term using the `getNextTerm` function.
   - The `getNextTerm` function constructs the next term by counting consecutive digits in the current term and appending the count followed by the digit to the next term string.

3. **Writing Output**:
   - We use `std::ofstream` to write the nth term to the file `sir.out`.

This solution ensures efficient handling of string manipulations and adheres to the constraints provided.
