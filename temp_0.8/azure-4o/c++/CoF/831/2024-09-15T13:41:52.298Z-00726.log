---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `bete.in` and write to `bete.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Ana și Bogdan au găsit la bunicul lor o cutie cu $N$ bețe de aceeași lungime. După câteva minute de joacă urmează cearta. Bunicul le-a propus să rupă cele $N$ bețe și apoi Ana să primească fragmentele din mâna stângă, iar Bogdan fragmentele din mâna dreaptă. Zis și făcut. Copiii au luat fragmentele, le-au numerotat fiecare cu numere de la $1$ la $N$, le-au măsurat și acum își doresc să lipească fragmentele primite, dar mai au nevoie de câteva informații.

# Cerință

Cunoscând $N$ numărul de bețe, $A_1$, $A_2$, ..., $A_N$ lungimile fragmentelor primite de Ana și $B_1$, $B_2$, ..., $B_N$ lungimile fragmentelor primite de Bogdan, să se scrie un program care să determine:

* lungimea inițială a bețelor;
* lungimea celui mai lung băț care se poate obține prin lipirea unui fragment aparținând Anei cu un fragment care aparține lui Bogdan;
* numărul bețelor de lungime maximă care se pot obține prin lipirea unui fragment aparținând Anei cu un fragment care aparține lui Bogdan.

# Date de intrare


Fișierul de intrare `bete.in` conține pe prima linie numărul natural $N$ reprezentând numărul de bețe. Pe a doua linie sunt $N$ numere naturale $A_1$, $A_2$, ..., $A_N$ reprezentând lungimile fragmentelor primite de Ana și pe a treia linie sunt $N$ numere naturale $B_1$, $B_2$, ..., $B_N$ reprezentând lungimile fragmentelor primite de Bogdan.


# Date de ieșire

Fișierul de ieșire `bete.out` va conține trei linii. Pe prima linie se va scrie numărul natural $L$ reprezentând lungimea inițială a bețelor, pe a doua linie se va scrie numărul natural $K$ reprezentând lungimea celui mai lung băț care se poate obține prin lipirea unui fragment aparținând Anei cu un fragment care aparține lui Bogdan, iar pe a treia linie se va scrie numărul natural $P$ reprezentând numărul bețelor de lungime maximă care se pot obține prin lipirea unui fragment aparținând Anei cu un fragment care aparține lui Bogdan.


# Restricții și precizări

* $1 \leq N \leq 1 \ 000$;
* $1 \leq A_i \leq 10 \ 000$;
* $1 \leq B_i \leq 10 \ 000$;
* $1 \leq L \leq 20 \ 000$;
* $1 \leq K \leq 20 \ 000$;
* $1 \leq P \leq 1 \ 000$;
* Odată lipite două fragmente, acestea nu se pot dezlipi.
* Pentru determinarea corectă a valorii L se acordă 30% din punctaj, pentru determinarea corectă a valorii K se acordă 30% din punctaj, iar pentru determinarea corectă a valorii P se acordă 40% din punctaj.

---

Example:
`bete.in`
```
6
2 6 7 1 3 5
5 4 7 8 9 3
```

`bete.out`
```
10
16
1
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:To solve this problem efficiently, I will write a C++ program that reads the input from `bete.in`, processes the data to compute the required values, and writes the output to `bete.out`.

### Steps to solve the problem:

1. **Reading Input**: Read the number of sticks `N`, the lengths of fragments received by Ana, and the lengths of fragments received by Bogdan.
2. **Calculate Initial Length `L`**:
    - The initial stick length `L` can be found by summing up the total lengths of fragments received by Ana and Bogdan and then dividing by `N` (since each stick was originally of the same length).
3. **Finding Maximum Length `K`**:
    - The maximum length `K` is the sum of the longest fragment from Ana's list and the longest fragment from Bogdan's list.
4. **Counting Number of Sticks of Maximum Length `P`**:
    - To determine `P`, iterate through all possible pairs of fragments from Ana and Bogdan, count how many pairs sum up to the maximum length `K`.

Here is the C++ code to perform these steps efficiently:

```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <algorithm>

int main() {
    std::ifstream inFile("bete.in");
    std::ofstream outFile("bete.out");

    int N;
    inFile >> N;

    std::vector<int> A(N), B(N);
    int totalA = 0, totalB = 0;

    for (int i = 0; i < N; ++i) {
        inFile >> A[i];
        totalA += A[i];
    }

    for (int i = 0; i < N; ++i) {
        inFile >> B[i];
        totalB += B[i];
    }

    // Calculate the initial length of the sticks
    int L = (totalA + totalB) / N;
    
    // Find the maximum possible length by combining fragments
    int maxA = *std::max_element(A.begin(), A.end());
    int maxB = *std::max_element(B.begin(), B.end());
    int K = maxA + maxB;

    // Count how many pairs generate the maximum length
    int P = 0;
    for (int i = 0; i < N; ++i) {
        for (int j = 0; j < N; ++j) {
            if (A[i] + B[j] == K) {
                ++P;
            }
        }
    }

    // Write the results to output file
    outFile << L << "\n" << K << "\n" << P << "\n";

    inFile.close();
    outFile.close();

    return 0;
}
```

### Explanation:
1. **Input Reading**:
    - Read the value of `N`.
    - Read the lengths of fragments received by Ana and store them in vector `A`.
    - Read the lengths of fragments received by Bogdan and store them in vector `B`.

2. **Calculate Initial Length `L`**:
    - Sum up all lengths in `A` and `B` to get `totalA` and `totalB`.
    - Calculate `L = (totalA + totalB) / N`.

3. **Calculate Maximum Length `K`**:
    - Find the maximum element in vector `A` (let's call it `maxA`).
    - Find the maximum element in vector `B` (let's call it `maxB`).
    - Compute `K = maxA + maxB`.

4. **Count Pairs of Maximum Length `P`**:
    - Iterate through all pairs of elements from `A` and `B`.
    - Count the pairs where the sum is equal to `K`.

5. **Output Results**:
    - Write `L`, `K`, and `P` to the file `bete.out`.

This solution reads the input, processes the data, and writes the results efficiently. The nested loop to count pairs with maximum length is acceptable given the constraints (`N` up to 1000), making the approach efficient and straightforward.
