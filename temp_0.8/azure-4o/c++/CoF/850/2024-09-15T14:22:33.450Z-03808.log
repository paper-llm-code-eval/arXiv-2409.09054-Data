---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `ferma.in` and write to `ferma.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Un fermier deține o fermă de formă dreptunghiulară cu lungimea $m$ metri și lățimea $n$ metri. Respectând principiul rotației culturilor, fermierul și a realizat un plan pentru semănarea culturilor în noul an. Astfel, el a desenat un dreptunghi pe care l-a împărțit în $m \cdot n$ celule, fiecare corespunzând unui metru pătrat, și a colorat în culori diferite zonele care corespund unor culturi diferite. O cultură poate fi semănată pe mai multe parcele. Două celule care au o latură comună aparțin aceleiași parcele dacă au aceeași culoare (sunt însămânțate cu aceeași cultură).  Fermierul are posibilitatea să irige o sigură parcelă și dorește să aleagă parcela cu cea mai mare suprafață. Nefiind mulțumit de suprafața rezultată, s-a întrebat dacă ar putea schimba cultura de pe o singură celulă, astfel încât să obțină o parcelă de suprafață mai mare.

Exemplu de fermă (_imagine 1_):

~[0.png]

# Cerință

Dându-se dimensiunile fermei și pentru fiecare celulă culoarea corespunzătoare culturii semănate, determinați:

1. **Varianta 1:** Suprafața maximă a unei parcele în planul inițial.
2. **Varianta 2:** Numărul liniei, respectiv al coloanei celulei pe care va semăna o altă cultură și culoarea corespunzătoare noii culturi în vederea obţinerii celei mai mari parcele posibile.


# Date de intrare


Fișierul de intrare `ferma.in` va conține:]

* pe prima linie un număr natural $v$ ($1 ≤ v ≤ 2$) indicând varianta cerinței de rezolvare
* pe a doua linie două numere naturale $m$ şi $n$ separate printr-un spațiu, cu semnificația din enunț
* pe fiecare dintre următoarele $m$ linii se găsesc câte $n$ caractere (litere mici), reprezentând codurile culturilor ce vor fi semănate pe cele $n$ celule corespunzătoare fiecărei linii. 


# Date de ieșire


Fișierul de ieșire `ferma.out` va conține:
**Varianta 1** – pentru $v=1$: 
* pe prima linie numărul natural $s$, reprezentând suprafața maximă a unei parcele.

**Varianta 2** – pentru $v=2$: 
* pe prima linie două numere naturale separate printr-un spațiu, reprezentând numărul liniei, respectiv al coloanei celulei pe care va semăna o altă cultură, în vederea obținerii unei parcele cu suprafața maximă; 
* pe a doua linie un caracter reprezentând codul culorii corespunzătoare noii culturi din celula determinată.


# Restricții și precizări

* $2 \leq n, m \leq 400$
* Numărul de culturi distincte este cel puţin $2$ şi cel mult $26$.
* $30\%$ din teste vor avea pe prima linie valoarea $1$, iar restul de $70\%$ din teste vor avea pe prima linie valoarea $2$.
* Pentru varianta $2$ se punctează orice soluție care conduce la obținerea unei parcele cu suprafața maximă. Nu se acordă punctaje parțiale.

---

Example:
`ferma.in`
```
1
7 8
rmmgggaa
mvvgggaa
mvvgvvvv
vvvrvvvv
vvrrrgga
vvrrrggg
aaaaaaag
```

`ferma.out`
```
11
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:Let's break down the solution for the challenge step-by-step.

### Steps to Solve the Problem:

1. **Reading Input Data:**
   - Read the input from `ferma.in`.
   - Determine whether we need to solve for Variant 1 or Variant 2.
   - Parse the dimensions of the farm (`m` and `n`) and the grid representing the farm.

2. **Finding the Largest Parcel (Variant 1):**
   - Use Depth-First Search (DFS) or Breadth-First Search (BFS) to find connected components of the same color in the grid.
   - Keep track of the size of each parcel and update the maximum size found.

3. **Optimizing Parcel Size by Changing One Cell (Variant 2):**
   - For each cell in the grid, simulate changing it to each of the other possible colors.
   - Calculate the new maximum parcel size after each change.
   - Track the cell change that results in the largest parcel size.

4. **Output the Result:**
   - Write the results to `ferma.out` based on the variant specified.

### Implementation Considerations:
- Efficiently traverse the grid to find connected components.
- Handle the edge cases where changing a cell doesn't increase the parcel size.
- Ensure the solution runs efficiently given the constraints.

```cpp
#include <fstream>
#include <vector>
#include <queue>
#include <algorithm>

using namespace std;

const int MAX_N = 400;
const int DIRECTIONS[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
char farm[MAX_N][MAX_N];
bool visited[MAX_N][MAX_N];
int m, n;

struct Parcel {
    int size;
    vector<pair<int, int>> cells;
};

// Function to perform BFS and find the size of a parcel
Parcel bfs(int x, int y, char color) {
    Parcel parcel = {0, {}};
    queue<pair<int, int>> q;
    q.push({x, y});
    visited[x][y] = true;

    while (!q.empty()) {
        auto [cx, cy] = q.front();
        q.pop();
        parcel.size++;
        parcel.cells.push_back({cx, cy});

        // Explore neighbors
        for (int i = 0; i < 4; ++i) {
            int nx = cx + DIRECTIONS[i][0];
            int ny = cy + DIRECTIONS[i][1];
            if (nx >= 0 && nx < m && ny >= 0 && ny < n && !visited[nx][ny] && farm[nx][ny] == color) {
                visited[nx][ny] = true;
                q.push({nx, ny});
            }
        }
    }
    return parcel;
}

int main() {
    ifstream fin("ferma.in");
    ofstream fout("ferma.out");

    int variant;
    fin >> variant >> m >> n;

    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            fin >> farm[i][j];
        }
    }

    if (variant == 1) {
        int maxParcelSize = 0;

        // Find the largest parcel in the initial grid
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (!visited[i][j]) {
                    Parcel parcel = bfs(i, j, farm[i][j]);
                    maxParcelSize = max(maxParcelSize, parcel.size);
                }
            }
        }
        fout << maxParcelSize << '\n';

    } else if (variant == 2) {
        int maxParcelSize = 0;
        pair<int, int> bestCell = {-1, -1};
        char bestColor = 'a';

        // Find and change one cell to maximize the parcel size
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                char originalColor = farm[i][j];

                for (char newColor = 'a'; newColor <= 'z'; ++newColor) {
                    if (newColor == originalColor) continue;

                    farm[i][j] = newColor;
                    fill(&visited[0][0], &visited[0][0] + sizeof(visited), false);
                    int newMaxParcelSize = 0;

                    // Calculate the maximum parcel size with the new color
                    for (int x = 0; x < m; ++x) {
                        for (int y = 0; y < n; ++y) {
                            if (!visited[x][y]) {
                                Parcel parcel = bfs(x, y, farm[x][y]);
                                newMaxParcelSize = max(newMaxParcelSize, parcel.size);
                            }
                        }
                    }

                    if (newMaxParcelSize > maxParcelSize) {
                        maxParcelSize = newMaxParcelSize;
                        bestCell = {i, j};
                        bestColor = newColor;
                    }

                    farm[i][j] = originalColor;  // Restore original color
                }
            }
        }

        fout << bestCell.first + 1 << " " << bestCell.second + 1 << '\n';
        fout << bestColor << '\n';
    }

    fin.close();
    fout.close();
    return 0;
}
```

### Explanation:
- The code starts by reading input from `ferma.in` and setting up the grid.
- For Variant 1, it uses BFS to find the size of the largest parcel.
- For Variant 2, it tries changing each cell to each possible new color, recalculates the maximum parcel size, and keeps track of the best change.
- Finally, it writes the appropriate result to `ferma.out`.

This solution ensures efficient traversal and handling of the grid based on the given constraints.
