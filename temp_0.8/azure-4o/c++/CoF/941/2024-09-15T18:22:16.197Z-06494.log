---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `ceas.in` and write to `ceas.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Un atelier de fabricat ceasuri cu cuc are nevoie de plăcuțe cu numerele pentru orele pe care trebuie să le așeze pe discul ceasurilor. Aceste numere sunt realizate la o imprimantă.

Din cauza unei erori imprimanta tipărește plăcuțe cu numere naturale, unele mai mari ca $12$. Atelierul poate utiliza doar plăcuțe cu numere cuprinse ı̂ntre $0$ și $12$. Pentru a utiliza aceste numere este nevoie ca ele să fie tăiate ı̂ncepând din partea dreaptă ı̂n grupuri de maximum două cifre, fiecare grup reprezentând valoarea de pe o plăcuță, care să fie o cifră la $0$ la $9$ sau unul dintre numerele $10$, $11$, $12$. Dacă pe o plăcuță se găsește un număr mai mare ca $12$ atunci plăcuța trebuie tăiată, astfel ı̂ncât ı̂n urma tăierii să se obțină numere de cel mult $2$ cifre. Dacă ı̂n numărul de pe o plăcuță cifra zecilor este $0$, atunci la prima tăiere se ia doar cifra unităților, altfel dacă numărul format cu cifra zecilor și unităților este mai mare ca $12$, atunci se taie prima dată cifra unităților, iar dacă numărul format cu cifra zecilor și unităților este $10$, $11$ sau $12$ se taie prima dată numărul format din ultimele două cifre, apoi procedeul se repetă până la tăierea completă a plăcuței. Imprimanta a realizat N plăcuțe. De exemplu dacă plăcuța este $12030$, după tăiere se obțin $0$, $3$, $0$, $12$.

# Cerință
1. Determinați numărul total de apariții ale cifrei $X$ pe plăcuțe ı̂nainte de tăiere.
2. Determinați numărul de tăieturi realizate conform enunțului.

# Date de intrare

Pe prima linie a fișierului `ceas.in` se află valorile $C$, $X$ și $N$ separate prin câte un singur spațiu. Pe linia a doua se află $N$ numere naturale separate prin câte un singur spațiu, având semnificația din enunț. Pentru $C = 1$ se rezolvă doar cerința $1$, iar pentru $C = 2$ se rezolvă doar cerința $2$.

# Date de ieșire

Fișierul `ceas.out` conține pe prima linie un singur număr natural care reprezintă valoarea calculată conform cerinței.

# Restricții și precizări

* $1 \leq N \leq 100 \ 000$;
* $0 \leq X \leq 9$;
* Valorile din șir sunt numere naturale $\leq 50 \ 000$;
* Pentru testele în care avem $C = 2$ valoarea $X$ este prezentă în fișierul de intrare chiar dacă nu este folosită în rezolvare.
* Pentru teste în valoare de $39$ de puncte avem $C = 1$
* Pentru teste în valoare de $61$ de puncte avem $C = 2$

---

Example:
`ceas.in`
```
1 0 6
1010 40 201 5123 31 6
```

`ceas.out`
```
4
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```cpp
#include <fstream>
#include <vector>
#include <string>

int count_digit_occurrences(int number, int digit) {
    int count = 0;
    while (number > 0) {
        if (number % 10 == digit) {
            count++;
        }
        number /= 10;
    }
    return count;
}

int count_cuts(int number) {
    int cuts = 0;

    std::string num_str = std::to_string(number);
    while (num_str.length() > 0) {
        if (num_str.length() > 1) {
            int last_two_digits = stoi(num_str.substr(num_str.length() - 2));
            if (last_two_digits >= 10 && last_two_digits <= 12) {
                cuts++;
                num_str = num_str.substr(0, num_str.length() - 2);
                continue;
            }
        }
        cuts++;
        num_str.pop_back();
    }

    return cuts - 1; // Subtract 1 because the last cut is not really a cut
}

int main() {
    std::ifstream fin("ceas.in");
    std::ofstream fout("ceas.out");

    int C, X, N;
    fin >> C >> X >> N;

    std::vector<int> numbers(N);
    for (int i = 0; i < N; ++i) {
        fin >> numbers[i];
    }

    if (C == 1) {
        int total_occurrences = 0;
        for (int i = 0; i < N; ++i) {
            total_occurrences += count_digit_occurrences(numbers[i], X);
        }
        fout << total_occurrences;
    } else if (C == 2) {
        int total_cuts = 0;
        for (int i = 0; i < N; ++i) {
            total_cuts += count_cuts(numbers[i]);
        }
        fout << total_cuts;
    }

    fin.close();
    fout.close();
    return 0;
}
```

### Explanation:

1. **Input Reading:**
   - We read the input values for `C`, `X`, and `N`.
   - Then, we read the `N` numbers into a vector.

2. **First Requirement (C=1):**
   - If `C` is 1, we count the total occurrences of the digit `X` in all the numbers.
   - The function `count_digit_occurrences` is used to count the occurrences of `X` in each number.

3. **Second Requirement (C=2):**
   - If `C` is 2, we count the total number of cuts required for all the numbers.
   - The function `count_cuts` simulates the cutting process as described and counts the number of cuts.

4. **Output:**
   - The result (either the total occurrences or total cuts) is written to the output file `ceas.out`.

This solution is designed to be both efficient and easy to understand, following the guidelines and constraints provided.
