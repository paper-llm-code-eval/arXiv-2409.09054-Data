---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `multimi.in` and write to `multimi.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Se consideră $n$ mulțimi. Fiecare mulțime conține numai numere naturale consecutive. Pentru a indica o astfel de mulțime este suficient să dăm primul și ultimul element din ea.

# Cerință

Scrieți un program care să determine elementele intersecției celor $n$ mulțimi.

# Date de intrare

De pe prima linie a fișierului de intrare `multimi.in` se citește numărul $n$. Apoi, de pe fiecare din cele $n$ linii următoare, se citesc perechi de numere, câte o pereche pe linie, separate prin câte un spațiu, care reprezintă cel mai mic, respectiv cel mai mare element din fiecare mulțime.


# Date de ieșire

Pe prima linie a fișierului de ieșire `multimi.out` se vor afișa elementele intersecției cu câte un spațiu între ele. În cazul în care intersecția nu are nici un element se va afișa mesajul `multimea vida`.


# Restricții și precizări

* $1 \leq n \leq 30$
* Elementele mulțimilor sunt numere naturale $\leq 30 \ 000$.

---

Example:
`multimi.in`
```
3
5 10
4 11
2 9
```

`multimi.out`
```
5 6 7 8 9
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:To solve the problem of finding the intersection of n sets of consecutive natural numbers, let's break down the steps and then provide the C++ solution.

1. **Read Input**: We need to read the number of sets and then the pairs of numbers that define the ranges for each set.
2. **Determine Intersection**: The intersection of all ranges can be found by determining the maximum of the lower bounds and the minimum of the upper bounds. If the maximum lower bound is greater than the minimum upper bound, the intersection is empty.
3. **Output Result**: We need to output the intersection range or indicate that the set is empty.

Here's how the solution can be implemented in C++:

```cpp
#include <fstream>
#include <algorithm>
#include <vector>

int main() {
    std::ifstream fin("multimi.in");
    std::ofstream fout("multimi.out");
    
    int n;
    fin >> n;

    // Initialize the intersection range to cover all possible values
    int max_lower = 0;
    int min_upper = 30000;

    for (int i = 0; i < n; ++i) {
        int lower, upper;
        fin >> lower >> upper;
        max_lower = std::max(max_lower, lower);
        min_upper = std::min(min_upper, upper);
    }

    if (max_lower <= min_upper) {
        for (int i = max_lower; i <= min_upper; ++i) {
            fout << i << " ";
        }
    } else {
        fout << "multimea vida";
    }

    fin.close();
    fout.close();

    return 0;
}
```

### Explanation:
1. **Reading Input**: We use `std::ifstream` to read from `multimi.in` and `std::ofstream` to write to `multimi.out`. We first read the number of sets `n`.
2. **Determining Intersection**: We initialize `max_lower` to 0 and `min_upper` to 30000 because these are the lowest and highest possible values given the problem constraints. For each set, we update `max_lower` to be the maximum of the current `max_lower` and the lower bound of the set, and `min_upper` to be the minimum of the current `min_upper` and the upper bound of the set.
3. **Output Result**: After computing the final `max_lower` and `min_upper`, we check if `max_lower` is less than or equal to `min_upper`. If true, we print all numbers between `max_lower` and `min_upper` inclusive. Otherwise, we print "multimea vida".

This approach ensures that the solution is both efficient and correct, handling the input and output file operations appropriately and adhering to the problem constraints.
