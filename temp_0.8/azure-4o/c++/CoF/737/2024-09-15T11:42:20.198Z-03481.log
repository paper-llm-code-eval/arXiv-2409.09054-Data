---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `multimi.in` and write to `multimi.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Se consideră $n$ mulțimi. Fiecare mulțime conține numai numere naturale consecutive. Pentru a indica o astfel de mulțime este suficient să dăm primul și ultimul element din ea.

# Cerință

Scrieți un program care să determine elementele intersecției celor $n$ mulțimi.

# Date de intrare

De pe prima linie a fișierului de intrare `multimi.in` se citește numărul $n$. Apoi, de pe fiecare din cele $n$ linii următoare, se citesc perechi de numere, câte o pereche pe linie, separate prin câte un spațiu, care reprezintă cel mai mic, respectiv cel mai mare element din fiecare mulțime.


# Date de ieșire

Pe prima linie a fișierului de ieșire `multimi.out` se vor afișa elementele intersecției cu câte un spațiu între ele. În cazul în care intersecția nu are nici un element se va afișa mesajul `multimea vida`.


# Restricții și precizări

* $1 \leq n \leq 30$
* Elementele mulțimilor sunt numere naturale $\leq 30 \ 000$.

---

Example:
`multimi.in`
```
3
5 10
4 11
2 9
```

`multimi.out`
```
5 6 7 8 9
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:Here is the C++ solution for the given challenge. This solution reads from the `multimi.in` file and writes to the `multimi.out` file.

```cpp
#include <fstream>
#include <algorithm>

int main() {
    std::ifstream inFile("multimi.in");
    std::ofstream outFile("multimi.out");

    int n;
    inFile >> n;

    int start, end;
    inFile >> start >> end;

    int globalStart = start;
    int globalEnd = end;

    for (int i = 1; i < n; ++i) {
        inFile >> start >> end;
        globalStart = std::max(globalStart, start);
        globalEnd = std::min(globalEnd, end);

        if (globalStart > globalEnd) {
            outFile << "multimea vida";
            return 0;
        }
    }

    for (int i = globalStart; i <= globalEnd; ++i) {
        outFile << i << " ";
    }

    return 0;
}
```

### Explanation:
1. **Reading Input:**
   - The program reads from the file `multimi.in`.
   - The first number is `n`, which represents the number of sets.
   - For each set, the program reads two numbers representing the start and end of the range.

2. **Finding Intersection:**
   - It initializes the intersection range with the first set.
   - For every subsequent set, it updates the intersection range by taking the maximum of the starts (`globalStart`) and the minimum of the ends (`globalEnd`).
   - If at any point `globalStart` is greater than `globalEnd`, it means the intersection is empty, and the program outputs `multimea vida` and exits.

3. **Output Result:**
   - If the intersection is not empty, it prints all numbers from `globalStart` to `globalEnd` to `multimi.out`.

### Example:
Given the input:
```
3
5 10
4 11
2 9
```
The program calculates the intersection as:
- Intersection of [5, 10] and [4, 11] -> [5, 10]
- Intersection of [5, 10] and [2, 9] -> [5, 9]

Thus, the output will be:
```
5 6 7 8 9
```

This is a simple yet efficient solution with a linear time complexity relative to the number of sets, making it optimal for the given constraints.
