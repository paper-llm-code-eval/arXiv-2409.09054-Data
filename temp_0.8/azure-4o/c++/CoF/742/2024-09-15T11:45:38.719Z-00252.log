---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `tabel.in` and write to `tabel.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

După cum probabil știți, contabilii își țin datele sub formă de tabele și calculează tot felul de sume pe linii și pe coloane. Contabilul nostru Atnoc și-a organizat valorile sub forma unui tabel cu $n$ linii (numerotate de la $1$ la $n$) și $m$ coloane (numerotate de la $1$ la $m$). Elementele de pe ultima coloană sunt sumele elementelor de pe linii (mai exact, elementul de pe linia $i$ și coloana $m$ este egal cu suma elementelor de pe linia $i$ aflate pe coloanele $1, 2, \dots, m-1$), iar elementele de pe ultima linie sunt sumele elementelor de pe coloane (mai exact, elementul de pe linia $n$ și coloana $i$ este egal cu suma elementelor de pe coloana $i$ aflate pe liniile $1, 2, \dots, n-1$). Un exemplu de astfel de tabel este dat în figura următoare.

Din păcate, Atnoc a stropit cu apă minunatul său tabel și astfel o parte dintre numerele din tabel au devenit ilizibile.

~[tabel.png|width=30em]

# Cerință

Scrieți un program care să reconstituie toate datele din tabel.

# Date de intrare

Pe prima linie a fișierului text de intrare `tabel.in` se află două numere naturale $n$ și $m$, separate printr-un spațiu, ce reprezintă numărul de linii și respectiv numărul de coloane ale tabelului. Pe cea de a doua linie a fișierului de intrare se află un număr natural $p$ care reprezintă numărul de valori nedeteriorate din tabel. Pe fiecare dintre următoarele $p$ linii se află câte trei numere naturale, separate prin câte un spațiu $l \ c \ v$, unde $l$ este numărul liniei, $c$ este numărul coloanei și $v$ este valoarea elementului de pe linia $l$ și coloana $c$ din tabel.

# Date de ieșire

În fișierul text de ieșire `tabel.out` se va scrie tabelul reconstituit, pe $n$ linii câte $m$ valori separate prin câte un spațiu.

# Restricții și precizări

* $1 < n, m \leq 50$
* Valorile din tabel sunt numere naturale $< 32 \ 000$.
* În toate testele datele din tabel pot fi reconstituite.

---

Example:
`tabel.in`
```
3 4
10
1 1 2
1 2 5
1 3 7
1 4 14
2 2 6
2 4 23
3 1 13
3 2 11
3 3 13
3 4 37
```

`tabel.out`
```
2 5 7 14
11 6 6 23
13 11 13 37
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:### Solution Approach

To solve this problem, we need to reconstruct a table where each row's last element is the sum of the preceding elements in that row, and each column's last element is the sum of the preceding elements in that column. Given that we have some intact values, we can use those to deduce the missing ones.

Here's a step-by-step approach:

1. **Reading Input Efficiently:** We'll read the input using file streams for efficiency.
2. **Matrix Initialization:** Initialize a matrix to store the values. Use a 2D vector initialized to a known "unset" flag (like `-1`).
3. **Placing Known Values:** Populate the matrix with the known values.
4. **Reconstructing the Table:**
   - First, calculate the last column values (sum of each row).
   - Then calculate the last row values (sum of each column).
5. **Output the Matrix:** Write the final matrix to the output file using file streams.

### Implementation in C++

```cpp
#include <iostream>
#include <fstream>
#include <vector>

int main() {
    std::ifstream inFile("tabel.in");
    std::ofstream outFile("tabel.out");
    
    int n, m, p;
    inFile >> n >> m >> p;
    
    std::vector<std::vector<int>> table(n, std::vector<int>(m, -1));
    
    for (int i = 0; i < p; ++i) {
        int l, c, v;
        inFile >> l >> c >> v;
        table[l-1][c-1] = v;
    }
    
    // Compute sums for missing values in the last column
    for (int i = 0; i < n-1; ++i) {
        if (table[i][m-1] == -1) {
            int rowSum = 0;
            for (int j = 0; j < m-1; ++j) {
                if (table[i][j] != -1) {
                    rowSum += table[i][j];
                }
            }
            table[i][m-1] = rowSum;
        }
    }

    // Compute sums for missing values in the last row
    for (int j = 0; j < m-1; ++j) {
        if (table[n-1][j] == -1) {
            int colSum = 0;
            for (int i = 0; i < n-1; ++i) {
                if (table[i][j] != -1) {
                    colSum += table[i][j];
                }
            }
            table[n-1][j] = colSum;
        }
    }

    // Compute last element if missing
    int lastElement = 0;
    for (int i = 0; i < n-1; ++i) {
        lastElement += table[i][m-1];
    }
    table[n-1][m-1] = lastElement;
    
    // Output the table
    for (const auto& row : table) {
        for (size_t j = 0; j < row.size(); ++j) {
            if (j > 0) outFile << " ";
            outFile << row[j];
        }
        outFile << "\n";
    }
    
    return 0;
}
```

### Explanation:
1. **Reading Input:** We use `ifstream` to read from `tabel.in` and `ofstream` to write to `tabel.out`.
2. **Matrix Initialization:** A 2D vector `table` is initialized with `-1` to mark unset values.
3. **Placing Known Values:** Known values are read and placed in the appropriate positions in the `table`.
4. **Reconstructing the Table:**
   - For each row, calculate the sum if the last element is missing.
   - For each column, calculate the sum if the last element is missing.
   - Finally, calculate the bottom-right element if missing.
5. **Outputting the Table:** The final matrix is written to `tabel.out`.

This solution ensures efficiency both in terms of time complexity and practical implementation, adhering to the constraints provided.
---------- user ----------


Program result did not match expected result.
Input data:
```
3 4
10
1 1 2
1 2 5
1 3 7
1 4 14
2 2 6
2 4 23
3 1 13
3 2 11
3 3 13
3 4 37
```
Expected output:
```
2 5 7 14
11 6 6 23
13 11 13 37
```
Found output:
```
2 5 7 14
-1 6 -1 23
13 11 13 37
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The discrepancy arises because the original solution does not account for all possible missing values in the matrix. Specifically, it only handles the sums for the last column and last row, but not intermediate missing values.

To fix this, we can use the following approach:

1. **Read the input and initialize the matrix.**
2. **Set known values in the matrix.**
3. **Iteratively solve for missing values using the properties of row and column sums.**
4. **Output the reconstructed table.**

Here's the corrected solution implementing this approach:

```cpp
#include <iostream>
#include <fstream>
#include <vector>

int main() {
    std::ifstream inFile("tabel.in");
    std::ofstream outFile("tabel.out");
    
    int n, m, p;
    inFile >> n >> m >> p;
    
    std::vector<std::vector<int>> table(n, std::vector<int>(m, -1));
    
    for (int i = 0; i < p; ++i) {
        int l, c, v;
        inFile >> l >> c >> v;
        table[l-1][c-1] = v;
    }
    
    // Iteratively solve the table
    bool updated;
    do {
        updated = false;

        // Solve for row sums
        for (int i = 0; i < n-1; ++i) {
            int sum = 0, unknowns = 0;
            for (int j = 0; j < m-1; ++j) {
                if (table[i][j] == -1) {
                    unknowns++;
                } else {
                    sum += table[i][j];
                }
            }
            if (unknowns == 1) {
                for (int j = 0; j < m-1; ++j) {
                    if (table[i][j] == -1) {
                        table[i][j] = table[i][m-1] - sum;
                        updated = true;
                        break;
                    }
                }
            }
        }

        // Solve for column sums
        for (int j = 0; j < m-1; ++j) {
            int sum = 0, unknowns = 0;
            for (int i = 0; i < n-1; ++i) {
                if (table[i][j] == -1) {
                    unknowns++;
                } else {
                    sum += table[i][j];
                }
            }
            if (unknowns == 1) {
                for (int i = 0; i < n-1; ++i) {
                    if (table[i][j] == -1) {
                        table[i][j] = table[n-1][j] - sum;
                        updated = true;
                        break;
                    }
                }
            }
        }
    } while (updated);

    // Compute the last element if missing
    if (table[n-1][m-1] == -1) {
        int sum = 0;
        for (int i = 0; i < n-1; ++i) {
            sum += table[i][m-1];
        }
        table[n-1][m-1] = sum;
    }
    
    // Output the table
    for (const auto& row : table) {
        for (size_t j = 0; j < row.size(); ++j) {
            if (j > 0) outFile << " ";
            outFile << row[j];
        }
        outFile << "\n";
    }

    return 0;
}
```

### Explanation

1. **Reading Input and Initializing the Matrix:** We read the input values and initialize a `table` matrix with `-1` to signify unset values.
2. **Setting Known Values:** Populate the matrix with the known values from the input.
3. **Iteratively Solving for Unknown Values:**
   - We use a loop to iteratively solve for rows and columns independently by identifying rows and columns with exactly one unknown value.
   - For rows, we compute the row sum if there's exactly one unknown value in the row.
   - For columns, we compute the column sum if there's exactly one unknown value in the column.
   - Repeat this process until no more changes occur.
4. **Compute the Last Element:** If the bottom-right element is still unset, compute it using the sum of values in the last column.
5. **Output the Matrix:** Write the final matrix to the output file.

This approach ensures that all missing values in intermediate positions are correctly computed before finally computing the last element if necessary.
