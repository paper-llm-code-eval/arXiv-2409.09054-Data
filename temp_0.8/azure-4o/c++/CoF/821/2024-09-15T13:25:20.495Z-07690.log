---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `cifru.in` and write to `cifru.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Costel a descoperit într-o debara servieta cu cifru a tatălui său. Cifrul este compus din $4$ discuri metalice pe care sunt inscripționate cifrele de la $0$ la $9$. Fiecare disc se poate mișca individual, de sus în jos sau de jos în sus, formându-se combinații de cifre. De multe ori, datorită comodității, combinația ce permite deschiderea servietei este formată numai din cifre identice: $0000, 1111$ etc.

Costel își imaginează un cifru compus din $N$ discuri metalice, fiecare având inscripționate cifrele de la $0$ la $9$, fiecare putând fi deplasat în cele două direcții specificate anterior. Prin mutare Costel înțelege deplasarea unui disc în sus sau în jos, cu o singură poziție, adică deplasarea discului până la cifra precedentă, respectiv următoare celei curente.

# Cerință

Realizați un program care, cunoscând poziția inițială a fiecărui disc dintre cele N discuri ale cifrului, determină și afișează:

1. cifra cea mai mare care apare pe discurile cifrului în forma inițială;
2. numărul minim de mutări necesare pentru ca numărul obținut pe cifru să fie compus numai din cifre identice, număr necesar deschiderii servietei;
3. cifra cea mai mică ce se poate obține în urma efectuării numărului minim de mutări determinat;
4. numărul de combinații formate din cifre identice, care se poate obține în urma efectuării numărului minim de mutări determinat.

# Date de intrare

Fișierul `cifru.in` conține:

* pe prima linie numărul natural $N$ reprezentând numărul discurilor;
* pe următoarele $N$ linii câte o cifră, reprezentând cifra curentă de pe fiecare disc al cifrului.

# Date de ieșire

În fișierul de ieșire `cifru.out` se vor afișa, pe linii separate, cele $4$ valori solicitate.

# Restricții și precizări

* $1 < N \leq 100 \ 000$;
* Un disc poate să rămână nemișcat.
* Pentru rezolvarea corectă a cerinței $1$ se acordă $20\%$ din punctajul fiecărui test
* Pentru rezolvarea corectă a cerinței $2$ se acordă $40\%$ din punctajul fiecărui test
* Pentru rezolvarea corectă a cerinței $3$ se acordă $20\%$ din punctajul fiecărui test
* Pentru rezolvarea corectă a cerinței $4$ se acordă $20\%$ din punctajul fiecărui test

---

Example:
`cifru.in`
```
4
7
3
9
0
```

`cifru.out`
```
9
7
0
2
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:Sure, let's break down the solution step-by-step and then implement it in C++.

### Step-by-Step Solution

1. **Read Input:**
   - First, we need to read the number of discs `N` and the initial positions of these discs.

2. **Determine the Maximum Digit:**
   - To find the maximum digit in the initial configuration, simply traverse the list of digits and keep track of the highest value.

3. **Determine the Minimum Moves to Form Identical Digits:**
   - For each digit from 0 to 9, calculate the total number of moves required to make all discs show that digit. Track the minimum number of moves and the corresponding digit.

4. **Count the Number of Identical Combinations:**
   - Count how many different digits require the same minimum number of moves to form identical digits.

### Implementation in C++

```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <algorithm>
#include <climits>

int main() {
    std::ifstream infile("cifru.in");
    std::ofstream outfile("cifru.out");
    
    int N;
    infile >> N;
    
    std::vector<int> discs(N);
    int maxDigit = 0;
    
    for (int i = 0; i < N; ++i) {
        infile >> discs[i];
        if (discs[i] > maxDigit) {
            maxDigit = discs[i];
        }
    }
    
    int minMoves = INT_MAX;
    int minDigit = 0;
    std::vector<int> movesToDigit(10, 0);
    
    for (int targetDigit = 0; targetDigit <= 9; ++targetDigit) {
        int currentMoves = 0;
        for (int i = 0; i < N; ++i) {
            int diff = std::abs(discs[i] - targetDigit);
            currentMoves += std::min(diff, 10 - diff);
        }
        movesToDigit[targetDigit] = currentMoves;
        if (currentMoves < minMoves) {
            minMoves = currentMoves;
            minDigit = targetDigit;
        }
    }
    
    int identicalCombinationCount = 0;
    for (int targetDigit = 0; targetDigit <= 9; ++targetDigit) {
        if (movesToDigit[targetDigit] == minMoves) {
            ++identicalCombinationCount;
        }
    }
    
    outfile << maxDigit << '\n';
    outfile << minMoves << '\n';
    outfile << minDigit << '\n';
    outfile << identicalCombinationCount << '\n';
    
    return 0;
}
```

### Explanation of the Implementation

1. **Reading the Input:**
   - The input is read using `ifstream` and stored in a vector `discs`.

2. **Finding the Maximum Digit:**
   - A simple loop keeps track of the maximum digit encountered.

3. **Calculating Minimum Moves:**
   - For each possible target digit (0-9), we calculate the total moves required to align all discs to that digit:
     - The difference `diff` between the current digit and the target digit is computed.
     - We consider both possible directions (up or down) and choose the minimum move required.
   - Keep track of the minimum moves and the corresponding digit.

4. **Counting Identical Combinations:**
   - After computing the minimum moves for each digit, count how many digits require the minimum number of moves.

### Verification

This program reads the input from `cifru.in` and outputs the required results to `cifru.out`. It ensures optimal time complexity and handles the constraints effectively. The logic is verified against the provided example to ensure correctness.
