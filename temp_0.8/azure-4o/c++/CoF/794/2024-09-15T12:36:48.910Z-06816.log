---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `numar.in` and write to `numar.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Se dă un număr raţional strict pozitiv $q$, sub formă de fracţie zecimală.

# Cerință

Să se determine două numere naturale $a$ şi $b$ astfel încât $q = a / b$, iar modulul diferenţei dintre $a$ şi $b$ să fie minim.

# Date de intrare


Fişierul `numar.in` conţine:

* pe prima linie două valori naturale $ni$ şi $nz$. $ni$ reprezintă numărul de cifre care formeaza partea întreagă a lui $q$ iar $nz$ reprezintă numărul de cifre care formează partea fracţionara a lui $q$.
* pe a doua linie, $ni$ cifre care reprezintă partea întreagă a lui $q$. Între două cifre se află câte un caracter spaţiu.
* pe a treia linie, $nz$ cifre care reprezintă partea zecimală a lui $q$. Între două cifre se află câte un caracter spaţiu.


# Date de ieșire


Fişierul `numar.out` va conţine:

* pe prima linie un număr natural $n_1$ care reprezintă numărul de cifre din care este alcătuit numărul $a$;
* pe a doua linie, cifrele numărului $a$, fără spaţiu între ele.
* pe a treia linie un număr natural $n_2$ care reprezintă numărul de cifre din care este alcătuit numărul $b$;
* pe a patra linie, cifrele numarului $b$, fără spaţiu între ele.


# Restricții și precizări

* $1 \leq ni, nz < 2 \ 000$.
* $1 \leq ni + nz \leq 2 \ 000$.
* Cifrele din care este alcătuit $q$ sunt cele din sistemul zecimal.
* Pentru $20$% dintre teste, $ni + nz \leq 9$; pentru alte $15$% dintre teste, $10 \leq ni + nz \leq 16$.

---

Example:
`numar.in`
```
1 3
0
3 7 5
```

`numar.out`
```
1
3
1
8
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:Let's break down the problem and then provide the solution in C++. 

## Problem Breakdown
Given a rational number `q` in its decimal form, our task is to compute two natural numbers `a` and `b` such that `q = a / b` and the absolute difference `|a - b|` is minimized.

### Steps
1. **Read Input:**
   - Read the number of digits in the integer part (`ni`).
   - Read the number of digits in the fractional part (`nz`).
   - Read the integer part.
   - Read the fractional part.

2. **Formulate the Rational Number:**
   - Combine the integer and fractional parts to form the numerator `a`.
   - The denominator `b` will be `10^nz` to account for the number of decimal places.

3. **Simplify the Fraction:**
   - Compute the greatest common divisor (GCD) of `a` and `b`.
   - Divide both `a` and `b` by this GCD to get the simplified fraction.

4. **Output the Result:**
   - Output the number of digits and the digits of `a`.
   - Output the number of digits and the digits of `b`.

Here’s the code in C++:

```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <numeric>
#include <cmath>

// Function to read a sequence of digits from file
std::vector<int> readDigits(std::ifstream& in, int count) {
    std::vector<int> digits(count);
    for (int i = 0; i < count; i++) {
        in >> digits[i];
    }
    return digits;
}

// Function to convert a vector of digits to an integer
long long vectorToNumber(const std::vector<int>& digits) {
    long long number = 0;
    for (int digit : digits) {
        number = number * 10 + digit;
    }
    return number;
}

int main() {
    std::ifstream inFile("numar.in");
    std::ofstream outFile("numar.out");

    int ni, nz;
    inFile >> ni >> nz;

    auto integerPart = readDigits(inFile, ni);
    auto fractionalPart = readDigits(inFile, nz);

    long long a = vectorToNumber(integerPart) * static_cast<long long>(std::pow(10, nz)) + vectorToNumber(fractionalPart);
    long long b = static_cast<long long>(std::pow(10, nz));

    long long gcd = std::gcd(a, b);
    a /= gcd;
    b /= gcd;

    outFile << std::to_string(a).length() << "\n" << a << "\n";
    outFile << std::to_string(b).length() << "\n" << b << "\n";

    return 0;
}
```

### Explanation
1. We read the input values from `numar.in`.
2. We then read the integer part and the fractional part as vectors of digits.
3. We convert these vectors to integers.
4. We construct `a` and `b` such that `a` is the combined number and `b` is `10` raised to the power of the number of fractional digits.
5. We simplify the fraction by dividing both `a` and `b` by their greatest common divisor (GCD).
6. Finally, we write the results to `numar.out`.

This solution efficiently constructs and simplifies the rational number, ensuring correct and fast results.
