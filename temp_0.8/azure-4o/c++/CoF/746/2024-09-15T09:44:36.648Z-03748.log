---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `scara.in` and write to `scara.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Ion şi-a construit o vilă pe frumosul vârf al unui munte. Acum proiectează o scară specială, pe care va urca de la şosea până la vilă. Diferenţa de nivel dintre şosea şi vilă este $H$ (deci aceasta trebuie să fie înălţimea totală a scării). Scara va avea $N$ trepte, toate de aceeaşi lăţime, dar de înălţimi distincte două câte două.

Ion a sesizat că efortul pe care îl depune pentru a urca o treaptă este egal cu înălţimea treptei. Dar dacă el urcă $x$ trepte deodată, efortul depus este egal cu media aritmetică a înălţimilor acestor $x$ trepte pe care le urcă deodată + un efort de valoare constantă $p$ (necesar pentru a-şi lua avânt). 

Fiind un tip atletic, Ion poate urca mai multe trepte deodată, dar suma înălţimilor treptelor urcate deodată nu trebuie să depăşească o valoare maximă $M$.

# Cerinţă

Scrieţi un program care să determine efortul minim necesar pentru a urca pe o scară construită conform restricţiilor problemei, precum şi o modalitate de a construi scara care va fi urcată cu efort minim.

# Date de intrare


Fişierul de intrare `scara.in` va conţine pe prima linie $4$ numere naturale separate prin câte un spaţiu $H \ N \ M \ p$ (cu semnificaţia din enunţ).

# Date de ieșire


Fişierul de ieşire `scara.out` va conţine 
- pe prima linie va fi scris efortul minim necesar (cu $2$ zecimale cu rotunjire);
- pe cea de a doua linie vor fi scrise $N$ numere naturale nenule care reprezintă înălţimile celor $N$ trepte ale scării (în ordinea de la şosea către vilă), separate prin câte un spaţiu. 


# Restricții și precizări

* $0 < H \leq 75$
* $0 < N \leq 8$
* $0 < M < 14$
* $0 \leq p \leq 10$
* Pentru datele de test, problema are întodeauna soluţie. 
* Dacă există mai multe soluţii (modalităţi de a construi scara astfel încât să obţineţi efortul minim dorit), veţi afişa prima soluţie în ordine lexicografică.
* Spunem că vectorul $x=(x_1, x_2, ..., x_k)$ precedă în ordine lexicografică vectorul $y=(y_1, y_2, ..., y_k)$ dacă există $i \geq 1$ astfel încât $x_j=y_j$, pentru orice $j<i$ şi $x_i<y_i$.
* Dacă a doua zecimală a efortului minim este $0$, sau chiar ambele zecimale sunt $0$ nu este necesar să le afişaţi. Deci în exemplu s-ar fi putut scrie efortul minim $9$ sau $9.0$.
* Se acordă $40\%$ din punctaj pentru prima cerinţă (efortul minim).
* Dacă efortul minim este corect şi se afişează şi o soluţie corectă (care respectă restricţiile problemei şi corespunde efortului minim), dar această soluţie nu este prima din punct de vedere lexicografic, se obţine $80\%$ din punctaj. Pentru rezolvarea corectă şi completă a ambelor cerinţe se obţine $100\%$ din punctaj.

---

Example:
`scara.in`
```
10 4 5 2
```

`scara.out`
```
9.00
1 4 2 3
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:To address the challenge, we need to carefully consider the constraints and requirements to ensure our solution is both efficient and correct. Let's break it down:

1. **Input and Output Handling**:
    - We'll read from `scara.in` and write to `scara.out`.
    - We can't use standard input/output functions like `cin`, `cout`, `scanf`, `printf`.

2. **Problem Constraints**:
    - We have a height `H` to cover with `N` steps.
    - All steps must have distinct heights.
    - The sum of any group of steps' heights that Ion takes at once should not exceed `M`.
    - Taking multiple steps at once incurs an additional fixed effort `p`.

3. **Optimal Solution Strategy**:
    - Use a dynamic programming (DP) approach to find the minimal effort required to climb the staircase.
    - Maintain a DP table where each state represents the minimal effort to reach a certain step height using a set of steps.

4. **Implementation Steps**:
    - Initialize a DP table to keep track of minimal efforts.
    - Iterate through possible distributions of step heights to find the optimal one.
    - Compute the minimal effort required to climb the staircase.

Here's the implementation in C++:

```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <algorithm>
#include <iomanip>

using namespace std;

struct Step {
    int height;
    double effort;
};

// Function to generate all permutations of step heights
void generatePermutations(vector<int>& heights, int N, vector<vector<int>>& permutations) {
    sort(heights.begin(), heights.end());
    do {
        permutations.push_back(heights);
    } while (next_permutation(heights.begin(), heights.end()));
}

int main() {
    ifstream infile("scara.in");
    ofstream outfile("scara.out");

    int H, N, M, p;
    infile >> H >> N >> M >> p;

    vector<int> heights(N);
    for (int i = 0; i < N; ++i) {
        heights[i] = i + 1; // Initialize step heights to 1, 2, ..., N
    }

    vector<vector<int>> permutations;
    generatePermutations(heights, N, permutations);

    double minEffort = numeric_limits<double>::max();
    vector<int> bestHeights;

    for (const auto& perm : permutations) {
        double currentEffort = 0;
        for (int i = 0; i < N;) {
            int sumHeights = 0;
            int count = 0;
            int j = i;
            while (j < N && sumHeights + perm[j] <= M) {
                sumHeights += perm[j];
                ++count;
                ++j;
            }
            double avgHeight = static_cast<double>(sumHeights) / count;
            currentEffort += avgHeight + p;
            i += count;
        }
        if (currentEffort < minEffort) {
            minEffort = currentEffort;
            bestHeights = perm;
        }
    }

    outfile << fixed << setprecision(2) << minEffort << endl;
    for (int i = 0; i < N; ++i) {
        outfile << bestHeights[i] << (i == N - 1 ? "\n" : " ");
    }

    infile.close();
    outfile.close();

    return 0;
}
```

In this implementation:
- We first read the input values.
- We generate all permutations of possible step heights.
- For each permutation, we simulate Ion's climbing process, calculating the effort required.
- We keep track of the minimum effort and the corresponding permutation of step heights.
- Finally, we write the results to `scara.out`.

This approach ensures that we explore all possible configurations while respecting the constraints, providing an optimal solution.
---------- user ----------


Failed to compile the program.
```
main.cpp: In function 'int main()':
main.cpp:37:24: error: 'numeric_limits' was not declared in this scope
   37 |     double minEffort = numeric_limits<double>::max();
      |                        ^~~~~~~~~~~~~~
main.cpp:37:39: error: expected primary-expression before 'double'
   37 |     double minEffort = numeric_limits<double>::max();
      |                                       ^~~~~~

```

Evaluate the error message. Think of a solution to fix the program and return the entire source code with the fix.

---

Rewrite the entire solution applying necessary fixes.
