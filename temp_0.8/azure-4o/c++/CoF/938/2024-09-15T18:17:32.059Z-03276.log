---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `labirint.in` and write to `labirint.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Un labirint este descris ca fiind o matrice binară cu $N$ linii și $M$ coloane, cu semnificația că $0$ reprezintă o poziție liberă, iar $1$ reprezintă o poziție în care se află un zid. Un drum în labirint este un traseu în matrice care începe cu poziția $(1, 1)$ și ajunge în poziția $(N, M)$ prin deplasare doar pe poziții care au valoarea 0 și sunt vecine cu poziția curentă, pe una din cele patru direcții: sus, jos, stânga, dreapta. Lungimea unui drum este egală cu numărul de poziții vizitate.

Notăm cu $d_0$ lungimea drumului minim de la poziția $(1, 1)$ la poziția $(N, M)$. Fie $d(i, j)$ lungimea drumului minim de la poziția $(1, 1)$ la poziția $(N, M)$, dacă poziției $(i, j)$ i se atribuie valoarea $0$. Observăm că dacă poziția $(i, j)$ conține inițial un $0$, atunci $d_0 = d(i, j)$.


# Cerință


Pentru fiecare poziție $(i, j)$, să se verifice dacă $d(i, j) < d_0$.


# Date de intrare


Pe prima linie a fișierului `labirint.in` se află două numere naturale $N$ și $M$, dimensiunile matricei binare ce descrie labirintul, apoi pe următoarele $N$ linii se vor afla câte $M$ valori binare, ce reprezint˘a elementele matricei care descrie labirintul, neseparate prin spații.


# Date de ieșire


în fișierul `labirint.out` se vor scrie $N$ linii, iar pe fiecare linie se vor scrie $M$ cifre, neseparate prin spații. Cifra a $j$-a de pe linia a $i$-a este $1$ dacă și numai dacă $d(i, j) < d_0$, altfel este $0$.


# Restricții și precizări

* $1 \leq N, M \leq 1 \ 000$;
* Pe pozițiile $(1, 1)$ și $(N, M)$ se vor afla valori $0$.
* Se garantează că există un drum în matricea inițială între pozițiile $(1, 1)$ și $(N, M)$.


| # | Punctaj | Restricții          |
| - | ------- | ------------------- |
| 1 | 10      | $1 \leq N, M \leq 50$, $d_0 = N + M - 1$ |
| 2 | 30      | $1 \leq N, M \leq 50$      |
| 3 | 60      | Fără restricții suplimentare.      |

---

Example:
`labirint.in`
```
5 6
010001
000101
011001
010010
001000
```

`labirint.out`
```
010000
000100
001001
010010
001000
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:To solve this challenge, we need to implement an efficient algorithm that can quickly determine if changing a cell from 1 to 0 will produce a shorter path from the start (1,1) to the end (N,M) in a binary matrix representing a labyrinth. 

Here’s a step-by-step breakdown of the approach:

1. **Read Input File**: Parse the input file to get the dimensions of the labyrinth and the matrix itself.
2. **Shortest Path Calculation (BFS)**:
    - Use Breadth-First Search (BFS) to find the shortest path from (1,1) to (N,M) in the initial matrix. This will give us `d_0`.
    - Store the distances from (1,1) to each cell in a distance matrix `dist`.
3. **Evaluate Each Cell**:
    - For each cell (i, j) in the matrix, temporarily set the cell to 0 if it's not already 0.
    - Use BFS again to find the shortest path from (1,1) to (N,M) with this temporary change.
    - Compare this new path length `d(i, j)` with `d_0`.
    - If `d(i, j) < d_0`, mark the cell as 1 in the result matrix. Otherwise, mark it as 0.
4. **Write Output File**: Output the result matrix to the file `labirint.out`.

Here’s the implementation in C++:

```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <queue>
#include <climits>

using namespace std;

vector<vector<int>> directions {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

int bfs(vector<vector<int>>& grid, int startX, int startY, int endX, int endY) {
    int N = grid.size(), M = grid[0].size();
    vector<vector<int>> dist(N, vector<int>(M, INT_MAX));
    queue<pair<int, int>> q;
    q.push({startX, startY});
    dist[startX][startY] = 1;  // Start from 1 instead of 0 to count steps

    while (!q.empty()) {
        auto [x, y] = q.front();
        q.pop();

        for (const auto& dir : directions) {
            int nx = x + dir[0], ny = y + dir[1];
            if (nx >= 0 && nx < N && ny >= 0 && ny < M && grid[nx][ny] == 0 && dist[nx][ny] == INT_MAX) {
                dist[nx][ny] = dist[x][y] + 1;
                q.push({nx, ny});
                if (nx == endX && ny == endY) {
                    return dist[nx][ny];
                }
            }
        }
    }
    return INT_MAX;  // If no path exists
}

int main() {
    ifstream inFile("labirint.in");
    ofstream outFile("labirint.out");

    int N, M;
    inFile >> N >> M;

    vector<vector<int>> grid(N, vector<int>(M));
    for (int i = 0; i < N; ++i) {
        string line;
        inFile >> line;
        for (int j = 0; j < M; ++j) {
            grid[i][j] = line[j] - '0';
        }
    }

    // Calculate d0
    int d0 = bfs(grid, 0, 0, N - 1, M - 1);

    // Result grid
    vector<vector<int>> result(N, vector<int>(M, 0));

    // Check each cell
    for (int i = 0; i < N; ++i) {
        for (int j = 0; j < M; ++j) {
            if (grid[i][j] == 1) {
                grid[i][j] = 0; // Temporarily change to 0
                int di = bfs(grid, 0, 0, N - 1, M - 1);
                if (di < d0) {
                    result[i][j] = 1;
                }
                grid[i][j] = 1; // Change back
            }
        }
    }

    // Write output
    for (const auto& row : result) {
        for (const auto& value : row) {
            outFile << value;
        }
        outFile << '\n';
    }

    return 0;
}
```

### Explanation:
1. **Reading Input**: We read the labyrinth dimensions and the binary matrix from the file `labirint.in`.
2. **BFS Function**: The `bfs` function calculates the shortest path from `(startX, startY)` to `(endX, endY)`. It uses a queue for BFS and returns the shortest distance.
3. **Calculate `d_0`**: We calculate the initial shortest path from `(0,0)` to `(N-1,M-1)` and store it in `d_0`.
4. **Checking Each Cell**: For each cell that is a wall (`1`), we temporarily convert it to `0` and calculate the new shortest path. If the new path is shorter than `d_0`, we mark the cell in the result matrix.
5. **Output the Result**: Finally, we write the result matrix to the file `labirint.out`.
