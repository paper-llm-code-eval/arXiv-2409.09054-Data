---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `exponent.in` and write to `exponent.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Se dă un număr natural $n$ și o cifră $k$ din mulțimea $\{2, 3, 5, 7\}$.

# Cerință

Se cere să se afișeze exponentul lui $k$ în descompunerea în factori primi a produsului $1 \cdot 2 \cdot 3 \cdot \ldots \cdot n$.

# Date de intrare

Fișierul de intrare `exponent.in` conține pe prima linie $n$ și $k$.


# Date de ieșire

În fișierul de ieșire `exponent.out` se va scrie un singur număr natural, adică exponentul cerut de problemă.


# Restricții și precizări

* $1 \leq n \leq 100$;
* $k = \{2, 3, 5, 7\}$;

---

Example:
`exponent.in`
```
6 3
```

`exponent.out`
```
2
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:To solve the problem, we need to determine the exponent of a prime number \( k \) in the prime factorization of the factorial \( n! \). That requires counting how many times \( k \) appears as a factor in each integer from 1 to \( n \).

Given that:
- \( n \) is a natural number.
- \( k \) is one of the prime numbers in the set \(\{2, 3, 5, 7\}\).

The exponent of \( k \) in \( n! \) can be calculated using the formula:
\[ \text{exponent} = \left\lfloor \frac{n}{k} \right\rfloor + \left\lfloor \frac{n}{k^2} \right\rfloor + \left\lfloor \frac{n}{k^3} \right\rfloor + \cdots \]
This formula works because it counts all multiples of \( k \), \( k^2 \), \( k^3 \), etc., in the numbers from 1 to \( n \).

Now, let's write the C++ code to read from `exponent.in`, compute the required exponent, and write the result to `exponent.out`.

```cpp
#include <fstream>
#include <cmath>

int main() {
    std::ifstream infile("exponent.in");
    std::ofstream outfile("exponent.out");

    int n, k;
    infile >> n >> k;

    int exponent = 0;
    for (int i = k; i <= n; i *= k) {
        exponent += n / i;
    }

    outfile << exponent << std::endl;

    return 0;
}
```

### Explanation of the Code:
1. **Input Reading:**
   - We use `std::ifstream` to read the input from `exponent.in`. The input consists of two integers \( n \) and \( k \), which are read into the variables `n` and `k`.

2. **Exponent Calculation:**
   - We initialize `exponent` to 0.
   - We use a loop to iterate over powers of \( k \) (i.e., \( k, k^2, k^3, \ldots \)) as long as they are less than or equal to \( n \).
   - In each iteration, we add the integer division of \( n \) by the current power of \( k \) to `exponent`.
   - This loop effectively counts the multiples of \( k, k^2, k^3, \ldots \) in the range from 1 to \( n \).

3. **Output Writing:**
   - We use `std::ofstream` to write the computed `exponent` to `exponent.out`.

This approach is efficient and works well within the constraints provided (i.e., \( 1 \leq n \leq 100 \)). The code avoids unnecessary I/O operations and employs a direct mathematical approach to solving the problem, ensuring fast execution.
