---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `exponent.in` and write to `exponent.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Se dă un număr natural $n$ și o cifră $k$ din mulțimea $\{2, 3, 5, 7\}$.

# Cerință

Se cere să se afișeze exponentul lui $k$ în descompunerea în factori primi a produsului $1 \cdot 2 \cdot 3 \cdot \ldots \cdot n$.

# Date de intrare

Fișierul de intrare `exponent.in` conține pe prima linie $n$ și $k$.


# Date de ieșire

În fișierul de ieșire `exponent.out` se va scrie un singur număr natural, adică exponentul cerut de problemă.


# Restricții și precizări

* $1 \leq n \leq 100$;
* $k = \{2, 3, 5, 7\}$;

---

Example:
`exponent.in`
```
6 3
```

`exponent.out`
```
2
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:Sure, let's break down the approach to solve this problem efficiently.

## Plan
1. **Read Input**:
   - We'll read `n` and `k` from the file `exponent.in`.

2. **Calculate Exponent**:
   - To find the exponent of `k` in the prime factorization of the factorial of `n` (`n!`), we need to count how many times `k` is a factor in all numbers from `1` to `n`.
   - This can be achieved by counting multiples of `k`, `k^2`, `k^3`, ..., until `k^m` where `k^m > n`. The contribution of each power of `k` needs to be added to get the total exponent.

3. **Write Output**:
   - The result should be written to `exponent.out`.

## Example
For `n = 6` and `k = 3`:
- Factorial of `6` is `6! = 720`.
- Prime factorization of `720` is `2^4 * 3^2 * 5`.
- The exponent of `3` in `720` is `2`.

## Implementation
Here is the efficient C++ code to solve the problem:

```cpp
#include <fstream>

int main() {
    std::ifstream infile("exponent.in");
    std::ofstream outfile("exponent.out");

    int n, k;
    infile >> n >> k;

    int exponent = 0;
    for (int power = k; power <= n; power *= k) {
        exponent += n / power;
    }

    outfile << exponent;

    infile.close();
    outfile.close();
    return 0;
}
```

### Explanation
1. **Reading Input**:
   - Using `std::ifstream` to read from `exponent.in`.
   - Read integers `n` and `k`.

2. **Calculating Exponent**:
   - Initialize `exponent` to `0`.
   - Loop through powers of `k` (i.e., `k`, `k^2`, `k^3`, ...) and for each power, add the integer division of `n` by that power to `exponent`.

3. **Writing Output**:
   - Write the result to `exponent.out` using `std::ofstream`.

This approach ensures that the program runs efficiently even for the upper limit of `n = 100`. The time complexity is approximately `O(log_k(n))`, which is very efficient given the constraints.
