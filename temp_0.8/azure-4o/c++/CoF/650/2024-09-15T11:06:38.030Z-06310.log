---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `yinyang.in` and write to `yinyang.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Se dă o matrice $A$ cu $N$ linii și $M$ coloane, cu valori cuprinse între $1$ și $N \cdot M$ inclusiv, nu neapărat distincte. O **operație** constă în selectarea a două linii sau două coloane consecutive și interschimbarea acestora (swap). O matrice **yin-yang** este o matrice în care $A[i][j] \geq A[i][j – 1]$, pentru orice pereche $(i, j)$ cu $1 \leq i \leq N$ și $2 \leq j \leq M$ și $A[i][j] \geq A[i – 1][j]$, pentru orice pereche $(i, j)$ cu $2 \leq i \leq N$ și $1 \leq j \leq M$.

# Cerinţă

Să se determine numărul minim de operații necesare pentru a transforma matricea dată într-o matrice yin-yang.

# Date de intrare

În fișierul de intrare `yinyang.in` se află scrise pe prima linie numerele naturale $N$ și $M$, cu semnificația din enunț. Pe fiecare dintre următoarele $N$ linii se află câte $M$ numere naturale, reprezentând elementele matricei date $A$. Numerele aflate pe aceeași linie a fișierului sunt separate prin câte un spațiu.

# Date de ieșire

În fișierul `yinyang.out` se va scrie numărul minim de operații cerut sau $-1$ dacă nu există soluție.

# Restricții și precizări

* $1 \leq N, M \leq 100$;
* Pentru teste în valoare de $9$ puncte: $1 \leq N, M \leq 5$;
- Pentru alte teste în valoare de $18$ puncte: $N = 1$;
- Pentru alte teste în valoare de $36$ de puncte elementele din matrice sunt **DISTINCTE**.

---

Example:
`yinyang.in`
```
2 3
1 2 4
3 5 6
```

`yinyang.out`
```
0
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:Certainly! Let's break down the problem and devise a solution step-by-step.

### Problem Analysis
The goal is to transform a given matrix into a **yin-yang** matrix with the minimum number of operations. A matrix is considered **yin-yang** if:
1. Each element in a row is greater than or equal to the element to its left.
2. Each element in a column is greater than or equal to the element above it.

### Constraints and Observations
- The dimensions \( N \) and \( M \) of the matrix are at most 100.
- The values in the matrix are between 1 and \( N \times M \).
- The operations allowed are swapping consecutive rows or columns.

### Approach
1. **Sorting Rows and Columns**: The problem can be simplified by sorting the matrix. Since we are allowed to swap consecutive rows and columns, one way to approach this is to repeatedly swap until the matrix becomes sorted.
2. **Priority Queue or BFS**: A priority queue/BFS can be used to keep track of the minimum number of swaps required to sort the matrix.

### Steps
1. Read the matrix dimensions and elements from the file.
2. Implement a function to check if the matrix is yin-yang.
3. Use a BFS approach to explore all possible matrices formed by swapping consecutive rows or columns.
4. Track the minimum number of swaps needed to transform the matrix into a yin-yang matrix.
5. Output the result.

### Implementation in C++
Let's now write the code following the above approach.

```cpp
#include <fstream>
#include <vector>
#include <queue>
#include <algorithm>
#include <set>
#include <utility>

using namespace std;

bool isYinYang(const vector<vector<int>>& matrix, int N, int M) {
    for (int i = 0; i < N; ++i) {
        for (int j = 1; j < M; ++j) {
            if (matrix[i][j] < matrix[i][j-1]) return false;
        }
    }
    for (int j = 0; j < M; ++j) {
        for (int i = 1; i < N; ++i) {
            if (matrix[i][j] < matrix[i-1][j]) return false;
        }
    }
    return true;
}

string matrixToString(const vector<vector<int>>& matrix) {
    string result;
    for (const auto& row : matrix) {
        for (const auto& val : row) {
            result += to_string(val) + " ";
        }
    }
    return result;
}

int main() {
    ifstream inFile("yinyang.in");
    ofstream outFile("yinyang.out");

    int N, M;
    inFile >> N >> M;
    
    vector<vector<int>> matrix(N, vector<int>(M));
    for (int i = 0; i < N; ++i) {
        for (int j = 0; j < M; ++j) {
            inFile >> matrix[i][j];
        }
    }

    if (isYinYang(matrix, N, M)) {
        outFile << 0 << endl;
        return 0;
    }

    set<string> visited;
    queue<pair<vector<vector<int>>, int>> q;
    q.push({matrix, 0});
    visited.insert(matrixToString(matrix));

    while (!q.empty()) {
        auto [curMatrix, steps] = q.front();
        q.pop();

        for (int i = 0; i < N - 1; ++i) {
            swap(curMatrix[i], curMatrix[i + 1]);
            string matrixStr = matrixToString(curMatrix);
            if (visited.find(matrixStr) == visited.end()) {
                visited.insert(matrixStr);
                if (isYinYang(curMatrix, N, M)) {
                    outFile << steps + 1 << endl;
                    return 0;
                }
                q.push({curMatrix, steps + 1});
            }
            swap(curMatrix[i], curMatrix[i + 1]);
        }

        for (int j = 0; j < M - 1; ++j) {
            for (int i = 0; i < N; ++i) {
                swap(curMatrix[i][j], curMatrix[i][j + 1]);
            }
            string matrixStr = matrixToString(curMatrix);
            if (visited.find(matrixStr) == visited.end()) {
                visited.insert(matrixStr);
                if (isYinYang(curMatrix, N, M)) {
                    outFile << steps + 1 << endl;
                    return 0;
                }
                q.push({curMatrix, steps + 1});
            }
            for (int i = 0; i < N; ++i) {
                swap(curMatrix[i][j], curMatrix[i][j + 1]);
            }
        }
    }

    outFile << -1 << endl;
    return 0;
}
```

### Explanation
1. **Reading Input**: The matrix is read from `yinyang.in`.
2. **Checking Yin-Yang**: The function `isYinYang` checks if the current matrix satisfies the yin-yang conditions.
3. **Breadth-First Search**:
   - Start with the initial matrix.
   - Use a queue to explore all possible matrices formed by swapping rows or columns.
   - Track visited matrices to avoid redundant work.
   - If a matrix becomes yin-yang, output the number of steps taken.
4. **Output Result**: Write the result to `yinyang.out`.

This approach ensures that we explore the minimum number of operations needed efficiently.
