---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `tort.in` and write to `tort.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Un tort dreptunghiular de dimensiuni $M \cdot N$ trebuie împărţit în porţii pătrate de aceeaşi mărime.

# Cerință

Găsiţi numărul minim de porţii care se pot obţine şi dimensiunea $L$ a acestora. Atât dimensiunile dreptunghiului cât şi ale pătratelor în care se împarte sunt numere întregi.

# Date de intrare

Fişierul `tort.in` va conţine pe prima linie numerele $M$ şi $N$ separate printr-un spaţiu. 

# Date de ieșire

Fişierul `tort.out` va conţine pe o singură linie, două numere naturale separate printr-un spaţiu, primul fiind numărul minim de porţii, iar celălalt dimensiunea $L$.


# Restricții și precizări

* $1 \leq M, N \leq 10 \ 000$;

---

Example:
`tort.in`
```
20 24
```

`tort.out`
```
30 4
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:To solve the problem of splitting the rectangular cake into the minimum number of square portions, we need to find the largest square size \( L \) such that both dimensions \( M \) and \( N \) are divisible by \( L \). This \( L \) is the greatest common divisor (GCD) of \( M \) and \( N \). Once we have \( L \), the number of \( L \times L \) squares that can fill the entire \( M \times N \) rectangle is \((M \times N) / (L \times L)\).

Here is the complete C++ code implementation for this approach, which reads from "tort.in" and writes to "tort.out":

```cpp
#include <fstream>
#include <algorithm>
#include <numeric>

int main() {
    std::ifstream inFile("tort.in");
    std::ofstream outFile("tort.out");

    int M, N;
    inFile >> M >> N;

    // Calculate the greatest common divisor (GCD) of M and N
    int L = std::gcd(M, N);

    // Calculate the number of L x L squares needed
    int numSquares = (M * N) / (L * L);

    // Output the results
    outFile << numSquares << " " << L << std::endl;

    inFile.close();
    outFile.close();

    return 0;
}
```

### Explanation:
1. **Reading Input**:
   - The input file `tort.in` is read using `ifstream`.
   - We read the integer values of \( M \) and \( N \).

2. **Finding the Greatest Common Divisor (GCD)**:
   - We use the `std::gcd` function from the `<numeric>` header to find the GCD of \( M \) and \( N \). This GCD is the side length \( L \) of the largest square that can tile the given rectangle.

3. **Calculating the Number of Squares**:
   - The total number of \( L \times L \) squares required to cover the \( M \times N \) rectangle is computed as \((M \times N) / (L \times L)\).

4. **Writing Output**:
   - The results are written to the output file `tort.out` using `ofstream`.

### Complexity:
- Finding the GCD of two numbers is efficient (logarithmic complexity).
- The overall time complexity of the solution is \( O(\log(\min(M, N))) \), which is very efficient given the constraints \( 1 \leq M, N \leq 10,000 \).

This solution ensures fast execution and correct results for the given problem constraints.
