---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `tort.in` and write to `tort.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Un tort dreptunghiular de dimensiuni $M \cdot N$ trebuie împărţit în porţii pătrate de aceeaşi mărime.

# Cerință

Găsiţi numărul minim de porţii care se pot obţine şi dimensiunea $L$ a acestora. Atât dimensiunile dreptunghiului cât şi ale pătratelor în care se împarte sunt numere întregi.

# Date de intrare

Fişierul `tort.in` va conţine pe prima linie numerele $M$ şi $N$ separate printr-un spaţiu. 

# Date de ieșire

Fişierul `tort.out` va conţine pe o singură linie, două numere naturale separate printr-un spaţiu, primul fiind numărul minim de porţii, iar celălalt dimensiunea $L$.


# Restricții și precizări

* $1 \leq M, N \leq 10 \ 000$;

---

Example:
`tort.in`
```
20 24
```

`tort.out`
```
30 4
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:To achieve the most efficient solution for dividing a rectangular cake into the minimum number of square portions of equal size, we need to determine the greatest common divisor (GCD) of the dimensions \( M \) and \( N \). The GCD will provide us with the size \( L \) of the largest possible square that can be used to partition the rectangle.

Here's the logic:
1. **Find the GCD of \( M \) and \( N \)**: This will be the side length \( L \) of the maximum square that can divide both dimensions without leaving any remainder.
2. **Calculate the number of squares**: This is given by \((M \cdot N) / (L^2)\).

Given this plan, let's write the code in C++ to read from `tort.in`, compute the needed values, and write the results to `tort.out`. We will use file I/O operations to read and write data.

Here's the solution:

```cpp
#include <iostream>
#include <fstream>
#include <algorithm>

// Function to compute the greatest common divisor (GCD) using Euclidean algorithm
int gcd(int a, int b) {
    while (b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}

int main() {
    std::ifstream inFile("tort.in");
    std::ofstream outFile("tort.out");

    int M, N;
    inFile >> M >> N;

    // Calculate GCD of M and N
    int L = gcd(M, N);

    // Calculate the number of squares
    int numPortions = (M / L) * (N / L);

    // Write the result to the output file
    outFile << numPortions << " " << L << std::endl;

    inFile.close();
    outFile.close();

    return 0;
}
```

### Explanation:
1. **GCD Calculation**: The `gcd` function uses the Euclidean algorithm to compute the greatest common divisor of \( M \) and \( N \).
2. **Reading Input**: We open the input file `tort.in` and read the dimensions \( M \) and \( N \).
3. **Computing Size and Number of Squares**: With the GCD \( L \) calculated, the number of squares is computed by \((M / L) * (N / L)\).
4. **Writing Output**: We write the result in the required format to `tort.out`.

This solution is efficient and utilizes the properties of the Euclidean algorithm to ensure the fastest computation possible for the given constraints.
