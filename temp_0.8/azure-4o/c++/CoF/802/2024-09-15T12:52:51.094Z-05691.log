---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `secvente.in` and write to `secvente.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Mariei îi plac numerele prime și puterile numerelor prime. Pornind de la un număr prim $p$, ea construiește noi numere, fiecare număr construit fiind un produs de forma $p^y$ ($y \in ℕ$, $y \neq 0$) sau $q \cdot p^m$, $m \in ℕ$ și $q$ un număr prim, numindu-le numere $p$-prime. De exemplu, numerele $2, 3, 4, 5, 6, 7, 8, 10, 12, 13, 14, 16, 17 $sunt primele $13$ numere $2$-prime deoarece $2 = 2^1$, $3 = 3 \cdot 2^0$, $4 = 2^2$, $5 = 5 \cdot 2^0$, $6 = 3 \cdot 2^1$, $7 = 7 \cdot 2^0$, $8 = 2^3$, $10 = 5 \cdot 2^1$, $12 = 3 \cdot 2^2$, $13 = 13 \cdot 2^0$, $14 = 7 \cdot 2^1$, $16 = 2^4$, $17 = 17 \cdot 2^0$.

Într-o zi Maria a găsit o foaie de hârtie, pe care era scris un șir format din $n$ numere naturale nenule. Cum pe lângă numerele $p$-prime ea este pasionată și de secvențe, și-a pus următoarea întrebare: câte secvențe sunt pe foaie cu următoarele proprietăți:

* conțin exact $k$ numere $p$-prime;
* încep și se termină cu un număr $p$-prim.

În plus, Maria dorește să știe care este poziția de început și cea de final, pentru fiecare secvență descoperită, relative la șirul scris pe foaia de hârtie.

# Cerință

Scrieți un program care să citească mai multe seturi de date, fiecare set fiind format din numerele $n, p, k$, cu semnificațiile din enunț, și șirul cu $n$ elemente $a_1, a_2, a_3, \dots, a_n$, numerele Mariei. Programul va determina pentru fiecare set de date numărul secvențelor ce conțin exact $k$ numere $p$-prime, precum și pozițiile de început și de final ale acestor secvențe în șirul din set.

# Date de intrare

Pe prima linie a fișierului `secvente.in` se află numărul $D$ reprezentând numărul de seturi de date din fișier. Seturile de date sunt scrise în fișier pe linii succesive. Pentru fiecare set de date, prima linie conține câte trei numere naturale: $n$ (numărul de elemente de pe foaie), $p$ și $k$ (cu semnificația din enunț), separate prin câte un spațiu, iar fiecare dintre următoarele $n$ linii conține câte un număr natural al șirului $a_1, a_2, a_3, \dots, a_n$, numerele din șirul Mariei.

# Date de ieșire

Fișierul `secvente.out` va conține $D$ soluții corespunzătoare celor $D$ seturi de date. Pentru fiecare soluție prima linie va conține un număr $x$ reprezentând numărul de secvențe ce îndeplinesc proprietățile cerute, iar fiecare dintre următoarele $x$ linii vor conține câte $2$ numere naturale, separate printr-un spațiu, reprezentând poziția de început, respectiv de final a fiecărei secvențe, linii ordonate crescător după poziția de început. Dacă în șir nu există o astfel de secvență, prima linie a setului va conține valoarea $0$.

# Restricții și precizări

* $1 \leq D \leq 15$;
* $1 \leq k, n \leq 15 \ 000$;
* $2 \leq p \leq 30 \ 000$; $p$ este un număr natural prim
* $1 \leq a_1, a_2, a_3, \dots, a_n \leq 30 \ 000$; $a_1, a_2, a_3, \dots, a_n \in ℕ$
* Pozițiile din șir sunt numerotate de la 1.
* Numărul $1$ nu este $p$-prim.
* O secvență dintr-un șir este formată din elemente aflate pe poziții consecutive în șirul dat.

---

Example:
`secvente.in`
```
2
5 3 2
7
27
4
45
1
3 5 7
3
4
5
```

`secvente.out`
```
2
1 2
2 4
0
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```cpp
#include <fstream>
#include <vector>
#include <cmath>

inline bool is_p_prime(int num, int p, const std::vector<bool>& prime_check) {
    if (num == p) return true;
    if (num % p == 0) {
        while (num % p == 0) {
            num /= p;
        }
        return prime_check[num];
    }
    return prime_check[num];
}

int main() {
    std::ifstream fin("secvente.in");
    std::ofstream fout("secvente.out");

    int D;
    fin >> D;

    for (int d = 0; d < D; ++d) {
        int n, p, k;
        fin >> n >> p >> k;

        std::vector<int> a(n);
        for (int i = 0; i < n; ++i) {
            fin >> a[i];
        }

        std::vector<bool> is_prime(30001, true);
        is_prime[0] = is_prime[1] = false;
        for (int i = 2; i <= 30000; ++i) {
            if (is_prime[i]) {
                for (int j = i * 2; j <= 30000; j += i) {
                    is_prime[j] = false;
                }
            }
        }

        std::vector<int> p_prime_indices;

        for (int i = 0; i < n; ++i) {
            if (is_p_prime(a[i], p, is_prime)) {
                p_prime_indices.push_back(i);
            }
        }

        int count = 0;
        std::vector<std::pair<int, int>> sequences;

        for (int i = 0; i <= p_prime_indices.size() - k; ++i) {
            int start = p_prime_indices[i];
            int end = p_prime_indices[i + k - 1];
            sequences.push_back({start + 1, end + 1});
            count++;
        }

        fout << count << '\n';
        for (const auto& seq : sequences) {
            fout << seq.first << ' ' << seq.second << '\n';
        }
    }

    fin.close();
    fout.close();

    return 0;
}
```

Explanation:

1. **Input Reading**: The program reads the number of datasets `D` and then enters a loop to process each dataset.
2. **Prime Check Preparation**: A sieve of Eratosthenes is used to prepare a boolean array `is_prime` for quick prime checking up to 30000.
3. **Reading Each Dataset**: For each dataset, the program reads `n`, `p`, and `k`. It then reads the sequence of `n` numbers.
4. **Identifying p-prime Numbers**: The program identifies numbers in the sequence that are `p-prime` using the function `is_p_prime()`.
5. **Finding Valid Sequences**: It finds all valid sequences that start and end with `p-prime` numbers and contain exactly `k` `p-prime` numbers.
6. **Output Writing**: The results are written to the output file in the specified format.

This solution is efficient and ensures that input/output operations are handled optimally for large input sizes.
---------- user ----------


Program exited with code 139.
stdout:
```

```
stderr:
```

```

Think of what has caused the exit code. Use the standard out and standard error to help you understand the issue.
Implement a solution to fix the program

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The exit code 139 typically indicates a segmentation fault, which often occurs due to invalid memory access. In the given solution, there are a few potential pitfalls:
1. **Array bounds violation**: If `p_prime_indices.size() < k`, accessing `p_prime_indices[i + k - 1]` will cause an out-of-bounds access.
2. **Memory use**: The memory requirements of the sieve and other operations may be too high if not handled properly.

Let's carefully address these issues and reimplement the solution.

```cpp
#include <fstream>
#include <vector>
#include <cmath>

inline bool is_p_prime(int num, int p, const std::vector<bool>& prime_check) {
    if (num == p) return true;
    if (num % p == 0) {
        int original_num = num;
        while (num % p == 0) {
            num /= p;
        }
        if (num == 1) return true; // It is a power of p
        return prime_check[num];
    }
    return prime_check[num];
}

int main() {
    std::ifstream fin("secvente.in");
    std::ofstream fout("secvente.out");

    int D;
    fin >> D;

    // Sieve of Eratosthenes to determine prime numbers up to 30000
    std::vector<bool> is_prime(30001, true);
    is_prime[0] = is_prime[1] = false;
    for (int i = 2; i <= 30000; ++i) {
        if (is_prime[i]) {
            for (int j = i * 2; j <= 30000; j += i) {
                is_prime[j] = false;
            }
        }
    }

    for (int d = 0; d < D; ++d) {
        int n, p, k;
        fin >> n >> p >> k;

        std::vector<int> a(n);
        for (int i = 0; i < n; ++i) {
            fin >> a[i];
        }

        std::vector<int> p_prime_indices;

        // Identify indices of p-prime numbers in the sequence
        for (int i = 0; i < n; ++i) {
            if (is_p_prime(a[i], p, is_prime)) {
                p_prime_indices.push_back(i);
            }
        }

        int count = 0;
        std::vector<std::pair<int, int>> sequences;

        // Find all valid sequences with exactly k p-prime numbers
        int len = p_prime_indices.size();
        for (int i = 0; i <= len - k; ++i) {
            int start = p_prime_indices[i];
            int end = p_prime_indices[i + k - 1];
            sequences.push_back({start + 1, end + 1});
            count++;
        }

        fout << count << '\n';
        for (const auto& seq : sequences) {
            fout << seq.first << ' ' << seq.second << '\n';
        }
    }

    fin.close();
    fout.close();

    return 0;
}
```

Fixes applied:
1. **Sieve Precomputation**: The sieve computation is moved out of the dataset loop to avoid redundant calculations and reduce memory usage.
2. **Bounds Checking**: Added a check to ensure that `p_prime_indices.size() >= k` before accessing indices to prevent out-of-bounds errors.
3. **Corrected p-prime Checking**: Improved the `is_p_prime` function to correctly handle the case where a number is simply a power of `p`.

This should resolve the segmentation fault and ensure the program runs as expected.
