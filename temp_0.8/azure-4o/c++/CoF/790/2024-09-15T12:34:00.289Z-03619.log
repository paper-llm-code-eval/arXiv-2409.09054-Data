---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `235.in` and write to `235.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Definim o putere a lui $3$ un număr de forma $3^k$, ($k$ număr natural strict pozitiv), o putere a lui $5$ un număr de forma $5^k$ (k număr natural strict pozitiv), iar o putere a lui $2$ un număr de forma $2^k$ ($k$ număr natural strict pozitiv).
Se dă un șir de $n$ numere naturale. Plecând de la acest șir, formăm un nou șir prin eliminarea tuturor numerele care nu sunt puteri ale lui $3$ și nici puteri ale lui $5$. Ordinea relativă între numerele care nu sunt eliminate se păstrează.

# Cerințe

- Să se determine câte numere conține șirul nou format.
- Să se determine de asemenea numărul de secvențe având lungimea egală cu o putere a lui $2$ existente în șirul nou format în care numărul de puteri ale lui $3$ este egal cu numărul de puteri ale lui $5$. O secvență este formată din elemente aflate pe poziții consecutive în acest șir nou format, iar lungimea unei secvențe este egală cu numărul de elemente pe care aceasta îl conține.

# Date de intrare

Pe prima linie in fișierul `235.in` se afla un număr natural $n$. Pe fiecare dintre următoarele $n$ linii câte un număr natural mai mare decât $1$ reprezentând numerele șirului inițial.

# Date de ieșire

Pe prima linie a fișierului `235.out` se va afla o valoare naturală $m$ care va reprezenta numărul de elemente rămase în șir după eliminare. Pe a doua linie se va afla o valoare naturală $S$ reprezentând numărul de secvențe din șirul nou format care au proprietățile cerute.

# Restricții și precizări

* $2 \leq n \leq 500 \ 000$;
* Numerele din șirul inițial sunt numere naturale din intervalul [$2, 2 \cdot 10^9$].
* Se garantează că $m \leq 40 \ 000$; pentru fiecare set de date de intrare.
* Pentru determinarea corectă a valorii numărului $m$ se acordă $30$% din punctaj iar pentru determinarea corectă a ambelor valori ($m$ şi $s$) se acordă $100$% din punctaj.

---

Example:
`235.in`
```
8
625
125
5
9
15
81
100
125
```

`235.out`
```
6
4
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:Here's a step-by-step explanation of the approach for solving this problem, followed by the C++ implementation:

1. **Filter the Sequence:**
   - First, we need to filter out the numbers from the input sequence that are not powers of 3 or 5.
   - To determine if a number is a power of 3 or 5, we can keep dividing the number by 3 or 5 until the result is 1 (confirming it is a power) or it is not divisible by 3 or 5 anymore (confirming it is not a power).

2. **Count Valid Sequences:**
   - We need to count the number of sequences of lengths that are powers of 2 where the count of powers of 3 equals the count of powers of 5.
   - We can precompute the valid lengths (powers of 2) and then use a sliding window approach to check all possible subsequences of these lengths.

3. **Efficient Reading and Writing:**
   - Since we are restricted from using standard I/O functions like `cin`, `cout`, etc., we will use file streams to read from `235.in` and write to `235.out`.

Here's a direct implementation in C++:

```cpp
#include <fstream>
#include <vector>
#include <cmath>
#include <unordered_set>

bool isPowerOf(int number, int base) {
    while (number > 1) {
        if (number % base != 0) return false;
        number /= base;
    }
    return number == 1;
}

int main() {
    std::ifstream input("235.in");
    std::ofstream output("235.out");

    int n;
    input >> n;

    std::vector<int> filtered;
    filtered.reserve(n);

    for (int i = 0; i < n; ++i) {
        int number;
        input >> number;
        if (isPowerOf(number, 3) || isPowerOf(number, 5)) {
            filtered.push_back(number);
        }
    }

    int m = filtered.size();
    output << m << "\n";

    std::vector<int> powerOf2;
    for (int i = 1; i <= m; i *= 2) {
        powerOf2.push_back(i);
    }

    int S = 0;
    std::vector<int> count3(m + 1, 0), count5(m + 1, 0);

    for (int i = 0; i < m; ++i) {
        count3[i + 1] = count3[i] + (isPowerOf(filtered[i], 3) ? 1 : 0);
        count5[i + 1] = count5[i] + (isPowerOf(filtered[i], 5) ? 1 : 0);
    }

    for (int len : powerOf2) {
        for (int i = 0; i + len <= m; ++i) {
            int c3 = count3[i + len] - count3[i];
            int c5 = count5[i + len] - count5[i];
            if (c3 == c5) {
                S++;
            }
        }
    }

    output << S << "\n";

    return 0;
}
```

### Explanation

1. **Filter the Sequence:**
   - We read the input numbers and filter out the ones that are not powers of 3 or 5 using the `isPowerOf` function.
2. **Count Valid Sequences:**
   - We count the occurrences of powers of 3 and 5 in prefixes of the filtered list.
   - We iterate over all valid lengths (powers of 2) and employ a sliding window to check subsequences.
3. **Efficient Reading and Writing:**
   - We use file streams for reading from `235.in` and writing to `235.out`.

This approach ensures efficient processing and handles the constraints effectively.
