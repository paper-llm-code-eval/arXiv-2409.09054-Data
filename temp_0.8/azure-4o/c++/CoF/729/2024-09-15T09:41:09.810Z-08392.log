---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `siruri.in` and write to `siruri.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Se consideră un vector unidimensional $x$ cu $n$ componente numere naturale distincte, cel mult egale cu $32 \ 000$.

# Cerință

Scrieți un program care să construiască vectorul $y$ cu elemente din mulțimea $\{1, 2, \dots, n\}$ astfel încât oricare ar fi numerele naturale $i, j$ cu proprietatea că $1 \leq i \leq n$, $1 \leq j \leq n$ și $x_i < x_j$ să avem $y_i < y_j$.

# Date de intrare

Fișierul de intrare `siruri.in` va conține:

* pe prima linie numărul $n$
* pe linia a doua componentele vectorului $x$ separate prin câte un spațiu

# Date de ieșire

Fișierul de ieșire `siruri.out` va conține pe prima linie componentele vectorului $y$ separate prin câte un spațiu.

# Restricții și precizări

* $1 \leq n \leq 100$;
* Componentele vectorului x sunt numere naturale cel mult egale cu $32 \ 000$.

---

Example:
`siruri.in`
```
6
12 3 7 16 10 1
```

`siruri.out`
```
5 2 3 6 4 1
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:To solve this problem, we need to map each element of the vector \( x \) to its rank in an increasing order, yielding vector \( y \). Here’s a step-by-step explanation and the corresponding C++ code to solve the problem efficiently:

1. **Read Input from File**:
   - Read the number of elements \( n \).
   - Read the elements of vector \( x \).

2. **Create a Vector of Pairs**:
   - Store each element along with its original index.

3. **Sort the Vector of Pairs**:
   - Sort based on the values of the elements.

4. **Assign Ranks**:
   - Traverse the sorted vector and assign ranks based on the position in the sorted order.

5. **Write Output to File**:
   - Write the ranks to the output file.

Here's the C++ code implementing this approach:

```cpp
#include <fstream>
#include <vector>
#include <algorithm>

int main() {
    std::ifstream infile("siruri.in");
    std::ofstream outfile("siruri.out");

    int n;
    infile >> n;
    
    std::vector<std::pair<int, int>> x(n);
    for (int i = 0; i < n; ++i) {
        infile >> x[i].first;
        x[i].second = i;
    }

    std::sort(x.begin(), x.end());

    std::vector<int> y(n);
    for (int i = 0; i < n; ++i) {
        y[x[i].second] = i + 1;
    }

    for (int i = 0; i < n; ++i) {
        outfile << y[i] << " ";
    }
    
    return 0;
}
```

### Explanation of the Code:

1. **Reading Input**:
   - Open the input file `siruri.in` and read the number of elements \( n \).
   - Read the elements of the array \( x \) and store them along with their original indices in a vector of pairs.

2. **Sorting**:
   - Sort the vector of pairs based on the element values. The `std::sort` function sorts the pairs primarily by the first element (the value of \( x \)).

3. **Assigning Ranks**:
   - After sorting, assign ranks based on the sorted position. The rank of the element is given by its position in the sorted array plus one.

4. **Writing Output**:
   - Open the output file `siruri.out` and write the ranks, ensuring each rank is separated by a space.

This solution is efficient with a time complexity of \( O(n \log n) \) due to the sorting step, which is suitable given the constraint \( n \leq 100 \).
