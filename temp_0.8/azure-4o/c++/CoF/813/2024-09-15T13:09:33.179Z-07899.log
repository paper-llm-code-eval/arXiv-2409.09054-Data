---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `adunscad.in` and write to `adunscad.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Considerăm un număr întreg $N$ și un șir de $M$ cifre zecimale nenule. Să se determine dacă numărul $N$ poate fi rezultatul unei expresii aritmetice simple (fără paranteze), formată exclusiv din cifrele șirului citit și din operatorii aritmetici desemnați pentru operațiile de adunare și scădere ($+, -$).

# Cerință

Scrieți un program care citește numerele $N$ și $M$ de pe prima linie a fișierului de intrare și șirul de $M$ cifre de pe linia următoare și determină și afișează expresia găsită sau valoarea 0 în cazul în care nu există soluție.

# Date de intrare

Fișierul de intrare `adunscad.in` conține pe prima linie numerele întregi $N \ M$, separate printr-un spațiu, reprezentând valoarea ce trebuie obținută la evaluarea expresiei și numărul de cifre din șir. Linia a doua a fișierului de intrare conține șirul celor $M$ cifre nenule, separate prin câte un spațiu.

# Date de ieșire

În fișierul de ieșire `adunscad.out` va conține pe prima linie expresia determinată, în cazul în care există soluție, sau valoarea $0$ în cazul în care nu există soluție.

# Restricții și precizări

* $-180 \leq N \leq 180$;
* $2 \leq M \leq 20$;
* În șirul citit cifrele se pot repeta.
* Toate cifrele din șir trebuie să apară și în expresia aritmetică, în aceeași ordine în care au fost citite.
* În expresia aritmetică, orice cifră trebuie să fie precedată de un operator; în cazul în care prima cifră este precedată de operatorul + acesta nu se pune în expresie. În expresia aritmetică nu există spații.
* În cazul în care soluția nu este unică se va afișa o soluție corectă.

---

Example:
`adunscad.in`
```
21 4
3 9 1 8
```

`adunscad.out`
```
3+9+1+8
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:The challenge requires us to determine if we can form a given number \( N \) using the provided sequence of digits with the operations of addition and subtraction without rearranging the digits. We'll use a backtracking approach to explore all possible combinations of adding or subtracting the digits from the sequence and check if any of these expressions result in \( N \).

Here is the solution in C++:

```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <string>

int N, M;
std::vector<int> digits;
std::string result;

// Helper function to perform the backtracking
bool findExpression(int index, int currentSum, std::string expression) {
    if (index == M) {
        if (currentSum == N) {
            result = expression;
            return true;
        }
        return false;
    }
    
    // Try adding the next digit
    if (findExpression(index + 1, currentSum + digits[index], expression + "+" + std::to_string(digits[index]))) {
        return true;
    }
    
    // Try subtracting the next digit
    if (findExpression(index + 1, currentSum - digits[index], expression + "-" + std::to_string(digits[index]))) {
        return true;
    }
    
    return false;
}

int main() {
    std::ifstream infile("adunscad.in");
    std::ofstream outfile("adunscad.out");

    infile >> N >> M;
    digits.resize(M);
    
    for (int i = 0; i < M; ++i) {
        infile >> digits[i];
    }
    
    // Initialize the result string with the first digit
    if (findExpression(1, digits[0], std::to_string(digits[0]))) {
        outfile << result << std::endl;
    } else {
        outfile << "0" << std::endl;
    }

    infile.close();
    outfile.close();
    
    return 0;
}
```

### Explanation
1. **Reading Input:** We read the integers \( N \) and \( M \), followed by reading the sequence of digits.
2. **Backtracking Function:** The `findExpression` function attempts to form the number \( N \) starting from the first digit and trying all possible combinations of adding or subtracting the next digits.
   - If `index` reaches `M`, it means we have considered all digits, and we check if the current sum equals \( N \).
   - If the current sum equals \( N \), we save the expression and return `true`.
3. **Initial Call:** We start with the first digit as the initial value of the expression and current sum.
4. **Output Result:** If a valid expression is found, it is written to `adunscad.out`. If no valid expression is found, we write `0`.

This approach ensures that we explore all possible ways to form \( N \) using the given sequence of digits with addition and subtraction, and it terminates early if a valid expression is found. The constraints are small enough to allow this brute-force method to run efficiently.
---------- user ----------


Program result did not match expected result.
Input data:
```
-1 4
1 2 3 5
```
Expected output:
```
-1+2+3-5
```
Found output:
```
0
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The discrepancy between the expected and found result arises because the current algorithm does not handle the initial negative value correctly. The algorithm starts with the first digit as part of the initial expression and does not consider starting with a subtraction of the first digit, which is necessary in this case to reach the solution.

Here's a revised solution that handles the case where the first digit might need to be subtracted right at the beginning:

```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <string>

int N, M;
std::vector<int> digits;
std::string result;

// Helper function to perform the backtracking
bool findExpression(int index, int currentSum, std::string expression) {
    if (index == M) {
        if (currentSum == N) {
            result = expression;
            return true;
        }
        return false;
    }
    
    // Try adding the next digit
    if (findExpression(index + 1, currentSum + digits[index], expression + "+" + std::to_string(digits[index]))) {
        return true;
    }
    
    // Try subtracting the next digit
    if (findExpression(index + 1, currentSum - digits[index], expression + "-" + std::to_string(digits[index]))) {
        return true;
    }
    
    return false;
}

int main() {
    std::ifstream infile("adunscad.in");
    std::ofstream outfile("adunscad.out");

    infile >> N >> M;
    digits.resize(M);
    
    for (int i = 0; i < M; ++i) {
        infile >> digits[i];
    }
    
    // Initialize the result string with the first digit as positive
    if (findExpression(1, digits[0], std::to_string(digits[0]))) {
        outfile << result << std::endl;
    }
    // Initialize the result string with the first digit as negative
    else if (findExpression(1, -digits[0], "-" + std::to_string(digits[0]))) {
        outfile << result << std::endl;
    }
    else {
        outfile << "0" << std::endl;
    }

    infile.close();
    outfile.close();
    
    return 0;
}
```

### Explanation
1. **Reading Input:** We read the integers \( N \) and \( M \), followed by reading the sequence of digits.
2. **Backtracking Function:** The `findExpression` function attempts to form the number \( N \) starting from the first digit and trying all possible combinations of adding or subtracting the next digits.
   - If `index` reaches `M`, it means we have considered all digits, and we check if the current sum equals \( N \).
   - If the current sum equals \( N \), we save the expression and return `true`.
3. **Initial Call:** We start with the first digit as the initial value of the expression and current sum. We now also handle the case where the first digit must be subtracted.
   - First, call `findExpression` starting with the first digit as positive.
   - If that fails, call `findExpression` starting with the first digit as negative.
4. **Output Result:** If a valid expression is found, it is written to `adunscad.out`. If no valid expression is found, we write `0`.

This updated approach ensures that we consider both possible initial states (positive and negative first digit), which should correctly handle cases where the target number is negative or requires starting with a subtraction.
