---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `control.in` and write to `control.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Gigel a primit spre păstrare un set de $n$ cutii de greutăți nu neapărat distincte. El a cântărit cutiile și pentru fiecare greutate distinctă a notat pe o foaie, în ordine crescătoare a greutăților, numărul de cutii cu greutatea respectivă.

Deoarece fratele său mai mic avea prostul obicei să se joace cu numerele scrise de el pe foaie, Gigel s-a gândit să calculeze un „număr de control” după următorul algoritm: începând de la primul număr a grupat numerele de apariții ale greutăților câte trei (dacă îi rămân numere negrupate la sfârșit, le ignoră). Dacă într-un grup sunt numai numere pare sau numai impare notează grupul cu cifra $1$, altfel îl notează cu cifra $0$. Din șirul astfel obținut, se formează un număr care are ca valoare cifra zecilor egală cu numărul de valori $1$ și cifra unităților egală cu numărul de valori $0$, obținându-se astfel „numărul de control”.

# Cerință

Citind greutățile cutiilor, să se determine „numărul de control” și să se verifice dacă este număr prim.

# Date de intrare

De pe prima linie a fișierului de intrare `control.in` se citește numărul $n$. Pe fiecare dintre următoarele $n$ linii se găsește câte un număr natural reprezentând greutățile celor n cutii.

# Date de ieșire

În fișierul de ieșire `control.out` se va scrie pe prima linie „numărul de control”, urmat, pe linia a doua, de valoarea $0$ sau $1$. Pe linia a doua se va afișa $1$ dacă numărul este prim, respectiv $0$ în caz contrar.

# Restricții și precizări

* $1 \leq n \leq 100$;
* Fiecare greutate este un număr natural, mai mic sau egal cu $200$

---

Example:
`control.in`
```
21
1
3
2
6
2
6
2
8
9
8
8
9
10
8
11
18
11
12
14
15
17
```

`control.out`
```
31
1
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:To tackle the problem, we will follow these steps:

1. **Read Input:** Read the number of weights and the weights themselves from the `control.in` file.
2. **Count Frequencies:** Calculate the frequency of each distinct weight.
3. **Group Frequencies:** Group these frequencies in sets of three.
4. **Determine Group Type:** For each group, determine if all numbers are either even or odd. If so, mark the group with a `1`, otherwise mark it with a `0`.
5. **Form Control Number:** Form a control number where the tens digit is the count of `1`s and the units digit is the count of `0`s.
6. **Check for Primality:** Determine if the control number is a prime number.
7. **Write Output:** Write the control number and whether it is prime to the `control.out` file.

Here is the C++ solution:

```cpp
#include <fstream>
#include <vector>
#include <map>
#include <algorithm>

// Function to check if a number is prime
bool isPrime(int num) {
    if (num <= 1) return false;
    if (num <= 3) return true;
    if (num % 2 == 0 || num % 3 == 0) return false;
    for (int i = 5; i * i <= num; i += 6) {
        if (num % i == 0 || num % (i + 2) == 0) return false;
    }
    return true;
}

int main() {
    // Open input and output files
    std::ifstream inFile("control.in");
    std::ofstream outFile("control.out");

    // Read number of weights
    int n;
    inFile >> n;

    // Read weights and calculate frequencies
    std::map<int, int> frequency;
    for (int i = 0; i < n; ++i) {
        int weight;
        inFile >> weight;
        ++frequency[weight];
    }

    // Extract frequencies into a vector
    std::vector<int> freqValues;
    for (const auto& pair : frequency) {
        freqValues.push_back(pair.second);
    }

    // Determine the control number
    int count1 = 0, count0 = 0;
    for (size_t i = 0; i + 2 < freqValues.size(); i += 3) {
        bool even = (freqValues[i] % 2 == 0) && (freqValues[i + 1] % 2 == 0) && (freqValues[i + 2] % 2 == 0);
        bool odd = (freqValues[i] % 2 != 0) && (freqValues[i + 1] % 2 != 0) && (freqValues[i + 2] % 2 != 0);
        if (even || odd) {
            ++count1;
        } else {
            ++count0;
        }
    }

    // Form the control number
    int controlNumber = count1 * 10 + count0;

    // Check if the control number is prime
    bool prime = isPrime(controlNumber);

    // Write results to output file
    outFile << controlNumber << "\n" << (prime ? 1 : 0) << "\n";

    // Close files
    inFile.close();
    outFile.close();

    return 0;
}
```

### Explanation:

1. **Reading Input:** We use an `ifstream` to read from `control.in` and read `n` weights.
2. **Counting Frequencies:** We store each weight's frequency in a `map<int, int>`.
3. **Extracting Frequencies:** We transfer the frequency counts to a `vector<int>`.
4. **Grouping and Analyzing:** We iterate over the frequency vector in groups of three, checking if all numbers in the group are even or odd to determine if we append `1` or `0` to our control number.
5. **Forming Control Number:** Calculate the control number and check if it is a prime number.
6. **Writing Output:** We use an `ofstream` to write the control number and the primality result to `control.out`.

### Example Verification:
For the provided example, the algorithm calculates the control number as `31` and correctly identifies it as a prime number, which matches the expected output of `31` and `1`.
