---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `control.in` and write to `control.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Gigel a primit spre păstrare un set de $n$ cutii de greutăți nu neapărat distincte. El a cântărit cutiile și pentru fiecare greutate distinctă a notat pe o foaie, în ordine crescătoare a greutăților, numărul de cutii cu greutatea respectivă.

Deoarece fratele său mai mic avea prostul obicei să se joace cu numerele scrise de el pe foaie, Gigel s-a gândit să calculeze un „număr de control” după următorul algoritm: începând de la primul număr a grupat numerele de apariții ale greutăților câte trei (dacă îi rămân numere negrupate la sfârșit, le ignoră). Dacă într-un grup sunt numai numere pare sau numai impare notează grupul cu cifra $1$, altfel îl notează cu cifra $0$. Din șirul astfel obținut, se formează un număr care are ca valoare cifra zecilor egală cu numărul de valori $1$ și cifra unităților egală cu numărul de valori $0$, obținându-se astfel „numărul de control”.

# Cerință

Citind greutățile cutiilor, să se determine „numărul de control” și să se verifice dacă este număr prim.

# Date de intrare

De pe prima linie a fișierului de intrare `control.in` se citește numărul $n$. Pe fiecare dintre următoarele $n$ linii se găsește câte un număr natural reprezentând greutățile celor n cutii.

# Date de ieșire

În fișierul de ieșire `control.out` se va scrie pe prima linie „numărul de control”, urmat, pe linia a doua, de valoarea $0$ sau $1$. Pe linia a doua se va afișa $1$ dacă numărul este prim, respectiv $0$ în caz contrar.

# Restricții și precizări

* $1 \leq n \leq 100$;
* Fiecare greutate este un număr natural, mai mic sau egal cu $200$

---

Example:
`control.in`
```
21
1
3
2
6
2
6
2
8
9
8
8
9
10
8
11
18
11
12
14
15
17
```

`control.out`
```
31
1
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:Here's the step-by-step breakdown of the solution:

1. **Input Reading**: We'll read the input from the file `control.in`. First, we'll read the number of weights `n`, followed by the actual weights.
2. **Count Frequencies**: We'll use a `std::map` to count the frequency of each distinct weight.
3. **Processing Groups**: We'll process the counts in groups of three, determining if each group contains all odd, all even, or mixed numbers.
4. **Form the Control Number**: Using the processed group results, we'll form a number. The tens digit will be the count of groups with all odds or all evens (`1`s), and the units digit will be the count of mixed groups (`0`s).
5. **Prime Check**: We'll implement a function to check if the control number is prime.
6. **Output the Result**: Finally, we'll write the control number and whether it's prime to the file `control.out`.

Now, let's write the C++ code that performs these steps:

```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <map>
#include <cmath>

bool is_prime(int num) {
    if (num <= 1) return false;
    if (num <= 3) return true;

    if (num % 2 == 0 || num % 3 == 0) return false;
    for (int i = 5; i * i <= num; i += 6) {
        if (num % i == 0 || num % (i + 2) == 0) return false;
    }
    return true;
}

int main() {
    std::ifstream infile("control.in");
    std::ofstream outfile("control.out");

    int n;
    infile >> n;
    std::vector<int> weights(n);
    for (int i = 0; i < n; ++i) {
        infile >> weights[i];
    }

    std::map<int, int> freq;
    for (int w : weights) {
        freq[w]++;
    }

    std::vector<int> counts;
    for (const auto& pair : freq) {
        counts.push_back(pair.second);
    }

    int count_1 = 0, count_0 = 0;
    int group_size = 3;
    for (size_t i = 0; i + group_size <= counts.size(); i += group_size) {
        bool all_even = true, all_odd = true;
        for (int j = 0; j < group_size; ++j) {
            if (counts[i + j] % 2 == 0) {
                all_odd = false;
            } else {
                all_even = false;
            }
        }
        if (all_even || all_odd) {
            count_1++;
        } else {
            count_0++;
        }
    }

    int control_number = count_1 * 10 + count_0;
    outfile << control_number << '\n';
    outfile << (is_prime(control_number) ? 1 : 0) << '\n';

    return 0;
}
```

This code effectively handles:
- Reading input data from the file.
- Counting frequencies of each weight.
- Grouping and processing counts in groups of three.
- Forming the control number.
- Checking if the control number is prime.
- Writing output data to the file.

The approach ensures efficiency given the constraints, ensuring quick execution even for the upper limit of inputs.
