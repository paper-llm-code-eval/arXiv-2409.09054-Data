---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `control.in` and write to `control.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Gigel a primit spre păstrare un set de $n$ cutii de greutăți nu neapărat distincte. El a cântărit cutiile și pentru fiecare greutate distinctă a notat pe o foaie, în ordine crescătoare a greutăților, numărul de cutii cu greutatea respectivă.

Deoarece fratele său mai mic avea prostul obicei să se joace cu numerele scrise de el pe foaie, Gigel s-a gândit să calculeze un „număr de control” după următorul algoritm: începând de la primul număr a grupat numerele de apariții ale greutăților câte trei (dacă îi rămân numere negrupate la sfârșit, le ignoră). Dacă într-un grup sunt numai numere pare sau numai impare notează grupul cu cifra $1$, altfel îl notează cu cifra $0$. Din șirul astfel obținut, se formează un număr care are ca valoare cifra zecilor egală cu numărul de valori $1$ și cifra unităților egală cu numărul de valori $0$, obținându-se astfel „numărul de control”.

# Cerință

Citind greutățile cutiilor, să se determine „numărul de control” și să se verifice dacă este număr prim.

# Date de intrare

De pe prima linie a fișierului de intrare `control.in` se citește numărul $n$. Pe fiecare dintre următoarele $n$ linii se găsește câte un număr natural reprezentând greutățile celor n cutii.

# Date de ieșire

În fișierul de ieșire `control.out` se va scrie pe prima linie „numărul de control”, urmat, pe linia a doua, de valoarea $0$ sau $1$. Pe linia a doua se va afișa $1$ dacă numărul este prim, respectiv $0$ în caz contrar.

# Restricții și precizări

* $1 \leq n \leq 100$;
* Fiecare greutate este un număr natural, mai mic sau egal cu $200$

---

Example:
`control.in`
```
21
1
3
2
6
2
6
2
8
9
8
8
9
10
8
11
18
11
12
14
15
17
```

`control.out`
```
31
1
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:Here is the C++ solution that meets the requirements of the challenge. It reads from `control.in` and writes to `control.out` without using `cin`, `cout`, `printf()`, or `scanf()`. The solution also uses efficient methods to calculate the control number and check whether it is a prime number.

```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <map>
#include <algorithm>
#include <cmath>

bool is_prime(int num) {
    if (num <= 1) return false;
    if (num <= 3) return true;
    if (num % 2 == 0 || num % 3 == 0) return false;
    for (int i = 5; i * i <= num; i += 6) {
        if (num % i == 0 || num % (i + 2) == 0) return false;
    }
    return true;
}

int main() {
    std::ifstream infile("control.in");
    std::ofstream outfile("control.out");
    
    if (!infile.is_open() || !outfile.is_open()) {
        return 1;
    }

    int n;
    infile >> n;
    std::vector<int> weights(n);
    for (int i = 0; i < n; ++i) {
        infile >> weights[i];
    }
    infile.close();

    std::map<int, int> weight_count;
    for (const int& weight : weights) {
        weight_count[weight]++;
    }

    std::vector<int> counts;
    for (const auto& pair : weight_count) {
        counts.push_back(pair.second);
    }

    int ones = 0, zeros = 0;
    for (size_t i = 0; i < counts.size(); i += 3) {
        if (i + 2 < counts.size()) {
            int even_count = ((counts[i] % 2 == 0) + (counts[i+1] % 2 == 0) + (counts[i+2] % 2 == 0));
            int odd_count = 3 - even_count;
            if (even_count == 3 || odd_count == 3) {
                ones++;
            } else {
                zeros++;
            }
        }
    }

    int control_number = ones * 10 + zeros;
    outfile << control_number << std::endl;
    outfile << (is_prime(control_number) ? 1 : 0) << std::endl;
    
    outfile.close();
    return 0;
}
```

### Explanation:

1. **Reading Input:**
   - We read the number of weights `n` and then the `n` weights from the file `control.in`.

2. **Counting Weights:**
   - We use a `std::map` to count the occurrences of each weight.

3. **Grouping Counts:**
   - We extract the counts and group them in sets of three. For each group of three counts, we check if all counts are either even or odd. If they are, we count it as `1`; otherwise, as `0`.

4. **Calculating Control Number:**
   - The control number is formed by placing the number of `1`s at the tens place and the number of `0`s at the units place.

5. **Checking Primality:**
   - We implement a function `is_prime` to check if the control number is prime.

6. **Writing Output:**
   - We write the control number and whether it is prime to the file `control.out`.

This solution efficiently handles the given constraints and ensures correct input/output operations as specified.
