---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `cifre.in` and write to `cifre.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Se dau două numere naturale $a$ și $b$ cu maxim $9$ cifre.

# Cerință

1. Să se determine cifrele distincte, comune numerelor $a$ și $b$.
2. Să se afișeze numărul cel mai mare format din toate cifrele lui $a$ și $b$.

# Date de intrare


Din fișierul de intrare `cifre.in` se citesc de pe prima linie, separate printr-un spațiu, valorile $a$ și $b$.


# Date de ieșire


Datele de ieșire se afișează în fișierul de ieșire `cifre.out`, pe exact două linii. Răspunsul la prima cerință se va afișa pe prima linie a fișierului, cifrele fiind scrise în ordine strict crescătoare separate prin exact un spațiu, iar răspunsul la cea de a doua cerință pe linia a doua. În cazul în care cele două numere nu au nici o cifră comună pe prima linie a fișierului de ieșire se va afișa valoarea $-1$.


# Restricții și precizări

* $1 \leq a, b < 10^9$;
* Se acordă $50\%$ din punctaj pentru cerința $1$ și întregul punctaj pentru cerințele $1$ si $2$ rezolvate corect.

---

Example:
`cifre.in`
```
2115 29025
```

`cifre.out`
```
2 5
955222110
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```cpp
#include <fstream>
#include <vector>
#include <algorithm>
#include <set>
#include <string>

int main() {
    std::ifstream infile("cifre.in");
    std::ofstream outfile("cifre.out");

    unsigned int a, b;
    infile >> a >> b;

    std::vector<bool> digitsA(10, false);
    std::vector<bool> digitsB(10, false);

    unsigned int temp = a;
    while (temp > 0) {
        digitsA[temp % 10] = true;
        temp /= 10;
    }

    temp = b;
    while (temp > 0) {
        digitsB[temp % 10] = true;
        temp /= 10;
    }

    std::set<int> commonDigits;
    std::vector<int> allDigits;

    for (int i = 0; i < 10; ++i) {
        if (digitsA[i] || digitsB[i]) {
            allDigits.push_back(i);
        }
        if (digitsA[i] && digitsB[i]) {
            commonDigits.insert(i);
        }
    }

    if (commonDigits.empty()) {
        outfile << -1 << "\n";
    } else {
        for (int digit : commonDigits) {
            outfile << digit << " ";
        }
        outfile << "\n";
    }

    std::sort(allDigits.begin(), allDigits.end(), std::greater<int>());
    for (int digit : allDigits) {
        outfile << digit;
    }
    outfile << "\n";

    return 0;
}
```

### Explanation:
1. **File Reading**: The solution reads inputs `a` and `b` from `cifre.in` file using `ifstream`.
2. **Digit Extraction**: Two boolean vectors `digitsA` and `digitsB` keep track of which digits are present in `a` and `b`, respectively.
3. **Common Digits and All Digits**:
    - **Common Digits**:
        - Stored in a `set` to automatically sort and avoid duplicates.
        - If no common digits are found, `-1` is output.
    - **All Digits**:
        - Collected in a `vector` which is sorted in descending order.
4. **Output**:
    - The common digits are printed in ascending order.
    - The all digits are printed as a single number in descending order.

### Performance:
- The solution uses basic arithmetic and boolean operations which are very fast.
- Sorting operations are minimized by using direct comparisons and efficient data structures.
- The number of digits is constant (0-9), ensuring constant-time operations within loops.
---------- user ----------


Program result did not match expected result.
Input data:
```
2115 29025
```
Expected output:
```
2 5
955222110
```
Found output:
```
2 5 
95210
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

Thank you for pointing out the issue. The problem arises because the digits are not being accumulated correctly to form the largest number. Let's fix this by ensuring that all digits from both numbers are considered when forming the largest number.

We'll also ensure that the output format is correct, particularly for the common digits.

Here is the corrected solution in C++:

```cpp
#include <fstream>
#include <vector>
#include <algorithm>
#include <set>
#include <string>

int main() {
    std::ifstream infile("cifre.in");
    std::ofstream outfile("cifre.out");

    unsigned int a, b;
    infile >> a >> b;

    std::vector<int> digitCountA(10, 0);
    std::vector<int> digitCountB(10, 0);

    unsigned int temp = a;
    while (temp > 0) {
        digitCountA[temp % 10]++;
        temp /= 10;
    }

    temp = b;
    while (temp > 0) {
        digitCountB[temp % 10]++;
        temp /= 10;
    }

    std::set<int> commonDigits;
    std::vector<int> allDigits;

    for (int i = 0; i < 10; ++i) {
        if (digitCountA[i] > 0 || digitCountB[i] > 0) {
            for (int j = 0; j < digitCountA[i] + digitCountB[i]; ++j) {
                allDigits.push_back(i);
            }
        }
        if (digitCountA[i] > 0 && digitCountB[i] > 0) {
            commonDigits.insert(i);
        }
    }

    if (commonDigits.empty()) {
        outfile << -1 << "\n";
    } else {
        for (auto it = commonDigits.begin(); it != commonDigits.end(); ++it) {
            if (it != commonDigits.begin()) {
                outfile << " ";
            }
            outfile << *it;
        }
        outfile << "\n";
    }

    std::sort(allDigits.begin(), allDigits.end(), std::greater<int>());
    for (int digit : allDigits) {
        outfile << digit;
    }
    outfile << "\n";

    return 0;
}
```

### Explanation of Changes:
1. **Digit Counting**: Instead of just marking the presence of digits, we now count the occurrences of each digit in both `a` and `b` using `digitCountA` and `digitCountB` arrays.
2. **Constructing All Digits**: We construct the list of all digits by considering the counts from both numbers, ensuring that all occurrences are included.
3. **Common Digits**: This part remains the same, using a set to find and order the common digits.
4. **Output Formatting**: 
   - For common digits, we ensure correct formatting by adding spaces appropriately.
   - For the largest number, we sort the combined list of all digits in descending order and print them without any spaces.

### Testing:
Using the provided example:
Input:
```
2115 29025
```
Expected Output:
```
2 5
955222110
```
This implementation will correctly handle the input and produce the expected output.
