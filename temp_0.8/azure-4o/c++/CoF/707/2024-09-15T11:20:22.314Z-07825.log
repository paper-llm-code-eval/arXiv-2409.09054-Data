---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `sir.in` and write to `sir.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Se consideră următorul şir, construit astfel încât fiecare element al lui, cu excepţia primului, se obţine din cel precedent: $1, 11, 21, 1211, 111221, \dots$
Termenii din şir sunt numerotaţi începând cu $1$.

# Cerință

Dat $n$, un număr natural, să se determine cel de-al $n$-lea termen din şirul dat.

# Date de intrare

Pe prima linie a fișierului de intrare `sir.in` se găseste numarul $n$.

# Date de ieșire

Pe prima linie a fișierului de ieșire `sir.out` se va găsi un singur număr întreg, al $n$-lea termen al sirului.

# Restricții și precizări

* $4 \leq n \leq 35$;
* numărul de cifre ale unui termen nu depăşeşte $17 \ 000$.

---

Example:
`sir.in`
```
4
```

`sir.out`
```
1211
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```cpp
#include <fstream>
#include <string>

using namespace std;

// Function to generate the next term in the sequence
string getNextTerm(const string &currentTerm) {
    string nextTerm;
    int length = currentTerm.length();
    for (int i = 0; i < length; i++) {
        int count = 1;
        // Count occurrences of the same digit
        while (i < length - 1 && currentTerm[i] == currentTerm[i + 1]) {
            count++;
            i++;
        }
        // Append the count and the digit to the next term
        nextTerm += to_string(count) + currentTerm[i];
    }
    return nextTerm;
}

int main() {
    ifstream inputFile("sir.in");
    ofstream outputFile("sir.out");

    int n;
    inputFile >> n;

    string term = "1"; // Starting term of the sequence
    for (int i = 1; i < n; i++) {
        term = getNextTerm(term);
    }

    outputFile << term;

    inputFile.close();
    outputFile.close();

    return 0;
}
```

### Explanation:
1. **Reading Input:**
   - The input file `sir.in` is read to get the value of `n`.

2. **Generating the Sequence:**
   - The sequence is initialized with the first term, `"1"`.
   - A loop runs from 1 to `n-1` to generate each subsequent term using the `getNextTerm` function.

3. **Generating the Next Term:**
   - The `getNextTerm` function takes the current term as input and generates the next term by counting contiguous digits and appending the count followed by the digit.

4. **Outputting the Result:**
   - The final term is written to the `sir.out` file.

### Example Verification:
For `n = 4`:
- Term 1: "1"
- Term 2: "11" (one 1)
- Term 3: "21" (two 1s)
- Term 4: "1211" (one 2, one 1)

As shown, the example and the logic match correctly. This solution should be efficient and work within the given constraints.
