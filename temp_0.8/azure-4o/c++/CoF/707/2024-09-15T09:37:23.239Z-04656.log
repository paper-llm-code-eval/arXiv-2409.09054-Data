---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `sir.in` and write to `sir.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Se consideră următorul şir, construit astfel încât fiecare element al lui, cu excepţia primului, se obţine din cel precedent: $1, 11, 21, 1211, 111221, \dots$
Termenii din şir sunt numerotaţi începând cu $1$.

# Cerință

Dat $n$, un număr natural, să se determine cel de-al $n$-lea termen din şirul dat.

# Date de intrare

Pe prima linie a fișierului de intrare `sir.in` se găseste numarul $n$.

# Date de ieșire

Pe prima linie a fișierului de ieșire `sir.out` se va găsi un singur număr întreg, al $n$-lea termen al sirului.

# Restricții și precizări

* $4 \leq n \leq 35$;
* numărul de cifre ale unui termen nu depăşeşte $17 \ 000$.

---

Example:
`sir.in`
```
4
```

`sir.out`
```
1211
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:To solve the problem, we need to generate the n-th term of a sequence where each term is derived from describing the previous term. This sequence is known as the "look-and-say" sequence. 

We'll implement a function to generate each term of the sequence iteratively until we reach the desired term. The process involves reading the current sequence and constructing the next term by counting contiguous digits.

Here's the complete C++ code for the solution:

```cpp
#include <fstream>
#include <string>

// Function to generate the next term in the look-and-say sequence
std::string getNextTerm(const std::string& s) {
    std::string result;
    int count = 1;

    // Iterate through the string
    for (size_t i = 1; i <= s.length(); ++i) {
        if (i < s.length() && s[i] == s[i - 1]) {
            ++count;
        } else {
            result += std::to_string(count) + s[i - 1];
            count = 1;
        }
    }

    return result;
}

int main() {
    std::ifstream inputFile("sir.in");
    std::ofstream outputFile("sir.out");

    int n;
    inputFile >> n;

    std::string term = "1"; // The first term in the sequence

    // Generate terms up to the n-th term
    for (int i = 1; i < n; ++i) {
        term = getNextTerm(term);
    }

    outputFile << term;

    inputFile.close();
    outputFile.close();
    
    return 0;
}
```

### Explanation
1. **Reading the Input**: We read the value of `n` from the input file `sir.in`.
2. **Generating the Sequence**: We start with the initial term "1" and iteratively generate the next term using the `getNextTerm` function.
3. **Writing the Output**: Once the n-th term is generated, we write it to the output file `sir.out`.

### Function `getNextTerm`
- This function takes a string `s`, which represents the current term in the sequence.
- It constructs the next term by counting contiguous digits and appending the count followed by the digit to the result string.
- This process continues until the entire string `s` is processed.

### Efficiency
- The algorithm efficiently constructs each term by processing each character of the current term exactly once.
- Given the constraints, this solution is optimal and will perform well within the limits.

By following this approach, we ensure that the solution is both correct and efficient for the given constraints.
