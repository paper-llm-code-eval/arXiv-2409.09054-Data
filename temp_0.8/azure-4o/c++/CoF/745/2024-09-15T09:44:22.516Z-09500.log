---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `lacusta.in` and write to `lacusta.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Se consideră o matrice dreptunghiulară cu $m$ linii şi $n$ coloane, cu valori naturale. Traversăm matricea pornind de la colţul stânga-sus la colţul dreapta-jos. O traversare constă din mai multe deplasări. La fiecare deplasare se execută un salt pe orizontală şi un pas pe verticală. Un salt înseamnă că putem trece de la o celulă la oricare alta aflată pe aceeaşi linie, iar un pas înseamnă că putem trece de la o celulă la celula aflată imediat sub ea. Excepţie face ultima deplasare (cea în care ne aflăm pe ultima linie), când vom face doar un salt pentru a ajunge în colţul dreapta-jos, dar nu vom mai face şi pasul corespunzător. Astfel traversarea va consta din vizitarea a $2 \cdot m$ celule. 

# Cerinţă

Scrieţi un program care să determine suma minimă care se poate obţine pentru o astfel de traversare.

# Date de intrare


Fişierul de intrare `lacusta.in` conţine pe prima linie două numere naturale separate printr-un spaţiu $m \ n$, reprezentând numărul de linii şi respectiv numărul de coloane ale matricei. Pe următoarele $m$ linii este descrisă matricea, câte $n$ numere pe fiecare linie, separate prin câte un spaţiu.

# Date de ieșire


Fişierul de ieşire `lacusta.out` va conţine o singură linie pe care va fi scrisă suma minimă găsită.

# Restricții și precizări

* $1 \leq m, n \leq 100$
* Valorile elementelor matricei sunt numere întregi din intervalul $[1, 255]$

---

Example:
`lacusta.in`
```
4 5
3 4 5 7 9
6 6 3 4 4
6 3 3 9 6
6 5 3 8 2
```

`lacusta.out`
```
28
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:Certainly! Let's break down the approach for solving this problem and then provide the C++ solution.

## Approach

1. **Dynamic Programming:** Given the constraints, a dynamic programming approach is feasible. We will use a DP table to keep track of the minimum sum path to each cell in the matrix.
2. **State Definition:**
   - Let `dp[i][j]` be the minimum sum to reach cell `(i, j)` from the top-left corner `(0, 0)`.
3. **Transition:**
   - For the first row, `dp[0][j]` will be the value of the cell itself because we can only make jumps horizontally.
   - For each subsequent row `i`:
     - Calculate the minimum sum to reach each cell `(i, j)` using the values from the previous row.
     - This involves checking all possible cells in the previous row and taking the minimum sum.
4. **Final State:**
   - The answer will be the minimum value in the last row plus the value to jump directly to the bottom-right corner from any cell in the last row.

**Example Walkthrough:**
For the given example:
```
4 5
3 4 5 7 9
6 6 3 4 4
6 3 3 9 6
6 5 3 8 2
```
1. Construct the `dp` table row by row using the rules described.
2. Finally, the answer will be derived from the last row values.

## Implementation

```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <algorithm>
#include <climits>

int main() {
    std::ifstream infile("lacusta.in");
    std::ofstream outfile("lacusta.out");

    // Read dimensions
    int m, n;
    infile >> m >> n;

    // Read the matrix
    std::vector<std::vector<int>> matrix(m, std::vector<int>(n));
    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            infile >> matrix[i][j];
        }
    }

    // Initialize DP table
    std::vector<std::vector<int>> dp(m, std::vector<int>(n, INT_MAX));

    // First row is just the values of the matrix
    for (int j = 0; j < n; ++j) {
        dp[0][j] = matrix[0][j];
    }

    // Fill DP table
    for (int i = 1; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            for (int k = 0; k < n; ++k) {
                if (j != k) { // Must not be the same column
                    dp[i][j] = std::min(dp[i][j], dp[i-1][k] + matrix[i][j]);
                }
            }
        }
    }

    // Find the minimum sum of the last row and add the value to jump to bottom-right corner
    int result = INT_MAX;
    for (int j = 0; j < n; ++j) {
        result = std::min(result, dp[m-1][j] + matrix[m-1][n-1]);
    }

    // Output the result
    outfile << result << "\n";

    infile.close();
    outfile.close();
    return 0;
}
```

## Explanation

1. **Reading Input:**
   - We read the dimensions `m` and `n` and then the matrix itself from `lacusta.in`.
2. **Initialization:**
   - The `dp` table is initialized with `INT_MAX` to represent infinite initial values.
   - The first row of the `dp` table is initialized with the values of the first row of the matrix.
3. **DP Transition:**
   - For each cell `(i, j)`, we calculate the minimum sum to reach that cell considering all possible cells from the previous row except the same column.
4. **Finding Result:**
   - We find the minimum value in the last row of the `dp` table and add the value of the bottom-right cell to get the answer.
5. **Output:**
   - The result is written to `lacusta.out`.

This approach ensures that we find the minimum sum path efficiently, adhering to the constraints and the problem requirements.
---------- user ----------


Program result did not match expected result.
Input data:
```
4 5
3 4 5 7 9
6 6 3 4 4
6 3 3 9 6
6 5 3 8 2
```
Expected output:
```
28
```
Found output:
```
13
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
