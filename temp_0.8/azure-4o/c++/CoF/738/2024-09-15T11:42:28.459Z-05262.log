---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `ucif.in` and write to `ucif.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Fie $n$ un număr natural și $s = 1^1 + 2^2 + 3^3 + \dots + n^n$.

# Cerință

Scrieți un program care să afișeze ultima cifră a lui $s$.

# Date de intrare


De pe prima linie a fișierului de intrare `ucif.in` se citește numărul $n$.


# Date de ieșire


Pe prima linie a fișierului de ieșire `ucif.out` se va afișa numai ultima cifră a lui $s$.


# Restricții și precizări

* $1 \leq n \leq 100$

---

Example:
`ucif.in`
```
3
```

`ucif.out`
```
2
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:Let's implement the solution in C++ to efficiently compute the last digit of the sum \( s = 1^1 + 2^2 + 3^3 + \dots + n^n \) from a given `ucif.in` file and write the result to `ucif.out`.

Here's the C++ code for the solution:

```cpp
#include <fstream>
#include <cmath>

int main() {
    std::ifstream fin("ucif.in");
    std::ofstream fout("ucif.out");
    
    int n;
    fin >> n;

    int last_digit = 0;
    for (int i = 1; i <= n; ++i) {
        int term = 1;
        for (int j = 0; j < i; ++j) {
            term = (term * i) % 10;
        }
        last_digit = (last_digit + term) % 10;
    }
    
    fout << last_digit << "\n";
    
    fin.close();
    fout.close();

    return 0;
}
```

### Explanation:
1. **Reading Input**: We use `std::ifstream` to read the integer \( n \) from the file `ucif.in`.
2. **Initialization**: We initialize `last_digit` to 0 to keep track of the last digit of the sum.
3. **Compute Last Digits of Terms**: For each \( i \) from 1 to \( n \):
    - Compute \( i^i \) but only keep track of the last digit at each multiplication step to avoid large number overflows.
    - This is done by calculating \( (term * i) % 10 \) iteratively \( i \) times.
4. **Sum and Modulo**: Add the last digit of each term to `last_digit` and take the modulo 10 to maintain only the last digit at each step.
5. **Writing Output**: Use `std::ofstream` to write the result to `ucif.out`.

This approach ensures that we minimize the number of operations and handle only the necessary computations to derive the last digit, keeping the solution efficient even for the upper limit \( n = 100 \).
