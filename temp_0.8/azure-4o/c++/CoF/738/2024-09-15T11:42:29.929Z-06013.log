---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `ucif.in` and write to `ucif.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Fie $n$ un număr natural și $s = 1^1 + 2^2 + 3^3 + \dots + n^n$.

# Cerință

Scrieți un program care să afișeze ultima cifră a lui $s$.

# Date de intrare


De pe prima linie a fișierului de intrare `ucif.in` se citește numărul $n$.


# Date de ieșire


Pe prima linie a fișierului de ieșire `ucif.out` se va afișa numai ultima cifră a lui $s$.


# Restricții și precizări

* $1 \leq n \leq 100$

---

Example:
`ucif.in`
```
3
```

`ucif.out`
```
2
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:The challenge at hand requires computing the last digit of the sum \(s = 1^1 + 2^2 + 3^3 + \ldots + n^n\). Given the constraints, it is essential to ensure the solution is both correct and efficient.

Here's an efficient solution written in C++:

```cpp
#include <fstream>
#include <cmath>

int main() {
    std::ifstream input("ucif.in");
    std::ofstream output("ucif.out");

    int n;
    input >> n;

    long long sum = 0;

    for (int i = 1; i <= n; ++i) {
        long long current_term = 1;
        for (int j = 1; j <= i; ++j) {
            current_term = (current_term * i) % 10;
        }
        sum = (sum + current_term) % 10;
    }

    output << sum << '\n';

    input.close();
    output.close();
    return 0;
}
```

### Explanation:
1. **Reading Input:**
   - We read the input value `n` from the file `ucif.in`.

2. **Initialization:**
   - We initialize a variable `sum` to zero which will store the sum of the last digits of the terms.

3. **Computation:**
   - We iterate from 1 to `n`.
   - For each `i`, we compute \(i^i \mod 10\) to get the last digit of \(i^i\).
   - The inner loop computes \(i^i \mod 10\) by multiplying `i` with itself `i` times, each time taking the result modulo 10 to keep the computation efficient.
   - We add this last digit to `sum`, taking `sum % 10` to ensure we only keep the last digit of the cumulative sum.

4. **Output the Result:**
   - We write the result (last digit of the sum) to the output file `ucif.out`.

### Optimization:
By focusing only on the last digit during the entire computation, we keep the operations lightweight and avoid handling large numbers, which ensures the solution is efficient even for the upper limit of \( n = 100 \). 

This method ensures the program runs fast and meets the challenge requirements effectively.
