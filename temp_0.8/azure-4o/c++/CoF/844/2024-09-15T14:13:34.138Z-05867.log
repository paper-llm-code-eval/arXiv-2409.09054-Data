---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `imprimanta.in` and write to `imprimanta.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

_Cif-Oji6_ este o imprimantă matriceală numită și imprimantă cu ace, deoarece tipărirea se realizează prin impactul acelor capului de imprimare pe o bandă cu tuș. Acele sunt aranjate într-o grilă dreptunghiulară formată din $5$ rânduri de ace, pe fiecare rând aflându-se la distanțe egale câte $3$ ace, așa cum se observă în figura următoare.

~[imprimanta-1.png]

Prin acționarea diferitelor combinații de ace din grilă, se definește forma fiecărei cifre ce permite tipărirea acesteia prin puncte, în felul următor:

~[imprimanta-2.png]

De exemplu, cifra $2$ va fi tipărită prin $11$ puncte ca rezultat al acționării a $11$ ace din grilă: din primul rând de ace al grilei se vor acționa toate cele $3$ ace, din următorul rând doar acul din dreapta, apoi de pe următorul rând toate cele $3$ ace, apoi acul din stânga de pe penultimul rând iar din ultimul rând toate cele $3$ ace.

# Cerință

1. Știind că imprimanta Cif-Oji6 a tipărit numărul $N$, determinați care este cea mai mare cifră a numărul $N$ pentru care s-a acționat un număr minim de ace ale grilei.
2. Știind că imprimanta mai are tuș pe bandă doar pentru imprimarea a $K$ puncte, determinați **cel mai mare număr natural** ce poate fi tipărit prin **exact $K$ puncte**.

# Date de intrare

Fișierul de intrare `imprimanta.in` conține pe prima linie două numere naturale $N$ și $K$ separate printr-un spațiu, unde $N$ reprezintă numărul tipărit de imprimantă iar $K$ numărul de puncte pentru care imprimanta mai are tuș.

# Date de ieșire

Fișierul de ieșire `imprimanta.out` va conține:

* pe prima linie un singur număr natural ce reprezintă cea mai mare cifră a numărul $N$ pentru care s-a acționat un număr minim de ace ale grilei.
* pe cea de-a doua linie a fișierului se va scrie **cel mai mare număr natural** ce poate fi tipărit prin $K$ puncte.

# Restricții și precizări

* $10 \leq N \leq 10^{15}$;
* $14 \leq K \leq 100 \ 000$;
* Pentru rezolvarea corectă a cerinței $1$ se acordă $30$% din punctajul fiecărui test iar pentru rezolvarea corectă a cerinței $2$ se acordă $70$% din punctajul fiecărui test.

---

Example:
`imprimanta.in`
```
2852 16
```

`imprimanta.out`
```
5
74
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```cpp
#include <fstream>
#include <vector>
#include <algorithm>

// Predefined number of points required to print each digit 0-9
const int points[] = {12, 5, 11, 11, 9, 11, 10, 7, 12, 11};

// Function to determine the digit with the minimum points required
int find_min_points_digit(const std::string& number) {
    int min_points = INT_MAX;
    int digit_with_min_points = -1;
    
    for (char c : number) {
        int digit = c - '0';
        if (points[digit] < min_points || (points[digit] == min_points && digit > digit_with_min_points)) {
            min_points = points[digit];
            digit_with_min_points = digit;
        }
    }
    
    return digit_with_min_points;
}

// Function to determine the largest number that can be printed with exactly K points
std::string find_largest_number_with_k_points(int K) {
    if (K < *std::min_element(points, points + 10)) {
        return "-1";  // If K is less than the minimum points required to print a single digit
    }

    std::vector<int> min_digits(K + 1, -1);
    min_digits[0] = 0;

    for (int i = 0; i <= K; ++i) {
        if (min_digits[i] == -1) continue;
        for (int d = 0; d < 10; ++d) {
            if (i + points[d] <= K) {
                min_digits[i + points[d]] = std::max(min_digits[i + points[d]], min_digits[i] * 10 + d);
            }
        }
    }

    return std::to_string(min_digits[K]);
}

int main() {
    std::ifstream infile("imprimanta.in");
    std::ofstream outfile("imprimanta.out");

    long long N;
    int K;
    infile >> N >> K;

    std::string N_str = std::to_string(N);
    int min_points_digit = find_min_points_digit(N_str);
    std::string largest_number_with_k_points = find_largest_number_with_k_points(K);

    outfile << min_points_digit << std::endl;
    outfile << largest_number_with_k_points << std::endl;

    infile.close();
    outfile.close();

    return 0;
}
```

### Explanation:
1. **Data Reading**: The program reads the input values `N` and `K` from the `imprimanta.in` file.
2. **Predefined Digits Points**: The number of points required to print each digit (0-9) is defined in the `points` array.
3. **Finding the Minimum Points Digit**:
    - The function `find_min_points_digit` iterates through each digit of `N` to find the digit with the minimum points required. In case of a tie, it selects the larger digit.
4. **Finding the Largest Number with Exactly K Points**:
    - The function `find_largest_number_with_k_points` uses dynamic programming to determine the largest number that can be printed with exactly `K` points.
    - It uses a vector to store the maximum "number" that can be formed with a given number of points.
5. **Output Writing**: The results are written to the `imprimanta.out` file.

This approach ensures that the solution is efficient and meets the problem requirements, considering the constraints provided.
---------- user ----------


Failed to compile the program.
```
main.cpp: In function 'int find_min_points_digit(const string&)':
main.cpp:10:22: error: 'INT_MAX' was not declared in this scope
   10 |     int min_points = INT_MAX;
      |                      ^~~~~~~
main.cpp:4:1: note: 'INT_MAX' is defined in header '<climits>'; did you forget to '#include <climits>'?
    3 | #include <algorithm>
  +++ |+#include <climits>
    4 | 

```

Evaluate the error message. Think of a solution to fix the program and return the entire source code with the fix.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

Certainly! The error message indicates that the macro `INT_MAX` is not recognized because we need to include the `<climits>` header. Let's fix this issue by including the required header and providing the corrected solution below:

```cpp
#include <fstream>
#include <vector>
#include <algorithm>
#include <climits>  // Include the necessary header for INT_MAX
#include <string>

// Predefined number of points required to print each digit 0-9
const int points[] = {12, 5, 11, 11, 9, 11, 10, 7, 12, 11};

// Function to determine the digit with the minimum points required
int find_min_points_digit(const std::string& number) {
    int min_points = INT_MAX;
    int digit_with_min_points = -1;
    
    for (char c : number) {
        int digit = c - '0';
        if (points[digit] < min_points || (points[digit] == min_points && digit > digit_with_min_points)) {
            min_points = points[digit];
            digit_with_min_points = digit;
        }
    }
    
    return digit_with_min_points;
}

// Function to determine the largest number that can be printed with exactly K points
std::string find_largest_number_with_k_points(int K) {
    if (K < *std::min_element(points, points + 10)) {
        return "-1";  // If K is less than the minimum points required to print a single digit
    }

    std::vector<int> min_digits(K + 1, -1);
    min_digits[0] = 0;

    for (int i = 0; i <= K; ++i) {
        if (min_digits[i] == -1) continue;
        for (int d = 0; d < 10; ++d) {
            if (i + points[d] <= K) {
                min_digits[i + points[d]] = std::max(min_digits[i + points[d]], min_digits[i] * 10 + d);
            }
        }
    }

    return std::to_string(min_digits[K]);
}

int main() {
    std::ifstream infile("imprimanta.in");
    std::ofstream outfile("imprimanta.out");

    long long N;
    int K;
    infile >> N >> K;

    std::string N_str = std::to_string(N);
    int min_points_digit = find_min_points_digit(N_str);
    std::string largest_number_with_k_points = find_largest_number_with_k_points(K);

    outfile << min_points_digit << std::endl;
    outfile << largest_number_with_k_points << std::endl;

    infile.close();
    outfile.close();

    return 0;
}
```

### Explanation of Fixes:
1. **Header Inclusion**: Added the `#include <climits>` to ensure the macro `INT_MAX` is recognized.
2. **Compile and Execution**: Now, the program should compile and execute correctly based on the given requirements.

This solution reads from `imprimanta.in`, processes the input to determine both required outputs, and writes the results to `imprimanta.out`.
---------- user ----------


Program result did not match expected result.
Input data:
```
2852 16
```
Expected output:
```
5
74
```
Found output:
```
5
91
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

Let's reevaluate the approach to ensure we meet the requirements accurately.

### Analysis of the Issue:
1. The first part of the solution correctly identifies the digit with the minimum points in the given number `N`.
2. The second part needs to generate the largest number possible with exactly `K` points. The approach used in the previous solution incorrectly computes the largest number that can be formed using dynamic programming.

### Correct Approach:
For the second part, the goal is to create the largest number using exactly `K` points. To do this:
1. We should prioritize digits that require fewer points to maximize the number of digits in the result.
2. Dynamically construct the largest possible number by selecting appropriate digits.

### Corrected Code:
```cpp
#include <fstream>
#include <vector>
#include <algorithm>
#include <climits>
#include <string>

// Predefined number of points required to print each digit 0-9
const int points[] = {12, 5, 11, 11, 9, 11, 10, 7, 12, 11};

// Function to determine the digit with the minimum points required
int find_min_points_digit(const std::string& number) {
    int min_points = INT_MAX;
    int digit_with_min_points = -1;
    
    for (char c : number) {
        int digit = c - '0';
        if (points[digit] < min_points || (points[digit] == min_points && digit > digit_with_min_points)) {
            min_points = points[digit];
            digit_with_min_points = digit;
        }
    }
    
    return digit_with_min_points;
}

// Function to determine the largest number that can be printed with exactly K points
std::string find_largest_number_with_k_points(int K) {
    // To ensure the largest number, prioritize digits with fewer points
    std::vector<std::pair<int, int>> digit_points;
    for (int i = 0; i < 10; ++i) {
        digit_points.push_back({points[i], i});
    }
    std::sort(digit_points.begin(), digit_points.end());

    std::string result = "";
    while (K > 0) {
        bool found = false;
        for (int i = 9; i >= 0; --i) {
            int d = digit_points[i].second;
            int p = digit_points[i].first;
            if (p <= K) {
                result += std::to_string(d);
                K -= p;
                found = true;
                break;
            }
        }
        if (!found) {
            return "-1";
        }
    }

    // Sort the result in descending order to ensure the largest number
    std::sort(result.begin(), result.end(), std::greater<char>());
    return result;
}

int main() {
    std::ifstream infile("imprimanta.in");
    std::ofstream outfile("imprimanta.out");

    long long N;
    int K;
    infile >> N >> K;

    std::string N_str = std::to_string(N);
    int min_points_digit = find_min_points_digit(N_str);
    std::string largest_number_with_k_points = find_largest_number_with_k_points(K);

    outfile << min_points_digit << std::endl;
    outfile << largest_number_with_k_points << std::endl;

    infile.close();
    outfile.close();

    return 0;
}
```

### Explanation of Changes:
1. **Find Largest Number with Exactly K Points**:
   - The function `find_largest_number_with_k_points` now prioritizes digits with fewer points to maximize the number of digits.
   - It then constructs the largest number possible by greedily selecting the highest possible digit that fits within the remaining points `K`.
   - Finally, the result is sorted in descending order to ensure the largest numeric representation.

This corrected approach aligns with the requirement to find the largest number that can be printed with exactly `K` points. Based on the provided example, this should now produce the correct output.
---------- user ----------


Program result did not match expected result.
Input data:
```
2852 16
```
Expected output:
```
5
74
```
Found output:
```
5
-1
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

Upon re-evaluating the problem and the provided solution, it becomes clear that the current approach to finding the largest number with exactly `K` points is flawed. Specifically, the dynamic programming approach does not correctly account for the possibility of forming valid numbers with exactly `K` points.

### Correct Approach:
To solve the second part of the problem correctly, we should:
1. Use a greedy approach to form the largest number by choosing the digits that can fit within the remaining points.
2. Ensure that we can form a valid number by correctly updating the remaining points and selecting the appropriate digits.

Here's the corrected solution:

```cpp
#include <fstream>
#include <vector>
#include <algorithm>
#include <climits>
#include <string>

// Predefined number of points required to print each digit 0-9
const int points[] = {12, 5, 11, 11, 9, 11, 10, 7, 12, 11};

// Function to determine the digit with the minimum points required
int find_min_points_digit(const std::string& number) {
    int min_points = INT_MAX;
    int digit_with_min_points = -1;
    
    for (char c : number) {
        int digit = c - '0';
        if (points[digit] < min_points || (points[digit] == min_points && digit > digit_with_min_points)) {
            min_points = points[digit];
            digit_with_min_points = digit;
        }
    }
    
    return digit_with_min_points;
}

// Function to determine the largest number that can be printed with exactly K points
std::string find_largest_number_with_k_points(int K) {
    std::vector<std::pair<int, int>> digit_points;
    for (int i = 0; i < 10; ++i) {
        digit_points.emplace_back(points[i], i);
    }
    std::sort(digit_points.begin(), digit_points.end());

    std::string result = "";
    while (K > 0) {
        for (int i = 9; i >= 0; --i) {
            int d = digit_points[i].second;
            int p = digit_points[i].first;
            if (p <= K) {
                result += std::to_string(d);
                K -= p;
                break;
            }
        }
        // Sort the result in descending order to ensure the largest number
        std::sort(result.begin(), result.end(), std::greater<char>());
        // If we cannot add any more digits, check if we've used exactly K points
        if (K > 0 && result.empty()) {
            return "-1";
        }
    }
    return result;
}

int main() {
    std::ifstream infile("imprimanta.in");
    std::ofstream outfile("imprimanta.out");

    long long N;
    int K;
    infile >> N >> K;

    std::string N_str = std::to_string(N);
    int min_points_digit = find_min_points_digit(N_str);
    
    // Ensure that the K value is feasible to form a valid number
    std::string largest_number_with_k_points = (K >= 5) ? find_largest_number_with_k_points(K) : "-1";

    outfile << min_points_digit << std::endl;
    outfile << largest_number_with_k_points << std::endl;

    infile.close();
    outfile.close();

    return 0;
}
```

### Explanation of Changes:
1. **Digit and Points Mapping**:
    - The `digit_points` vector now pairs each digit with its corresponding points and sorts it.
2. **Greedy Construction**:
    - The method `find_largest_number_with_k_points` constructs the largest number by iterating from the largest digits down to the smallest that fit within the remaining points.
    - This ensures that we always attempt to use the highest possible digits while still respecting the points constraint.
3. **Validity Check**:
    - If `K` is less than the minimum possible points needed to form a digit (which is 5 for digit '1'), the function returns `-1`.

This corrected approach should provide the correct results for the given problem constraints.
---------- user ----------


Program exited with code 137.
stdout:
```

```
stderr:
```

```

Think of what has caused the exit code. Use the standard out and standard error to help you understand the issue.
Implement a solution to fix the program

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The exit code 137 typically indicates that the program was terminated by the operating system due to excessive resource usage, such as CPU time or memory. Given the nature of the problem, it's likely that the solution involves an inefficient algorithm or an infinite loop, especially in the part where it tries to construct the largest number with exactly `K` points.

To fix this, we need to ensure our approach is both correct and efficient. Here is the revised solution:

### Revised Approach:
1. **Digit with Minimum Points**:
    - This part remains the same as it correctly identifies the digit with the minimum points in the given number `N`.
2. **Largest Number with Exactly K Points**:
    - For this part, we need a more refined greedy algorithm to ensure it constructs the largest number using exactly `K` points without running into performance issues.

### Corrected Code:
```cpp
#include <fstream>
#include <vector>
#include <algorithm>
#include <climits>
#include <string>

// Predefined number of points required to print each digit 0-9
const int points[] = {12, 5, 11, 11, 9, 11, 10, 7, 12, 11};

// Function to determine the digit with the minimum points required
int find_min_points_digit(const std::string& number) {
    int min_points = INT_MAX;
    int digit_with_min_points = -1;
    
    for (char c : number) {
        int digit = c - '0';
        if (points[digit] < min_points || (points[digit] == min_points && digit > digit_with_min_points)) {
            min_points = points[digit];
            digit_with_min_points = digit;
        }
    }
    
    return digit_with_min_points;
}

// Function to determine the largest number that can be printed with exactly K points
std::string find_largest_number_with_k_points(int K) {
    std::vector<std::pair<int, int>> digit_points;
    for (int i = 0; i < 10; ++i) {
        digit_points.emplace_back(points[i], i);
    }
    std::sort(digit_points.begin(), digit_points.end());

    std::string result = "";
    while (K > 0) {
        bool found = false;
        for (int i = 9; i >= 0; --i) {
            int d = digit_points[i].second;
            int p = digit_points[i].first;
            if (p <= K) {
                result += std::to_string(d);
                K -= p;
                found = true;
                break;
            }
        }
        // If we cannot add any more digits, check if we've used exactly K points
        if (!found) {
            return "-1";
        }
    }

    // Sort the result in descending order to ensure the largest number
    std::sort(result.begin(), result.end(), std::greater<char>());
    return result;
}

int main() {
    std::ifstream infile("imprimanta.in");
    std::ofstream outfile("imprimanta.out");

    long long N;
    int K;
    infile >> N >> K;

    std::string N_str = std::to_string(N);
    int min_points_digit = find_min_points_digit(N_str);
    
    // Ensure that the K value is feasible to form a valid number
    std::string largest_number_with_k_points = (K >= 5) ? find_largest_number_with_k_points(K) : "-1";

    outfile << min_points_digit << std::endl;
    outfile << largest_number_with_k_points << std::endl;

    infile.close();
    outfile.close();

    return 0;
}
```

### Explanation of Fixes:
1. **Sorting Digits and Points**: 
   - We pair each digit with its corresponding points and sort the pairs. This ensures we can always select the digit with the smallest point requirement when necessary.
2. **Greedy Construction**:
   - We build the result string by repeatedly selecting the largest digit that fits within the remaining points `K`.
3. **Infinite Loop Prevention**:
   - Ensure the loop terminates correctly by checking if no digit can fit within the remaining points, returning `-1` if that's the case.

This revised solution should effectively address the performance and correctness issues, ensuring the program runs within the resource limits and produces the correct results.
---------- user ----------


Program result did not match expected result.
Input data:
```
2852 16
```
Expected output:
```
5
74
```
Found output:
```
5
-1
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The previous solutions did not correctly handle the problem of constructing the largest number with exactly `K` points. Let's walk through a more precise and optimized approach to ensure correctness.

### Detailed Plan:
1. **Identify the digit with the minimum points in `N`**: This part involves iterating through the digits of `N` and checking each digit's point count.
2. **Construct the largest number with exactly `K` points**:
    - We need to use a dynamic programming approach or a greedy strategy that ensures we use exactly `K` points.
    - Instead of iterating in a generic way, we must ensure that we are forming numbers from the highest possible digits within the constraints.

### Updated Algorithm for the Second Requirement:
1. **Initialize a table to store the largest number we can form with exactly `i` points**.
2. **Iterate through possible point values and update the table based on the possible digits**.
3. **Construct the final result by backtracking from the table**.

### Corrected Code:
```cpp
#include <fstream>
#include <vector>
#include <algorithm>
#include <climits>
#include <string>

// Predefined number of points required to print each digit 0-9
const int points[] = {12, 5, 11, 11, 9, 11, 10, 7, 12, 11};

// Function to determine the digit with the minimum points required
int find_min_points_digit(const std::string& number) {
    int min_points = INT_MAX;
    int digit_with_min_points = -1;
    
    for (char c : number) {
        int digit = c - '0';
        if (points[digit] < min_points || (points[digit] == min_points && digit > digit_with_min_points)) {
            min_points = points[digit];
            digit_with_min_points = digit;
        }
    }
    
    return digit_with_min_points;
}

// Function to determine the largest number that can be printed with exactly K points
std::string find_largest_number_with_k_points(int K) {
    // DP array to store the maximum number formed with exactly i points
    std::vector<std::string> dp(K + 1, "");

    for (int i = 1; i <= K; ++i) {
        for (int d = 0; d < 10; ++d) {
            if (points[d] <= i && !dp[i - points[d]].empty()) {
                std::string candidate = dp[i - points[d]] + std::to_string(d);
                if (candidate.length() > dp[i].length() || (candidate.length() == dp[i].length() && candidate > dp[i])) {
                    dp[i] = candidate;
                }
            }
        }
        if (i >= points[1] && dp[i].empty()) {
            dp[i] = "1";
        }
    }

    return dp[K].empty() ? "-1" : dp[K];
}

int main() {
    std::ifstream infile("imprimanta.in");
    std::ofstream outfile("imprimanta.out");

    long long N;
    int K;
    infile >> N >> K;

    std::string N_str = std::to_string(N);
    int min_points_digit = find_min_points_digit(N_str);

    // Ensure that the K value is feasible to form a valid number
    std::string largest_number_with_k_points = (K >= 5) ? find_largest_number_with_k_points(K) : "-1";

    outfile << min_points_digit << std::endl;
    outfile << largest_number_with_k_points << std::endl;

    infile.close();
    outfile.close();

    return 0;
}
```

### Detailed Fixes:
1. **Dynamic Programming Array Initialization**:
   - Initialized a DP table `dp` where `dp[i]` holds the largest number that can be formed with exactly `i` points.
2. **Filling the DP Table**:
   - For every point value from `1` to `K`, and for every digit from `0` to `9`, update the DP table if the digit can fit in the remaining points.
   - If forming a number is possible, update the table entry with the new candidate number if it is greater than the current stored number.
3. **Handling Edge Cases**:
   - Ensure that the DP table is correctly initialized to handle the smallest valid point value.

### Conclusion:
This revised solution handles the requirements more robustly by using dynamic programming to ensure that the largest number formed has exactly `K` points. It avoids the pitfalls of previous attempts by carefully managing the DP table and constructing the result string efficiently.
---------- user ----------


Program result did not match expected result.
Input data:
```
2852 16
```
Expected output:
```
5
74
```
Found output:
```
5
111
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

I apologize for the previous errors. The bug lies in the handling of the dynamic programming array to ensure that the largest possible number is formed with exactly `K` points. The current implementation does not correctly account for the formation of the largest possible number due to improper initialization and updates to the dynamic programming table.

To ensure that we form the largest number, we need to:
1. Properly initialize the dynamic programming table.
2. Correctly update the table by considering valid transitions between states.

### Revised Approach:
1. **Initialization**: Initialize the DP table with an empty string for `dp[0]` and default impossible values for other indices.
2. **DP Updates**: Update the table by iterating over each point value and trying to extend the current number with each digit.
3. **Result Construction**: Carefully construct the result from the DP table by selecting the highest possible digits.

Let's correct the implementation:

```cpp
#include <fstream>
#include <vector>
#include <algorithm>
#include <climits>
#include <string>
#include <sstream>

// Predefined number of points required to print each digit 0-9
const int points[] = {12, 5, 11, 11, 9, 11, 10, 7, 12, 11};

// Function to determine the digit with the minimum points required
int find_min_points_digit(const std::string& number) {
    int min_points = INT_MAX;
    int digit_with_min_points = -1;
    
    for (char c : number) {
        int digit = c - '0';
        if (points[digit] < min_points || (points[digit] == min_points && digit > digit_with_min_points)) {
            min_points = points[digit];
            digit_with_min_points = digit;
        }
    }
    
    return digit_with_min_points;
}

// Function to determine the largest number that can be printed with exactly K points
std::string find_largest_number_with_k_points(int K) {
    // DP array to store the maximum number formed with exactly i points
    std::vector<std::string> dp(K + 1, "");
    dp[0] = "";

    for (int i = 1; i <= K; ++i) {
        for (int d = 0; d < 10; ++d) {
            int p = points[d];
            if (i >= p && !dp[i - p].empty()) {
                std::string candidate = std::to_string(d) + dp[i - p];
                // Ensure the candidate is the largest number possible
                if (candidate.length() > dp[i].length() || (candidate.length() == dp[i].length() && candidate > dp[i])) {
                    dp[i] = candidate;
                }
            }
        }
        // Special case to handle single-digit formation
        if (i == points[1]) {
            dp[i] = "1";
        }
    }

    return dp[K].empty() ? "-1" : dp[K];
}

int main() {
    std::ifstream infile("imprimanta.in");
    std::ofstream outfile("imprimanta.out");

    long long N;
    int K;
    infile >> N >> K;

    std::string N_str = std::to_string(N);
    int min_points_digit = find_min_points_digit(N_str);
    
    // Ensure that the K value is feasible to form a valid number
    std::string largest_number_with_k_points = find_largest_number_with_k_points(K);

    outfile << min_points_digit << std::endl;
    outfile << largest_number_with_k_points << std::endl;

    infile.close();
    outfile.close();

    return 0;
}
```

### Explanation of Fixes:
1. **Proper Initialization**: The DP table is initialized with an empty string for `dp[0]` to signify that zero points constitute an empty number.
2. **Valid Updates**: For each point value `i`, the DP table is updated by considering each digit and checking if extending the current number results in a valid candidate.
3. **Candidate Selection**: The candidate number is formed by prepending the digit to ensure that the highest numeric value is achieved.

### Conclusion:
This revised solution ensures the correct formation of the largest possible number using exactly `K` points by properly managing the dynamic programming state transitions and candidate number construction. This approach is designed to handle the constraints effectively and produce the expected results.
