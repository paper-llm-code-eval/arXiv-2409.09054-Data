---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `cursuri.in` and write to `cursuri.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Într-o tabără de vară se programează susținerea unor cursuri în $K$ săli de clasă. Sunt $N$ profesori care și-au exprimat dorința de a participa, fiecare dintre ei specificând intervalul de timp [$a_i, b_i$] în care își poate susține cursul. Programarea pe săli a profesorilor trebuie să țină cont de faptul că într-o clasă, la un moment dat, nu poate preda decât un singur profesor.

# Cerință

Cunoscându-se faptul că organizatorii doresc susținerea a cât mai multor cursuri, să se determine:

1) Numărul maxim de cursuri care pot fi programate în cele $K$ săli de clasă, ținând cont de restricția indicată.
2) În dorința de a programa toate cursurile, în cele $K$ săli, organizatorii decid să modifice durata cursurilor, păstrând însă neschimbată ora de început a lor. Astfel, ei hotărăsc ca toate cursurile să dureze un interval egal de timp, care însă nu va depăși durata celui mai lung curs propus inițial de unul dintre cei $N$ profesori. Determinați care poate fi durata maximă pe care o pot avea cursurile în aceste condiții.

# Date de intrare

În fișierul de intrare `cursuri.in` se găsește pe prima linie un număr natural $C$. Pentru toate testele, $C$ poate lua numai valorile $1$ sau $2$. Pe linia a doua se găsește o pereche de numere naturale $N \ K$, separate printr-un spațiu, reprezentând numărul profesorilor și numărul de săli de clasă. Pe următoarele $N$ linii se găsesc perechi de numere naturale $a_i \ b_i$, care reprezintă intervalele de timp în care cei $N$ profesori își susțin cursurile. Numerele în cadrul unei linii sunt separate printr-un spațiu.

# Date de ieșire

Dacă valoarea lui $C$ este $1$, se va rezolva numai punctul $1$) din cerințe. În acest caz, fişierul de ieşire `cursuri.out` va conține pe prima linie un număr natural reprezentând numărul maxim de cursuri care pot fi programate în cele K săli de clasă, ținând cont de restricția indicată.

Dacă valoarea lui $C$ este $2$, se va rezolva numai punctul $2$) din cerințe. În acest caz, fişierul de ieşire `cursuri.out` va conține pe prima linie un număr natural reprezentând durata maximă pe care o pot avea cele $N$ cursuri, astfel încât toate să poată fi susținute în cele $K$ săli disponibile.

# Restricții și precizări

* $1 \leq N \leq 1 \ 000$;
* $1 \leq K \leq 1 \ 000$;
* $1 \leq a_i < b_i \leq 100 \ 000$;
* În cazul cerinței $2$ se garantează că pentru toate testele există soluție
* Pentru rezolvarea corectă a primei cerinţe se acordă $45$ de puncte, iar pentru rezolvarea corectă a celei de a doua cerințe se acordă $45$ de puncte. Se acordă $10$ puncte din oficiu.

---

Example:
`cursuri.in`
```
1
4 2
2 16
1 3
3 18
1 20
```

`cursuri.out`
```
3
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```cpp
#include <fstream>
#include <vector>
#include <algorithm>
#include <queue>

struct Interval {
    int start, end;
};

bool compareByEnd(const Interval &a, const Interval &b) {
    return a.end < b.end;
}

int maxCoursesScheduled(std::vector<Interval> &intervals, int K) {
    std::sort(intervals.begin(), intervals.end(), compareByEnd);
    std::priority_queue<int, std::vector<int>, std::greater<int>> endTimes;
    int count = 0;

    for (const auto &interval : intervals) {
        if (endTimes.size() < K) {
            endTimes.push(interval.end);
            count++;
        } else if (endTimes.top() <= interval.start) {
            endTimes.pop();
            endTimes.push(interval.end);
            count++;
        }
    }

    return count;
}

int maxUniformDuration(std::vector<Interval> &intervals, int K) {
    int low = 1, high = 100000;
    int maxDuration = 0;

    auto canScheduleAll = [&](int duration) {
        std::vector<int> endTimes(K, 0);
        for (const auto &interval : intervals) {
            bool scheduled = false;
            for (int &endTime : endTimes) {
                if (endTime <= interval.start) {
                    endTime = interval.start + duration;
                    scheduled = true;
                    break;
                }
            }
            if (!scheduled) return false;
        }
        return true;
    };

    while (low <= high) {
        int mid = (low + high) / 2;
        if (canScheduleAll(mid)) {
            maxDuration = mid;
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }

    return maxDuration;
}

int main() {
    std::ifstream infile("cursuri.in");
    std::ofstream outfile("cursuri.out");

    int C, N, K;
    infile >> C >> N >> K;

    std::vector<Interval> intervals(N);
    for (int i = 0; i < N; ++i) {
        infile >> intervals[i].start >> intervals[i].end;
    }

    if (C == 1) {
        outfile << maxCoursesScheduled(intervals, K) << '\n';
    } else if (C == 2) {
        outfile << maxUniformDuration(intervals, K) << '\n';
    }

    return 0;
}
```

### Explanation:
1. **Struct Definition**: We define a struct `Interval` to hold the start and end times.
2. **Comparison Function**: A comparison function `compareByEnd` is defined to sort intervals by their end time.
3. **Max Courses Scheduling Function**:
   - **Sorting**: We sort the intervals by their end time.
   - **Priority Queue**: We use a priority queue to keep track of the end times of scheduled courses.
   - **Logic**: For each interval, if there are less than `K` ongoing courses, we schedule it. Otherwise, if the earliest ending course ends before the start of the current course, we replace it.
4. **Max Uniform Duration Function**:
   - **Binary Search**: We use binary search to find the maximum possible uniform duration.
   - **Feasibility Check**: A lambda function `canScheduleAll` checks if all courses can be scheduled with a given uniform duration.
5. **Main Function**:
   - **Reading Input**: Read input from the file.
   - **Decision Based on `C`**: Depending on the value of `C`, call the appropriate function and write the result to the output file.
---------- user ----------


Program result did not match expected result.
Input data:
```
2
4 2
5 12
9 18
1 3
1 7
```
Expected output:
```
4
```
Found output:
```
0
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

Thank you for your feedback. It looks like there is a flaw in the previous implementation, particularly in the `maxUniformDuration` function. Let's correct this by taking a fresh approach to both parts of the problem.

### New Approach

1. **For Part 1 (Maximum Courses Scheduled):**
   - Use a greedy algorithm with a priority queue to keep track of ongoing courses in each classroom.

2. **For Part 2 (Maximum Uniform Duration):**
   - Use binary search to determine the maximum possible duration, while checking feasibility using a greedy approach with a priority queue.

### Revised Code

```cpp
#include <fstream>
#include <vector>
#include <algorithm>
#include <queue>
#include <iostream>

struct Interval {
    int start, end;
};

bool compareByEnd(const Interval &a, const Interval &b) {
    return a.end < b.end;
}

int maxCoursesScheduled(std::vector<Interval> &intervals, int K) {
    std::sort(intervals.begin(), intervals.end(), compareByEnd);
    std::priority_queue<int, std::vector<int>, std::greater<int>> endTimes;
    int count = 0;

    for (const auto &interval : intervals) {
        if (endTimes.size() < K) {
            endTimes.push(interval.end);
            count++;
        } else if (endTimes.top() <= interval.start) {
            endTimes.pop();
            endTimes.push(interval.end);
            count++;
        }
    }

    return count;
}

int maxUniformDuration(std::vector<Interval> &intervals, int K) {
    int low = 1, high = 100000;
    int maxDuration = 0;

    auto canScheduleAll = [&](int duration) {
        std::priority_queue<int, std::vector<int>, std::greater<int>> endTimes;
        for (const auto &interval : intervals) {
            while (!endTimes.empty() && endTimes.top() <= interval.start) {
                endTimes.pop();
            }
            if (endTimes.size() < K) {
                endTimes.push(interval.start + duration);
            } else {
                return false;
            }
        }
        return true;
    };

    while (low <= high) {
        int mid = (low + high) / 2;
        if (canScheduleAll(mid)) {
            maxDuration = mid;
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }

    return maxDuration;
}

int main() {
    std::ifstream infile("cursuri.in");
    std::ofstream outfile("cursuri.out");

    int C, N, K;
    infile >> C >> N >> K;

    std::vector<Interval> intervals(N);
    for (int i = 0; i < N; ++i) {
        infile >> intervals[i].start >> intervals[i].end;
    }

    if (C == 1) {
        outfile << maxCoursesScheduled(intervals, K) << '\n';
    } else if (C == 2) {
        std::sort(intervals.begin(), intervals.end(), [](const Interval &a, const Interval &b) { return a.start < b.start; });
        outfile << maxUniformDuration(intervals, K) << '\n';
    }

    return 0;
}
```

### Explanation of the Fix
1. **Sorting Intervals for Part 2:**
   - The intervals are sorted by their start time to ensure they are processed in the correct order.

2. **Feasibility Check (Part 2):**
   - When checking if all intervals can be scheduled with a given duration, the code now correctly handles removing expired courses from the priority queue, ensuring that the number of ongoing courses does not exceed `K`.

3. **Binary Search Logic:**
   - The binary search has been implemented correctly to find the maximum uniform duration, ensuring that all courses can be scheduled.

4. **Incorporating Sorting for Part 2:**
   - Added sorting by start time for intervals before performing the binary search for uniform duration.

### Verification
The revised solution should handle the given example correctly. The logic has been reimplemented to ensure the correct handling of intervals and room constraints. This should now produce the expected output.

