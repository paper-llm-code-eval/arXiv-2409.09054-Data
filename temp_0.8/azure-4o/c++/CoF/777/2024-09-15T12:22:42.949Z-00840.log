---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `virus.in` and write to `virus.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Pe Planeta ZUZU anul are $10 \ 000 \ 000$ zile, numerotate de la $1$ la $10 \ 000 \ 000$. La institutul de cercetări planetar, o grupă de specialişti au grijă de mai multe populaţii de viruşi. Pentru fiecare populaţie se alocă un interval de zile de lucru $[a, b]$, $a$ şi $b$ zile din anul zuzulian, în care se fac determinări asupra numărului de indivizi ai populaţiei, asupra formelor noi de viruşi apăruţi etc. Directorul institutului a constatat că există însă şi perioade în care nu se execută nici o cercetare, motiv pentru care l-a angajat pe Atomel, un statistician vestit, care trebuie să verifice perioada cea mai lungă de lucru în care cercetătorii sunt ocupaţi cu populaţiile de viruşi, precum şi cea mai lungă perioadă în care nu se face nici un studiu asupra viruşilor.

# Cerință

Fiind date numărul $n$ de intervale de lucru asupra populaţiilor de viruşi, precum şi pentru fiecare interval ziua de început şi cea de sfârşit a intervalului de lucru, să se determine care este cea mai lungă perioadă în care se lucrează asupra populaţiilor de viruşi, precum şi cea mai lungă perioadă în care nu se efectuează nici o observaţie asupra viruşilor.


# Date de intrare

Fişierul de intrare `virus.in` conţine pe prima linie o valoare n cu semnificaţia numărul de intervale date; pe următorele $n$ linii câte două valori separate prin spaţiu ce descriu un interval $[a, b]$ de lucru şi observaţii asupra populaţiilor de viruşi. Intervalele sunt date corect, $a<b$.

# Date de ieșire

Fişierul de ieşire `virus.out` conţine două valori separate printr-un spaţiu $L \ P$, unde $L$ reprezintă perioada cea mai lungă în care se fac cercetări asupra populaţiilor de viruşi, iar $P$ perioada cea mai lungă în care nu se fac observaţii. 

# Restricții și precizări

* $0 < n \leq 5 \ 000$;
* $1 \leq a, b \leq 10 \ 000 \ 000$; unde $a$ și $b$ descriu un interval de timp.

---

Example:
`virus.in`
```
3
700 1200
300 1000
1500 2100
```

`virus.out`
```
900 300
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:Sure, here's a step-by-step breakdown of the approach, followed by the corresponding C++ code.

**Approach:**
1. **Input Reading:**
    - Read from the file `virus.in`.
    - Parse the number of intervals `n`.
    - Parse the intervals `[a, b]`.

2. **Interval Merging:**
    - Sort the intervals based on their starting day `a`.
    - Merge overlapping and contiguous intervals to find the periods of continuous research.
    - While merging, keep track of the longest continuous research period.

3. **Finding Gaps:**
    - After merging the intervals, find the gaps between consecutive intervals to determine the longest period with no research.

4. **Output:**
    - Write the results to `virus.out`.

**Complexity Consideration:**
- Sorting the intervals takes `O(n log n)`.
- Merging the intervals and finding gaps is `O(n)`.

Here is the corresponding C++ code:

```cpp
#include <fstream>
#include <vector>
#include <algorithm>
#include <iostream>

struct Interval {
    int start;
    int end;
};

bool compareIntervals(const Interval& a, const Interval& b) {
    return a.start < b.start;
}

int main() {
    std::ifstream infile("virus.in");
    std::ofstream outfile("virus.out");
    
    int n;
    infile >> n;
    std::vector<Interval> intervals(n);
    
    for (int i = 0; i < n; ++i) {
        infile >> intervals[i].start >> intervals[i].end;
    }
    
    // Sort intervals based on the start time
    std::sort(intervals.begin(), intervals.end(), compareIntervals);
    
    int longestWorkPeriod = 0;
    int longestIdlePeriod = 0;
    
    // Initialize the first interval
    int currentStart = intervals[0].start;
    int currentEnd = intervals[0].end;
    longestWorkPeriod = currentEnd - currentStart;
    
    for (int i = 1; i < n; ++i) {
        if (intervals[i].start <= currentEnd) {
            // Merge intervals
            currentEnd = std::max(currentEnd, intervals[i].end);
        } else {
            // Calculate the idle period
            longestIdlePeriod = std::max(longestIdlePeriod, intervals[i].start - currentEnd);
            
            // Move to the next interval
            currentStart = intervals[i].start;
            currentEnd = intervals[i].end;
        }
        
        // Update the longest work period
        longestWorkPeriod = std::max(longestWorkPeriod, currentEnd - currentStart);
    }
    
    outfile << longestWorkPeriod << " " << longestIdlePeriod << std::endl;
    
    infile.close();
    outfile.close();
    
    return 0;
}
```

### Explanation of the Code:
1. **Reading Input:**
    - `ifstream` is used to read from `virus.in`.
    - The number of intervals `n` is read first.
    - Subsequent lines are read into a vector of `Interval` structs.

2. **Sorting Intervals:**
    - Intervals are sorted based on their start time using `std::sort`.

3. **Merging Intervals and Finding Gaps:**
    - We initialize `currentStart` and `currentEnd` with the start and end of the first interval.
    - Iterate through the sorted intervals:
        - If the current interval overlaps or touches the previous one, update `currentEnd`.
        - If it doesn't overlap, calculate the idle period and update the longest idle period if necessary.
        - Move the `currentStart` and `currentEnd` pointers to the new interval.
    - Throughout the process, keep updating the longest continuous work period.

4. **Output:**
    - Use `ofstream` to write the final result to `virus.out`.

This solution efficiently handles the intervals and calculates the required periods using sorting and a single pass through the data.
