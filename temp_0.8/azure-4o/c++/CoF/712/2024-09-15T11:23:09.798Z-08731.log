---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `numere.in` and write to `numere.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Gigel este un mare pasionat al cifrelor. Orice moment liber şi-l petrece jucându-se cu numere. Jucându-se astfel, într-o zi a scris pe hârtie $10$ numere distincte de câte două cifre şi a observat că printre acestea există două submulţimi disjuncte de sumă egală. Desigur, Gigel a crezut că este o întâmplare şi a scris alte $10$ numere distincte de câte două cifre şi spre surpriza lui, după un timp a găsit din nou două submulţimi disjuncte de sumă egală.

# Cerinţă
Date $10$ numere distincte de câte două cifre, determinaţi numărul de perechi de submulţimi **disjuncte** de sumă egală care se pot forma cu numere din cele date, precum şi una dintre aceste perechi pentru care suma numerelor din fiecare dintre cele două submulţimi este maximă.

# Date de intrare
Fişierul de intrare `numere.in` conţine pe prima linie $10$ numere naturale distincte separate prin câte un spaţiu $x_1$, $x_2$, $\dots$, $x_{10}$.

# Date de ieşire
Fişierul de ieşire `numere.out` conţine trei linii. Pe prima linie se află numărul de perechi de submulţimi de sumă egală şi suma maximă obţinută, separate printr-un spaţiu. Pe linia a doua se află elementele primei submulţimi separate prin câte un spațiu, iar pe linia a treia se află elementele celei de a doua submulţimi separate prin câte un spaţiu.

# Restricţii şi precizări
- $10 \leq x_i, y_i \leq 99$, pentru $1 \leq i \leq 10$
- $1 \leq k, p \leq 9$
- Ordinea submulţimilor în perechi nu contează.
- Perechea de submulţimi determinată nu este obligatoriu unică.

---

Example:
`numere.in`
```
60 49 86 78 23 97 69 71 32 10
```

`numere.out`
```
65 276
78 97 69 32
60 49 86 71 10
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:To tackle this problem efficiently in C++, we need to consider the following steps:

1. **Reading the Input**:
    - We'll read the ten distinct two-digit numbers from the file `numere.in`.
    
2. **Generating Subsets**:
    - Generate all possible non-empty subsets of these ten numbers.
    
3. **Checking for Disjoint Subsets with Equal Sums**:
    - For each pair of subsets, check if they are disjoint and if their sums are equal.
    - Track the number of such pairs and also keep the pair that has the maximum sum.
    
4. **Writing the Output**:
    - Write the results to the file `numere.out`.

To implement this efficiently, we'll use bit manipulation to generate subsets and a map to store the sums of subsets for quick lookup.

Here's the C++ solution:

```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <unordered_map>
#include <algorithm>

int main() {
    std::ifstream infile("numere.in");
    std::ofstream outfile("numere.out");

    std::vector<int> numbers(10);
    for (int i = 0; i < 10; ++i) {
        infile >> numbers[i];
    }

    std::unordered_map<int, std::vector<std::pair<int, std::vector<int>>>> sum_to_subsets;

    int max_sum = 0;
    int count = 0;
    std::pair<std::vector<int>, std::vector<int>> best_pair;

    int total_subsets = 1 << 10; // 2^10 subsets

    for (int i = 1; i < total_subsets; ++i) {
        int sum = 0;
        std::vector<int> subset;
        for (int j = 0; j < 10; ++j) {
            if (i & (1 << j)) {
                sum += numbers[j];
                subset.push_back(numbers[j]);
            }
        }
        sum_to_subsets[sum].push_back({i, subset});
    }

    for (auto &entry : sum_to_subsets) {
        auto &subsets = entry.second;
        int n = subsets.size();
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                if ((subsets[i].first & subsets[j].first) == 0) { // Disjoint check
                    ++count;
                    if (entry.first > max_sum) {
                        max_sum = entry.first;
                        best_pair = {subsets[i].second, subsets[j].second};
                    }
                }
            }
        }
    }

    outfile << count << " " << max_sum << "\n";
    for (int num : best_pair.first) {
        outfile << num << " ";
    }
    outfile << "\n";
    for (int num : best_pair.second) {
        outfile << num << " ";
    }
    outfile << "\n";

    return 0;
}
```

### Explanation:

1. **Reading Input**:
    - The numbers are read from `numere.in` into a vector named `numbers`.

2. **Generating Subsets and Storing Sums**:
    - Using bit manipulation, all subsets are generated.
    - For each subset, its sum and the subset itself are stored in a map `sum_to_subsets` where the key is the sum.

3. **Finding Disjoint Subset Pairs with Equal Sums**:
    - For each sum, we look at all pairs of subsets.
    - If the bitwise AND of their indices is zero, they are disjoint.
    - Count such pairs and track the pair with the maximum sum.

4. **Writing Output**:
    - The count and maximum sum are written to the file.
    - The elements of the two subsets with the maximum sum are also written.

This approach ensures that the solution is both efficient and correct, leveraging the power of bit manipulation and hashing for quick lookups.
---------- user ----------


Program result did not match expected result.
Input data:
```
60 49 86 78 23 97 69 71 32 10
```
Expected output:
```
65 276
78 97 69 32
60 49 86 71 10
```
Found output:
```
65 276
78 97 69 32 
60 49 86 71 10
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The provided solution indeed produces the correct result, but the issue seems to be related to the formatting of the output, especially around trailing spaces. The core logic of the solution is correct, but minor adjustments are needed to ensure the output format exactly matches the expected result.

Let's break this down:
1. **Output Formatting Issue**:
    - The output contains trailing spaces which are not expected in the actual result.

2. **Re-evaluating the Solution**:
    - The generation of subsets and checking disjoint subsets is correct.
    - We need to ensure no trailing spaces are present in the output.

Here's the revised C++ solution with proper formatting:

```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <unordered_map>
#include <algorithm>

int main() {
    std::ifstream infile("numere.in");
    std::ofstream outfile("numere.out");

    std::vector<int> numbers(10);
    for (int i = 0; i < 10; ++i) {
        infile >> numbers[i];
    }

    std::unordered_map<int, std::vector<std::pair<int, std::vector<int>>>> sum_to_subsets;

    int max_sum = 0;
    int count = 0;
    std::pair<std::vector<int>, std::vector<int>> best_pair;

    int total_subsets = 1 << 10; // 2^10 subsets

    for (int i = 1; i < total_subsets; ++i) {
        int sum = 0;
        std::vector<int> subset;
        for (int j = 0; j < 10; ++j) {
            if (i & (1 << j)) {
                sum += numbers[j];
                subset.push_back(numbers[j]);
            }
        }
        sum_to_subsets[sum].push_back({i, subset});
    }

    for (auto &entry : sum_to_subsets) {
        auto &subsets = entry.second;
        int n = subsets.size();
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                if ((subsets[i].first & subsets[j].first) == 0) { // Disjoint check
                    ++count;
                    if (entry.first > max_sum) {
                        max_sum = entry.first;
                        best_pair = {subsets[i].second, subsets[j].second};
                    }
                }
            }
        }
    }

    outfile << count << " " << max_sum << "\n";
    
    for (size_t i = 0; i < best_pair.first.size(); ++i) {
        outfile << best_pair.first[i];
        if (i != best_pair.first.size() - 1) {
            outfile << " ";
        }
    }
    outfile << "\n";
    
    for (size_t i = 0; i < best_pair.second.size(); ++i) {
        outfile << best_pair.second[i];
        if (i != best_pair.second.size() - 1) {
            outfile << " ";
        }
    }
    outfile << "\n";

    return 0;
}
```

### Explanation:

1. **Reading Input**:
    - The ten distinct two-digit numbers are read from `numere.in` into a vector.

2. **Generating Subsets and Storing Sums**:
    - Using bit manipulation, all subsets are generated, and their sums are stored in a map.

3. **Finding Disjoint Subset Pairs with Equal Sums**:
    - For each subset sum, pairs of disjoint subsets with the same sum are identified.
    - The count of such pairs is maintained, and the pair with the maximum sum is tracked.

4. **Writing Output**:
    - The count and maximum sum are written to `numere.out`.
    - The elements of the two subsets with the maximum sum are written without trailing spaces.

By ensuring no trailing spaces in the output, this solution aligns with the expected result format. The logic has been kept intact as it correctly identifies disjoint subsets with equal sums and tracks the pair with the maximum sum.
