---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `tai.in` and write to `tai.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Un număr este prim dacă are exact doi divizori naturali. Prin tăierea unui număr în $p$ părți înțelegem împărțirea acestuia în $p$ numere, fiecare de cel puțin o cifră, astfel încât prin alipirea numerelor obținute de la stânga la dreapta obținem numărul inițial.

De exemplu, dacă împărțim numărul $12045$ în două părți avem patru variante de tăiere obținându-se numerele: $1$ și $2045$; $12$ și $045$; $120$ și $45$; $1204$ și $5$. Dacă îl împărțim în trei părți avem șase variante de tăiere obținându-se numerele $1$, $2$ și $045$; $1$, $20$ și $45$; $1$, $204$ și $5$; $12$, $0$ și $45$; $12$, $04$ și $5$; $120$, $4$ și $5$.

# Cerință

Se consideră un șir format din $N$ numere naturale.

1. Determinați cel mai mare număr prim din șirul celor $N$ numere.
2. Determinați cel mai mare număr prim dintre cele obținute prin tăierea în două părți a fiecărui număr din șirul celor $N$.
3. Determinați cel mai mare număr prim dintre cele obținute prin tăierea în trei părți a fiecărui număr din șirul celor $N$.

# Date de intrare


Pe prima linie a fișierului `tai.in` se găsește numărul $C$ care poate avea doar valorile $1$, $2$ sau $3$ și reprezintă cerința care urmează a fi rezolvată. Pe a doua linie se găsește $N$, cu semnificația din enunț, iar pe a treia linie se găsește șirul celor $N$ numere naturale despărțite prin câte un spațiu.


# Date de ieșire


În fișierul de ieșire `tai.out` pe prima linie se va afișa un număr natural reprezentând răspunsul la cerința specificată.


# Restricții și precizări

* $1 \leq N \leq 100$;
* $0 \leq$ orice număr din șir $\leq 10^9$;
* Pentru cerințele $2$ și $3$ se garantează că pentru toate numerele din șir se poate efectua tăierea
* Pentru cerința $1$ dacă șirul nu conține numere prime se va afișa $0$
* Pentru cerințele $2$ și $3$ dacă în urma tăierilor nu se obține niciun număr prim, se va afișa $0$
* Pentru rezolvarea fiecărei cerințe se obțin $30$ de puncte.

---

Example:
`tai.in`
```
1
5
2 13 21 17 1
```

`tai.out`
```
17
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:Sure, I'll outline the approach and then provide the C++ code for the challenge.

### Approach

1. **Read Input:**
   - Read the value of \( C \) which defines the requirement (1, 2, or 3).
   - Read the value of \( N \) which is the number of numbers in the series.
   - Read the series of \( N \) numbers.

2. **Helper Functions:**
   - **Check if a number is prime:** A function to check if a given number is prime.
   - **Split number into parts:** Functions to split a number into two or three parts and check for the maximum prime in those parts.

3. **Main Logic Based on \( C \):**
   - **For \( C = 1 \):** Find the maximum prime in the series.
   - **For \( C = 2 \):** For each number in the series, split it into two parts and find the maximum prime among all possible splits.
   - **For \( C = 3 \):** For each number in the series, split it into three parts and find the maximum prime among all possible splits.

4. **Output the Result:**
   - Write the result to `tai.out`.

### C++ Code

```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <cmath>
#include <algorithm>

bool isPrime(int num) {
    if (num <= 1) return false;
    if (num <= 3) return true;
    if (num % 2 == 0 || num % 3 == 0) return false;
    for (int i = 5; i * i <= num; i += 6) {
        if (num % i == 0 || num % (i + 2) == 0) return false;
    }
    return true;
}

void findMaxPrime(const std::vector<int>& numbers, int& maxPrime) {
    for (int num : numbers) {
        if (isPrime(num)) {
            maxPrime = std::max(maxPrime, num);
        }
    }
}

void findMaxPrimeSplitTwo(const std::vector<int>& numbers, int& maxPrime) {
    for (int num : numbers) {
        std::string str = std::to_string(num);
        int len = str.length();
        for (int i = 1; i < len; ++i) {
            int left = std::stoi(str.substr(0, i));
            int right = std::stoi(str.substr(i));
            if (isPrime(left)) maxPrime = std::max(maxPrime, left);
            if (isPrime(right)) maxPrime = std::max(maxPrime, right);
        }
    }
}

void findMaxPrimeSplitThree(const std::vector<int>& numbers, int& maxPrime) {
    for (int num : numbers) {
        std::string str = std::to_string(num);
        int len = str.length();
        for (int i = 1; i < len; ++i) {
            for (int j = i + 1; j < len; ++j) {
                int left = std::stoi(str.substr(0, i));
                int middle = std::stoi(str.substr(i, j - i));
                int right = std::stoi(str.substr(j));
                if (isPrime(left)) maxPrime = std::max(maxPrime, left);
                if (isPrime(middle)) maxPrime = std::max(maxPrime, middle);
                if (isPrime(right)) maxPrime = std::max(maxPrime, right);
            }
        }
    }
}

int main() {
    std::ifstream infile("tai.in");
    std::ofstream outfile("tai.out");

    int C, N;
    infile >> C >> N;

    std::vector<int> numbers(N);
    for (int i = 0; i < N; ++i) {
        infile >> numbers[i];
    }

    int maxPrime = 0;

    if (C == 1) {
        findMaxPrime(numbers, maxPrime);
    } else if (C == 2) {
        findMaxPrimeSplitTwo(numbers, maxPrime);
    } else if (C == 3) {
        findMaxPrimeSplitThree(numbers, maxPrime);
    }

    outfile << maxPrime << "\n";

    infile.close();
    outfile.close();
    return 0;
}
```

### Explanation

1. **isPrime Function:** Efficiently checks if a number is prime.
2. **Helper Functions:** `findMaxPrime`, `findMaxPrimeSplitTwo`, and `findMaxPrimeSplitThree` handle the logic for the three cases.
3. **Main Function:**
   - Reads input.
   - Executes the required function based on \( C \).
   - Outputs the result.

This solution ensures efficient reading, processing, and writing, and it handles the constraints effectively.
