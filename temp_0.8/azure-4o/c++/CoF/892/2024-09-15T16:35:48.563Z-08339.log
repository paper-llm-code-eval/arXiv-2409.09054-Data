---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `tnia.in` and write to `tnia.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Se dă o matrice **binară** cu $n$ coloane și $m$ linii. Coloanele sunt numerotate de la stânga la dreapta cu valori de la $1$ la $n$, iar liniile sunt numerotate **de jos în sus** cu valori de la $1$ la $m$.

Matricea dată are o formă particulară, astfel că pentru fiecare coloană $i$ de la $1$ la $n$ toate elementele matricei de pe coloana respectivă au valoarea $1$ pentru toate liniile cuprinse în intervalul $[1, h_i]$ și în rest valoarea $0$. Valorile $h_i$ sunt numere naturale date în ordine crescătoare $(h_{i-1} \leq h_i$, $1 \leq i \leq n$).

# Cerință
Să se răspundă la $q$ întrebări de forma: dându-se numerele $A$, $B$, $C$, $D$ se cere suma elementelor din submatricea determinată de zona dreptunghiulară având colțul stânga-jos în coloana $A$ și linia $B$, iar colțul dreapta-sus în coloana $C$ și linia $D$.

# Date de intrare
Fișierul de intrare este `tnia.in`.
- pe prima linie se găsesc două numere naturale $n$ și $m$ despărțite printr-un spațiu, cu semnificația de mai sus;
- pe a doua linie sunt cele $n$ elemente $h_i$ ale vectorului despărțite prin câte un spațiu;
- pe a treia linie este un număr natural $q$ ce reprezintă numărul de întrebări;
- pe următoarele $q$ linii se găsesc câte 4 numere $A$, $B$, $C$, $D$ cu semnificația de mai sus, despărțite prin câte un spațiu.

# Date de ieşire
Fișierul de ieșire `tnia.out` va conține $q$ linii reprezentând răspunsul pentru fiecare întrebare.

# Restricţii și precizări
- $0 \leq h_i \leq m$
- $1 \leq n \leq 100\ 000$
- $1 \leq q \leq 100\ 000$
- $1 \leq m \leq 1\ 000\ 000\ 000$
- Pentru 15 puncte: $n, m, q \leq 100$.
- Pentru alte 16 puncte: $n, m, q \leq 3\ 000$.
- Pentru alte 16 puncte: $n \leq 100\ 000$, $m \leq 1\ 000\ 000\ 000$, $q \leq 100$.
- Pentru rezolvarea corectă a cerinței se acordă 90 de puncte.
- Din oficiu se acordă 10 puncte.

---

Example:
`tnia.in`
```
5 10
2 3 7 8 10
5
1 1 5 10
2 5 4 7
3 2 3 6
3 8 3 10
3 2 3 10
```

`tnia.out`
```
30
6
5
0
6
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:Let's break down the problem and devise an efficient solution step-by-step:

### Step-by-Step Plan

1. **Input Reading**: 
   - Read from `tnia.in` file.
   - First line contains the integers `n` (number of columns) and `m` (number of rows).
   - Second line contains `n` integers representing the heights `h_i` of the columns.
   - Third line contains the number `q` indicating the number of queries.
   - The next `q` lines each contain four integers `A`, `B`, `C`, `D` representing the coordinates of the submatrix.

2. **Data Structure**:
   - Store `h_i` in a vector of size `n`.

3. **Query Processing**:
   - For each query, calculate the sum of elements in the specified submatrix.
   - The sum calculation needs to be efficient, given the constraints.

### Efficient Approach
Given the constraints, we need an approach that avoids constructing the matrix explicitly due to its potentially massive size (`m` up to 1 billion). Instead, we can leverage the properties of the matrix and the ordered nature of `h_i`:

- For each query, determine the contribution of each column within the submatrix.
- Sum up contributions for columns `A` to `C`, considering the heights specified in `h_i`.

### Implementation in C++

```cpp
#include <iostream>
#include <fstream>
#include <vector>
using namespace std;

int main() {
    ifstream infile("tnia.in");
    ofstream outfile("tnia.out");
    
    int n, m;
    infile >> n >> m;
    vector<int> h(n);
    
    for (int i = 0; i < n; ++i) {
        infile >> h[i];
    }
    
    int q;
    infile >> q;
    
    while (q--) {
        int A, B, C, D;
        infile >> A >> B >> C >> D;
        
        long long sum = 0;
        for (int i = A-1; i <= C-1; ++i) {
            int height = h[i];
            if (height >= B) {
                sum += (min(height, D) - B + 1);
            }
        }
        
        outfile << sum << "\n";
    }
    
    infile.close();
    outfile.close();
    
    return 0;
}
```

### Explanation of the Code

1. **Reading Input**: 
   - We use `ifstream` to read the input from `tnia.in`.
   - The first line contains `n` and `m`, which are read into their respective variables.
   - The second line contains the heights of the columns, which are stored in a vector `h`.

2. **Processing Queries**:
   - For each query, we read the coordinates `A`, `B`, `C`, `D`.
   - We then calculate the sum of elements in the specified submatrix by iterating from column `A` to `C`.
   - For each column `i`, if `h[i]` is greater than or equal to `B`, we calculate the contribution of that column to the sum. The contribution is the number of `1`s in that column within the bounds specified by `B` and `D`.

3. **Output Results**:
   - We write the results to `tnia.out` using `ofstream`.

This approach ensures efficient processing of the input and queries without explicitly constructing a potentially massive matrix. The complexity is kept manageable by leveraging the properties of the matrix and the constraints given.
