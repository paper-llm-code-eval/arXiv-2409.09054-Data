---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `tnia.in` and write to `tnia.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Se dă o matrice **binară** cu $n$ coloane și $m$ linii. Coloanele sunt numerotate de la stânga la dreapta cu valori de la $1$ la $n$, iar liniile sunt numerotate **de jos în sus** cu valori de la $1$ la $m$.

Matricea dată are o formă particulară, astfel că pentru fiecare coloană $i$ de la $1$ la $n$ toate elementele matricei de pe coloana respectivă au valoarea $1$ pentru toate liniile cuprinse în intervalul $[1, h_i]$ și în rest valoarea $0$. Valorile $h_i$ sunt numere naturale date în ordine crescătoare $(h_{i-1} \leq h_i$, $1 \leq i \leq n$).

# Cerință
Să se răspundă la $q$ întrebări de forma: dându-se numerele $A$, $B$, $C$, $D$ se cere suma elementelor din submatricea determinată de zona dreptunghiulară având colțul stânga-jos în coloana $A$ și linia $B$, iar colțul dreapta-sus în coloana $C$ și linia $D$.

# Date de intrare
Fișierul de intrare este `tnia.in`.
- pe prima linie se găsesc două numere naturale $n$ și $m$ despărțite printr-un spațiu, cu semnificația de mai sus;
- pe a doua linie sunt cele $n$ elemente $h_i$ ale vectorului despărțite prin câte un spațiu;
- pe a treia linie este un număr natural $q$ ce reprezintă numărul de întrebări;
- pe următoarele $q$ linii se găsesc câte 4 numere $A$, $B$, $C$, $D$ cu semnificația de mai sus, despărțite prin câte un spațiu.

# Date de ieşire
Fișierul de ieșire `tnia.out` va conține $q$ linii reprezentând răspunsul pentru fiecare întrebare.

# Restricţii și precizări
- $0 \leq h_i \leq m$
- $1 \leq n \leq 100\ 000$
- $1 \leq q \leq 100\ 000$
- $1 \leq m \leq 1\ 000\ 000\ 000$
- Pentru 15 puncte: $n, m, q \leq 100$.
- Pentru alte 16 puncte: $n, m, q \leq 3\ 000$.
- Pentru alte 16 puncte: $n \leq 100\ 000$, $m \leq 1\ 000\ 000\ 000$, $q \leq 100$.
- Pentru rezolvarea corectă a cerinței se acordă 90 de puncte.
- Din oficiu se acordă 10 puncte.

---

Example:
`tnia.in`
```
5 10
2 3 7 8 10
5
1 1 5 10
2 5 4 7
3 2 3 6
3 8 3 10
3 2 3 10
```

`tnia.out`
```
30
6
5
0
6
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:To solve the problem efficiently, the main points to consider are:

1. **Input Handling**: Since the constraints are large, efficient input handling is crucial. We will use file streams to read the data.
2. **Preprocessing**: We need to quickly determine the height ranges where the values are 1 for any given column. Because the heights \( h_i \) are increasing, we can use this property to our advantage.
3. **Query Processing**: For each query, we need to compute the sum of the binary submatrix, which requires calculating the number of 1s in a given range efficiently.

Here is a step-by-step breakdown of the solution:

1. **Reading Input**: We will read the matrix dimensions \( n \) and \( m \), the heights \( h \), the number of queries \( q \), and the queries themselves from `tnia.in`.
2. **Handling Queries**: For each query, we will determine the number of 1s in the specified submatrix by leveraging the property of the increasing heights \( h \). Specifically, for each column in the range [A, C], we will count the number of rows in the range [B, D] that have a value of 1.

Here is the C++ solution:

```cpp
#include <fstream>
#include <vector>

int main() {
    // Reading input from file
    std::ifstream inFile("tnia.in");
    std::ofstream outFile("tnia.out");

    int n, m;
    inFile >> n >> m;
    
    std::vector<int> heights(n);
    for (int i = 0; i < n; ++i) {
        inFile >> heights[i];
    }
    
    int q;
    inFile >> q;
    
    while (q--) {
        int A, B, C, D;
        inFile >> A >> B >> C >> D;
        
        int sum = 0;
        for (int i = A - 1; i <= C - 1; ++i) {
            if (heights[i] >= B) {
                sum += std::min(heights[i], D) - B + 1;
            }
        }
        
        outFile << sum << '\n';
    }

    // Closing the file streams
    inFile.close();
    outFile.close();
    
    return 0;
}
```

### Explanation:
1. **Input Reading**:
   - `n` and `m` are read first.
   - `heights` is a vector of size `n` to store the heights \( h_i \).
   - The number of queries `q` is read next.
   - Each query consists of four integers: `A`, `B`, `C`, `D`.

2. **Handling Each Query**:
   - For each query, initialize `sum` to 0.
   - Iterate over each column in the range `[A, C]`.
   - For each column, if the height `h_i` is greater than or equal to `B`, calculate the number of rows in the range `[B, D]` that have a value of 1. This is done using `std::min(heights[i], D) - B + 1`.
   - Accumulate this count into `sum`.

3. **Output**:
   - Write the computed sum for each query to `tnia.out`.

This solution efficiently reads the input, processes each query in linear time relative to the number of columns in the query, and writes the results. This ensures the solution is both correct and performant under the given constraints.
