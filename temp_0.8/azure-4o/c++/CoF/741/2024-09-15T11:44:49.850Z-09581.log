---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `ocr.in` and write to `ocr.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

O imagine va fi reprezentată ca un tablou dreptunghiular de numere reale, fiecare număr reprezentând o valoare pe scala de gri a imaginii. Valorile sunt cuprinse între $0$ (corespunzând unei regiuni total albe) și $1$ (pentru zona total neagră), cu două zecimale.
Centrul de gravitate al imaginii este un element al tabloului. Să presupunem că el se află pe linia $i$ și coloana $j$. Atunci diferența, în modul, dintre suma elementelor din zona aflată deasupra liniei $i$ și suma elementelor din zona aflată sub linia $i$, este minimă. În mod analog, pentru această diferență minimă, diferența, în modul, dintre suma elementelor din stânga coloanei $j$ și suma elementelor din dreapta coloanei $j$ trebuie să fie de asemenea minimă.
Să considerăm ca exemplu următorul tabloul care poate proveni din scanarea literei mici ‘o’. Centrul de gravitate este pe linia $3$ și coloana $3$, deoarece diferența sumelor elementelor din fiecare zonă formată ignorând linia a treia este $0.1$ (sumele sunt $5.55$ și $5.65$) și de asemenea, diferența sumelor elementelor fiecărei zone formate ignorând coloana a treia este $0.1$ (sumele sunt $5.60$ și $5.70$).

~[ocr.png|width=30em]

# Cerință

Scrieți un program care să determine centrul de gravitate al unei imagini scanate.

# Date de intrare

Fișierul text de intrare `ocr.in` conține reprezentarea unei imagini. Prima linie a fișierului de intrare conține două valori naturale $n$ și $m$ separate printr-un spațiu reprezentând numărul de linii și respectiv numărul de coloane ale tabloului. Urmează $n$ linii, fiecare conținând câte $m$ numere reale din intervalul [$0, 1$] separate prin câte un spațiu, reprezentând imaginea scanată.

# Date de ieșire

Fișierul de ieșire `ocr.out` va conține o singură linie pe care se găsesc două numere naturale $l$ și $c$, separate printr-un spațiu, reprezentând coordonatele (linie, coloană) centrului de gravitate. În cazul în care sunt determinate mai multe centre de gravitate, se vor afișa coordonatele celui cu indicele de linie maxim; dacă există mai multe centre de gravitate pe aceeași linie, se va afișa cel cu indicele de coloană maxim.

# Restricții și precizări

* $1 \leq n, m \leq 50$;
* Valorile reale sunt exprimate cu maximum două zecimale
* Liniile sunt numerotate de la $1$ la $n$ (de sus în jos), iar coloanele de la $1$ la $m$ (de la stânga la dreapta).

---

Example:
`ocr.in`
```
5 5
0.1 0.2 0.1 0.2 0.1
0.1 0.2 0.3 0.1 0.1
0.2 0.3 0.1 0.1 0.3
0.4 0.1 0.1 0.1 0.2
0.2 0.2 0.3 0.3 0.1
```

`ocr.out`
```
3 3
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```cpp
#include <fstream>
#include <vector>
#include <cmath>
using namespace std;

// Function to calculate the sum of a specific row
double sumRow(const vector<vector<double>> &matrix, int row) {
    double sum = 0;
    for (double val : matrix[row]) {
        sum += val;
    }
    return sum;
}

// Function to calculate the sum of a specific column
double sumCol(const vector<vector<double>> &matrix, int col) {
    double sum = 0;
    for (const auto &row : matrix) {
        sum += row[col];
    }
    return sum;
}

int main() {
    ifstream inFile("ocr.in");
    ofstream outFile("ocr.out");

    int n, m;
    inFile >> n >> m;
    vector<vector<double>> matrix(n, vector<double>(m));

    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            inFile >> matrix[i][j];
        }
    }

    // Precompute row and column sums
    vector<double> rowSums(n, 0), colSums(m, 0);
    for (int i = 0; i < n; ++i) {
        rowSums[i] = sumRow(matrix, i);
    }
    for (int j = 0; j < m; ++j) {
        colSums[j] = sumCol(matrix, j);
    }

    pair<int, int> bestCenter = {0, 0};
    double minRowDiff = 1e9, minColDiff = 1e9;

    for (int i = 0; i < n; ++i) {
        double sumAbove = 0, sumBelow = 0;
        for (int r = 0; r < i; ++r) sumAbove += rowSums[r];
        for (int r = i + 1; r < n; ++r) sumBelow += rowSums[r];
        double rowDiff = abs(sumAbove - sumBelow);

        for (int j = 0; j < m; ++j) {
            double sumLeft = 0, sumRight = 0;
            for (int c = 0; c < j; ++c) sumLeft += colSums[c];
            for (int c = j + 1; c < m; ++c) sumRight += colSums[c];
            double colDiff = abs(sumLeft - sumRight);

            if ((rowDiff < minRowDiff) || (rowDiff == minRowDiff && colDiff < minColDiff) ||
                (rowDiff == minRowDiff && colDiff == minColDiff && (i > bestCenter.first || (i == bestCenter.first && j > bestCenter.second)))) {
                minRowDiff = rowDiff;
                minColDiff = colDiff;
                bestCenter = {i, j};
            }
        }
    }

    outFile << bestCenter.first + 1 << " " << bestCenter.second + 1 << endl;

    inFile.close();
    outFile.close();

    return 0;
}
```

- **Explanation**:
    - I first read the input from the file `ocr.in` and populate the 2D matrix.
    - I compute the sum of each row and each column.
    - I then iterate over each possible center `(i, j)`:
        - For each center, I compute the difference in sums of rows above and below the center.
        - For each column, I compute the difference in sums of columns to the left and right of the center.
    - I track the center that minimizes these differences while following the constraints for ties.
    - Finally, I write the center to `ocr.out`.

This ensures the program runs efficiently within the constraints and produces the correct output.
