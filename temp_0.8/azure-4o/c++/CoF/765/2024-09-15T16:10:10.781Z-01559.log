---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `excel.in` and write to `excel.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Gigel, elev în clasa a VII-a, pasionat de aplicațiile informatice, s-a gândit să-și facă un program care să simuleze cunoscutul produs Excel. Zis și făcut, s-a pus pe treabă și într-o oră a reușit să realizeze un program asemănător Excel-ului, dar care, spre deosebire de original, nu poate face decât o singură operație în celulele sale: suma. Încercați și dumneavoastră să realizați isprava lui Gigel!
Reamintim că o foaie de calcul în Excel se prezintă sub forma unei suprafețe liniate cu linii orizontale și verticale. Prin intersecția lor rezultă dreptunghiuri (numite celule), fiecare celulă având un nume format dintr-o literă și un număr, reprezentând coloana, respectiv linia pe care se află.

~[excel.png|align=center|width=45em]

De exemplu, celula din stânga sus este $A1$, urmată, pe linie, de $B1, C1$, etc. Introducerea unei formule într-o celulă începe întotdeauna cu semnul `=`. De exemplu dacă în celula `C2` scriem `=A2+B2` înseamnă că în această celulă se va scrie rezultatul adunării valorilor din celulele $A2$ și $B2$. Pot exista și celule cu formula `=A5` ceea ce înseamnă că în celula respectivă vom avea un rezultat egal cu cel din celula $A5$. Fiind abia la început și în ceea ce privește programarea și în ceea ce privește aplicația Excel, Gigel se gândește ca programul său să completeze celulele începând cu prima coloană, apoi a doua etc., astfel că formulele care pot apărea în celula ($col$, $lin$) pot folosi datele din coloanele $1$ până la $col-1$ și din celulele aflate pe liniile $1$ până la $lin-1$ din coloana $col$.

# Cerință

Dându-se o foaie de calcul să se înlocuiască toate formulele care apar, prin rezultatele obținute respectând cerințele date în text.

# Date de intrare

Fișierul `excel.in` are pe prima linie două valori $m \ n$, separate printr-un spațiu, reprezentând numărul de coloane, respectiv de linii ale foii de calcul. Pe următoarele $n$ linii se descriu cele $m$ coloane ale foii. O descriere poate fi formată din valori întregi pozitive sau formule separate printr-un singur spațiu. Formulele sunt șiruri de caractere care încep întotdeauna cu semnul `=`. Fișierul de intrare se consideră corect, în sensul că operațiile care apar se pot executa, iar foaia de calcul se poate completa.

# Date de ieșire

Fișierul `excel.out` va conține $n$ linii, pe fiecare linie câte $m$ valori reprezentând rezultatul final al operațiilor realizate în foaia de calcul.

# Restricții și precizări

* $0$ < numărul de coloane $\leq 26$, notate de la `A` la `Z`;
* $0$ < numărul de linii $\leq 50$;
* fiecare linie ce descrie foaia Excel are o lungime maximă $< 256$;
* fiecare valoare numerică din foaia de calcul inițială este un număr pozitiv $\leq 100$;
* formulele care pot să apară în celule se referă doar la operația de adunare.

---

Example:
`excel.in`
```
4 3
11 21 =A1+A2 =A3
10 15 =B1+B2 =A2+B1
=A1+A2 14 21 3
```

`excel.out`
```
11 21 21 21
10 15 36 31
21 14 21 3
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:To tackle this problem, we need to read the input file and process each cell in the spreadsheet based on its content, which could either be an integer or a formula. We will then replace the formulas with their evaluated values and output the final spreadsheet. Let's break it down:

1. **Reading the Input:** 
   We need to read the dimensions of the spreadsheet and the contents of each cell. 

2. **Processing the Cells:**
   - If a cell contains an integer, we store it as is.
   - If a cell contains a formula, we need to evaluate it based on the values of the referenced cells.

3. **Evaluating Formulas:**
   - Formulas are of the form `=A1+A2` (cell references).
   - We need to convert these references into indices to access the values from the spreadsheet.

4. **Outputting the Result:**
   - After evaluating all cells, write the results to the output file.

We'll use a 2D vector to store the spreadsheet values and a helper function to evaluate the formulas.

Here is the C++ code for the solution:

```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <sstream>
#include <string>
#include <cctype>

using namespace std;

int getValue(const vector<vector<int>>& sheet, const string& cell) {
    int row = stoi(cell.substr(1)) - 1;
    int col = cell[0] - 'A';
    return sheet[row][col];
}

int evaluateFormula(const vector<vector<int>>& sheet, const string& formula) {
    string left = formula.substr(1, formula.find('+') - 1);
    string right = formula.substr(formula.find('+') + 1);
    return getValue(sheet, left) + getValue(sheet, right);
}

int main() {
    ifstream inFile("excel.in");
    ofstream outFile("excel.out");
    
    if (!inFile || !outFile) {
        cerr << "Error opening file." << endl;
        return 1;
    }
    
    int m, n;
    inFile >> m >> n;
    vector<vector<int>> sheet(n, vector<int>(m));
    vector<vector<string>> inputSheet(n, vector<string>(m));
    
    inFile.ignore();
    for (int i = 0; i < n; ++i) {
        string line;
        getline(inFile, line);
        istringstream iss(line);
        for (int j = 0; j < m; ++j) {
            iss >> inputSheet[i][j];
        }
    }
    
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            if (isdigit(inputSheet[i][j][0])) {
                sheet[i][j] = stoi(inputSheet[i][j]);
            } else if (inputSheet[i][j][0] == '=') {
                sheet[i][j] = evaluateFormula(sheet, inputSheet[i][j]);
            }
        }
    }
    
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            outFile << sheet[i][j];
            if (j < m - 1) outFile << " ";
        }
        outFile << endl;
    }
    
    inFile.close();
    outFile.close();
    return 0;
}
```

### Explanation:

1. **Reading Input:**
   - First, we read the number of columns (`m`) and rows (`n`).
   - We then read the entire spreadsheet into a `vector<vector<string>>` to handle both integers and formulas as strings.

2. **Processing Cells:**
   - For each cell, if it’s a digit, we convert it to an integer.
   - If it’s a formula (starting with `=`), we evaluate it by extracting the referenced cells and summing their values.

3. **Evaluating Formulas:**
   - `getValue` function converts a cell reference like `A1` to its corresponding value in the sheet.
   - `evaluateFormula` extracts the cell references in the formula, converts them to indices using `getValue`, and calculates the sum.

4. **Outputting the Result:**
   - After processing all cells, we write the final values to the output file.

This approach ensures we efficiently read, process, and output the required spreadsheet data.
---------- user ----------


Program exited with code 139.
stdout:
```

```
stderr:
```
terminate called after throwing an instance of 'std::invalid_argument'
  what():  stoi

```

Think of what has caused the exit code. Use the standard out and standard error to help you understand the issue.
Implement a solution to fix the program

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The error message indicates that the program tried to convert a string to an integer using `stoi`, and it encountered an invalid argument. This is likely because some cells that start with `=` were not being properly checked or handled.

Let's fix the issues step by step:

1. **Ensure proper reading of input and ignore whitespace correctly**: When reading the input, make sure to handle rows and columns correctly.
2. **Properly check and handle formula cells**: Ensure that the string handling correctly identifies and processes formula cells.

Here's the corrected solution:

```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <sstream>
#include <string>
#include <cctype>

using namespace std;

int getValue(const vector<vector<int>>& sheet, const string& cell) {
    int row = stoi(cell.substr(1)) - 1;
    int col = cell[0] - 'A';
    return sheet[row][col];
}

int evaluateFormula(const vector<vector<int>>& sheet, const string& formula) {
    string left = formula.substr(1, formula.find('+') - 1);
    string right = formula.substr(formula.find('+') + 1);
    return getValue(sheet, left) + getValue(sheet, right);
}

int main() {
    ifstream inFile("excel.in");
    ofstream outFile("excel.out");
    
    if (!inFile || !outFile) {
        cerr << "Error opening file." << endl;
        return 1;
    }
    
    int m, n;
    inFile >> m >> n;
    
    // Ignore the rest of the line after reading m and n
    inFile.ignore(numeric_limits<streamsize>::max(), '\n');

    vector<vector<int>> sheet(n, vector<int>(m, 0));
    vector<vector<string>> inputSheet(n, vector<string>(m));
    
    for (int i = 0; i < n; ++i) {
        string line;
        getline(inFile, line);
        istringstream iss(line);
        for (int j = 0; j < m; ++j) {
            iss >> inputSheet[i][j];
        }
    }

    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            if (isdigit(inputSheet[i][j][0]) || inputSheet[i][j][0] == '-') {
                sheet[i][j] = stoi(inputSheet[i][j]);
            } else if (inputSheet[i][j][0] == '=') {
                try {
                    sheet[i][j] = evaluateFormula(sheet, inputSheet[i][j]);
                } catch (const exception& e) {
                    cerr << "Error evaluating formula: " << inputSheet[i][j] << " at cell (" << i << ", " << j << ")" << endl;
                    return 1;
                }
            }
        }
    }

    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            outFile << sheet[i][j];
            if (j < m - 1) outFile << " ";
        }
        outFile << endl;
    }
    
    inFile.close();
    outFile.close();
    return 0;
}
```

### Explanation of Fixes:

1. **Ignore the rest of the line after reading `m` and `n`**: Ensure that after reading the number of rows and columns, we ignore any additional characters on that line to correctly process subsequent lines.
   
2. **Handle negative numbers**: Checking if the first character is a digit or a negative sign before converting the string to an integer.

3. **Error Handling**: Adding a try-catch block around the formula evaluation to catch any potential errors that could arise from invalid formulas.

4. **Default Initialization**: Initializing the `sheet` vector with default values (0) to handle cases where the input might not fill all cells.

This solution should correctly handle the input and output for the given problem while avoiding the `std::invalid_argument` exception from `stoi`.
---------- user ----------


Failed to compile the program.
```
main.cpp: In function 'int main()':
main.cpp:35:19: error: 'numeric_limits' was not declared in this scope
   35 |     inFile.ignore(numeric_limits<streamsize>::max(), '\n');
      |                   ^~~~~~~~~~~~~~
main.cpp:35:44: error: expected primary-expression before '>' token
   35 |     inFile.ignore(numeric_limits<streamsize>::max(), '\n');
      |                                            ^
main.cpp:35:50: error: no matching function for call to 'max()'
   35 |     inFile.ignore(numeric_limits<streamsize>::max(), '\n');
      |                                             ~~~~~^~
In file included from /usr/local/include/c++/11.4.0/bits/char_traits.h:39,
                 from /usr/local/include/c++/11.4.0/ios:40,
                 from /usr/local/include/c++/11.4.0/ostream:38,
                 from /usr/local/include/c++/11.4.0/iostream:39,
                 from main.cpp:1:
/usr/local/include/c++/11.4.0/bits/stl_algobase.h:254:5: note: candidate: 'template<class _Tp> constexpr const _Tp& std::max(const _Tp&, const _Tp&)'
  254 |     max(const _Tp& __a, const _Tp& __b)
      |     ^~~
/usr/local/include/c++/11.4.0/bits/stl_algobase.h:254:5: note:   template argument deduction/substitution failed:
main.cpp:35:50: note:   candidate expects 2 arguments, 0 provided
   35 |     inFile.ignore(numeric_limits<streamsize>::max(), '\n');
      |                                             ~~~~~^~
In file included from /usr/local/include/c++/11.4.0/bits/char_traits.h:39,
                 from /usr/local/include/c++/11.4.0/ios:40,
                 from /usr/local/include/c++/11.4.0/ostream:38,
                 from /usr/local/include/c++/11.4.0/iostream:39,
                 from main.cpp:1:
/usr/local/include/c++/11.4.0/bits/stl_algobase.h:300:5: note: candidate: 'template<class _Tp, class _Compare> constexpr const _Tp& std::max(const _Tp&, const _Tp&, _Compare)'
  300 |     max(const _Tp& __a, const _Tp& __b, _Compare __comp)
      |     ^~~
/usr/local/include/c++/11.4.0/bits/stl_algobase.h:300:5: note:   template argument deduction/substitution failed:
main.cpp:35:50: note:   candidate expects 3 arguments, 0 provided
   35 |     inFile.ignore(numeric_limits<streamsize>::max(), '\n');
      |                                             ~~~~~^~

```

Evaluate the error message. Think of a solution to fix the program and return the entire source code with the fix.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The error indicates that `numeric_limits` was not declared in the scope. This can be fixed by including the appropriate header `<limits>`. Let's address this and ensure the program compiles correctly.

Here is the revised solution:

```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <sstream>
#include <string>
#include <cctype>
#include <limits>  // Include this header for numeric_limits

using namespace std;

int getValue(const vector<vector<int>>& sheet, const string& cell) {
    int row = stoi(cell.substr(1)) - 1;
    int col = cell[0] - 'A';
    return sheet[row][col];
}

int evaluateFormula(const vector<vector<int>>& sheet, const string& formula) {
    string left = formula.substr(1, formula.find('+') - 1);
    string right = formula.substr(formula.find('+') + 1);
    return getValue(sheet, left) + getValue(sheet, right);
}

int main() {
    ifstream inFile("excel.in");
    ofstream outFile("excel.out");
    
    if (!inFile || !outFile) {
        cerr << "Error opening file." << endl;
        return 1;
    }
    
    int m, n;
    inFile >> m >> n;
    
    // Ignore the rest of the line after reading m and n
    inFile.ignore(numeric_limits<streamsize>::max(), '\n');

    vector<vector<int>> sheet(n, vector<int>(m, 0));
    vector<vector<string>> inputSheet(n, vector<string>(m));
    
    for (int i = 0; i < n; ++i) {
        string line;
        getline(inFile, line);
        istringstream iss(line);
        for (int j = 0; j < m; ++j) {
            iss >> inputSheet[i][j];
        }
    }

    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            if (isdigit(inputSheet[i][j][0]) || inputSheet[i][j][0] == '-') {
                sheet[i][j] = stoi(inputSheet[i][j]);
            } else if (inputSheet[i][j][0] == '=') {
                try {
                    sheet[i][j] = evaluateFormula(sheet, inputSheet[i][j]);
                } catch (const exception& e) {
                    cerr << "Error evaluating formula: " << inputSheet[i][j] << " at cell (" << i << ", " << j << ")" << endl;
                    return 1;
                }
            }
        }
    }

    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            outFile << sheet[i][j];
            if (j < m - 1) outFile << " ";
        }
        outFile << endl;
    }
    
    inFile.close();
    outFile.close();
    return 0;
}
```

### Explanation of the Fixes:

1. **Include Correct Header for Numeric Limits**: 
   - Added `#include <limits>` to ensure `numeric_limits` is recognized.

2. **Ensure Correct Handling of `stoi` and Formulas**:
   - Added proper error handling when evaluating formulas to catch any potential exceptions and print an error message.

### Summary:

This version of the solution should now compile successfully and handle the input and output as required, evaluating each formula correctly and writing the final spreadsheet values to the output file.
---------- user ----------


Program exited with code 1.
stdout:
```

```
stderr:
```
Error evaluating formula: =A3 at cell (0, 3)

```

Think of what has caused the exit code. Use the standard out and standard error to help you understand the issue.
Implement a solution to fix the program

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The error message indicates that there was an issue evaluating the formula `=A3` in cell `(0, 3)`. This is likely because the formula references an invalid cell, which is not handled appropriately in the code.

To fix this:
1. **Enhance Formula Parsing**: Handle references to single cells (like `=A3`) as well as combined operations (like `=A1+A2`).
2. **Improve Error Checking**: Ensure that references are within valid ranges before attempting to access them.

Let's rewrite the entire solution implementing these necessary fixes:

```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <sstream>
#include <string>
#include <cctype>
#include <limits>
#include <stdexcept>

using namespace std;

int getValue(const vector<vector<int>>& sheet, const string& cell) {
    // Convert cell reference to indices
    int row = stoi(cell.substr(1)) - 1;
    int col = cell[0] - 'A';
    if (row < 0 || row >= sheet.size() || col < 0 || col >= sheet[0].size()) {
        throw out_of_range("Cell reference out of range");
    }
    return sheet[row][col];
}

int evaluateFormula(const vector<vector<int>>& sheet, const string& formula) {
    if (formula.find('+') == string::npos) {
        // Handle single cell reference
        return getValue(sheet, formula.substr(1));
    } else {
        // Handle sum of two cell references
        string left = formula.substr(1, formula.find('+') - 1);
        string right = formula.substr(formula.find('+') + 1);
        return getValue(sheet, left) + getValue(sheet, right);
    }
}

int main() {
    ifstream inFile("excel.in");
    ofstream outFile("excel.out");
    
    if (!inFile || !outFile) {
        cerr << "Error opening file." << endl;
        return 1;
    }
    
    int m, n;
    inFile >> m >> n;
    
    // Ignore the rest of the line after reading m and n
    inFile.ignore(numeric_limits<streamsize>::max(), '\n');

    vector<vector<int>> sheet(n, vector<int>(m, 0));
    vector<vector<string>> inputSheet(n, vector<string>(m));
    
    for (int i = 0; i < n; ++i) {
        string line;
        getline(inFile, line);
        istringstream iss(line);
        for (int j = 0; j < m; ++j) {
            iss >> inputSheet[i][j];
        }
    }

    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            if (isdigit(inputSheet[i][j][0]) || inputSheet[i][j][0] == '-') {
                sheet[i][j] = stoi(inputSheet[i][j]);
            } else if (inputSheet[i][j][0] == '=') {
                try {
                    sheet[i][j] = evaluateFormula(sheet, inputSheet[i][j]);
                } catch (const exception& e) {
                    cerr << "Error evaluating formula: " << inputSheet[i][j] << " at cell (" << i << ", " << j << ")" << endl;
                    return 1;
                }
            }
        }
    }

    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            outFile << sheet[i][j];
            if (j < m - 1) outFile << " ";
        }
        outFile << endl;
    }
    
    inFile.close();
    outFile.close();
    return 0;
}
```

### Explanation:

1. **Handle Single Cell References in Formulas**: 
   - The `evaluateFormula` function now checks if the formula contains a `+`. If it doesn't, it assumes it's a single cell reference and handles it accordingly.

2. **Error Checking for Cell References**:
   - The `getValue` function throws an `out_of_range` exception if the referenced cell is out of bounds.

3. **Improved Error Messages**:
   - More informative error messages when an exception is caught during formula evaluation.

This solution should now correctly handle all valid inputs, including single cell references and sums of two cells, and will provide informative error messages for any issues encountered during execution.
---------- user ----------


Program result did not match expected result.
Input data:
```
4 3
11 21 =A1+A2 =A3
10 15 =B1+B2 =A2+B1
=A1+A2 14 21 3
```
Expected output:
```
11 21 21 21
10 15 36 31
21 14 21 3
```
Found output:
```
11 21 11 0
10 15 36 31
21 14 21 3
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The differences between the expected and found result indicate that the formula evaluation for the cell `=A3` is not working correctly. Specifically, the cell at position `(0, 3)` should read as `21` but is evaluated as `0` in the found output. 

This indicates that the formula evaluation logic does not correctly handle dependencies on rows and columns that have not yet been processed. 

To fix this:
1. **Use a Topological Sort**: We need to ensure that all cells are evaluated in the correct order to resolve dependencies. This can be achieved using a topological sort on the graph of dependencies.
2. **Track Dependencies**: We'll maintain a map of dependencies for each formula to ensure they are evaluated in the correct order.

Here's the corrected and enhanced solution:

```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <sstream>
#include <string>
#include <cctype>
#include <limits>
#include <stdexcept>
#include <unordered_map>
#include <queue>

using namespace std;

int getValue(const vector<vector<int>>& sheet, const string& cell) {
    int row = stoi(cell.substr(1)) - 1;
    int col = cell[0] - 'A';
    if (row < 0 || row >= sheet.size() || col < 0 || col >= sheet[0].size()) {
        throw out_of_range("Cell reference out of range");
    }
    return sheet[row][col];
}

int evaluateFormula(const vector<vector<int>>& sheet, const string& formula) {
    if (formula.find('+') == string::npos) {
        // Handle single cell reference
        return getValue(sheet, formula.substr(1));
    } else {
        // Handle sum of two cell references
        string left = formula.substr(1, formula.find('+') - 1);
        string right = formula.substr(formula.find('+') + 1);
        return getValue(sheet, left) + getValue(sheet, right);
    }
}

void topologicalSort(int v, const unordered_map<int, vector<int>>& adj, vector<bool>& visited, vector<int>& order) {
    visited[v] = true;
    if (adj.find(v) != adj.end()) {
        for (int u : adj.at(v)) {
            if (!visited[u]) {
                topologicalSort(u, adj, visited, order);
            }
        }
    }
    order.push_back(v);
}

int main() {
    ifstream inFile("excel.in");
    ofstream outFile("excel.out");
    
    if (!inFile || !outFile) {
        cerr << "Error opening file." << endl;
        return 1;
    }
    
    int m, n;
    inFile >> m >> n;
    
    // Ignore the rest of the line after reading m and n
    inFile.ignore(numeric_limits<streamsize>::max(), '\n');

    vector<vector<int>> sheet(n, vector<int>(m, 0));
    vector<vector<string>> inputSheet(n, vector<string>(m));
    unordered_map<int, vector<int>> adj;  // For storing dependencies
    vector<int> indegree(n * m, 0);  // For storing indegrees of cells
    
    for (int i = 0; i < n; ++i) {
        string line;
        getline(inFile, line);
        istringstream iss(line);
        for (int j = 0; j < m; ++j) {
            iss >> inputSheet[i][j];
            if (inputSheet[i][j][0] == '=') {
                string formula = inputSheet[i][j].substr(1);
                size_t plusPos = formula.find('+');
                if (plusPos != string::npos) {
                    // Add dependencies for the two referenced cells
                    string left = formula.substr(0, plusPos);
                    string right = formula.substr(plusPos + 1);
                    int leftRow = stoi(left.substr(1)) - 1;
                    int leftCol = left[0] - 'A';
                    int rightRow = stoi(right.substr(1)) - 1;
                    int rightCol = right[0] - 'A';
                    int currentCell = i * m + j;
                    adj[leftRow * m + leftCol].push_back(currentCell);
                    adj[rightRow * m + rightCol].push_back(currentCell);
                    indegree[currentCell] += 2;
                } else {
                    // Add dependency for the single referenced cell
                    int refRow = stoi(formula.substr(1)) - 1;
                    int refCol = formula[0] - 'A';
                    int currentCell = i * m + j;
                    adj[refRow * m + refCol].push_back(currentCell);
                    indegree[currentCell]++;
                }
            }
        }
    }

    // Topological sort to get the evaluation order
    vector<bool> visited(n * m, false);
    vector<int> order;
    for (int i = 0; i < n * m; ++i) {
        if (!visited[i] && indegree[i] == 0) {
            topologicalSort(i, adj, visited, order);
        }
    }
    reverse(order.begin(), order.end());

    // Evaluate cells in topological order
    for (int cell : order) {
        int i = cell / m;
        int j = cell % m;
        if (isdigit(inputSheet[i][j][0]) || inputSheet[i][j][0] == '-') {
            sheet[i][j] = stoi(inputSheet[i][j]);
        } else if (inputSheet[i][j][0] == '=') {
            try {
                sheet[i][j] = evaluateFormula(sheet, inputSheet[i][j]);
            } catch (const exception& e) {
                cerr << "Error evaluating formula: " << inputSheet[i][j] << " at cell (" << i << ", " << j << ")" << endl;
                return 1;
            }
        }
    }

    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            outFile << sheet[i][j];
            if (j < m - 1) outFile << " ";
        }
        outFile << endl;
    }
    
    inFile.close();
    outFile.close();
    return 0;
}
```

### Explanation:

1. **Track Dependencies and In-degrees**:
   - A dependency graph (adjacency list) is built wherein each cell's dependencies are recorded.
   - In-degrees of cells are tracked to handle the topological sorting.

2. **Topological Sort**:
   - A topological sort is performed to ensure cells are evaluated in the correct order, respecting their dependencies.

3. **Evaluate Using Topological Order**:
   - Cells are evaluated in the topological order obtained, ensuring that dependent cells are evaluated after their dependencies.

This solution ensures that all cells are processed in a dependency-respecting order, resolving the issue with cells like `=A3` that depend on other cells.
---------- user ----------


Failed to compile the program.
```
main.cpp: In function 'int main()':
main.cpp:108:5: error: 'reverse' was not declared in this scope
  108 |     reverse(order.begin(), order.end());
      |     ^~~~~~~

```

Evaluate the error message. Think of a solution to fix the program and return the entire source code with the fix.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The error message indicates that the function `reverse` is not recognized. This is because we need to include the `<algorithm>` header which contains the definition for `reverse`.

Let's fix this issue by including the necessary header:

```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <sstream>
#include <string>
#include <cctype>
#include <limits>
#include <stdexcept>
#include <unordered_map>
#include <queue>
#include <algorithm>  // Include this header for reverse

using namespace std;

int getValue(const vector<vector<int>>& sheet, const string& cell) {
    int row = stoi(cell.substr(1)) - 1;
    int col = cell[0] - 'A';
    if (row < 0 || row >= sheet.size() || col < 0 || col >= sheet[0].size()) {
        throw out_of_range("Cell reference out of range");
    }
    return sheet[row][col];
}

int evaluateFormula(const vector<vector<int>>& sheet, const string& formula) {
    if (formula.find('+') == string::npos) {
        // Handle single cell reference
        return getValue(sheet, formula.substr(1));
    } else {
        // Handle sum of two cell references
        string left = formula.substr(1, formula.find('+') - 1);
        string right = formula.substr(formula.find('+') + 1);
        return getValue(sheet, left) + getValue(sheet, right);
    }
}

void topologicalSort(int v, const unordered_map<int, vector<int>>& adj, vector<bool>& visited, vector<int>& order) {
    visited[v] = true;
    if (adj.find(v) != adj.end()) {
        for (int u : adj.at(v)) {
            if (!visited[u]) {
                topologicalSort(u, adj, visited, order);
            }
        }
    }
    order.push_back(v);
}

int main() {
    ifstream inFile("excel.in");
    ofstream outFile("excel.out");
    
    if (!inFile || !outFile) {
        cerr << "Error opening file." << endl;
        return 1;
    }
    
    int m, n;
    inFile >> m >> n;
    
    // Ignore the rest of the line after reading m and n
    inFile.ignore(numeric_limits<streamsize>::max(), '\n');

    vector<vector<int>> sheet(n, vector<int>(m, 0));
    vector<vector<string>> inputSheet(n, vector<string>(m));
    unordered_map<int, vector<int>> adj;  // For storing dependencies
    vector<int> indegree(n * m, 0);  // For storing indegrees of cells
    
    for (int i = 0; i < n; ++i) {
        string line;
        getline(inFile, line);
        istringstream iss(line);
        for (int j = 0; j < m; ++j) {
            iss >> inputSheet[i][j];
            if (inputSheet[i][j][0] == '=') {
                string formula = inputSheet[i][j].substr(1);
                size_t plusPos = formula.find('+');
                if (plusPos != string::npos) {
                    // Add dependencies for the two referenced cells
                    string left = formula.substr(0, plusPos);
                    string right = formula.substr(plusPos + 1);
                    int leftRow = stoi(left.substr(1)) - 1;
                    int leftCol = left[0] - 'A';
                    int rightRow = stoi(right.substr(1)) - 1;
                    int rightCol = right[0] - 'A';
                    int currentCell = i * m + j;
                    adj[leftRow * m + leftCol].push_back(currentCell);
                    adj[rightRow * m + rightCol].push_back(currentCell);
                    indegree[currentCell] += 2;
                } else {
                    // Add dependency for the single referenced cell
                    int refRow = stoi(formula.substr(1)) - 1;
                    int refCol = formula[0] - 'A';
                    int currentCell = i * m + j;
                    adj[refRow * m + refCol].push_back(currentCell);
                    indegree[currentCell]++;
                }
            }
        }
    }

    // Topological sort to get the evaluation order
    vector<bool> visited(n * m, false);
    vector<int> order;
    for (int i = 0; i < n * m; ++i) {
        if (!visited[i] && indegree[i] == 0) {
            topologicalSort(i, adj, visited, order);
        }
    }
    reverse(order.begin(), order.end());

    // Evaluate cells in topological order
    for (int cell : order) {
        int i = cell / m;
        int j = cell % m;
        if (isdigit(inputSheet[i][j][0]) || inputSheet[i][j][0] == '-') {
            sheet[i][j] = stoi(inputSheet[i][j]);
        } else if (inputSheet[i][j][0] == '=') {
            try {
                sheet[i][j] = evaluateFormula(sheet, inputSheet[i][j]);
            } catch (const exception& e) {
                cerr << "Error evaluating formula: " << inputSheet[i][j] << " at cell (" << i << ", " << j << ")" << endl;
                return 1;
            }
        }
    }

    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            outFile << sheet[i][j];
            if (j < m - 1) outFile << " ";
        }
        outFile << endl;
    }
    
    inFile.close();
    outFile.close();
    return 0;
}
```

### Explanation of Fix:

1. **Include `<algorithm>` Header**:
   - The `reverse` function is part of the `<algorithm>` library, so we need to include this header to use it.

### Summary:

This version of the solution includes the necessary header for `reverse` and maintains the logic for topological sort and formula evaluation, ensuring that all cells are processed in a correct dependency-respecting order. This should resolve the issues and produce the expected output.
