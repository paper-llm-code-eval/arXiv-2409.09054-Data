---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `wind.in` and write to `wind.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Domnul Vânt a pus pe marginea unei șosele $N$ centrale eoliene, dintre care unele produc energie electrică, iar altele, deocamdată, doar consumă energie. El a etichetat centralele cu numerele naturale distincte de la $1$ la $N$, în ordinea poziționării lor pe șosea. Fiecare centrală eoliană are la bază un ecran pe care este afișat un număr întreg, reprezentând cantitatea de energie pe care o produce (dacă numărul este pozitiv) sau pe care o consumă (dacă numărul este negativ).

Pentru **a construi corect $k$ orașe** de-a lungul acestei șosele, un arhitect trebuie să aibă în vedere că:
- fiecărui oraș îi va fi atribuit câte un grup format din centrale eoliene vecine pe șosea, toate grupurile având același număr de centrale;
- cantitatea de energie repartizată unui oraș este egală cu suma numerelor afișate pe ecranele centralelor eoliene din grupul atribuit; uneori este posibil ca, deocamdată, suma obținută să fie negativă;
- fiecare dintre cele $N$ centrale eoliene trebuie să fie atribuită unui oraș;
- factorul de dezechilibru, notat cu $P(k)$, este valoarea maximă a diferenței dintre energiile repartizate oricăror două orașe diferite, dintre cele $k$.

# Cerință
Scrieţi un program care citește numărul $N$, valorile afișate pe cele $N$ ecrane ale centralelor eoliene și rezolvă următoarele două cerinţe:
1. afișează numărul $M$ de moduri în care se pot grupa cele $N$ centrale pentru construcția corectă de orașe;
2. afișează **numărul maxim** $X$ de orașe ce pot fi construite corect, **dintre cele care au factorul de dezechilibru minim**, precum și eticheta $E$ a primei centrale eoliene atribuită orașului cu cea mai mare cantitate de energie repartizată, dintre cele $X$ orașe; dacă sunt mai multe astfel de orașe, se ia în considerare cel care are atribuite centrale etichetate cu numere mai mari.

# Date de intrare
Fișierul de intrare `wind.in` conține pe prima linie un număr natural $C$ reprezentând cerința care trebuie rezolvată ($1$ sau $2$). A doua linie a fișierului conține un număr natural $N$, cu semnificația din enunț. A treia linie din fișier conține $N$ numere întregi, separate prin câte un spațiu, reprezentând valorile afișate pe cele $N$ ecrane ale centralelor eoliene, în ordinea poziționării acestora pe șosea.

# Date de ieșire
Fişierul de ieșire `wind.out` va conţine pe prima linie:
- dacă $C=1$, numărul natural $M$, reprezentând răspunsul la cerința 1;
- dacă $C=2$, cele două numere naturale $X$ și $E$, în această ordine, separate printr-un singur spațiu, reprezentând răspunsul la cerința 2.

# Restricţii și precizări
- $2 \leq N ≤ 100\ 000$, $N$ număr natural;
- Numerele afișate pe ecranele centralelor sunt numere întregi formate din cel mult 9 cifre;
- Se vor construi minimum 2 orașe;
- Pentru rezolvarea cerinței 1 se acordă 20 de puncte.
- Pentru rezolvarea cerinței 2 se acordă 70 de puncte. Pentru fiecare test al acestei cerințe veți primi $50\%$ din punctajul testului pentru valoarea corectă $X$ și $50\%$ din punctajul testului pentru valoarea corectă $E$. Această cerință necesită ca **în fișierul de ieșire să existe exact 2 numere**.

---

Example:
`wind.in`
```
1
12
2 4 -5 12 3 5 -6 4 5 7 -8 2
```

`wind.out`
```
5
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:Here's a C++ solution that reads from `wind.in` and writes to `wind.out`:

```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <algorithm>
#include <climits>

using namespace std;

int main() {
    ifstream fin("wind.in");
    ofstream fout("wind.out");

    int C, N;
    fin >> C >> N;
    vector<int> windmills(N);
    for (int i = 0; i < N; ++i) {
        fin >> windmills[i];
    }

    if (C == 1) {
        // Cerinta 1: Calculate the number of ways to group the windmills
        int M = 0;
        for (int k = 2; k <= N; ++k) {
            if (N % k == 0) {
                M++;
            }
        }
        fout << M << endl;
    } else if (C == 2) {
        // Cerinta 2: Find the maximum number of cities with minimal imbalance factor
        int bestX = 0;
        int bestE = 0;
        int minP = INT_MAX;

        for (int k = 2; k <= N; ++k) {
            if (N % k == 0) {
                int groupSize = N / k;
                vector<int> cityEnergies(k, 0);

                for (int i = 0; i < N; ++i) {
                    cityEnergies[i / groupSize] += windmills[i];
                }

                int maxEnergy = *max_element(cityEnergies.begin(), cityEnergies.end());
                int minEnergy = *min_element(cityEnergies.begin(), cityEnergies.end());
                int Pk = maxEnergy - minEnergy;

                if (Pk < minP) {
                    minP = Pk;
                    bestX = k;
                    bestE = distance(cityEnergies.begin(), max_element(cityEnergies.begin(), cityEnergies.end())) * groupSize + 1;
                } else if (Pk == minP) {
                    int candidateE = distance(cityEnergies.begin(), max_element(cityEnergies.begin(), cityEnergies.end())) * groupSize + 1;
                    if (k > bestX || (k == bestX && candidateE > bestE)) {
                        bestX = k;
                        bestE = candidateE;
                    }
                }
            }
        }
        fout << bestX << " " << bestE << endl;
    }

    fin.close();
    fout.close();
    return 0;
}
```

### Explanation

1. **Reading the Input:**
   - The program first reads the requirements from the file `wind.in`.
   - It captures whether `C` is 1 or 2, the total number of windmills `N`, and their respective energy values.

2. **Requirement 1:**
   - If `C == 1`, we need to find the number of ways to evenly divide the windmills into groups.
   - This is done by iterating through possible group sizes from 2 to `N` and checking if `N` is divisible by the group size. If it is, increment the count `M`.

3. **Requirement 2:**
   - If `C == 2`, the goal is to find the maximum number of cities (groups) that can be formed with the minimum imbalance factor.
   - Iterate through potential group counts `k` from 2 to `N`, checking if `N % k == 0`.
   - Calculate the energy for each group and the imbalance factor `Pk` for each grouping.
   - Track the minimal imbalance factor and the corresponding number of cities and the index of the first windmill for the group with the highest energy output.

4. **Output the Result:**
   - Depending on whether `C` was 1 or 2, the program outputs the appropriate result to `wind.out`.

This solution ensures it efficiently processes the input and computes the results using straightforward logic and standard C++ library functions.
