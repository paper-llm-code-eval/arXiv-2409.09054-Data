---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `panglica.in` and write to `panglica.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Gigel are o panglică alcătuită din benzi de $1 cm$ lăţime, colorate în diverse culori. Panglica are $N$ benzi, fiecare colorată cu una din $C$ culori, culori pe care le vom numerota de la $1$ la $C$. Gigel vrea ca la ambele capete ale panglicii să aibă aceeaşi culoare, dar cum nu poate schimba culorile benzilor, singura posibilitate rămâne tăierea unor bucăţi de la capete. 

# Cerință

Scrieţi un program care să determine modul de tăiere a panglicii astfel încât la cele două capete să fie benzi de aceeaşi culoare, iar lungimea panglicii obţinute să fie maximă.

# Date de intrare

Fişierul de intrare `panglica.in` conţine:

- pe prima linie numerele naturale $N$ şi $C$ separate printr-un spaţiu;
- pe următoarele $N$ linii descrierea panglicii: pe fiecare linie un număr natural de la $1$ la $C$, reprezentând în ordine culorile fâşiilor ce alcătuiesc panglica.

# Date de ieșire

Fişierul de ieşire `panglica.out` va conţine următoarele $4$ numere:

- pe prima linie numărul de fâşii rămase;
- pe linia a doua numărul culorii care se află la capete;
- pe linia a treia câte fâşii trebuie tăiate de la începutul panglicii iniţiale;
- pe linia a patra câte fâşii trebuie tăiate de la sfârşitul panglicii iniţiale

# Restricții și precizări

* $2 \leq N \leq 10 \ 000$;
* $1 \leq C \leq 200$;
* Dacă există mai multe soluţii alegeţi pe cea în care se taie cât mai puţin din partea de început a panglicii.

---

Example:
`panglica.in`
```
6 3
1
2
1
3
2
3
```

`panglica.out`
```
4
2
1
1
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:Let's break down the solution step by step, then implement it in C++.

### Problem Breakdown
1. **Input Reading**: 
   - First, we need to read `N` and `C` from the input file.
   - Then, read the colors of the `N` strips.
   
2. **Finding the Maximum Length with Same Colors at Both Ends**:
   - We need to find two positions `i` and `j` such that the color at position `i` is the same as the color at position `j` and `j - i + 1` is maximized.
   - We should also ensure minimal cuts from the start of the ribbon for such a maximum length.

3. **Output**:
   - The number of strips remaining.
   - The color at both ends.
   - The number of strips cut from the start.
   - The number of strips cut from the end.

### Steps to Solve:
1. Read the input.
2. Use two pointers or a similar technique to find the longest segment satisfying the conditions.
3. Track the maximum length and the necessary cuts.
4. Write the results to the output file.

Here is the C++ implementation that follows the above steps:

```cpp
#include <fstream>
#include <vector>
#include <unordered_map>
#include <algorithm>

int main() {
    std::ifstream fin("panglica.in");
    std::ofstream fout("panglica.out");

    int N, C;
    fin >> N >> C;

    std::vector<int> colors(N);
    for (int i = 0; i < N; ++i) {
        fin >> colors[i];
    }

    int max_length = 0;
    int best_color = -1;
    int best_start_cuts = 0;
    int best_end_cuts = 0;

    std::unordered_map<int, int> first_occurrence;

    for (int i = 0; i < N; ++i) {
        if (first_occurrence.find(colors[i]) == first_occurrence.end()) {
            first_occurrence[colors[i]] = i;
        }
        int start_index = first_occurrence[colors[i]];
        int length = i - start_index + 1;

        if ((length > max_length) || 
            (length == max_length && start_index < best_start_cuts)) {
            max_length = length;
            best_color = colors[i];
            best_start_cuts = start_index;
            best_end_cuts = N - i - 1;
        }
    }

    fout << max_length << "\n";
    fout << best_color << "\n";
    fout << best_start_cuts << "\n";
    fout << best_end_cuts << "\n";

    return 0;
}
```

### Explanation:
1. **Reading Input**: 
   - The file input is read and stored in a vector `colors`.
   
2. **Finding the Segment**:
   - We use a hash map `first_occurrence` to store the first occurrence of each color.
   - As we iterate through the strips, we check if the current strip's color was seen before.
   - If it was, we calculate the length of the segment from the first occurrence to the current position.
   - We keep track of the maximum length found and update the necessary cuts.

3. **Output**:
   - The results are written to the output file as specified.

This approach ensures we find the optimal segment efficiently, handling the constraints provided.
