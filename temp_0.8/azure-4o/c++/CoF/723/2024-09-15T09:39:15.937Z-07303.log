---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `expresie.in` and write to `expresie.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Se dă un șir de $n$ numere naturale nenule $x_1, x_2, \dots, x_n$ și un număr natural $m$.

# Cerință
Să se verifice dacă valoarea expresiei $\sqrt[m]{x_1 x_2 x_3 \dots x_n}$ este un număr natural. În caz afirmativ să se afișeze acest număr descompus în factori primi.

# Date de intrare
În fișierul `expresie.in` se află pe prima linie $m$, pe linia a doua $n$, iar pe linia a treia numerele $x_1$, $x_2$, $\dots$, $x_n$ separate între ele prin câte un spațiu.

# Date de ieșire
În fișierul `expresie.out` se va scrie pe prima linie cifra $0$, dacă valoarea expresiei nu este un număr natural, respectiv $1$ dacă este un număr natural. 
Dacă valoarea expresiei este un număr natural, pe următoarele linii se vor scrie perechi de forma "$p\ e$" ($p$ este factor prim care apare în descompunere la puterea $e \geq 1$). Aceste perechi se vor scrie în ordine crescătoare după primul număr (adică $p$).

# Restricții
- $n$ este un număr natural nenul mai mic strict decât $5\ 000$.
- $x_i$ este un număr natural nenul mai mic strict decât $30\ 000$, $i \in \{1, 2, \dots, n\}$.
- **$m$ poate fi una din cifrele $2$, $3$ sau $4$.**

---

Example:
`expresie.in`
```
2
4
32 81 100 19
```

`expresie.out`
```
0
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:The challenge requires verifying whether the expression \(\sqrt[m]{x_1 x_2 x_3 \dots x_n}\) is a natural number and if so, outputting its prime factors.

To efficiently solve this problem, we need to:
1. Compute the product of all the given numbers \( x_1, x_2, \ldots, x_n \).
2. Calculate its \( m \)-th root.
3. Check if the \( m \)-th root is an integer.
4. If it is a natural number, then factorize it into its prime factors.

Given the constraints, a direct computation of the product might lead to overflow since the product of numbers can be extremely large. Hence, we need to approach this problem using logarithms to handle large products safely.

Here is the solution in C++ encapsulated in a markdown code block:

```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <cmath>
#include <unordered_map>
#include <algorithm>

std::unordered_map<int, int> primeFactorization(int num) {
    std::unordered_map<int, int> prime_factors;
    while (num % 2 == 0) {
        prime_factors[2]++;
        num /= 2;
    }
    for (int i = 3; i <= sqrt(num); i += 2) {
        while (num % i == 0) {
            prime_factors[i]++;
            num /= i;
        }
    }
    if (num > 2) {
        prime_factors[num]++;
    }
    return prime_factors;
}

int main() {
    std::ifstream infile("expresie.in");
    std::ofstream outfile("expresie.out");

    int m, n;
    infile >> m >> n;
    
    std::vector<int> numbers(n);
    for (int i = 0; i < n; ++i) {
        infile >> numbers[i];
    }
    
    double log_product = 0.0;
    for (int num : numbers) {
        log_product += std::log(num);
    }

    double root_value = std::exp(log_product / m);
    int rounded_root = std::round(root_value);

    bool is_natural = std::pow(rounded_root, m) == std::round(std::exp(log_product));

    if (!is_natural) {
        outfile << 0 << std::endl;
    } else {
        std::unordered_map<int, int> total_factors;
        for (int num : numbers) {
            auto factors = primeFactorization(num);
            for (const auto& factor : factors) {
                total_factors[factor.first] += factor.second;
            }
        }

        for (auto& factor : total_factors) {
            if (factor.second % m != 0) {
                outfile << 0 << std::endl;
                return 0;
            }
            factor.second /= m;
        }

        outfile << 1 << std::endl;
        std::vector<std::pair<int, int>> sorted_factors(total_factors.begin(), total_factors.end());
        std::sort(sorted_factors.begin(), sorted_factors.end());
        for (const auto& factor : sorted_factors) {
            outfile << factor.first << " " << factor.second << std::endl;
        }
    }

    return 0;
}
```

### Explanation:
1. **Reading Input**: The code reads `m`, `n`, and the sequence of numbers from `expresie.in`.
2. **Logarithmic Product Calculation**: It computes the sum of logarithms of the numbers to handle large products.
3. **Root Calculation**: It calculates the \( m \)-th root of the product by using exponentiation of the logarithmic sum divided by `m`.
4. **Rounding Root**: The rounded value of the root is checked if raising it back to power `m` equals the original product (to handle floating-point inaccuracies).
5. **Prime Factorization**: If the root is a natural number, the numbers are factorized, and the total factors are calculated.
6. **Factor Validation and Output**: It checks if all exponents of the factors are divisible by `m` and writes the result to `expresie.out`. If valid, it outputs the prime factors in sorted order. Otherwise, it outputs `0`.

This solution handles large inputs and avoids overflow by using logarithms, ensuring both accuracy and efficiency.
