---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `arma.in` and write to `arma.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

În anul $2214$ a izbucnit primul război interstelar. Pământul a fost atacat de către $n$ civilizații extraterestre, pe care le vom numerota pentru simplicitate de la $1$ la $n$.

Pentru a se apăra, pământenii au inventat o armă specială ce poate fi încărcată cu proiectile de diferite greutăți, fabricate dintr-un material special denumit narun. Dacă arma este programată la nivelul $p$, atunci un proiectil de greutate $k$ va ajunge exact la distanța $k^p$ km ($k$ la puterea $p$) față de Pământ și dacă în acel punct se află cartierul general al unui atacator, acesta va fi distrus. De exemplu, dacă arma este programată la nivelul $2$, un proiectil de greutate 10 va distruge cartierul general al extratereștrilor situat la distanța $10^2 = 100$ km de Pământ.
Arma poate fi încărcată cu proiectile de diferite greutăți, dar cum narunul este un material foarte rar și foarte scump, pământenii vor să folosească proiectile cât mai ușoare pentru a distruge cartierele generale inamice.

# Cerință

Cunoscându-se $n$, numărul atacatorilor, precum și cele $n$ distanțe până la cartierele generale ale acestora, să se scrie un program care determină:

1. Cantitatea minimă de narun necesară pentru a distruge toate cartierele generale inamice;
2. Nivelurile la care trebuie programată arma, pentru a distruge fiecare cartier general inamic cu o cantitate minimă de narun.

# Date de intrare

Fișierul de intrare `arma.in` conține pe prima linie un număr natural $c$ reprezentând cerința care trebuie să fie rezolvată ($1$ sau $2$). Pe cea de a doua linie se află numărul natural $n$, reprezentând numărul atacatorilor. Pe următoarele $n$ linii se află $n$ numere naturale, câte un număr pe o linie; pe cea de a $i$-a linie dintre cele $n$ se află distanța față de Pământ a cartierului general al celei de a $i$-a civilizații extraterestre

# Date de ieșire

Dacă cerința $c = 1$, atunci pe prima linie a fișierului `arma.out` va fi scris un număr natural reprezentând cantitatea minimă de narun necesară distrugerii tuturor cartierelor generale inamice.

Dacă cerința este $c = 2$, atunci fișierul de ieșire `arma.out` va conține $n$ linii. Pe a $i$-a linie se va scrie nivelul la care trebuie programată arma pentru a distruge cartierul general al celei de a $i$-a civilizații extraterestre.

# Restricții și precizări

* $1 \leq n \leq 10 \ 000$;
* Distanțele până la cartierele generale inamice sunt numere naturale nenule $\leq 2 \cdot 10^9$;
* Pentru $50$% dintre teste cerința este $1$.

---

Example:
`arma.in`
```
1
5
100
97
625
40353607
81
```

`arma.out`
```
122
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:To solve the challenge efficiently, we need to handle two possible requirements: either to find the minimum amount of material (narun) needed, or to determine the levels at which the weapon should be programmed for each distance. Here is the efficient C++ solution:

1. **For Requirement 1**: We need to find the minimal weight of projectiles (minimal `k`) for each distance, given the optimal level `p`. This involves finding the smallest integer `k` such that `k^p = distance`.

2. **For Requirement 2**: We need to determine the exact level `p` for each distance that minimizes the projectile weight.

### Detailed Steps

1. Read the input from `arma.in`.
2. Based on the requirement (`c`), either:
   - Compute the minimum amount of narun (sum of minimal weights `k`).
   - Determine the level `p` for each distance.
3. Write the result to `arma.out`.

We'll use mathematical tools like logarithms and integer rounding to deduce the values efficiently. Here’s the complete C++ code for the solution:

```cpp
#include <iostream>
#include <fstream>
#include <cmath>
#include <limits>
#include <vector>

void solveRequirement1(const std::vector<long long>& distances) {
    long long totalNarun = 0;
    for (const auto& distance : distances) {
        long long minWeight = std::numeric_limits<long long>::max();
        for (int p = 1; p <= 31; ++p) { // as 2^31 > 2*10^9, so we check up to p = 31
            long long k = std::round(std::pow(distance, 1.0 / p));
            if (std::pow(k, p) == distance || std::pow(k + 1, p) == distance) {
                minWeight = std::min(minWeight, k);
            }
        }
        totalNarun += minWeight;
    }
    std::ofstream outFile("arma.out");
    outFile << totalNarun << std::endl;
    outFile.close();
}

void solveRequirement2(const std::vector<long long>& distances) {
    std::ofstream outFile("arma.out");
    for (const auto& distance : distances) {
        int optimalP = 1;
        long long minWeight = std::numeric_limits<long long>::max();
        for (int p = 1; p <= 31; ++p) { // as 2^31 > 2*10^9, so we check up to p = 31
            long long k = std::round(std::pow(distance, 1.0 / p));
            if (std::pow(k, p) == distance || std::pow(k + 1, p) == distance) {
                if (k < minWeight) {
                    minWeight = k;
                    optimalP = p;
                }
            }
        }
        outFile << optimalP << std::endl;
    }
    outFile.close();
}

int main() {
    std::ifstream inFile("arma.in");
    int c, n;
    inFile >> c >> n;
    std::vector<long long> distances(n);
    for (int i = 0; i < n; ++i) {
        inFile >> distances[i];
    }
    inFile.close();

    if (c == 1) {
        solveRequirement1(distances);
    } else {
        solveRequirement2(distances);
    }

    return 0;
}
```

### Explanation:
1. **Reading the input**: We read the requirement `c` and the number of distances `n`, followed by the distances.
2. **For Requirement 1**: We calculate the minimal weight for each distance by iterating over possible `p` values (from 1 to 31) and finding the smallest `k` such that `k^p = distance`. We sum these minimal weights.
3. **For Requirement 2**: We compute the optimal `p` for each distance in a similar loop and find the level `p` that provides the minimal weight `k` and write these levels to the output file.

This ensures the solution is efficient and meets the constraints given.
