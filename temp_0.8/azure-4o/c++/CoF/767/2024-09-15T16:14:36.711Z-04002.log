---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `dreptc.in` and write to `dreptc.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Se consideră $N$ puncte colorate dispuse în plan. Ele sunt identificate prin coordontele lor întregi, pe axele OX și OY. Fiecare punct are asociat un număr natural între $1$ și $C$ reprezentând codul culorii lui. Un dreptunghi se numește *corect* dacă îndeplinește simultan următoarele condiții:

* toate cele patru vârfuri se regăsesc printre cele N puncte date;
* are laturile paralele cu axele OX, OY;
* are vârfurile colorate în aceeași culoare.

# Cerință

Să se determine numărul maxim de dreptunghiuri *corecte* care se pot forma cu cele $N$ puncte din plan.

# Date de intrare

Pe prima linie a fișierul text `dreptc.in` se găsesc două numere $N, MaxC$ reprezentând numărul de puncte din plan și numărul de culori asociate punctelor. Pe următoarele $N$ linii se citesc câte trei numere $x \ y \ c$ reprezentând în ordine coordonata pe axa OX (abscisa), coordonata pe axa OY (ordonata) și codul culorii asociate punctului.

# Date de ieșire

Pe prima linie a fișierul text `dreptc.out` se va scrie un singur număr cu semnificația numărul maxim de dreptunghiuri corecte.

# Restricții și precizări

* $1 \leq N \leq 1 \ 000$;
* $1 \leq C \leq 5$;
* $-1 \ 000 \leq x, y \leq 1 \ 000$;
* Nu există două puncte cu aceleași coordonate
* $40$% din teste vor avea $N \leq 100$;

---

Example:
`dreptc.in`
```
9 2
3 10 1
3 8 2
3 6 1
3 4 1
3 0 1
6 0 1
6 4 1
6 8 2
6 10 1
```

`dreptc.out`
```
3
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:To tackle the problem efficiently, we need to focus on the conditions that make a rectangle "correct." Specifically, we need to look for groups of four points with the same color that form the vertices of a rectangle with sides parallel to the axes.

To achieve this, the following steps outline the efficient approach:

1. **Read Input:** Read the input data from the file.
2. **Organize Points by Color:** Since we need rectangles with vertices of the same color, organize the points by their color code.
3. **Find Rectangles:** For each color, find pairs of points that can form potential sides of rectangles. For each pair of points with the same x-coordinate (forming a vertical side) or the same y-coordinate (forming a horizontal side), check if the corresponding opposite sides exist.
4. **Count Rectangles:** Count the number of valid rectangles.

Let's implement this approach in C++:

```cpp
#include <iostream>
#include <fstream>
#include <unordered_map>
#include <vector>
#include <unordered_set>

using namespace std;

struct Point {
    int x, y, color;
};

int main() {
    ifstream fin("dreptc.in");
    ofstream fout("dreptc.out");

    int N, MaxC;
    fin >> N >> MaxC;

    vector<Point> points(N);
    unordered_map<int, vector<pair<int, int>>> colorPoints; // color -> list of (x, y)

    for (int i = 0; i < N; ++i) {
        int x, y, c;
        fin >> x >> y >> c;
        points[i] = {x, y, c};
        colorPoints[c].emplace_back(x, y);
    }

    int maxRectangles = 0;

    for (const auto& [color, pts] : colorPoints) {
        unordered_map<int, unordered_set<int>> xPoints, yPoints;
        for (const auto& [x, y] : pts) {
            xPoints[x].insert(y);
            yPoints[y].insert(x);
        }

        for (size_t i = 0; i < pts.size(); ++i) {
            for (size_t j = i + 1; j < pts.size(); ++j) {
                int x1 = pts[i].first, y1 = pts[i].second;
                int x2 = pts[j].first, y2 = pts[j].second;

                if (x1 == x2) {
                    // Vertical side candidate
                    if (yPoints[y1].count(x2) && yPoints[y2].count(x1)) {
                        ++maxRectangles;
                    }
                }
                else if (y1 == y2) {
                    // Horizontal side candidate
                    if (xPoints[x1].count(y2) && xPoints[x2].count(y1)) {
                        ++maxRectangles;
                    }
                }
            }
        }
    }

    fout << maxRectangles / 2 << endl; // Each rectangle counted twice

    return 0;
}
```

### Explanation:
1. **Reading Input:**
   - We read the number of points `N` and the number of colors `MaxC`.
   - Store the points in a vector and organize them by color using a map where the key is the color, and the value is a vector of coordinate pairs.

2. **Organize Points:**
   - For each color, we organize the points into two maps:
     - `xPoints` which maps x-coordinates to y-coordinates.
     - `yPoints` which maps y-coordinates to x-coordinates.

3. **Find Rectangles:**
   - For each pair of points, check if they can form vertical or horizontal sides of a rectangle.
   - If the points share the same x-coordinate, they are vertical side candidates. If they share the same y-coordinate, they are horizontal side candidates.
   - Check if the corresponding opposite sides exist in the `xPoints` and `yPoints` maps.

4. **Count Rectangles:**
   - Each valid rectangle is counted twice (once for each pair considered), so we divide the count by 2 before outputting the result.

This approach leverages hash maps and efficient lookups to ensure that the solution runs quickly even for the maximum constraints.
---------- user ----------


Program result did not match expected result.
Input data:
```
9 2
3 10 1
3 8 2
3 6 1
3 4 1
3 0 1
6 0 1
6 4 1
6 8 2
6 10 1
```
Expected output:
```
3
```
Found output:
```
6
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The discrepancy arises because the solution counts every valid pair twice. For example, for a rectangle formed by points (3, 0), (3, 4), (6, 4), (6, 0), the initial solution counts it both when considering (3, 0) and (3, 4) as one pair and (6, 0) and (6, 4) as another pair.

To fix this, we should ensure that each rectangle is counted once by considering only pairs of points that are both on a horizontal line and ensuring the remaining points form a proper rectangle.

Here is a reimplementation of the solution:

```cpp
#include <iostream>
#include <fstream>
#include <unordered_map>
#include <vector>
#include <unordered_set>

using namespace std;

struct Point {
    int x, y, color;
};

int main() {
    ifstream fin("dreptc.in");
    ofstream fout("dreptc.out");

    int N, MaxC;
    fin >> N >> MaxC;

    vector<Point> points(N);
    unordered_map<int, unordered_map<int, unordered_set<int>>> colorXMap; // color -> x -> set of y
    unordered_map<int, unordered_map<int, unordered_set<int>>> colorYMap; // color -> y -> set of x

    for (int i = 0; i < N; ++i) {
        int x, y, c;
        fin >> x >> y >> c;
        points[i] = {x, y, c};
        colorXMap[c][x].insert(y);
        colorYMap[c][y].insert(x);
    }

    int maxRectangles = 0;

    for (auto& [color, xMap] : colorXMap) {
        for (auto& [x1, ySet1] : xMap) {
            for (auto& [x2, ySet2] : xMap) {
                if (x1 >= x2) continue; // Ensure each pair is considered once

                for (int y1 : ySet1) {
                    for (int y2 : ySet1) {
                        if (y1 >= y2) continue; // Ensure each pair is considered once

                        // Check if both (x2, y1) and (x2, y2) exist
                        if (ySet2.count(y1) && ySet2.count(y2)) {
                            ++maxRectangles;
                        }
                    }
                }
            }
        }
    }

    fout << maxRectangles << endl;

    return 0;
}
```

### Explanation:
1. **Reading Input:**
   - Read the number of points `N` and the number of colors `MaxC`.
   - Store the points in a vector and organize them by color using two maps:
     - `colorXMap` which maps color to x-coordinates to sets of y-coordinates.
     - `colorYMap` which maps color to y-coordinates to sets of x-coordinates.

2. **Find Rectangles:**
   - Iterate over each color's x-coordinates.
   - For each pair of distinct x-coordinates, ensure that pairs of y-coordinates form potential rectangles.
   - Check if the corresponding opposite points exist in the `colorXMap`.

3. **Count Rectangles:**
   - The rectangles are counted only once by ensuring each x and y pair is considered in a specific order (to avoid duplication).

This approach ensures each rectangle is counted exactly once, matching the expected output.
