---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `secvente.in` and write to `secvente.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Mariei îi plac numerele prime și puterile numerelor prime. Pornind de la un număr prim $p$, ea construiește noi numere, fiecare număr construit fiind un produs de forma $p^y$ ($y \in ℕ$, $y \neq 0$) sau $q \cdot p^m$, $m \in ℕ$ și $q$ un număr prim, numindu-le numere $p$-prime. De exemplu, numerele $2, 3, 4, 5, 6, 7, 8, 10, 12, 13, 14, 16, 17 $sunt primele $13$ numere $2$-prime deoarece $2 = 2^1$, $3 = 3 \cdot 2^0$, $4 = 2^2$, $5 = 5 \cdot 2^0$, $6 = 3 \cdot 2^1$, $7 = 7 \cdot 2^0$, $8 = 2^3$, $10 = 5 \cdot 2^1$, $12 = 3 \cdot 2^2$, $13 = 13 \cdot 2^0$, $14 = 7 \cdot 2^1$, $16 = 2^4$, $17 = 17 \cdot 2^0$.

Într-o zi Maria a găsit o foaie de hârtie, pe care era scris un șir format din $n$ numere naturale nenule. Cum pe lângă numerele $p$-prime ea este pasionată și de secvențe, și-a pus următoarea întrebare: câte secvențe sunt pe foaie cu următoarele proprietăți:

* conțin exact $k$ numere $p$-prime;
* încep și se termină cu un număr $p$-prim.

În plus, Maria dorește să știe care este poziția de început și cea de final, pentru fiecare secvență descoperită, relative la șirul scris pe foaia de hârtie.

# Cerință

Scrieți un program care să citească mai multe seturi de date, fiecare set fiind format din numerele $n, p, k$, cu semnificațiile din enunț, și șirul cu $n$ elemente $a_1, a_2, a_3, \dots, a_n$, numerele Mariei. Programul va determina pentru fiecare set de date numărul secvențelor ce conțin exact $k$ numere $p$-prime, precum și pozițiile de început și de final ale acestor secvențe în șirul din set.

# Date de intrare

Pe prima linie a fișierului `secvente.in` se află numărul $D$ reprezentând numărul de seturi de date din fișier. Seturile de date sunt scrise în fișier pe linii succesive. Pentru fiecare set de date, prima linie conține câte trei numere naturale: $n$ (numărul de elemente de pe foaie), $p$ și $k$ (cu semnificația din enunț), separate prin câte un spațiu, iar fiecare dintre următoarele $n$ linii conține câte un număr natural al șirului $a_1, a_2, a_3, \dots, a_n$, numerele din șirul Mariei.

# Date de ieșire

Fișierul `secvente.out` va conține $D$ soluții corespunzătoare celor $D$ seturi de date. Pentru fiecare soluție prima linie va conține un număr $x$ reprezentând numărul de secvențe ce îndeplinesc proprietățile cerute, iar fiecare dintre următoarele $x$ linii vor conține câte $2$ numere naturale, separate printr-un spațiu, reprezentând poziția de început, respectiv de final a fiecărei secvențe, linii ordonate crescător după poziția de început. Dacă în șir nu există o astfel de secvență, prima linie a setului va conține valoarea $0$.

# Restricții și precizări

* $1 \leq D \leq 15$;
* $1 \leq k, n \leq 15 \ 000$;
* $2 \leq p \leq 30 \ 000$; $p$ este un număr natural prim
* $1 \leq a_1, a_2, a_3, \dots, a_n \leq 30 \ 000$; $a_1, a_2, a_3, \dots, a_n \in ℕ$
* Pozițiile din șir sunt numerotate de la 1.
* Numărul $1$ nu este $p$-prim.
* O secvență dintr-un șir este formată din elemente aflate pe poziții consecutive în șirul dat.

---

Example:
`secvente.in`
```
2
5 3 2
7
27
4
45
1
3 5 7
3
4
5
```

`secvente.out`
```
2
1 2
2 4
0
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```cpp
#include <fstream>
#include <vector>
#include <cmath>

bool isPrime(int x) {
    if (x < 2) return false;
    if (x <= 3) return true;
    if (x % 2 == 0 || x % 3 == 0) return false;
    int i = 5;
    while (i * i <= x) {
        if (x % i == 0 || x % (i + 2) == 0) return false;
        i += 6;
    }
    return true;
}

bool isPPrime(int number, int p) {
    if (number == 1) return false;
    if (number == p) return true;
    if (number % p != 0) return isPrime(number);
    while (number % p == 0) number /= p;
    return isPrime(number);
}

int main() {
    std::ifstream in("secvente.in");
    std::ofstream out("secvente.out");

    int D, n, p, k, num;
    in >> D;
    while (D--) {
        in >> n >> p >> k;
        std::vector<int> pPrimes;
        std::vector<int> startPos;
        std::vector<std::pair<int, int>> sequences;

        for (int i = 1; i <= n; ++i) {
            in >> num;
            if (isPPrime(num, p)) {
                pPrimes.push_back(i);
            }
        }

        for (size_t j = 0; j + k - 1 < pPrimes.size(); ++j) {
            if (pPrimes[j + k - 1] - pPrimes[j] == k - 1) {
                sequences.emplace_back(pPrimes[j], pPrimes[j + k - 1]);
            }
        }

        out << sequences.size() << '\n';
        for (const auto& seq : sequences) {
            out << seq.first << ' ' << seq.second << '\n';
        }
    }
    return 0;
}
```
This code should read the input from `secvente.in`, process the data to find the sequences of exact `k` `p`-primes as described, and write the results to `secvente.out`. The isPrime function is used to check if a number is prime, and the isPPrime function checks if a number is `p`-prime according to Maria's definition. The main part of the program reads the input and processes each dataset, finding the `p`-prime numbers and their positions, then determining the sequences that match the criteria.
---------- user ----------


Program result did not match expected result.
Input data:
```
2
5 3 2
7
27
4
45
1
3 5 7
3
4
5
```
Expected output:
```
2
1 2
2 4
0
```
Found output:
```
0
0
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The initial solution incorrectly assumes that a valid sequence of `k` `p`-primes only occurs when the difference between the positions of the first and the last `p`-prime in a subset of the pPrimes vector is exactly `k - 1`. However, the problem statement allows for non-`p`-prime numbers to exist between the `p`-primes within a sequence. Thus, the condition `pPrimes[j + k - 1] - pPrimes[j] == k - 1` is too restrictive.

Here is the revised solution:

```cpp
#include <fstream>
#include <vector>

bool isPrime(int number) {
    if (number < 2) return false;
    for (int i = 2; i * i <= number; i++) {
        if (number % i == 0) return false;
    }
    return true;
}

bool isPPrime(int number, int p) {
    if (number == 1) return false;
    if (number == p) return true;
    if (number % p == 0) number /= p;
    return number == 1 || isPrime(number);
}

int main() {
    std::ifstream in("secvente.in");
    std::ofstream out("secvente.out");

    int D, n, p, k, num;
    in >> D;
    while (D--) {
        in >> n >> p >> k;
        std::vector<int> nums(n);
        std::vector<std::pair<int, int>> sequences;

        for (int i = 0; i < n; ++i) {
            in >> nums[i];
        }

        int count = 0, left = 0, right = 0;
        // Sliding window approach to find valid sequences
        while (right < n) {
            // Expand the window to the right
            if (isPPrime(nums[right++], p)) {
                count++;
            }

            // If we have exactly k p-primes, record the sequence
            while (count == k) {
                if (isPPrime(nums[left], p)) {
                    if (isPPrime(nums[right - 1], p)) {
                        sequences.emplace_back(left + 1, right);
                    }
                    // Increment left to potentially start a new sequence
                    count--;
                }
                left++;
            }
        }

        out << sequences.size() << '\n';
        for (const auto& seq : sequences) {
            out << seq.first << ' ' << seq.second << '\n';
        }
    }

    in.close();
    out.close();
    return 0;
}
```

This revised solution takes a sliding window approach. It reads the input data and then uses two pointers, `left` and `right`, to maintain the window. The window is expanded by moving `right` to the next position as long as there are fewer than `k` p-primes in the window. When there are exactly `k` p-primes in the window, a valid sequence is recorded, and then `left` is incremented to potentially start a new sequence. This process continues until `right` reaches the end of the list of numbers.

The `isPrime` and `isPPrime` functions check for prime and p-prime numbers, respectively. The `isPPrime` function now properly handles the case where a `p`-prime can be a prime number multiplied by a power of `p` (including `p^0` which is 1).

This solution should now produce the correct output as per the problem statement and example provided.
---------- user ----------


Program result did not match expected result.
Input data:
```
2
5 3 2
7
27
4
45
1
3 5 7
3
4
5
```
Expected output:
```
2
1 2
2 4
0
```
Found output:
```
0
0
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

Apologies for the confusion. Let's evaluate the differences and find out why the expected output does not match the found output.

The expected output indicates that for the first set of data, there are 2 sequences that satisfy the conditions:
- The sequence starting at position 1 and ending at position 2, which contains the numbers 7 and 27 (both are 3-prime numbers).
- The sequence starting at position 2 and ending at position 4, which contains the numbers 27, 4, and 45 (with 27 and 45 being 3-prime numbers).

For the second set of data, there are no sequences that satisfy the conditions since there are not enough 5-prime numbers to make up a sequence of 7 consecutive 5-prime numbers.

To fix the solution, we need to adjust the conditions that determine when a sequence is valid. Specifically, the solution should look for sequences that contain exactly `k` numbers that are `p`-prime and that start and end with a `p`-prime number. It must also be noted that non-`p`-prime numbers can be part of the sequence but don't count towards the `k` `p`-primes.

Here is the corrected solution:

```cpp
#include <fstream>
#include <vector>

std::ifstream in("secvente.in");
std::ofstream out("secvente.out");

bool isPrime(int x) {
    if (x < 2) return false;
    for (int d = 2; d * d <= x; ++d) {
        if (x % d == 0) return false;
    }
    return true;
}

bool isPPrime(int number, int p) {
    if (number % p == 0) {
        do {
            number /= p;
        } while (number % p == 0);
    }
    return isPrime(number);
}

int main() {
    int D, n, p, k, num;
    in >> D;
    while (D--) {
        in >> n >> p >> k;
        std::vector<bool> isPPrimeArray(n, false);
        int pPrimeCount = 0, startSeq = -1, endSeq, totalSeq = 0;

        for (int i = 0; i < n; ++i) {
            in >> num;
            if (isPPrime(num, p)) {
                isPPrimeArray[i] = true;
                if (startSeq == -1) startSeq = i;
                pPrimeCount++;
            }
            if (pPrimeCount == k) {
                endSeq = i;
                while (!isPPrimeArray[startSeq]) startSeq++;
                out << startSeq + 1 << " " << endSeq + 1 << "\n";
                totalSeq++;
                startSeq++;
                pPrimeCount--;
            }
        }

        // Output the number of total sequences at the beginning
        out.seekp(std::ios_base::beg);
        out << totalSeq << "\n";
        out.seekp(0, std::ios_base::end);
    }

    in.close();
    out.close();
    return 0;
}
```

This version of the solution keeps track of the start and end positions of potential sequences and counts the number of `p`-primes encountered. When exactly `k` `p`-primes are found in a sequence, it is written to the output. The use of `seekp` allows us to first write the number of sequences at the beginning of each test case after computing all sequences.

This corrected solution should now align with the expected output provided in the problem statement.
---------- user ----------


Program result did not match expected result.
Input data:
```
2
5 3 2
7
27
4
45
1
3 5 7
3
4
5
```
Expected output:
```
2
1 2
2 4
0
```
Found output:
```
0
4
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

It seems I made a mistake with the use of `seekp` which is not working as intended; manipulating the file pointer is not the correct approach for this problem. Instead, we should store the sequence information and write all output at the end.

Let's revise the solution to store the sequences first, and then write the count and the sequences afterwards. We will fix the algorithm to correctly find sequences that start and end with a `p`-prime and contain exactly `k` `p`-primes, including any number of non-`p`-primes in between.

Here is the corrected solution:

```cpp
#include <fstream>
#include <vector>

std::ifstream in("secvente.in");
std::ofstream out("secvente.out");

bool isPrime(int x) {
    if (x < 2) return false;
    for (int d = 2; d * d <= x; ++d) {
        if (x % d == 0) return false;
    }
    return true;
}

bool isPPrime(int number, int p) {
    if (number == 1) return false;
    if (number == p) return true;
    if (number % p == 0) number /= p;
    return number == 1 || isPrime(number);
}

int main() {
    int D, n, p, k, num;
    in >> D;

    while (D--) {
        in >> n >> p >> k;
        std::vector<int> pPrimeIndices;
        for (int i = 0; i < n; ++i) {
            in >> num;
            if (isPPrime(num, p)) {
                pPrimeIndices.push_back(i);
            }
        }

        // Now find all sequences that contain exactly k p-primes
        std::vector<std::pair<int, int>> sequences;
        for (size_t i = 0; i + k - 1 < pPrimeIndices.size(); ++i) {
            if (i + k < pPrimeIndices.size() && 
                pPrimeIndices[i + k] - pPrimeIndices[i] == k) {
                continue; // Skip this sequence as it has more than k p-primes
            }
            if (pPrimeIndices[i + k - 1] - pPrimeIndices[i] >= k - 1) {
                sequences.emplace_back(pPrimeIndices[i] + 1, pPrimeIndices[i + k - 1] + 1);
            }
        }

        // Write the results for the current test case
        out << sequences.size() << "\n";
        for (const auto& seq : sequences) {
            out << seq.first << " " << seq.second << "\n";
        }
    }

    in.close();
    out.close();
    return 0;
}
```

This solution uses a vector `pPrimeIndices` to store the indices of `p`-primes. After reading all numbers, it finds all sequences that contain exactly `k` `p`-primes. For each potential starting index, it checks that adding `k` `p`-primes does not exceed a sequence length of `k` and that the sequence length is at least `k` including any non-`p`-primes between the start and end `p`-primes. The results are then written to the output file.

This revised solution should output the correct sequences as expected.
---------- user ----------


Program result did not match expected result.
Input data:
```
2
5 3 2
7
27
4
45
1
3 5 7
3
4
5
```
Expected output:
```
2
1 2
2 4
0
```
Found output:
```
0
0
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

Upon further examination, the current approach does not retain the intermediate non-p-prime values when counting the sequences. We need to implement a sliding window approach that can maintain the count of p-primes within a certain range, and only if the count matches `k` do we then consider recording the sequence. The sequence is valid if it starts and ends with a p-prime, regardless of the values in between, as long as exactly `k` p-primes are within the sequence.

Let's implement the correct sliding window approach to solve this issue:

```cpp
#include <fstream>
#include <vector>

std::ifstream in("secvente.in");
std::ofstream out("secvente.out");

bool isPrime(int number) {
    if (number < 2) return false;
    for (int i = 2; i * i <= number; ++i) {
        if (number % i == 0) return false;
    }
    return true;
}

bool isPPrime(int number, int p) {
    if (number == 1) return false;
    if (number == p) return true;
    if (number % p != 0) return isPrime(number);
    while (number % p == 0) number /= p;
    return isPrime(number);
}

int main() {
    int D;
    in >> D;

    while (D--) {
        int n, p, k;
        in >> n >> p >> k;

        std::vector<int> pIndicies; // Store indices of p-prime numbers
        std::vector<std::pair<int, int>> sequences; // Store sequences found

        for (int i = 0; i < n; ++i) {
            int num;
            in >> num;
            if (isPPrime(num, p)) {
                pIndicies.push_back(i);
            }
        }

        int count = 0;
        for (size_t start = 0, end = 0; end < pIndicies.size(); ++end) {
            // If we have more p-primes than needed, move the start forward
            if (end - start + 1 > k) {
                ++start;
            }
            // If we have exactly k p-primes, check for sequences
            if (end - start + 1 == k) {
                int startPos = pIndicies[start] + 1; // 1-based index
                int endPos = pIndicies[end] + 1; // 1-based index
                // Check both ends of the sequence for p-primes
                for (int i = pIndicies[start]; i <= pIndicies[end]; ++i) {
                    if (isPPrime(i + 1, p)) { // Convert to 1-based index for comparison
                        startPos = std::min(startPos, i + 1);
                        break;
                    }
                }
                for (int i = pIndicies[end]; i >= pIndicies[start]; --i) {
                    if (isPPrime(i + 1, p)) { // Convert to 1-based index for comparison
                        endPos = std::max(endPos, i + 1);
                        break;
                    }
                }
                sequences.emplace_back(startPos, endPos);
                ++start; // Move start forward for the next potential sequence
            }
        }

        out << sequences.size() << '\n';
        for (const auto& seq : sequences) {
            out << seq.first << ' ' << seq.second << '\n';
        }
    }

    return 0;
}
```

In this revised version, we first collect all the indices of the p-primes. Then, using a sliding window, we find sequences of `k` p-primes. A valid sequence must start and end with a p-prime, but it can contain non-p-prime numbers in between. When we find a sequence with exactly `k` p-primes, we make sure that both the starting and ending positions align with a p-prime.

This solution should now produce the expected output correctly.
---------- user ----------


Program result did not match expected result.
Input data:
```
2
5 3 2
7
27
4
45
1
3 5 7
3
4
5
```
Expected output:
```
2
1 2
2 4
0
```
Found output:
```
1
1 4
0
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

Let's analyze the situation:

1. The expected output indicates that there should be two sequences found for the first data set: one starting at position 1 and ending at position 2, and another starting at position 2 and ending at position 4.
2. The found output only reports one sequence starting at position 1 and ending at position 4, which is incorrect. It should also have reported the second sequence starting at position 2 and ending at position 4.

The issue seems to be the logic used to detect the sequences. The current solution tries to adjust the start and end positions based on the presence of `p`-primes at the edges of the current window. However, the algorithm should simply check if there are `k` `p`-primes within a range and that the first and last elements of the range are `p`-primes.

Let's correct the algorithm:

```cpp
#include <fstream>
#include <vector>

std::ifstream in("secvente.in");
std::ofstream out("secvente.out");

bool isPrime(int number) {
    if (number == 2) return true;
    if (number < 2 || number % 2 == 0) return false;
    for (int div = 3; div * div <= number; div += 2) {
        if (number % div == 0) return false;
    }
    return true;
}

bool isPPrime(int number, int p) {
    if (number == p) return true;
    if (number % p == 0) {
        number /= p;
        while (number % p == 0) {
            number /= p;
        }
    }
    return isPrime(number);
}

int main() {
    int D;
    in >> D;
    while (D--) {
        int n, p, k;
        in >> n >> p >> k;
        std::vector<int> seq;
        std::vector<std::pair<int, int>> results;

        for (int i = 0; i < n; ++i) {
            int number;
            in >> number;
            if (isPPrime(number, p)) {
                seq.push_back(i + 1); // Using 1-based indexing for positions
            }
        }

        int start = 0;
        int end = 0;

        // Use a sliding window to find sequences of exactly k p-primes
        while (end < seq.size()) {
            if ((end - start + 1) < k) {
                end++;
            } else if ((end - start + 1) == k) {
                // Check for additional p-primes right outside the current window
                if ((start > 0 && isPPrime(seq[start - 1], p)) || (end < seq.size() - 1 && isPPrime(seq[end + 1], p))) {
                    start++; // This is not a valid start, move the window
                    continue;
                }
                // At this point, we have exactly k p-primes in the window, and we can record the sequence
                results.push_back({seq[start], seq[end]});
                start++;
                end++;
            } else {
                start++;
            }
        }

        out << results.size() << "\n";
        for (const auto &result : results) {
            out << result.first << " " << result.second << "\n";
        }
    }
    in.close();
    out.close();
    return 0;
}
```

This solution correctly processes the input to find and output sequences of exactly `k` p-primes using a sliding window approach, taking into account the condition that sequences must start and end with a p-prime, and no extra p-primes are immediately before or after the sequence.

The expected behavior is that this solution will produce the correct output as per the example provided.
---------- user ----------


Program result did not match expected result.
Input data:
```
2
5 3 2
7
27
4
45
1
3 5 7
3
4
5
```
Expected output:
```
2
1 2
2 4
0
```
Found output:
```
1
1 4
0
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The issue with the found output is that it is not correctly identifying all the valid sequences. The expected output shows two valid sequences for the first set of input data, but our code is only finding one. The current algorithm must be adjusted to identify every valid sequence that starts and ends with a p-prime number and contains exactly k p-primes.

The mistake in the last attempt was in the sliding window condition where it incorrectly skipped valid sequences by checking for p-primes outside of the current window.

Let's correct the algorithm to properly identify sequences:

```cpp
#include <fstream>
#include <vector>

std::ifstream in("secvente.in");
std::ofstream out("secvente.out");

bool isPrime(int number) {
    if (number < 2) return false;
    for (int i = 2; i * i <= number; ++i) {
        if (number % i == 0) return false;
    }
    return true;
}

bool isPPrime(int number, int p) {
    if (number == 1) return false;
    if (number == p) return true;
    if (number % p != 0) return isPrime(number);
    while (number % p == 0) number /= p;
    return isPrime(number);
}

int main() {
    int D;
    in >> D;
    while (D--) {
        int n, p, k;
        in >> n >> p >> k;
        std::vector<int> numbers(n);
        std::vector<bool> isPPrimeVec(n, false);
        std::vector<std::pair<int, int>> sequences;

        for (int i = 0; i < n; ++i) {
            in >> numbers[i];
            if (isPPrime(numbers[i], p)) {
                isPPrimeVec[i] = true;
            }
        }

        int pCount = 0;
        int start = -1;
        // Iterate through all numbers, maintaining the count of p-primes
        for (int i = 0; i < n; ++i) {
            if (isPPrimeVec[i]) {
                pCount++;
                if (start == -1) start = i;
            }
            // When we have k p-primes, check if the sequence is valid
            if (pCount == k && isPPrimeVec[i]) {
                int end = i;
                // Look for the next non-p-prime to define the sequence end
                while (end + 1 < n && !isPPrimeVec[end + 1]) {
                    ++end;
                }
                sequences.push_back(std::make_pair(start + 1, end + 1)); // 1-based indexing
                // Reset the start and decrease the p-prime count for the next sequence
                start = -1;
                pCount = 0;
                i -= k - 1; // Move back to process overlapping sequences
            }
        }

        out << sequences.size() << "\n";
        for (const auto& seq : sequences) {
            out << seq.first << " " << seq.second << "\n";
        }
    }
    in.close();
    out.close();
    return 0;
}
```
In this solution, we maintain a count of the p-primes we encounter as we iterate through the numbers. When we reach exactly `k` p-primes, we check if the current number is a p-prime to ensure a valid end of the sequence. Then, we find the end of the sequence by looking for the next non-p-prime number. After recording a sequence, we reset the start position and p-prime count, and we move back in the array to consider overlapping sequences. This should cover cases where multiple valid sequences overlap. The output should now match the expected results.
