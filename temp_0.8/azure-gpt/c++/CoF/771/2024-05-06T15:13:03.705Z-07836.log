---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `pluricex.in` and write to `pluricex.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Anul acesta se organizează prima ediţie a Olimpiadei Pluridisciplinare pentru Centrele de Excelenţă, *PluriCEX*. Fiecare Centru de Excelenţă din ţară va trimite la concurs o echipă formată din $k$ membri (toţi participanţi la Centrul de Excelenţă). Echipa va trebui să rezolve probleme interdisciplinare, disciplinele vizate fiind cele de la Centrul de Excelenţă ($D$ discipline, pe care le vom considera numerotate de la $1$ la $D$).

Directorul CEX Iaşi a făcut o listă cu primii $n$ cei mai buni elevi de la CEX, apoi a numerotat elevii de la $1$ la $n$, în ordinea apariţiei lor în listă. Pentru fiecare elev, directorul a notat disciplinele la care el participă la CEX.

# Cerinţă
Scrieţi un program care să determine toate echipele ce pot fi formate din $k$ dintre cei $n$ elevi de pe lista directorului, cu condiţia ca pentru fiecare disciplină să existe în echipă cel puţin un membru care să studieze la CEX disciplina respectivă.

# Date de intrare
Fişierul de intrare `pluricex.in` conţine pe prima linie trei numere naturale $n$, $k$ și $D$ (cu semnificaţia din enunţ). Urmează $n$ linii care descriu participările la CEX ale celor $n$ elevi de pe lista directorului. Mai exact, pe linia $i+1$ este descrisă participarea elevului $i$ astfel: $nr$, $d_1$, $d_2$, $\dots$, $d_{nr}$.

Primul număr de pe linie ($nr$) indică numărul de discipline la care participă elevul $i$. Următoarele $nr$ numere reprezintă disciplinele la care participă elevul $i$. Numerele scrise pe aceeaşi linie sunt separate prin spaţiu.

# Date de ieşire
Fişierul de ieşire `pluricex.out` va conţine toate echipele ce se pot forma respectând condiţiile din enunţ, câte o echipă pe o linie. Membrii unei echipe vor fi scrişi în ordine crescătoare, separaţi prin câte un spaţiu. Echipele vor fi scrise în ordine lexicografică.

# Restricţii şi precizări
- $0 < n \leq 22$
- $0 < k \leq 8$
- $0 < D \leq 10$
- Pentru datele de test problema admite întotdeauna soluţie, numărul de soluţii fiind $< 20\ 000$.
- Spunem că vectorul $(x_1, x_2, \dots, x_n)$ precedă lexicografic vectorul $(y_1, y_2, \dots, y_n)$ dacă există un indice $i$ astfel încât $x_j=y_j$ pentru orice $1 \leq j < i$, iar $x_i < y_i$.
- Pentru $20\%$ din teste soluţia este unică.

---

Example:
`pluricex.in`
```
6 3 5
1 2
2 1 4
3 2 4 3
1 5
2 3 1
1 3
```

`pluricex.out`
```
2 3 4
3 4 5
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```cpp
#include <fstream>
#include <vector>
#include <bitset>

std::vector<int> students[23];
std::vector<int> teams;
std::bitset<11> disciplines_covered;
std::ofstream ofs("pluricex.out");

void generate(int idx, int selected, int n, int k, int D) {
    if (selected == k) {
        for (int disc = 1; disc <= D; ++disc) {
            if (!disciplines_covered[disc]) return;
        }
        for (int i = 0; i < k; ++i) {
            ofs << teams[i] + 1 << (i + 1 == k ? '\n' : ' ');
        }
        return;
    }
    if (idx == n) return;

    // try to select the current student
    teams.push_back(idx);
    std::bitset<11> disciplines_backup = disciplines_covered;
    for (int disc : students[idx]) {
        disciplines_covered.set(disc);
    }
    generate(idx + 1, selected + 1, n, k, D);

    // backtrack: unselect the current student
    teams.pop_back();
    disciplines_covered = disciplines_backup;
    generate(idx + 1, selected, n, k, D);
}

int main() {
    std::ifstream ifs("pluricex.in");
    int n, k, D;
    ifs >> n >> k >> D;

    for (int i = 0; i < n; ++i) {
        int m, discipline;
        ifs >> m;
        while (m--) {
            ifs >> discipline;
            students[i].push_back(discipline);
        }
    }
    
    generate(0, 0, n, k, D);
    ofs.close();
    ifs.close();

    return 0;
}
```

Let's go over the key points of the solution:

- We're using an array of vectors `students` to store the disciplines each student is good at.
- We use a vector `teams` to store the current team being considered.
- A `std::bitset` named `disciplines_covered` is used to quickly check whether all disciplines are covered by the current team.
- The function `generate` is a recursive backtracking function that tries to form valid teams by including or excluding each student one by one.
- The output file `pluricex.out` is written using `std::ofstream` to comply with the requirement of avoiding `cout`, `printf`, etc.
- Once a valid team is found (all disciplines are covered), we write the team to the output file.
- The backtracking mechanism ensures that all possible combinations are checked, and the lexicographic order is naturally maintained by the way the recursive function is structured.
