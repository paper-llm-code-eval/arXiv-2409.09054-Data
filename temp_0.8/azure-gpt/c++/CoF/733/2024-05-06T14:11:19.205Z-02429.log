---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `perle.in` and write to `perle.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Graniţa nu se trece uşor. Asta pentru că Balaurul Arhirel (mare pasionat de informatică) nu lasă pe nimeni să treacă decât după ce răspunde la nişte întrebări...

În acea ţară există $3$ tipuri de perle normale (le vom nota cu $1$, $2$ şi $3$) şi $3$ tipuri de perle magice (le vom nota cu $A$, $B$ şi $C$). Perlele magice sunt deosebite prin faptul că se pot transforma în alte perle (una sau mai multe, normale sau magice):
- Perla magică de tipul $A$ se poate transforma în orice perlă normală (una singură);
- Perla magică de tipul $B$ se poate transforma într-o perlă normală de tipul $2$ şi una magică de tipul $B$, sau într-o perlă normală de tipul $1$, una magică de tipul $A$, una normală de tipul $3$, una magică de tipul $A$ şi una magică de tipul $C$;
- Perla magică de tipul $C$ se poate transforma într-o perlă normală de tipul $2$ sau într-o perlă normală de tipul $3$, una magică de tipul $B$ şi una magică de tipul $C$ sau într-o perlă normală de tipul $1$, una normală de tipul $2$ şi una magică de tipul $A$.

Ca să rezumăm cele de mai sus putem scrie:
```
A -> 1  | 2     | 3
B -> 2B | 1A3AC
C -> 2  | 3BC   | 12A
```

Balaurul Arhirel ne lasă la început să ne alegem o perlă magică (una singură), iar apoi folosind numai transformările de mai sus trebuie să obţinem un anumit şir de perle normale. Când o perlă magică se transformă, perlele din stânga şi din dreapta ei rămân la fel (şi în aceeaşi ordine). De asemenea ordinea perlelor rezultate din transformare este chiar cea prezentată mai sus.

De exemplu, dacă balaurul ne cere să facem şirul de perle `21132123`, putem alege o perlă magică de tipul $B$ şi următorul şir de transformări: `B -> 2B -> 21A3AC -> 21A3A12A -> 21132123`.

Întrucât Balaurul nu are prea multă răbdare, el nu ne cere decât să spunem dacă se poate sau nu obţine şirul respectiv de perle.

# Cerință

Să se determine pentru fiecare şir de intrare dacă se poate obţine prin transformările de mai sus sau nu (alegând orice primă perlă magică, la fiecare şir).

# Date de intrare

Fişierul de intrare `perle.in` are următoarea structură:
* Pe prima linie numărul $N$, reprezentând numărul de şiruri din fişierul de intrare;
* Urmează $N$ linii; a $i$-a linie dintre cele $N$ descrie şirul $i$, printr-o succesiune de numere naturale despărţite de câte un spaţiu. Primul număr reprezintă lungimea şirului $L_i$, iar următoarele $L_i$ numere sunt tipurile de perle normale, în ordine, de la stânga la dreapta.

# Date de ieșire

Fişierul `perle.out` va conţine $N$ linii. Pe linia $i$ se va scrie un singur număr $1$ sau $0$ ($1$ dacă se poate obţine şirul respectiv (al $i$-lea) şi $0$ dacă nu se poate).

# Restricții și precizări

* $1 \leq N \leq 10$;
* $1 \leq L_i \leq 10 \ 000$, pentru oricare $i$;

---

Example:
`perle.in`
```
3
8 2 1 1 3 2 1 2 3
2 2 2
1 3
```

`perle.out`
```
1
0
1
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```cpp
#include <fstream>
#include <vector>
#include <string>

using namespace std;

int check_string(const vector<int>& beads) {
    int balanceA = 0, balanceB = 0, balanceC = 0;
    for (int bead : beads) {
        switch (bead) {
            case 1:
                if (balanceA > 0) --balanceA;
                else if (balanceC > 0) --balanceC;
                else return 0;
                break;
            case 2:
                if (balanceB > 0) --balanceB;
                else if (balanceC > 0) --balanceC;
                else ++balanceA;
                break;
            case 3:
                if (balanceA > 0) --balanceA;
                else if (balanceC > 0) --balanceC;
                else {
                    if (balanceB > 0) --balanceB;
                    else ++balanceC;
                }
                break;
        }
    }
    // Check if we can close all the opened magic beads
    if (balanceA == 0 && balanceB == 0 && balanceC == 0) return 1;
    return 0;
}

int main() {
    ifstream fin("perle.in");
    ofstream fout("perle.out");

    int N, L;
    fin >> N;
    vector<int> beads;

    while (N--) {
        fin >> L;
        beads.clear();
        beads.reserve(L);
        for (int i = 0; i < L; ++i) {
            int bead;
            fin >> bead;
            beads.push_back(bead);
        }
        fout << check_string(beads) << '\n';
    }

    fin.close();
    fout.close();

    return 0;
}
```
---------- user ----------


Program result did not match expected result.
Input data:
```
3
8 2 1 1 3 2 1 2 3
2 2 2
1 3
```
Expected output:
```
1
0
1
```
Found output:
```
0
0
0
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The initial solution does not correctly check if the target string can be obtained from the magic beads. Let's revise the algorithm and fix the issue. The revised solution should check for all possibilities of transformations that can be made with the magic beads and ensure that if magic bead transformations are made in the right order, the target string can be obtained. Here is the revised solution:

```cpp
#include <fstream>
#include <vector>

using namespace std;

// Recursive function to check if the string can be obtained.
bool canObtainString(vector<int>& beads, int idx, int aCount, int bCount, int cCount) {
    // If we have used all beads, check if all counts are non-negative.
    if (idx == beads.size())
        return aCount >= 0 && bCount >= 0 && cCount >= 0;

    // If any count is negative, the string cannot be obtained.
    if (aCount < 0 || bCount < 0 || cCount < 0)
        return false;

    // Check if we can make the current bead using a magic bead. If so, recurse.
    switch (beads[idx]) {
        case 1:
            // Either use an A or open a C.
            return canObtainString(beads, idx + 1, aCount - 1, bCount, cCount) ||
                   canObtainString(beads, idx + 1, aCount + 2, bCount - 1, cCount);
        case 2:
            // Either use an A or use a B or use a C.
            return canObtainString(beads, idx + 1, aCount - 1, bCount, cCount) ||
                   canObtainString(beads, idx + 1, aCount, bCount - 1, cCount) ||
                   canObtainString(beads, idx + 1, aCount, bCount, cCount - 1);
        case 3:
            // Either use an A or use a C or use a B and open a C.
            return canObtainString(beads, idx + 1, aCount - 1, bCount, cCount) ||
                   canObtainString(beads, idx + 1, aCount, bCount, cCount - 1) ||
                   canObtainString(beads, idx + 1, aCount + 1, bCount - 1, cCount + 1);
        default:
            return false;
    }
}

int main() {
    ifstream fin("perle.in");
    ofstream fout("perle.out");

    int N, L;
    fin >> N;

    while (N--) {
        fin >> L;
        vector<int> beads(L);
        for (int i = 0; i < L; ++i) {
            fin >> beads[i];
        }
        // Start with one magic bead of each type since we can choose any.
        fout << canObtainString(beads, 0, 0, 0, 0) << '\n';
    }

    fin.close();
    fout.close();

    return 0;
}
```

This solution uses a recursive function `canObtainString` that attempts to build the target string from the magic beads, keeping track of how many times each magic bead can be used (aCount, bCount, cCount). We start with zero counts of magic beads since we can pick any one initially. The recursive function checks if the current bead in the target string can be obtained from the magic beads with the number of times each can be used. It backtracks if the current configuration does not lead to a solution.

The recursion will ensure that all possible combinations of magic bead transformations are tried in order to obtain the target string. If any of these combinations match the target string, the function will return true, indicating that the string can be obtained.
---------- user ----------


Program result did not match expected result.
Input data:
```
3
8 2 1 1 3 2 1 2 3
2 2 2
1 3
```
Expected output:
```
1
0
1
```
Found output:
```
0
0
0
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The previous solutions were incorrect because they did not take into account the proper transformation rules of the magic beads as described in the problem statement. The correct transformations should mimic the described behavior, which involves recursive or iterative checks with proper backtracking.

Let's implement a new solution that correctly applies the transformation rules:

```cpp
#include <fstream>
#include <vector>

using namespace std;

bool isTransformable(const vector<int> &target, int idx, int a, int b, int c) {
    // Base case: if the target is entirely checked
    if (idx == target.size()) return a == 0 && b == 0 && c == 0;

    // If the target cannot be constructed with the current beads
    if (a < 0 || b < 0 || c < 0) return false;

    // Check each possible transformation recursively
    bool result = false;
    switch (target[idx]) {
        case 1:
            // A can become 1 or we can close a previously opened A or C
            result = isTransformable(target, idx + 1, a - 1, b, c) || // A -> 1
                     isTransformable(target, idx + 1, a + 1, b - 1, c - 1); // C -> 1 2 A
            break;
        case 2:
            // A or C can become 2 or we can open a new B
            result = isTransformable(target, idx + 1, a - 1, b, c) || // A -> 2
                     isTransformable(target, idx + 1, a, b - 1, c) || // B -> 2 B
                     isTransformable(target, idx + 1, a, b, c - 1);   // C -> 2
            break;
        case 3:
            // A can become 3, B can become a sequence that ends with 3, or C can become a sequence with 3
            result = isTransformable(target, idx + 1, a - 1, b, c) || // A -> 3
                     isTransformable(target, idx + 1, a + 2, b - 1, c) || // B -> 1 A 3 A C
                     isTransformable(target, idx + 1, a, b, c - 1);   // C -> 3 B C
            break;
    }
    return result;
}

int main() {
    ifstream fin("perle.in");
    ofstream fout("perle.out");
    
    int N, L;
    fin >> N;
    
    while (N--) {
        fin >> L;
        vector<int> target(L);
        for (int i = 0; i < L; ++i) {
            fin >> target[i];
        }
        // We can choose any magic bead at the start, so we try with one of each
        fout << isTransformable(target, 0, 1, 1, 1) << '\n';
    }
    
    fin.close();
    fout.close();
    
    return 0;
}
```

In this solution, the `isTransformable` function checks if we can transform a sequence of magic beads A, B, and C into the given target string of normal beads. The function is called with the initial counts of 1 for each magic bead since we can choose any one of them to start with. We use recursion to simulate the application of transformation rules and use backtracking to undo a transformation if it does not lead to a solution.

The function `isTransformable` takes the following parameters:

- `target`: The vector containing the target sequence of normal beads.
- `idx`: The current position in the target sequence we are trying to match.
- `a`, `b`, `c`: The counts of how many times we can use each magic bead A, B, C.

When the function finishes, the `fout` writes `1` if the target string can be obtained; otherwise, it writes `0`.
---------- user ----------


Program result did not match expected result.
Input data:
```
3
8 2 1 1 3 2 1 2 3
2 2 2
1 3
```
Expected output:
```
1
0
1
```
Found output:
```
0
0
0
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

Let's diagnose why the previous solution failed to produce the correct output. Upon looking at the problem statement more carefully, we can see that the magic beads have very specific transformation rules which must be followed exactly. The previous solutions attempted to find a general recursive algorithm, but may not have handled the specific transformations correctly.

Let's try a different approach. We will map the transformations of each magic bead to the possible strings they could generate, then work backwards from the target string to see if we can reach a single magic bead.

Here's a new implementation considering the exact rules:

```cpp
#include <fstream>
#include <vector>
#include <string>

using namespace std;

// This function checks if it's possible to reduce the string to a single magic bead
bool isPossible(const string &s) {
    // Counts of each normal bead type
    int count1 = 0, count2 = 0, count3 = 0;

    // Calculate counts
    for (char ch : s) {
        count1 += (ch == '1');
        count2 += (ch == '2');
        count3 += (ch == '3');
    }

    // The string should have at least one type 2 bead and one type 3 bead, otherwise it's not possible
    if (count2 == 0 || count3 == 0) return false;

    // The amount of type 2 beads must equal type 1 plus type 3 beads, otherwise it's not possible
    if (count2 != count1 + count3) return false;

    // If it passes the conditions, it's possible
    return true;
}

int main() {
    ifstream fin("perle.in");
    ofstream fout("perle.out");

    int N, L;
    fin >> N;

    while (N--) {
        fin >> L;
        string s;
        for (int i = 0; i < L; ++i) {
            int bead;
            fin >> bead;
            s.push_back('0' + bead);
        }

        fout << isPossible(s) << '\n';
    }

    fin.close();
    fout.close();

    return 0;
}
```

This solution checks if the number of '2' beads in the sequence is equal to the number of '1' plus the number of '3' beads, which is a necessary condition for the sequence to be formed by the given transformation rules. If this condition is not met, the sequence cannot be formed by any series of transformations from a single magic bead. The solution also looks for at least one occurrence each of '2' and '3' beads, as no sequence that lacks either can be formed (since every transformation that produces '1' also produces '2' or '3'). If these conditions are met, we conclude that it is possible to form the sequence from a single magic bead.
---------- user ----------


Program result did not match expected result.
Input data:
```
3
8 2 1 1 3 2 1 2 3
2 2 2
1 3
```
Expected output:
```
1
0
1
```
Found output:
```
0
0
0
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The previous solutions were not correct because they failed to apply the transformation rules described in the problem statement. To devise a correct solution, we must carefully consider how the magic beads transform and how we can use these transformations to construct the target sequence.

Let's try a different approach. We can observe that:

1. A magic bead of type A can become any single normal bead (1, 2, or 3).
2. A magic bead of type B can become either:
    - Two beads: a normal bead of type 2 followed by a magic bead of type B.
    - Five beads: normal 1, magic A, normal 3, magic A, magic C.
3. A magic bead of type C can become either:
    - One normal bead of type 2.
    - Three beads: normal 3, magic B, and magic C.
    - Three beads: normal 1, normal 2, and magic A.

We can convert these observations into a system of linear equations based on the number of beads of each type. A correct sequence must satisfy these equations. We start by counting the number of 1s, 2s, and 3s in the target sequence. Then, we deduce if it's possible to obtain such a configuration starting from a single magic bead.

Here's an implementation of this idea:

```cpp
#include <fstream>
#include <vector>

using namespace std;

bool canFormSequence(const vector<int>& beads) {
    int count1 = 0, count2 = 0, count3 = 0;

    // Count the occurrences of each bead type
    for (int bead : beads) {
        if (bead == 1) ++count1;
        if (bead == 2) ++count2;
        if (bead == 3) ++count3;
    }

    // Check if we can form the sequence
    // For every 'B' or 'C' that transforms into '2', we need an 'A' to balance '1' and '3'.
    // Thus, the number of '2's must be equal to or greater than the sum of '1's and '3's.
    if (count2 < count1 + count3) return false;

    // If there are more '2's than '1's plus '3's, we need an extra 'B'.
    // Since 'B' can transform into '2B' or '1A3AC', the number of '2's can only be one more than the sum of '1's and '3's.
    if (count2 > count1 + count3) return false;

    // If we reach this point, it is possible to form the sequence
    return true;
}

int main() {
    ifstream fin("perle.in");
    ofstream fout("perle.out");

    int N, L;
    fin >> N;
    while (N--) {
        fin >> L;
        vector<int> beads(L);
        for (int i = 0; i < L; ++i) {
            fin >> beads[i];
        }

        fout << canFormSequence(beads) << '\n';
    }

    fin.close();
    fout.close();

    return 0;
}
```

This solution counts the number of each type of bead in the target sequence. It then checks if these counts satisfy the conditions for a valid transformation from a single magic bead of any type. If they do, the solution writes `1` to the output file; otherwise, it writes `0`.
---------- user ----------


Program result did not match expected result.
Input data:
```
3
8 2 1 1 3 2 1 2 3
2 2 2
1 3
```
Expected output:
```
1
0
1
```
Found output:
```
0
0
0
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

Apologies for the misunderstandings in the previous solutions. Let's carefully analyze the problem again and provide a correct solution.

From the problem statement, we have the following transformation rules for the magic beads:

1. Magic bead A can turn into a single normal bead of type 1, 2, or 3.
2. Magic bead B can turn into:
    - a normal bead 2 followed by a magic bead B, or
    - a normal bead 1, followed by a magic bead A, a normal bead 3, a magic bead A, and a magic bead C.
3. Magic bead C can turn into:
    - a normal bead 2, or
    - a normal bead 3 followed by a magic bead B and a magic bead C, or
    - a normal bead 1, followed by a normal bead 2, and a magic bead A.

The problem is essentially asking whether a given sequence of normal beads can be generated from a single magic bead of any type using these transformation rules.

To solve the problem, we can exploit the fact that a magic bead A can turn into any single normal bead, while beads B and C can generate sequences that have two normal beads 2 more than the sum of beads 1 and 3. Hence, a valid transformation is possible if and only if the number of beads 2 is greater than or equal to the sum of beads 1 and 3 and the number of beads 2 minus the sum of beads 1 and 3 is even.

Let's implement this logic:

```cpp
#include <fstream>
#include <vector>

using namespace std;

bool isPossible(int count1, int count2, int count3) {
    if (count2 < count1 + count3) return false; // Not enough 2s to balance 1s and 3s
    int diff = count2 - (count1 + count3);
    return (diff % 2 == 0); // Difference must be even for valid B and C transformations
}

int main() {
    ifstream fin("perle.in");
    ofstream fout("perle.out");

    int N, L;
    fin >> N;

    while (N--) {
        fin >> L;
        int bead, count1 = 0, count2 = 0, count3 = 0;
        for (int i = 0; i < L; ++i) {
            fin >> bead;
            if (bead == 1) ++count1;
            else if (bead == 2) ++count2;
            else if (bead == 3) ++count3;
        }

        fout << isPossible(count1, count2, count3) << '\n';
    }

    fin.close();
    fout.close();

    return 0;
}
```

This solution reads the input sequence and counts the occurrences of each type of normal bead. It then checks if the count of beads 2 minus the sum of beads 1 and 3 is even and that there are enough beads 2 to balance the 1s and 3s. If the conditions are met, it prints `1` into "perle.out", indicating that it is possible to form the sequence; otherwise, it prints `0`.
---------- user ----------


Program result did not match expected result.
Input data:
```
3
8 2 1 1 3 2 1 2 3
2 2 2
1 3
```
Expected output:
```
1
0
1
```
Found output:
```
0
1
0
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

After reevaluating the problem, it seems necessary to consider the number of transformations possible for each type of magic bead and how they can lead to the target string of normal beads.

The previous solutions misunderstood the transformation rules or did not implement them correctly. The correct approach to this problem is to simulate the transformation of magic beads into the sequence of normal beads.

Let's implement this correctly by considering the following:
- Each transformation rule must be applied in a way that the number of beads 1, 2, and 3 is preserved.
- A can transform into any single bead; B and C transformations must also be considered for the right combinations.

Given the constraints, a brute-force approach might not be efficient enough due to the problem's complexity. However, the transformation rules give us some patterns that we can exploit:
- Transforming B always produces another B and a 2, or it results in a 1, an A, a 3, another A, and a C.
- Transforming C always produces a 2, or it results in a 3, a B, and another C, or a 1, a 2, and an A.

We can notice that obtaining a bead of type 2 is straightforward using A, B, or C. However, obtaining beads of type 1 and 3 requires more attention. Type 1 beads can be obtained by using A or the second part of the B transformation. Type 3 beads can be obtained by using A or the second part of the C transformation.

The key observation is that if we used type B transformation, there must be a type 1 bead in front of a type 3 bead in the sequence (since B -> 1A3AC). Also, if we used type C transformation, there must be a type 3 bead in front of a type 2 bead in the sequence (since C -> 3BC or C -> 12A).

Using these observations, we can check for the possibility of forming each sequence.

Here is the revised solution:

```cpp
#include <fstream>
#include <vector>
#include <string>

bool check_sequence(const std::vector<int>& beads) {
    int ones = 0, twos = 0, threes = 0;
    for (int bead : beads) {
        ones += (bead == 1);
        twos += (bead == 2);
        threes += (bead == 3);
    }
    
    // For every A transformation that provides a 1 or 3, a 2 must follow.
    // For every B transformation that provides a 1 (followed by 3 and an A), a 2 must precede.
    // Similarly, for every C transformation that results in a 3 (followed by a B and a C), a 2 must precede.
    // Hence, there must always be at least as many 2s as 1s and 3s.
    if (twos < ones + threes) return false;

    // The excess of 2s (over the sum of 1s and 3s) must be even, because:
    // B always provides an extra 2 and can be used to adjust A transformations.
    // C can be transformed into a 2 without changing the count of 1s and 3s.
    int excess_twos = twos - (ones + threes);
    if (excess_twos % 2 != 0) return false;

    // The excess count of 2s divided by 2 must be no less than the count of 3s minus ones,
    // because each B can provide one 2 (by transforming into 2B) and each C can provide one 2
    // or three beads with two 3s (by transforming into 3BC or 12A).
    if (excess_twos / 2 < threes - ones) return false;

    return true;
}

int main() {
    std::ifstream fin("perle.in");
    std::ofstream fout("perle.out");

    int num_sequences, sequence_length;
    fin >> num_sequences;

    std::vector<int> beads;
    while (num_sequences--) {
        fin >> sequence_length;
        beads.resize(sequence_length);
        for (int& bead : beads) {
            fin >> bead;
        }

        fout << check_sequence(beads) << '\n';
    }

    fin.close();
    fout.close();
    return 0;
}
```

This revised solution uses the observations about the transformation rules to check if the sequence can be formed from a magic bead. It counts the number of each type of bead in the sequence and uses logic based on the transformation rules to determine if the sequence is possible. If the conditions are met, the solution writes `1` to `perle.out` to indicate that the sequence can be formed; otherwise, it writes `0`.
