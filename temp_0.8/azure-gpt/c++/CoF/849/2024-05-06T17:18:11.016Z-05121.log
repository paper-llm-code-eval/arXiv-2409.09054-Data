---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `tcif.in` and write to `tcif.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Avem la dispoziție patru numere naturale $N, A, B, C$, precum și trei cifre $c1, c2, c3$ distincte două câte două.

# Cerință

Să se determine numărul natural minim, strict mai mare decât $N$, care are exact $A$ cifre $c1$, $B$ cifre $c2$, $C$ cifre $c3$ și nu conține alte cifre.

# Date de intrare

Fișierul de intrare `tcif.in` conține pe prima linie, separate prin câte un spațiu, numerele naturale $A \ B \ C \ c1 \ c2 \ c3$. Pe linia a doua se află numărul natural $N$.

# Date de ieșire

Fișierul de ieșire `tcif.out` va conține o singură linie pe care va fi scris cel mai mic număr natural strict mai mare decât $N$ care conține exact $A$ cifre $c1$, exact $B$ cifre $c2$ și exact $C$ cifre $c3$ și nu conține alte cifre.

# Restricții și precizări

* $N$ va avea cel puțin o cifră și cel mult $1 \ 000$ de cifre.
* Pentru $10$% dintre teste, $N \leq 30 \ 000$;
* Pentru alte $40$% dintre teste, $N$ va avea cel mult $14$ cifre
* $0 \leq c1, c2, c3 \leq 9$; $c1, c2$ și $c3$ sunt distincte două câte două
* $1 \leq A, B, C$; $ A + B + C \leq 1 \ 000$;
* Datele de intrare sunt alese astfel încât va exista o soluție.

---

Example:
`tcif.in`
```
2 2 2 3 2 4
293187
```

`tcif.out`
```
322344
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```cpp
#include <fstream>
#include <vector>
#include <algorithm>

using namespace std;

void next_combination(vector<int>& digits, const vector<int>& counts, int N_size) {
    int pos = digits.size() - 1;
    while (pos >= 0) {
        digits[pos]++;
        int digit_count = count(digits.begin(), digits.end(), digits[pos]);
        if (digit_count > counts[digits[pos]]) {
            // Reset all digits to the right of the current position
            for (int i = pos + 1; i < digits.size(); ++i) {
                digits[i] = digits[pos];
            }
            ++pos; // Move one position to the right
        } else if (digits.size() - pos == N_size && digit_count == counts[digits[pos]]) {
            // If reached the size of N and the count is correct, move to the next digit
            pos--;
        } else {
            break; // Found the next valid combination
        }
    }
}

int main() {
    ifstream fin("tcif.in");
    ofstream fout("tcif.out");
    
    int A, B, C, c1, c2, c3;
    string N;
    fin >> A >> B >> C >> c1 >> c2 >> c3 >> N;
    
    vector<int> counts(10);
    counts[c1] = A;
    counts[c2] = B;
    counts[c3] = C;
    
    vector<int> digits(N.size() + 1, 0);
    for (int i = 0; i < N.size(); ++i) {
        digits[i + 1] = N[i] - '0';
    }
    
    next_combination(digits, counts, N.size());
    
    // Construct the answer from the digits
    bool leading_zero = true;
    for (int digit : digits) {
        if (leading_zero && digit == 0) continue;
        leading_zero = false;
        fout << digit;
    }
    fout << "\n";
    
    fin.close();
    fout.close();
    
    return 0;
}
```

This code reads the input data from `tcif.in`, computes the minimal number greater than N with exactly A, B, C count of digits c1, c2, c3, and writes the output to `tcif.out`. It uses file streams (`ifstream` and `ofstream`) for input and output operations according to the challenge requirements. The `next_combination` function finds the next valid combination of digits that is greater than N and has the correct counts of c1, c2, and c3.
---------- user ----------


Program exited with code 139.
stdout:
```

```
stderr:
```

```

Think of what has caused the exit code. Use the standard out and standard error to help you understand the issue.
Implement a solution to fix the program

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

Exit code 139 typically indicates a segmentation fault, which suggests that the program attempted to access memory that it wasn't allowed to. Reviewing the code, one potential issue is the manipulation of the `digits` vector without ensuring its size remains appropriate. If the `next_combination` function increments `pos` beyond the valid range or accesses `digits[pos]` when `pos` is negative, it could cause a segmentation fault.

Let's fix the solution by ensuring we properly handle the vector bounds and correctly implement the logic to find the next minimal number greater than N that satisfies the given conditions.

Here is the revised solution:

```cpp
#include <fstream>
#include <vector>
#include <algorithm>

using namespace std;

void increment(vector<int>& digits, const vector<int>& counts, bool& found) {
    int carry = 1;
    for (int i = digits.size() - 1; i >= 0 && carry; --i) {
        digits[i]++;
        carry = 0;
        if (digits[i] == 10) {
            digits[i] = 0;
            carry = 1;
        }
    }
    if (carry) {
        digits.insert(digits.begin(), 1);
    }
}

bool valid(const vector<int>& digits, const vector<int>& counts) {
    vector<int> count(10, 0);
    for (int digit : digits) {
        count[digit]++;
    }
    return count == counts;
}

int main() {
    ifstream fin("tcif.in");
    ofstream fout("tcif.out");
    
    int A, B, C, c1, c2, c3;
    string N;
    fin >> A >> B >> C >> c1 >> c2 >> c3 >> N;
    
    vector<int> counts(10, 0);
    counts[c1] = A;
    counts[c2] = B;
    counts[c3] = C;
    
    vector<int> digits;
    for (char digit : N) {
        digits.push_back(digit - '0');
    }
    
    bool found = false;
    while (!found) {
        increment(digits, counts, found);
        found = valid(digits, counts);
    }
    
    for (int digit : digits) {
        fout << digit;
    }
    fout << "\n";
    
    fin.close();
    fout.close();
    
    return 0;
}
```

This revised code ensures that the `digits` vector does not exceed its bounds and that we properly handle incrementing the number represented by the vector. The `increment` function takes care of incrementing the number and handling carry-over. The `valid` function checks whether the current combination of digits satisfies the count requirements for c1, c2, and c3.

We also removed the unnecessary resizing and initial zeroing of the `digits` vector, instead building it directly from the string representation of N. The loop now continues to increment the current number until it finds one that is valid according to the digit counts specified.
