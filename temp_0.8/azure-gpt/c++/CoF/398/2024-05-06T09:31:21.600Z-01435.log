---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `insule.in` and write to `insule.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Arhipelagul RGB este format din insule care aparţin ţărilor $R$, $G$ şi $B$. Putem reprezenta harta arhipelagului ca o matrice cu $n$ linii şi $m$ coloane cu elemente din mulţimea $\{0, 1, 2, 3\}$. Un element egal cu $0$ reprezintă o zonă acoperită de apă; un element egal cu $1$ reprezintă o zonă de pământ aparţinând unei insule din ţara $R$, iar un element egal cu $2$ reprezintă o zonă de pământ aparţinând unei insule din ţara $G$, iar un element egal cu $3$ reprezintă o zonă de pământ aparţinând unei insule din ţara $B$.

Se consideră că două elemente ale matricei sunt vecine dacă ele au aceeaşi valoare şi fie sunt consecutive pe linie, fie sunt consecutive pe coloană. Două elemente aparţin aceleiaşi insule dacă ele sunt vecine sau dacă se poate ajunge de la un element la celălalt pe un drum de-a lungul căruia oricare două elemente consecutive sunt vecine.

Pentru a încuraja relaţiile de colaborare dintre ţările $R$ şi $G$, se doreşte construirea unui pod care să unească o insulă aparţinând ţării R de o insulă aparţinând ţării G. Podul trebuie să respecte următoarele condiţii:

* Să înceapă pe o zonă cu apă consecutivă pe linie sau coloană cu o zonă aparţinând ţării $R$;
* Să se termine pe o zonă cu apă consecutivă pe linie sau coloană cu o zonă aparţinând ţării $G$;
* Să traverseze numai zone acoperite cu apă;
* Oricare două elemente consecutive ale podului trebuie să fie vecine;
* Lungimea podului să fie minimă (lungimea podului este egală cu numărul de elemente traversate de pod).

# Cerinţă

Dată fiind harta arhipelagului să se determine câte insule aparţin fiecărei ţări, precum şi lungimea minimă a unui pod care să satisfacă condiţiile din enunț.

# Date de intrare

Fişierul de intrare `insule.in` conţine pe prima linie numerele naturale $n$ şi $m$, separate prin spaţiu. Pe următoarele $n$ linii este descrisă harta arhipelagului. Pe fiecare dintre aceste $n$ linii sunt scrise câte m valori din mulţimea $\{0, 1, 2, 3\}$; valorile nu sunt separate prin spaţii.

# Date de ieşire

Fişierul de ieşire `insule.out` va conţine o singură linie pe care vor fi scrise patru numere naturale separate prin spaţii `NR` `NG` `NB` `Lg`, unde `NR` reprezintă numărul de insule aparţinând ţării $R$, `NG` numărul de insule aparţinând ţării $G$, `NB` numărul de insule aparţinând ţării $B$, iar `Lg` lungimea minimă a podului.

# Restricţii şi precizări

* $1 \lt n, m \leq 100$;
* Se garantează că pe hartă există cel puţin un element $1$, un element $2$ şi un element $0$;
* Se acordă 40% din punctaj pentru determinarea corectă a numărului de insule din fiecare ţară; se acordă punctaj integral pentru rezolvarea corectă a tuturor cerinţelor;
* Începutul şi sfârşitul podului pot să coincidă;
* Pentru datele de test există întotdeauna soluţie.

---

Example:
`insule.in`
```
6 7
1000320
0110313
3333000
2033000
2203011
2000010
```

`insule.out`
```
4 2 3 4
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```cpp
#include <fstream>
#include <vector>
#include <queue>
#include <algorithm>

using namespace std;

ifstream fin("insule.in");
ofstream fout("insule.out");

int n, m;
vector<vector<int>> map;
vector<vector<bool>> visited;
int dR[] = {-1, 0, 1, 0};
int dC[] = {0, 1, 0, -1};

void floodFill(int r, int c, int target, int replacement) {
    if (r < 0 || r >= n || c < 0 || c >= m || map[r][c] != target || visited[r][c])
        return;
    visited[r][c] = true;
    map[r][c] = replacement;
    for (int d = 0; d < 4; ++d) {
        floodFill(r + dR[d], c + dC[d], target, replacement);
    }
}

int getIslandCount(int target) {
    int count = 0;
    visited.assign(n, vector<bool>(m, false));
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            if (map[i][j] == target && !visited[i][j]) {
                floodFill(i, j, target, target);
                ++count;
            }
        }
    }
    return count;
}

struct Point {
    int r, c, dist;
};

int computeBridge() {
    queue<Point> q;
    vector<vector<int>> dist(n, vector<int>(m, -1));
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            if (map[i][j] == 1) {
                for (int d = 0; d < 4; ++d) {
                    int nr = i + dR[d], nc = j + dC[d];
                    if (nr >= 0 && nr < n && nc >= 0 && nc < m && map[nr][nc] == 0) {
                        q.push({nr, nc, 1});
                        dist[nr][nc] = 1;
                    }
                }
            }
        }
    }

    while (!q.empty()) {
        Point p = q.front();
        q.pop();
        if (map[p.r][p.c] == 2) return p.dist;

        for (int d = 0; d < 4; ++d) {
            int nr = p.r + dR[d], nc = p.c + dC[d];
            if (nr >= 0 && nr < n && nc >= 0 && nc < m && map[nr][nc] != 1 && dist[nr][nc] == -1) {
                q.push({nr, nc, p.dist + 1});
                dist[nr][nc] = p.dist + 1;
            }
        }
    }

    return -1; // should not happen according to problem statement guarantees
}

int main() {
    fin >> n >> m;
    map.resize(n, vector<int>(m));
    for (int i = 0; i < n; ++i) {
        string row;
        fin >> row;
        for (int j = 0; j < m; ++j) {
            map[i][j] = row[j] - '0';
        }
    }

    int NR = getIslandCount(1);
    int NG = getIslandCount(2);
    int NB = getIslandCount(3);
    int Lg = computeBridge();

    fout << NR << " " << NG << " " << NB << " " << Lg << "\n";

    fin.close();
    fout.close();
    return 0;
}
```

The algorithm uses a flood fill technique to count the number of islands for each country and BFS to find the shortest path for the bridge. The code works under the assumption that the input data is formatted exactly as specified, with no spaces between the values on each line of the input file.
---------- user ----------


Program result did not match expected result.
Input data:
```
6 7
1000320
0110313
3333000
2033000
2203011
2000010
```
Expected output:
```
4 2 3 4
```
Found output:
```
4 2 3 3
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

Upon examining the provided results, it is clear that the island counting part of the algorithm is correct; however, the bridge length computation seems to be failing. The found output indicates that the bridge length is computed as 3 instead of the expected 4. This discrepancy suggests that the BFS algorithm might not be correctly handling cases where the bridge starts adjacent to an R island and ends adjacent to a G island.

Let's analyze the issue:

The BFS algorithm is starting from all water cells immediately adjacent to R islands. When it encounters a cell adjacent to a G island, it returns the distance. However, there is a subtle bug. According to the problem statement, the bridge could start and end on the same cell, meaning the starting cell could be adjacent to both R and G islands. The current BFS does not account for that. It's necessary to adjust the BFS to handle this case correctly.

Let's fix the BFS computation part of the algorithm to correctly handle the possibility of the bridge starting and ending on the same cell:

```cpp
#include <fstream>
#include <vector>
#include <queue>
#include <algorithm>
#include <climits>

using namespace std;

ifstream fin("insule.in");
ofstream fout("insule.out");

int n, m;
vector<vector<int>> map;
vector<vector<bool>> visited;
int dR[] = {-1, 0, 1, 0};
int dC[] = {0, 1, 0, -1};

void floodFill(int r, int c, int target) {
    if (r < 0 || r >= n || c < 0 || c >= m || map[r][c] != target || visited[r][c])
        return;
    visited[r][c] = true;
    for (int d = 0; d < 4; ++d) {
        floodFill(r + dR[d], c + dC[d], target);
    }
}

int getIslandCount(int target) {
    int count = 0;
    visited.assign(n, vector<bool>(m, false));
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            if (map[i][j] == target && !visited[i][j]) {
                floodFill(i, j, target);
                ++count;
            }
        }
    }
    return count;
}

struct Point {
    int r, c, dist;
};

int computeBridge() {
    queue<Point> q;
    vector<vector<int>> dist(n, vector<int>(m, INT_MAX));
    int shortestBridge = INT_MAX;

    // Find all water cells adjacent to R and set their distances to 0
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            if (map[i][j] == 1) {
                for (int d = 0; d < 4; ++d) {
                    int nr = i + dR[d], nc = j + dC[d];
                    if (nr >= 0 && nr < n && nc >= 0 && nc < m && map[nr][nc] == 0 && dist[nr][nc] > 0) {
                        dist[nr][nc] = 1;
                        q.push({nr, nc, 1});
                    }
                }
            }
        }
    }

    while (!q.empty()) {
        Point p = q.front();
        q.pop();

        // If we have already found a shorter or equal bridge, no need to continue
        if (p.dist >= shortestBridge) continue;

        if (map[p.r][p.c] == 2) {
            shortestBridge = min(shortestBridge, p.dist);
            continue;  // We continue in case there's an even shorter bridge
        }

        for (int d = 0; d < 4; ++d) {
            int nr = p.r + dR[d], nc = p.c + dC[d];
            if (nr >= 0 && nr < n && nc >= 0 && nc < m && map[nr][nc] != 1 && p.dist + 1 < dist[nr][nc]) {
                q.push({nr, nc, p.dist + 1});
                dist[nr][nc] = p.dist + 1;
            }
        }
    }

    return shortestBridge;
}

int main() {
    fin >> n >> m;
    map.resize(n, vector<int>(m));
    for (int i = 0; i < n; ++i) {
        string row;
        fin >> row;
        for (int j = 0; j < m; ++j) {
            map[i][j] = row[j] - '0';
        }
    }

    int NR = getIslandCount(1);
    int NG = getIslandCount(2);
    int NB = getIslandCount(3);
    int Lg = computeBridge();

    fout << NR << " " << NG << " " << NB << " " << Lg << "\n";

    fin.close();
    fout.close();
    return 0;
}
```

Here are the changes made:

1. While initializing distances in the `dist` matrix, we set them to `INT_MAX` instead of `-1` to represent an infinite distance initially.
2. We look for the shortest bridge inside the BFS loop by keeping track of the shortest bridge length found so far, updating it if we find a shorter one.
3. After finding a G island, we continue the BFS instead of immediately returning because there might be a shorter bridge elsewhere.

With these fixes, the algorithm should now correctly compute the bridge length, even in cases where the bridge starts and ends on the same cell.
---------- user ----------


Program result did not match expected result.
Input data:
```
6 7
1000320
0110313
3333000
2033000
2203011
2000010
```
Expected output:
```
4 2 3 4
```
Found output:
```
4 2 3 3
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The discrepancy between the expected and found results indicates that the BFS algorithm still doesn't correctly calculate the bridge length. The issue seems to lie in the logic that checks adjacency to country G land cells. The BFS is likely finishing before considering all possible paths.

Let's refine the BFS algorithm to ensure that it examines water cells adjacent to both R and G islands correctly:

- First, we need to mark all water cells adjacent to G islands by setting a specific value in the `dist` matrix (e.g., -2) before starting the BFS.
- Then, during the BFS, if we reach a cell marked as adjacent to G, we update the shortest bridge length.
- We should continue the BFS until all paths are exhausted to ensure we find the truly shortest bridge.

Here is the revised solution:

```cpp
#include <fstream>
#include <vector>
#include <queue>

using namespace std;

ifstream fin("insule.in");
ofstream fout("insule.out");

int n, m;
vector<vector<int>> map;
vector<vector<bool>> visited;
int dR[] = {-1, 0, 1, 0};
int dC[] = {0, 1, 0, -1};

void floodFill(int r, int c, int target) {
    if (r < 0 || r >= n || c < 0 || c >= m || map[r][c] != target || visited[r][c])
        return;
    visited[r][c] = true;
    for (int d = 0; d < 4; ++d) {
        floodFill(r + dR[d], c + dC[d], target);
    }
}

int getIslandCount(int target) {
    int count = 0;
    visited.assign(n, vector<bool>(m, false));
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            if (map[i][j] == target && !visited[i][j]) {
                floodFill(i, j, target);
                ++count;
            }
        }
    }
    return count;
}

struct Point {
    int r, c, dist;
};

int computeBridge() {
    queue<Point> q;
    vector<vector<int>> dist(n, vector<int>(m, INT_MAX));

    // Mark water cells adjacent to G
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            if (map[i][j] == 2) {
                for (int d = 0; d < 4; ++d) {
                    int nr = i + dR[d], nc = j + dC[d];
                    if (nr >= 0 && nr < n && nc >= 0 && nc < m && map[nr][nc] == 0) {
                        dist[nr][nc] = -2;  // Mark as adjacent to G
                    }
                }
            }
        }
    }

    // Start BFS from water cells adjacent to R
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            if (map[i][j] == 1) {
                for (int d = 0; d < 4; ++d) {
                    int nr = i + dR[d], nc = j + dC[d];
                    if (nr >= 0 && nr < n && nc >= 0 && nc < m && map[nr][nc] == 0 && dist[nr][nc] != -2) {
                        q.push({nr, nc, 1});
                        dist[nr][nc] = 1;
                    }
                }
            }
        }
    }

    int shortestBridge = INT_MAX;
    while (!q.empty()) {
        Point p = q.front();
        q.pop();

        // If we reach a cell adjacent to G, update the shortest bridge length
        if (dist[p.r][p.c] == -2) {
            shortestBridge = min(shortestBridge, p.dist);
            continue;  // Continue to check for a shorter path
        }

        for (int d = 0; d < 4; ++d) {
            int nr = p.r + dR[d], nc = p.c + dC[d];
            if (nr >= 0 && nr < n && nc >= 0 && nc < m && map[nr][nc] == 0 && p.dist + 1 < dist[nr][nc]) {
                q.push({nr, nc, p.dist + 1});
                dist[nr][nc] = p.dist + 1;
            }
        }
    }

    // If a bridge can start and end on the same cell, we need to consider that as well
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            if (dist[i][j] == -2) {
                for (int d = 0; d < 4; ++d) {
                    int nr = i + dR[d], nc = j + dC[d];
                    if (nr >= 0 && nr < n && nc >= 0 && nc < m && map[nr][nc] == 1) {
                        shortestBridge = min(shortestBridge, 1); // The bridge can be of length 1
                    }
                }
            }
        }
    }

    return shortestBridge == INT_MAX ? -1 : shortestBridge;
}

int main() {
    fin >> n >> m;
    map.resize(n, vector<int>(m));
    for (int i = 0; i < n; ++i) {
        string row;
        fin >> row;
        for (int j = 0; j < m; ++j) {
            map[i][j] = row[j] - '0';
        }
    }

    int NR = getIslandCount(1);
    int NG = getIslandCount(2);
    int NB = getIslandCount(3);
    int Lg = computeBridge();

    fout << NR << " " << NG << " " << NB << " " << Lg << "\n";

    fin.close();
    fout.close();
    return 0;
}
```

With these changes, the BFS will now properly handle cases where a potential bridge can start and end on the same cell, resulting in the correct shortest bridge length being computed.
---------- user ----------


Failed to compile the program.
```
main.cpp: In function 'int computeBridge()':
main.cpp:45:48: error: 'INT_MAX' was not declared in this scope
   45 |     vector<vector<int>> dist(n, vector<int>(m, INT_MAX));
      |                                                ^~~~~~~
main.cpp:4:1: note: 'INT_MAX' is defined in header '<climits>'; did you forget to '#include <climits>'?
    3 | #include <queue>
  +++ |+#include <climits>
    4 | 

```

Evaluate the error message. Think of a solution to fix the program and return the entire source code with the fix.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The error message indicates that the symbol `INT_MAX` is not recognized because the header `<climits>` where it is defined was not included in the source code. To fix the program, we need to include the header `<climits>` at the beginning of the source file.

Here is the revised source code with the necessary fixes:

```cpp
#include <fstream>
#include <vector>
#include <queue>
#include <climits> // Include this header for INT_MAX

using namespace std;

ifstream fin("insule.in");
ofstream fout("insule.out");

int n, m;
vector<vector<int>> map;
vector<vector<bool>> visited;
int dR[] = {-1, 0, 1, 0};
int dC[] = {0, 1, 0, -1};

void floodFill(int r, int c, int target) {
    if (r < 0 || r >= n || c < 0 || c >= m || map[r][c] != target || visited[r][c])
        return;
    visited[r][c] = true;
    for (int d = 0; d < 4; ++d) {
        floodFill(r + dR[d], c + dC[d], target);
    }
}

int getIslandCount(int target) {
    int count = 0;
    visited.assign(n, vector<bool>(m, false));
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            if (map[i][j] == target && !visited[i][j]) {
                floodFill(i, j, target);
                ++count;
            }
        }
    }
    return count;
}

struct Point {
    int r, c, dist;
};

int computeBridge() {
    queue<Point> q;
    vector<vector<int>> dist(n, vector<int>(m, INT_MAX));

    // Start BFS from water cells adjacent to R
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            if (map[i][j] == 1) {
                for (int d = 0; d < 4; ++d) {
                    int nr = i + dR[d], nc = j + dC[d];
                    if (nr >= 0 && nr < n && nc >= 0 && nc < m && map[nr][nc] == 0 && dist[nr][nc] != -2) {
                        q.push({nr, nc, 1});
                        dist[nr][nc] = 1;
                    }
                }
            }
        }
    }

    // Find all water cells adjacent to G
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            if (map[i][j] == 2) {
                for (int d = 0; d < 4; ++d) {
                    int nr = i + dR[d], nc = j + dC[d];
                    if (nr >= 0 && nr < n && nc >= 0 && nc < m && map[nr][nc] == 0) {
                        dist[nr][nc] = -2;  // Mark as adjacent to G
                    }
                }
            }
        }
    }

    int shortestBridge = INT_MAX;
    while (!q.empty()) {
        Point p = q.front();
        q.pop();

        // If we reach a cell adjacent to G, update the shortest bridge length
        if (dist[p.r][p.c] == -2) {
            shortestBridge = min(shortestBridge, p.dist);
            continue;  // Continue to check for a shorter path
        }

        for (int d = 0; d < 4; ++d) {
            int nr = p.r + dR[d], nc = p.c + dC[d];
            if (nr >= 0 && nr < n && nc >= 0 && nc < m && map[nr][nc] == 0 && p.dist + 1 < dist[nr][nc]) {
                q.push({nr, nc, p.dist + 1});
                dist[nr][nc] = p.dist + 1;
            }
        }
    }

    // If a bridge can start and end on the same cell, we need to consider that as well
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            if (dist[i][j] == -2) {
                for (int d = 0; d < 4; ++d) {
                    int nr = i + dR[d], nc = j + dC[d];
                    if (nr >= 0 && nr < n && nc >= 0 && nc < m && map[nr][nc] == 1) {
                        shortestBridge = min(shortestBridge, 1); // The bridge can be of length 1
                    }
                }
            }
        }
    }

    return shortestBridge == INT_MAX ? -1 : shortestBridge;
}

int main() {
    fin >> n >> m;
    map.resize(n, vector<int>(m));
    for (int i = 0; i < n; ++i) {
        string row;
        fin >> row;
        for (int j = 0; j < m; ++j) {
            map[i][j] = row[j] - '0';
        }
    }

    int NR = getIslandCount(1);
    int NG = getIslandCount(2);
    int NB = getIslandCount(3);
    int Lg = computeBridge();

    fout << NR << " " << NG << " " << NB << " " << Lg << "\n";

    fin.close();
    fout.close();
    return 0;
}
```

With the inclusion of the `<climits>` header, the symbol `INT_MAX` will be recognized and the program should compile successfully. This should solve the bridge length calculation issue and produce the correct result, given the correct logic for BFS and flood fill has been implemented.
---------- user ----------


Program result did not match expected result.
Input data:
```
6 7
1000320
0110313
3333000
2033000
2203011
2000010
```
Expected output:
```
4 2 3 4
```
Found output:
```
4 2 3 -1
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The output `-1` for the bridge length suggests that the algorithm is not finding any path from R to G, which is incorrect based on the sample input provided. It seems there is a mistake in the BFS part of the algorithm, specifically the logic that identifies the adjacency of water cells to G islands, and then the subsequent BFS expansion from R islands.

Let's fix the BFS algorithm to correctly compute the length of the bridge:

1. First, we need to ensure that we properly initialize the BFS queue with all water cells adjacent to R islands.
2. We need to make sure to correctly handle checking for water cells adjacent to G islands during BFS.
3. We should update the bridge length when we reach a water cell adjacent to a G island, rather than when we directly reach a G island cell.

Here's the corrected solution:

```cpp
#include <fstream>
#include <vector>
#include <queue>
#include <climits>

using namespace std;

ifstream fin("insule.in");
ofstream fout("insule.out");

int n, m;
vector<vector<int>> map;
vector<vector<bool>> visited;
int dR[] = {-1, 0, 1, 0};
int dC[] = {0, 1, 0, -1};

void floodFill(int r, int c, int target) {
    if (r < 0 || r >= n || c < 0 || c >= m || map[r][c] != target || visited[r][c])
        return;
    visited[r][c] = true;
    for (int d = 0; d < 4; ++d) {
        floodFill(r + dR[d], c + dC[d], target);
    }
}

int getIslandCount(int target) {
    int count = 0;
    visited.assign(n, vector<bool>(m, false));
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            if (map[i][j] == target && !visited[i][j]) {
                floodFill(i, j, target);
                ++count;
            }
        }
    }
    return count;
}

struct Point {
    int r, c, dist;
};

int computeBridge() {
    queue<Point> q;
    vector<vector<int>> distance(n, vector<int>(m, INT_MAX));
    vector<vector<bool>> visitedG(n, vector<bool>(m, false));

    // Mark water cells adjacent to G
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            if (map[i][j] == 2) {
                for (int d = 0; d < 4; ++d) {
                    int nr = i + dR[d], nc = j + dC[d];
                    if (nr >= 0 && nr < n && nc >= 0 && nc < m && map[nr][nc] == 0) {
                        visitedG[nr][nc] = true;
                    }
                }
            }
        }
    }

    // Start BFS from water cells adjacent to R
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            if (map[i][j] == 1) {
                for (int d = 0; d < 4; ++d) {
                    int nr = i + dR[d], nc = j + dC[d];
                    if (nr >= 0 && nr < n && nc >= 0 && nc < m && map[nr][nc] == 0 && !visitedG[nr][nc]) {
                        q.push({nr, nc, 1});
                        distance[nr][nc] = 1;
                    }
                }
            }
        }
    }

    int shortestBridge = INT_MAX;
    while (!q.empty()) {
        Point current = q.front();
        q.pop();

        // If we reach a cell adjacent to G, update the shortest bridge length
        if (visitedG[current.r][current.c]) {
            shortestBridge = min(shortestBridge, current.dist);
            continue;  // Continue to check for a possibly shorter path
        }

        for (int d = 0; d < 4; ++d) {
            int nr = current.r + dR[d], nc = current.c + dC[d];
            if (nr >= 0 && nr < n && nc >= 0 && nc < m && map[nr][nc] == 0 && current.dist + 1 < distance[nr][nc]) {
                q.push({nr, nc, current.dist + 1});
                distance[nr][nc] = current.dist + 1;
            }
        }
    }

    return shortestBridge == INT_MAX ? -1 : shortestBridge;
}

int main() {
    fin >> n >> m;
    map.resize(n, vector<int>(m));
    for (int i = 0; i < n; ++i) {
        string row;
        fin >> row;
        for (int j = 0; j < m; ++j) {
            map[i][j] = row[j] - '0';
        }
    }

    int NR = getIslandCount(1);
    int NG = getIslandCount(2);
    int NB = getIslandCount(3);
    int Lg = computeBridge();

    fout << NR << " " << NG << " " << NB << " " << Lg << "\n";

    fin.close();
    fout.close();
    return 0;
}
```

By adjusting the BFS logic, the algorithm should now account for water cells adjacent to both R and G islands and properly compute the shortest bridge length.
