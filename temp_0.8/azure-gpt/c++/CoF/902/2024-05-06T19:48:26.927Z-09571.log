---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `turnuri.in` and write to `turnuri.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Cel mai nou proiect imobiliar din capitală este compus din $N$ blocuri-turn, construite unul lângă altul, de-a lungul unui bulevard central și numerotate de la $1$ la $N$. Pentru fiecare turn se cunoaște numărul etajelor din care este compus acesta și se mai știe că nu există două turnuri cu același număr de etaje. Ultimele norme urbanistice definesc **coeficientul de frumusețe** al turnului cu numărul $T$, ca fiind numărul turnurilor din secvența de turnuri care începe cu turnul $S$, se termină cu turnul $D$ și are următoarele proprietăți:
* $1 \leq S \leq T \leq D \leq N$
* numărul etajelor fiecărui turn din secvență, cu excepţia turnului $T$, este mai mic decât numărul de etaje ale turnului $T$
* Dacă $S ≠ 1$ atunci turnul $S-1$ este cel mai apropiat turn din stânga turnului $T$, care are un număr de etaje strict mai mare decât turnul $T$
* Dacă $D ≠ N$ atunci turnul $D+1$ este cel mai apropiat turn din dreapta turnului $T$, care are un număr de etaje strict mai mare decât turnul $T$

**Coeficientul de frumusețe al întregului ansamblu de turnuri** este suma coeficienților de frumusețe avuţi de turnurile componente. Dezvoltatorul proiectului dorește să renunțe la unul dintre turnuri și să construiască în locul acestuia un restaurant subteran, acesta considerându-se un turn cu **zero** etaje. Dezvoltatorul dorește să calculeze coeficientul de frumusețe al ansamblului de turnuri, pentru fiecare posibilă amplasare a restaurantului.

# Cerință

Cunoscând numărul $N$ de turnuri și numărul etajelor fiecăruia, determinați coeficientul de frumusețe al ansamblului de turnuri pentru toate cele $N$ posibilități de amplasare ale restaurantului, pe pozițiile $1$, $2$, ..., $N$.

# Date de intrare


Datele de intrare se citesc din fişierul `turnuri.in`, care are următoarea structură:

* pe prima linie se află numărul natural $N$, reprezentând numărul de turnuri
* pe a doua linie se află $N$ valori naturale nenule, separate prin câte un spațiu, reprezentând numărul etajelor turnurilor

# Date de ieșire


Datele de ieşire se vor scrie în fişierul `turnuri.out`, pe linii separate, astfel: pe linia $i$ ($1 \leq i \leq N$) se găsește un număr natural reprezentând coeficientul de frumusețe al ansamblului dacă restaurantul s-ar construi în locul turnului $i$.


# Restricții și precizări

* $1 \leq N \leq 100 \ 000$
* Numărul de etaje ale unui turn este un număr natural între $1$ și $1 \ 000 \ 000 \ 000$
* Se acordă $10$ puncte din oficiu.

| Subtask | Punctaj | Restricții          |
| - | ------- | ------------------- |
| 1 | 30      | $N \leq 100$ |
| 2 | 30      | $N \leq 2 \ 000$      |
| 3 | 30      | Fără restricții suplimentare.      |

---

Example:
`turnuri.in`
```
7
10 3 1 7 8 6 5
```

`turnuri.out`
```
19
22
22
22
21
22
22
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```cpp
#include <fstream>
#include <stack>
#include <vector>

std::ifstream fin("turnuri.in");
std::ofstream fout("turnuri.out");

int main() {
    int N;
    fin >> N;

    std::vector<int> heights(N + 1); // One-indexed array for convenience.
    std::vector<int> beauty(N + 1, 0);
    std::vector<int> leftGreater(N + 1, 0);
    std::vector<int> rightGreater(N + 1, N + 1);

    // Read the heights and calculate the initial beauty coefficient.
    for (int i = 1; i <= N; ++i) {
        fin >> heights[i];
    }

    std::stack<int> s;
    // Calculate the nearest left greater for each tower.
    for (int i = 1; i <= N; ++i) {
        while (!s.empty() && heights[s.top()] < heights[i]) {
            s.pop();
        }
        leftGreater[i] = s.empty() ? 0 : s.top();
        s.push(i);
    }

    // Clear the stack for the right pass.
    while (!s.empty()) s.pop();

    // Calculate the nearest right greater for each tower.
    for (int i = N; i >= 1; --i) {
        while (!s.empty() && heights[s.top()] < heights[i]) {
            s.pop();
        }
        rightGreater[i] = s.empty() ? N + 1 : s.top();
        s.push(i);
    }

    // Calculate the total beauty coefficient.
    int totalBeauty = 0;
    for (int i = 1; i <= N; ++i) {
        beauty[i] = i - leftGreater[i] + rightGreater[i] - i - 1;
        totalBeauty += beauty[i];
    }

    // Calculate and write the beauty coefficient for each possible restaurant position.
    for (int i = 1; i <= N; ++i) {
        int coef = totalBeauty - beauty[i];
        if (leftGreater[i] > 0) {
            coef += rightGreater[i] - leftGreater[i] - 1;
        }
        fout << coef << '\n';
    }

    fin.close();
    fout.close();
    return 0;
}
```
This code reads the number of towers from "turnuri.in", then reads the heights, calculates the nearest left and right taller towers for each tower, computes the total beauty coefficient, and then outputs to "turnuri.out" the beauty coefficient with each tower replaced by a restaurant one by one. The solution uses a stack to compute the nearest left and right greater elements efficiently, which is a common technique in such problems to ensure an O(N) time complexity.
---------- user ----------


Program result did not match expected result.
Input data:
```
7
10 3 1 7 8 6 5
```
Expected output:
```
19
22
22
22
21
22
22
```
Found output:
```
15
22
22
22
22
22
22
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

Upon reviewing the code and the expected output, I found that there is an issue with the way the initial total beauty coefficient is calculated. The problem is that the calculation of the initial beauty for each tower is incorrect; I have inadvertently subtracted the index `i` twice, which caused an underestimation of the initial beauty coefficients.

Let's correct this by adjusting the beauty calculation and ensuring the correct totalBeauty is obtained. This needs to be done before any restaurant replacement is considered to ensure that we start with the correct baseline for calculations.

Here is the corrected solution:
```cpp
#include <fstream>
#include <stack>
#include <vector>

std::ifstream fin("turnuri.in");
std::ofstream fout("turnuri.out");

int main() {
    int N;
    fin >> N;

    std::vector<int> heights(N + 2); // Add padding for convenience.
    std::vector<int> leftGreater(N + 2);
    std::vector<int> rightGreater(N + 2);
    std::stack<int> s;
    int totalBeauty = 0;

    // Read the heights.
    for (int i = 1; i <= N; ++i) {
        fin >> heights[i];
    }

    // Sentinel values for boundaries.
    heights[0] = heights[N + 1] = 1e9 + 1;
    
    // Calculate the nearest greater to left for each tower.
    s.push(0);
    for (int i = 1; i <= N; ++i) {
        while (heights[s.top()] <= heights[i]) {
            s.pop();
        }
        leftGreater[i] = s.top();
        s.push(i);
    }

    // Clear the stack for the next pass.
    while (!s.empty()) s.pop();

    // Calculate the nearest greater to right for each tower.
    s.push(N + 1);
    for (int i = N; i >= 1; --i) {
        while (heights[s.top()] <= heights[i]) {
            s.pop();
        }
        rightGreater[i] = s.top();
        s.push(i);
    }

    // Calculate the total beauty coefficient.
    for (int i = 1; i <= N; ++i) {
        totalBeauty += i - leftGreater[i] + rightGreater[i] - i - 1;
    }

    // Write the beauty coefficient for each possible restaurant position.
    for (int i = 1; i <= N; ++i) {
        int coef = totalBeauty;
        // Subtract the beauty of the removed tower.
        coef -= (i - leftGreater[i] + rightGreater[i] - i - 1);
        // Add the beauty of the nearest left greater tower if it exists.
        if (leftGreater[i] != 0) {
            coef += (rightGreater[i] - leftGreater[i] - 1);
        }
        fout << coef << '\n';
    }

    fin.close();
    fout.close();
    return 0;
}
```
This corrected code should now properly calculate the beauty coefficient for each possible restaurant position by first calculating the total beauty coefficient correctly, then adjusting it for each position where the restaurant could be placed. It will output the adjusted beauty coefficients to "turnuri.out".
---------- user ----------


Program result did not match expected result.
Input data:
```
7
10 3 1 7 8 6 5
```
Expected output:
```
19
22
22
22
21
22
22
```
Found output:
```
15
22
22
22
22
22
22
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The initial solution attempts to precompute the total beauty and then adjust it based on the turn being removed. However, there seems to be an error in the calculation of the beauty coefficient when a turn (tower) is replaced by a restaurant, leading to the incorrect output.

To address this, we need to reconsider the calculation of the beauty coefficient when a tower is removed and a restaurant is put in its place. Specifically, we must account for the fact that the towers to the left and right of the replaced tower may now become part of the beauty coefficient calculation for the neighboring taller towers, since the restaurant does not count as a taller tower.

Let's re-implement the solution with the necessary fixes:

```cpp
#include <fstream>
#include <stack>
#include <vector>

std::ifstream fin("turnuri.in");
std::ofstream fout("turnuri.out");

int main() {
    int N;
    fin >> N;

    std::vector<int> heights(N);
    std::vector<int> left(N, -1);   // Indices of the nearest taller tower to the left
    std::vector<int> right(N, N);   // Indices of the nearest taller tower to the right
    std::stack<int> s;

    // Read the heights.
    for (int i = 0; i < N; ++i) {
        fin >> heights[i];
    }

    // Find nearest taller tower to the left for each tower
    for (int i = 0; i < N; ++i) {
        while (!s.empty() && heights[s.top()] < heights[i]) {
            s.pop();
        }
        if (!s.empty()) {
            left[i] = s.top();
        }
        s.push(i);
    }

    // Clear the stack for the next pass.
    while (!s.empty()) s.pop();

    // Find nearest taller tower to the right for each tower
    for (int i = N - 1; i >= 0; --i) {
        while (!s.empty() && heights[s.top()] < heights[i]) {
            s.pop();
        }
        if (!s.empty()) {
            right[i] = s.top();
        }
        s.push(i);
    }

    // Compute the beauty coefficient for each tower and the total beauty
    std::vector<int> beauty(N); // Individual beauty of each tower
    int totalBeauty = 0;
    for (int i = 0; i < N; ++i) {
        beauty[i] = (i - left[i]) + (right[i] - i) - 1;
        totalBeauty += beauty[i];
    }

    // Write the beauty coefficient for each possible restaurant position.
    for (int i = 0; i < N; ++i) {
        int lostBeauty = beauty[i]; // Beauty lost by removing this tower
        
        // Gain in beauty for the nearest left taller tower, if exists
        if (left[i] != -1) {
            lostBeauty -= (i - left[i] - 1);
            lostBeauty += (right[i] - left[i] - 1);
        }
        
        // Gain in beauty for the nearest right taller tower, if exists
        if (right[i] != N) {
            lostBeauty -= (right[i] - i - 1);
        }
        
        int newBeauty = totalBeauty - lostBeauty; // New beauty after placing restaurant
        fout << newBeauty << '\n';
    }

    fin.close();
    fout.close();
    return 0;
}
```
This revised solution keeps track of the nearest taller towers to the left and right and recalculates the beauty for the remaining towers when a tower is replaced by a restaurant. It does not simply subtract the original beauty of the removed tower but also accounts for the changes to the beauty of surrounding towers. This should provide the correct output and match the expected results.
---------- user ----------


Program result did not match expected result.
Input data:
```
7
10 3 1 7 8 6 5
```
Expected output:
```
19
22
22
22
21
22
22
```
Found output:
```
15
19
20
18
13
18
20
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The previous attempts had misunderstandings in calculating the beauty coefficient after removing a tower. We need to reconsider the impact of replacing a tower with a restaurant on adjacent towers' beauty coefficients. When a tower is replaced with a restaurant, the beauty coefficient of the adjacent towers can extend beyond the replaced tower until they meet a taller tower.

Let's fix the solution by accurately recalculating the beauty coefficients of the neighboring towers when each tower is replaced by a restaurant:

```cpp
#include <fstream>
#include <vector>

#define MAXN 100010
#define MAXHEIGHT 1000000010

std::ifstream fin("turnuri.in");
std::ofstream fout("turnuri.out");

int N;
int heights[MAXN];
int left_index[MAXN];  // Index of the previous tower that is taller than the current one
int right_index[MAXN]; // Index of the next tower that is taller than the current one

int main() {
    fin >> N;
    for (int i = 1; i <= N; ++i) {
        fin >> heights[i];
    }
    
    // Sentinels
    heights[0] = MAXHEIGHT;
    heights[N + 1] = MAXHEIGHT;

    // Compute left_index for every tower
    left_index[1] = 0;
    for (int i = 2; i <= N; ++i) {
        int prev = i - 1;
        while (heights[prev] < heights[i]) {
            prev = left_index[prev];
        }
        left_index[i] = prev;
    }

    // Compute right_index for every tower
    right_index[N] = N + 1;
    for (int i = N - 1; i >= 1; --i) {
        int next = i + 1;
        while (heights[next] < heights[i]) {
            next = right_index[next];
        }
        right_index[i] = next;
    }

    // Compute the total beauty
    int total_beauty = 0;
    for (int i = 1; i <= N; ++i) {
        total_beauty += i - left_index[i] + right_index[i] - i - 1;
    }

    // Compute the beauty coefficient for each possible restaurant position
    for (int i = 1; i <= N; ++i) {
        int left_tower = left_index[i];
        int right_tower = right_index[i];
        int contribution = i - left_tower + right_tower - i - 1;
        int new_beauty = total_beauty - contribution;
        if (heights[left_tower] != MAXHEIGHT) {
            new_beauty += right_tower - left_tower - 1;
        }
        fout << new_beauty << '\n';
    }

    fin.close();
    fout.close();
    return 0;
}
```

This code calculates the `left_index` and `right_index` for each tower. These indices point to the nearest taller towers on the left and right of each tower, respectively. When we remove a tower to build a restaurant, we subtract its contribution from the total beauty and add the extended beauty coefficient of the nearest taller tower(s) to the left, if any. The right side does not need to be considered separately, as its effect is already included in the computation of the left side. This will give us the new beauty coefficient for each possible restaurant position, which is then written to the output file.
---------- user ----------


Program result did not match expected result.
Input data:
```
7
10 3 1 7 8 6 5
```
Expected output:
```
19
22
22
22
21
22
22
```
Found output:
```
15
22
22
22
22
22
22
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

Upon reviewing the code once more and the expected output, it appears that there is an oversight in the logic that calculates the beauty coefficient after a tower is replaced by a restaurant. The previous code incorrectly calculates the beauty coefficient when it fails to account for the contribution of the replaced tower to the total beauty, and how the beauty of its adjacent towers changes in the absence of the replaced tower.

To correct this, we need to ensure that when a tower is replaced by a restaurant, the contribution of the replaced tower is removed from the total beauty, and the beauty contributions of the neighboring taller towers are recalculated as if the restaurant (with zero height) is not there.

Here is the corrected solution:

```cpp
#include <fstream>
#include <vector>

std::ifstream fin("turnuri.in");
std::ofstream fout("turnuri.out");

int main() {
    int N;
    fin >> N;

    std::vector<int> heights(N + 1, 0);
    std::vector<int> left(N + 1, 0);
    std::vector<int> right(N + 1, 0);
    std::vector<int> stack(N + 1, 0);

    // Read the heights.
    for (int i = 1; i <= N; ++i) {
        fin >> heights[i];
    }

    int st_size = 0;
    // Calculate left limits
    for (int i = 1; i <= N; ++i) {
        while (st_size && heights[stack[st_size]] <= heights[i]) {
            st_size--;
        }
        left[i] = (st_size ? stack[st_size] : 0);
        stack[++st_size] = i;
    }

    st_size = 0;
    // Calculate right limits
    for (int i = N; i >= 1; --i) {
        while (st_size && heights[stack[st_size]] <= heights[i]) {
            st_size--;
        }
        right[i] = (st_size ? stack[st_size] : N + 1);
        stack[++st_size] = i;
    }

    // Calculate total beauty value
    long long total_beauty = 0;
    for (int i = 1; i <= N; ++i) {
        total_beauty += i - left[i];
        total_beauty += right[i] - i - 1;
    }

    // Calculate and write the beauty coefficient for each possible restaurant position.
    for (int i = 1; i <= N; ++i) {
        long long result = total_beauty;

        // Remove the contribution of the replaced tower
        result -= i - left[i];
        result -= right[i] - i - 1;

        // Add the contribution of the next taller towers, if any
        if (left[i] > 0) { // There is a taller tower to the left
            result -= right[left[i]] - left[i] - 1; // Remove its old right-side contribution
            result += right[i] - left[i] - 1; // Add its new right-side contribution, which extends up to the next taller tower to the right
        }

        if (right[i] <= N) { // There is a taller tower to the right
            result -= right[i] - left[right[i]]; // Remove its old left-side contribution
        }

        fout << result << '\n';
    }

    fin.close();
    fout.close();
    return 0;
}
```

With these corrections, the code should now correctly calculate the beauty coefficient for each possible restaurant position by taking into account the contributions of the neighboring towers after one tower is replaced by a restaurant. This should match the expected results.
---------- user ----------


Program result did not match expected result.
Input data:
```
7
10 3 1 7 8 6 5
```
Expected output:
```
19
22
22
22
21
22
22
```
Found output:
```
15
13
18
12
16
20
21
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The previous solution still contains logical errors in recalculating the beauty coefficient after a tower is replaced by a restaurant. Specifically, it is not handling the changes in beauty correctly for the neighboring towers of the replaced tower. To fix this, we should carefully analyze the effect of replacing each tower on the beauty coefficients of the towers to its left and right.

The correct approach is as follows:

1. Determine the left and right limits for each tower, which are the nearest towers on the left and right that are taller.
2. Calculate the initial total beauty coefficient summing up the beauty coefficients for all towers.
3. For each tower, calculate the new beauty coefficient as if it were replaced by a restaurant. This means:
   - Subtracting the beauty of the tower being replaced.
   - If there's a left taller tower, its right limit will now possibly extend further, increasing its beauty.
   - If there's a right taller tower, its left limit may now be extended by the left limit of the tower being replaced.

Let's implement the solution with these fixes:

```cpp
#include <fstream>
#include <vector>
#include <stack>

std::ifstream fin("turnuri.in");
std::ofstream fout("turnuri.out");

int main() {
    int N;
    fin >> N;

    std::vector<int> heights(N + 1);
    std::vector<int> left(N + 1);
    std::vector<int> right(N + 1);
    std::stack<int> st;

    // Sentinel values for the fictitious towers beyond the actual range
    heights[0] = heights[N + 1] = 2e9;

    // Read tower heights
    for (int i = 1; i <= N; ++i) {
        fin >> heights[i];
    }

    // Compute left limits
    for (int i = 1; i <= N; ++i) {
        while (!st.empty() && heights[st.top()] <= heights[i]) {
            st.pop();
        }
        left[i] = st.empty() ? 0 : st.top();
        st.push(i);
    }

    // Clearing the stack to reuse for the right limits
    while (!st.empty()) st.pop();

    // Compute right limits
    for (int i = N; i >= 1; --i) {
        while (!st.empty() && heights[st.top()] <= heights[i]) {
            st.pop();
        }
        right[i] = st.empty() ? N + 1 : st.top();
        st.push(i);
    }

    // Calculate total beauty
    long long total_beauty = 0;
    for (int i = 1; i <= N; ++i) {
        total_beauty += i - left[i] + right[i] - i - 1;
    }

    // Calculate and write the beauty coefficient for each possible restaurant position
    for (int i = 1; i <= N; ++i) {
        long long new_beauty = total_beauty;

        // Subtract the tower's own beauty coefficient
        new_beauty -= i - left[i] + right[i] - i - 1;

        // Add the effect of this tower's absence on the left neighbor's beauty, if any
        if (left[i] > 0) {
            new_beauty -= right[left[i]] - left[i] - 1; // Subtract old contribution of left neighbor
            new_beauty += right[i] - left[i] - 1;      // Add new contribution of left neighbor
        }

        // Add the effect of this tower's absence on the right neighbor's beauty, if any
        if (right[i] < N + 1) {
            new_beauty -= right[i] - left[right[i]] - 1; // Subtract old contribution of right neighbor
            new_beauty += right[right[i]] - left[right[i]] - 1; // Add new contribution of right neighbor
        }

        fout << new_beauty << '\n';
    }

    fin.close();
    fout.close();
    return 0;
}
```

This code should now correctly handle the recalculation of the beauty coefficient when each tower is replaced by a restaurant and produce the expected output.
---------- user ----------


Program result did not match expected result.
Input data:
```
7
10 3 1 7 8 6 5
```
Expected output:
```
19
22
22
22
21
22
22
```
Found output:
```
15
17
22
19
16
20
21
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The expected output indicates that the beauty coefficient of the ensemble changes for each potential location of the restaurant. The issue in the previous solutions lies in the incorrect adjustment of the beauty coefficient for towers adjacent to the one being replaced by a restaurant.

The beauty coefficient is determined by the number of towers on the left and right side of each tower that are shorter than the tower in question, up to the point where a taller tower is encountered.

When we remove a tower (to build a restaurant), this affects the beauty coefficient of the taller towers to its left and right (if they exist) because their span of shorter towers may extend further.

Let's write the correct solution, taking into account the specific rules for recalculating the beauty coefficient:

```cpp
#include <fstream>
#include <vector>
#include <stack>

int main() {
    std::ifstream fin("turnuri.in");
    std::ofstream fout("turnuri.out");

    int N;
    fin >> N;

    std::vector<int> heights(N);
    std::vector<int> left(N), right(N);
    std::stack<int> s;

    for (int i = 0; i < N; ++i) {
        fin >> heights[i];
    }

    // Calculate nearest greater on the left
    for (int i = 0; i < N; ++i) {
        while (!s.empty() && heights[s.top()] <= heights[i]) {
            s.pop();
        }
        left[i] = s.empty() ? -1 : s.top();
        s.push(i);
    }

    // Clear the stack to use for nearest greater on the right
    while (!s.empty()) s.pop();

    // Calculate nearest greater on the right
    for (int i = N - 1; i >= 0; --i) {
        while (!s.empty() && heights[s.top()] <= heights[i]) {
            s.pop();
        }
        right[i] = s.empty() ? N : s.top();
        s.push(i);
    }

    // Calculate initial beauty for each tower and the total beauty
    long long total_beauty = 0;
    for (int i = 0; i < N; ++i) {
        total_beauty += (i - left[i]) + (right[i] - i - 1);
    }

    for (int i = 0; i < N; ++i) {
        long long beauty_without_i = total_beauty;
        
        // Remove the beauty contribution of the current tower
        beauty_without_i -= (i - left[i]) + (right[i] - i - 1);

        // If there's a left taller tower, calculate its new contribution
        if (left[i] != -1) {
            beauty_without_i -= (right[left[i]] - left[i] - 1);
            beauty_without_i += (right[i] - left[i] - 1);
        }

        // If there's a right taller tower, calculate its new contribution
        if (right[i] != N) {
            beauty_without_i -= (right[i] - right[right[i]] - 1);
            beauty_without_i += (right[right[i]] - i - 1);
        }

        fout << beauty_without_i << '\n';
    }

    fin.close();
    fout.close();
    return 0;
}
```

This solution properly recalculates the beauty coefficients after removing a tower by making the necessary adjustments for the adjacent towers. It should match the expected output and behave according to the specifications of the problem.
