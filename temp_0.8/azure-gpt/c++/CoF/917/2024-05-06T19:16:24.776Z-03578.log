---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `cetate.in` and write to `cetate.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Cetatea Vizima din regatul Temeria poate fi reprezentată printr-o matrice cu $N$ linii și $M$ coloane, numerotate începând cu $1$. Vizima este o cetate înfloritoare, fapt datorat numărului mare de negustori și meșteri prezenți. Din acest motiv, fiecărei celule îi este atribuit un profit corespunzător zonei respective. Regele Foltest dorește să reconstruiască zidurile cetății, dar cum războiul cu Imperiul Nilfgaard bate la ușă și resursele regatului sunt limitate, el trebuie să aleagă o porțiune pe care să o poată apăra, reprezentată ca o submatrice. O submatrice este identificată printr-o **configurație** de patru numere $(i_1, j_1, i_2, j_2)$ ($1 \leq i_1 \leq i_2 \leq N$, $1 \leq j_1 \leq j_2 \leq M$), în această ordine, și este formată din elementele situate pe liniile consecutive $i_1, i_1+1, \ldots, i_2$ și pe coloanele consecutive $j_1, j_1+1, \ldots, j_2$ ale matricei prin care este reprezentată cetatea. **Laturile** submatricei sunt egale cu numărul de linii, respectiv de coloane din care a preluat elemente, iar **profitul** submatricei este suma valorilor din celulele sale.

# Cerințe
Scrieți un program care, cunoscând matricea cetății și o valoare $K$, determină:
1) profitul maxim al unei submatrice cu laturile egale cu $K$, precum și configurația prin care se identifică ea.
2) profitul maxim al unei submatrice cu laturile cel mult egale cu $K$, precum și configurația prin care se identifică ea.

# Date de intrare
Fișierul de intrare `cetate.in` conține pe primul rând o valoare $c$ egală cu $1$ sau $2$, reprezentând cerința ce urmează a fi rezolvată. Următoarea linie conține în ordine $N$, $M$ și $K$, cu semnificația din enunț, iar pe următoarele $N$ linii se află câte $M$ numere, reprezentând valorile din matricea dată. Numerele aflate pe aceeași linie a fișierului sunt separate prin câte un spațiu.

# Date de ieșire
Fișierul de ieșire `cetate.out` va conține pe prima linie profitul maxim cerut, conform cerinței, iar pe a doua linie va conține 4 numere naturale, reprezentând configurația prin care se identifică submatricea obținută. Dacă există mai multe submatrice conform cerinței, se va lua în considerare cea pentru care configurația formată din cele 4 numere de mai sus este minim lexicografică.

# Restricții și precizări
- $1 \leq N,M \leq 400$
- $1 \leq K \leq min(N,M)$
- Valorile date pentru matricea cetății se află în intervalul $[-10^9, 10^9]$.
- Pentru teste în valoare de 20 de puncte, $c=1$, iar pentru restul testelor, în valoare de 70 de puncte, $c=2$. Pentru teste în valoare de 8 puncte, $c=1$ și $1 \leq N,M \leq 70$. Pentru teste în valoare de 25 de puncte, $c=2$ și $1 \leq N,M \leq 70$.
- Configurația $(x_1, x_2, x_3, x_4)$ este mai mică din punct de vedere lexicografic decât configurația $(y_1, y_2, y_3, y_4)$ dacă există $p$ astfel încât $x_p < y_p$ și $x_1 = y_1$, $x_2 = y_2$, $\dots$, $x_{p-1} = y_{p-1}$.

---

Example:
`cetate.in`
```
1
3 4 3
-1 -1 -1 -1
-1 2 -1 -1
-1 -1 -1 -1
```

`cetate.out`
```
-6
1 1 3 3
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```cpp
#include <fstream>
#include <algorithm>
#include <vector>

std::ifstream fin("cetate.in");
std::ofstream fout("cetate.out");

int main() {
    int c, N, M, K;
    fin >> c >> N >> M >> K;

    std::vector<std::vector<long long>> profit(N + 1, std::vector<long long>(M + 1));
    long long x;

    // Reading matrix and computing prefix sums
    for (int i = 1; i <= N; ++i) {
        for (int j = 1; j <= M; ++j) {
            fin >> x;
            profit[i][j] = x - profit[i - 1][j - 1] + profit[i - 1][j] + profit[i][j - 1];
        }
    }

    long long maxProfit = -1e18;
    int i1 = 0, j1 = 0, i2 = 0, j2 = 0;

    for (int i = 1; i <= N; ++i) {
        for (int j = 1; j <= M; ++j) {
            for (int ni = i; ni <= N && (c == 1 ? ni - i + 1 == K : ni - i + 1 <= K); ++ni) {
                for (int nj = j; nj <= M && (c == 1 ? nj - j + 1 == K : nj - j + 1 <= K); ++nj) {
                    long long subProfit = profit[ni][nj] - profit[i - 1][nj] - profit[ni][j - 1] + profit[i - 1][j - 1];
                    if (subProfit > maxProfit) {
                        maxProfit = subProfit;
                        i1 = i;
                        j1 = j;
                        i2 = ni;
                        j2 = nj;
                    }
                }
            }
        }
    }

    fout << maxProfit << '\n';
    fout << i1 << ' ' << j1 << ' ' << i2 << ' ' << j2 << '\n';

    fin.close();
    fout.close();

    return 0;
}
```

This program computes the prefix sums for the grid to allow for fast computation of the profit of any submatrix. Then it iterates through all possible submatrices that meet the criteria of the problem and finds the one with the maximum profit, outputting the profit and the coordinates of the submatrix to the file `cetate.out`.
---------- user ----------


Program result did not match expected result.
Input data:
```
1
3 4 3
-1 -1 -1 -1
-1 2 -1 -1
-1 -1 -1 -1
```
Expected output:
```
-6
1 1 3 3
```
Found output:
```
-1000000000000000000
0 0 0 0
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

Upon reviewing the provided code, I have identified a bug related to how the maximum profit is being initialized. The maximum profit starts at `-1e18`, which is unnecessary since we can start with the minimum possible value that can be obtained from the input grid (i.e., `-10^9 * K * K` if every cell in the submatrix of size KxK had the minimum value `-10^9`). Additionally, the check for "subProfit > maxProfit" should consider the case when "subProfit" is equal to "maxProfit" to ensure the lexicographically smallest configuration is chosen.

Let's correct these problems and rewrite the solution with these fixes in mind:

```cpp
#include <fstream>
#include <vector>

int main() {
    std::ifstream fin("cetate.in");
    std::ofstream fout("cetate.out");

    int c, N, M, K;
    fin >> c >> N >> M >> K;

    std::vector<std::vector<long long>> profit(N + 1, std::vector<long long>(M + 1, 0));
    long long maxProfit = static_cast<long long>(-1e9) * K * K; // Adjusted maxProfit initialization
    int max_i1 = 1, max_j1 = 1, max_i2 = K, max_j2 = K;

    // Reading matrix and computing prefix sums
    for (int i = 1; i <= N; ++i) {
        for (int j = 1; j <= M; ++j) {
            fin >> profit[i][j];
            profit[i][j] += profit[i - 1][j] + profit[i][j - 1] - profit[i - 1][j - 1];
        }
    }

    // Iterate over all possible top-left corners of the submatrix
    for (int i = 1; i <= N - K + 1; ++i) {
        for (int j = 1; j <= M - K + 1; ++j) {
            int i2 = i + K - 1;
            int j2 = j + K - 1;
            // Calculate the sum of the submatrix using the prefix sums
            long long subProfit = profit[i2][j2] - profit[i - 1][j2] - profit[i2][j - 1] + profit[i - 1][j - 1];
            // Update the result if a better submatrix is found
            if (subProfit > maxProfit) {
                maxProfit = subProfit;
                max_i1 = i;
                max_j1 = j;
                max_i2 = i2;
                max_j2 = j2;
            }
        }
    }

    fin.close();

    fout << maxProfit << '\n';
    fout << max_i1 << ' ' << max_j1 << ' ' << max_i2 << ' ' << max_j2 << '\n';
    fout.close();

    return 0;
}
```

This corrected code initializes the maximum profit correctly, ensuring that it is set to the lowest possible value based on the grid size and value constraints. It also simplifies the iteration process by only considering submatrices with side lengths exactly equal to `K` for case `c = 1`. Furthermore, the program now initializes the top-left and bottom-right corners of the submatrix to an initial valid submatrix, ensuring that if all submatrices have negative profit, the lexicographically first submatrix will be chosen.
---------- user ----------


Program result did not match expected result.
Input data:
```
2
3 4 3
-1 -1 -1 -1
-1 2 1 -1
-1 -1 -1 -1
```
Expected output:
```
3
2 2 2 3
```
Found output:
```
-4
1 1 3 3
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The provided code only handles the case where `c = 1` and does not account for the case where `c = 2`, which allows for submatrices with laturile (sides) less than or equal to `K`. This is the main reason for the discrepancy between the expected and found outputs.

We need to update the code to handle both cases, `c = 1` and `c = 2`. For `c = 2`, we must iterate over all possible submatrix sizes up to `K` and update the maximum profit accordingly, always checking to ensure we are considering valid submatrices within the bounds of the matrix.

Let's rewrite the solution with these fixes:

```cpp
#include <fstream>
#include <vector>

int main() {
    std::ifstream fin("cetate.in");
    std::ofstream fout("cetate.out");

    int c, N, M, K;
    fin >> c >> N >> M >> K;

    std::vector<std::vector<long long>> profit(N + 1, std::vector<long long>(M + 1, 0));
    long long maxProfit = static_cast<long long>(-1e9) * K * K; // Adjust maxProfit initialization
    int max_i1 = 1, max_j1 = 1, max_i2 = K, max_j2 = K;

    // Reading matrix and computing prefix sums
    for (int i = 1; i <= N; ++i) {
        for (int j = 1; j <= M; ++j) {
            fin >> profit[i][j];
            profit[i][j] += profit[i - 1][j] + profit[i][j - 1] - profit[i - 1][j - 1];
        }
    }

    // Iterate over all possible submatrices
    for (int i = 1; i <= N; ++i) {
        for (int j = 1; j <= M; ++j) {
            for (int k = 0; k < K; ++k) {
                int ni = i + k;
                int nj = j + k;
                if (ni > N || nj > M) continue; // Ensure the submatrix is within the bounds

                long long subProfit = profit[ni][nj] - profit[i - 1][nj] - profit[ni][j - 1] + profit[i - 1][j - 1];
                if ((subProfit > maxProfit) || (subProfit == maxProfit && (i < max_i1 || (i == max_i1 && j < max_j1)))) {
                    maxProfit = subProfit;
                    max_i1 = i;
                    max_j1 = j;
                    max_i2 = ni;
                    max_j2 = nj;
                }
            }
        }
    }

    fin.close();

    fout << maxProfit << '\n';
    fout << max_i1 << ' ' << max_j1 << ' ' << max_i2 << ' ' << max_j2 << '\n';
    fout.close();

    return 0;
}
```

This updated solution should now correctly handle both cases, determining the maximum profit of a submatrix with sides exactly equal to `K` for `c = 1`, and the maximum profit of a submatrix with sides less than or equal to `K` for `c = 2`. Additionally, the code now includes a check to ensure the lexicographically first submatrix is chosen when multiple submatrices yield the same maximum profit.
---------- user ----------


Program result did not match expected result.
Input data:
```
1
3 4 3
-1 -1 -1 -1
-1 2 -1 -1
-1 -1 -1 -1
```
Expected output:
```
-6
1 1 3 3
```
Found output:
```
2
2 2 2 2
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The error in the previous code is due to the incorrect inclusion of varying submatrix sizes when `c = 1`. When `c = 1`, we only need to consider submatrices of size exactly `KxK`, not submatrices of varying sizes. The previous solution incorrectly allowed for submatrices smaller than `KxK` when `c = 1`.

Let's correct the code to handle both cases `c = 1` and `c = 2` properly:

```cpp
#include <fstream>
#include <vector>
#include <climits>

int main() {
    std::ifstream fin("cetate.in");
    std::ofstream fout("cetate.out");

    int c, N, M, K;
    fin >> c >> N >> M >> K;

    std::vector<std::vector<long long>> matrix(N + 1, std::vector<long long>(M + 1, 0));
    long long maxProfit = LLONG_MIN; // Using LLONG_MIN for the minimum possible value
    int max_i1 = 0, max_j1 = 0, max_i2 = 0, max_j2 = 0;

    // Reading matrix and computing prefix sums
    for (int i = 1; i <= N; ++i) {
        for (int j = 1; j <= M; ++j) {
            fin >> matrix[i][j];
            matrix[i][j] += matrix[i - 1][j] + matrix[i][j - 1] - matrix[i - 1][j - 1];
        }
    }

    // Iterate over all possible submatrices based on the value of c
    for (int i = 1; i <= N; ++i) {
        for (int j = 1; j <= M; ++j) {
            // Define the bounds for ni and nj based on whether c is 1 or 2
            int ni_end = (c == 1) ? std::min(N, i + K - 1) : N;
            int nj_end = (c == 1) ? std::min(M, j + K - 1) : M;

            for (int ni = i; ni <= ni_end; ++ni) {
                for (int nj = j; nj <= nj_end; ++nj) {
                    // Only consider submatrices with side lengths equal to K when c == 1
                    if (c == 1 && (ni - i + 1 != K || nj - j + 1 != K)) continue;
                    
                    long long subProfit = matrix[ni][nj] - matrix[i - 1][nj] - matrix[ni][j - 1] + matrix[i - 1][j - 1];

                    // Check for submatrices with maximum profit
                    if (subProfit > maxProfit ||
                        (subProfit == maxProfit && (i < max_i1 || (i == max_i1 && j < max_j1)))) {
                        maxProfit = subProfit;
                        max_i1 = i;
                        max_j1 = j;
                        max_i2 = ni;
                        max_j2 = nj;
                    }
                }
            }
        }
    }

    fout << maxProfit << '\n';
    fout << max_i1 << ' ' << max_j1 << ' ' << max_i2 << ' ' << max_j2 << '\n';

    fin.close();
    fout.close();

    return 0;
}
```

This solution ensures that when `c = 1`, we only look at submatrices of size exactly `KxK`, and when `c = 2`, we consider all submatrices up to `KxK`. The initialization of `maxProfit` to `LLONG_MIN` guarantees that any valid profit will be larger, making sure we choose the lexicographically first submatrix in case of all negative profits. This should now provide the correct output for both cases in the task.
