---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `poarta.in` and write to `poarta.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Se consideră harta universului ca fiind o matrice cu $250$ de linii şi $250$ de coloane. În fiecare celulă se găseşte o aşa numită poartă stelară, iar în anumite celule se găsesc echipaje ale porţii stelare. La o deplasare, un echipaj se poate deplasa din locul în care se află în oricare alt loc în care se găseşte o a doua poartă, în cazul nostru în orice altă poziţie din matrice. Nu se permite situarea simultană a mai mult de un echipaj într-o celulă. La un moment dat un singur echipaj se poate deplasa de la o poartă stelară la alta.

# Cerință

Dându-se un număr $p$ de echipaje, pentru fiecare echipaj fiind precizate poziţia iniţială şi poziţia finală, determinaţi numărul minim de deplasări necesare pentru ca toate echipajele să ajungă din poziţia iniţială în cea finală.

# Date de intrare
Fișierul de intrare `poarta.in` are următorul format:
- pe prima linie se află numărul natural $p$ reprezentând numărul echipaje.
- pe următoarele $p$ linii se află câte 4 numere naturale, primele două reprezentând coordonatele poziţiei iniţiale a unui echipaj (linie respectiv coloană), următoarele două reprezentând coordonatele poziţiei finale a aceluiaşi echipaj (linie respectiv coloană).

# Date de ieşire
Pe prima linie a fişierului de ieșire `poarta.out` se scrie un singur număr reprezentând numărul minim de deplasări necesar.

# Restricții și precizări
- $1 < p < 5\ 000$
- Coordonatele poziţiilor iniţiale şi finale ale echipajelor sunt numere naturale din intervalul $[1, 250]$.
- **Atenție la cazurile când poziția inițială este identică cu cea finală!**
- Poziţiile iniţiale ale celor $p$ echipaje sunt distincte două câte două.
- Poziţiile finale ale celor $p$ echipaje sunt distincte două câte două.

---

Example:
`poarta.in`
```
3
1 2 3 4
6 5 3 9
3 4 1 2
```

`poarta.out`
```
4
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```cpp
#include <fstream>
#include <unordered_map>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    ifstream fin("poarta.in");
    ofstream fout("poarta.out");

    int p;
    fin >> p;

    vector<pair<int, int>> start(p), end(p);
    for (int i = 0; i < p; ++i) {
        fin >> start[i].first >> start[i].second >> end[i].first >> end[i].second;
    }
    fin.close();

    // Mapping final positions to indices
    unordered_map<int, int> pos_end_map;
    for (int i = 0; i < p; ++i) {
        pos_end_map[end[i].first * 251 + end[i].second] = i;
    }

    // Sort start positions
    sort(start.begin(), start.end(), [](const pair<int, int> &a, const pair<int, int> &b) {
        return a.first == b.first ? a.second < b.second : a.first < b.first;
    });

    // Sort end positions
    sort(end.begin(), end.end(), [](const pair<int, int> &a, const pair<int, int> &b) {
        return a.first == b.first ? a.second < b.second : a.first < b.first;
    });

    int swaps = 0;
    vector<bool> visited(p, false);
    for (int i = 0; i < p; ++i) {
        if (visited[i] || (end[i].first == start[i].first && end[i].second == start[i].second)) {
            continue;
        }

        // Find cycles
        int cycle_size = 0;
        int j = i;
        while (!visited[j]) {
            visited[j] = true;
            j = pos_end_map[start[j].first * 251 + start[j].second];
            cycle_size++;
        }
        swaps += cycle_size - 1; // Number of swaps for this cycle
    }

    fout << swaps << '\n';
    fout.close();

    return 0;
}
```
Please note that this solution assumes that the constraints given in the challenge are strictly followed, particularly that the initial and final positions are distinct and within the specified range.
---------- user ----------


Program result did not match expected result.
Input data:
```
3
1 2 3 4
6 5 3 9
3 4 1 2
```
Expected output:
```
4
```
Found output:
```
1
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
