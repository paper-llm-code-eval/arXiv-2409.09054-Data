---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `expresie.in` and write to `expresie.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Se dă un șir de $n$ numere naturale nenule $x_1, x_2, \dots, x_n$ și un număr natural $m$.

# Cerință
Să se verifice dacă valoarea expresiei $\sqrt[m]{x_1 x_2 x_3 \dots x_n}$ este un număr natural. În caz afirmativ să se afișeze acest număr descompus în factori primi.

# Date de intrare
În fișierul `expresie.in` se află pe prima linie $m$, pe linia a doua $n$, iar pe linia a treia numerele $x_1$, $x_2$, $\dots$, $x_n$ separate între ele prin câte un spațiu.

# Date de ieșire
În fișierul `expresie.out` se va scrie pe prima linie cifra $0$, dacă valoarea expresiei nu este un număr natural, respectiv $1$ dacă este un număr natural. 
Dacă valoarea expresiei este un număr natural, pe următoarele linii se vor scrie perechi de forma "$p\ e$" ($p$ este factor prim care apare în descompunere la puterea $e \geq 1$). Aceste perechi se vor scrie în ordine crescătoare după primul număr (adică $p$).

# Restricții
- $n$ este un număr natural nenul mai mic strict decât $5\ 000$.
- $x_i$ este un număr natural nenul mai mic strict decât $30\ 000$, $i \in \{1, 2, \dots, n\}$.
- **$m$ poate fi una din cifrele $2$, $3$ sau $4$.**

---

Example:
`expresie.in`
```
2
4
32 81 100 19
```

`expresie.out`
```
0
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```c++
#include <fstream>
#include <vector>
#include <cmath>

std::ifstream fin("expresie.in");
std::ofstream fout("expresie.out");

const int MAX_N = 5000;
const int MAX_X = 30000;

int prime_factors[MAX_X + 1][2]; // Store prime factors and their count for each number

void preprocess_prime_factors() {
    for (int i = 2; i <= MAX_X; ++i) {
        if (prime_factors[i][0] == 0) { // i is prime
            for (int j = i; j <= MAX_X; j += i) {
                int count = 0;
                int k = j;
                while (k % i == 0) {
                    k /= i;
                    ++count;
                }
                prime_factors[j][0] = i;
                prime_factors[j][1] = count;
            }
        }
    }
}

bool verify_natural(int m, int n, std::vector<int>& numbers) {
    std::vector<int> prime_count(MAX_X + 1, 0);
    
    // Factorize each number and accumulate prime factors
    for (int num : numbers) {
        int factor = prime_factors[num][0];
        int count = prime_factors[num][1];
        prime_count[factor] += count;
    }
    
    // Check if each prime count is divisible by m
    for (int prime = 2; prime <= MAX_X; ++prime) {
        if (prime_count[prime] % m != 0) {
            return false;
        }
    }
    
    // Output the natural number in prime factorization
    fout << "1\n";
    for (int prime = 2; prime <= MAX_X; ++prime) {
        if (prime_count[prime] > 0) {
            fout << prime << ' ' << prime_count[prime] / m << '\n';
        }
    }
    
    return true;
}

int main() {
    int m, n;
    fin >> m >> n;
    std::vector<int> numbers(n);
    
    preprocess_prime_factors();
    
    for (int i = 0; i < n; ++i) {
        fin >> numbers[i];
    }
    
    if (!verify_natural(m, n, numbers)) {
        fout << "0\n";
    }
    
    fin.close();
    fout.close();
    return 0;
}
```
---------- user ----------


Program result did not match expected result.
Input data:
```
2
4
32 81 100 18
```
Expected output:
```
1
2 4
3 3
5 1
```
Found output:
```
0
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

Upon evaluation, it appears that the initial submission had a flawed implementation in the prime factorization part, which may lead to incorrect results. The implementation had assumed a unique prime factorization for each number up to `MAX_X`, but numbers can have multiple prime factors. For instance, the number 100 has the prime factors 2 and 5, but the initial implementation would only capture one of them.

To fix the issue, we need to correctly count all the prime factors of each number in the list and then determine whether the product of these numbers, when taken to the 1/mth power, is an integer. This requires a corrected algorithm for prime factorization.

Here is the rewritten solution:

```cpp
#include <fstream>
#include <vector>
#include <map>
#include <cmath>

const int MAX_X = 30000;

std::ifstream fin("expresie.in");
std::ofstream fout("expresie.out");

// Function to factorize a number into its prime factors and their powers
std::map<int, int> factorize(int number) {
    std::map<int, int> factors;
    for (int i = 2; i <= sqrt(number); ++i) {
        while (number % i == 0) {
            factors[i]++;
            number /= i;
        }
    }
    if (number > 1) {
        factors[number]++;
    }
    return factors;
}

int main() {
    int m, n, x;
    fin >> m >> n;
    std::map<int, int> total_factors;

    // Factorize each number and merge the factors
    for (int i = 0; i < n; ++i) {
        fin >> x;
        std::map<int, int> factors = factorize(x);
        for (const auto& factor : factors) {
            total_factors[factor.first] += factor.second;
        }
    }
    fin.close();

    // Check if the expression results in a natural number
    bool is_natural = true;
    for (auto& factor : total_factors) {
        if (factor.second % m != 0) {
            is_natural = false;
            break;
        }
        factor.second /= m;
    }

    // Output the result
    if (!is_natural) {
        fout << "0\n";
    } else {
        fout << "1\n";
        for (const auto& factor : total_factors) {
            if (factor.second > 0) { // Output only factors with a non-zero power
                fout << factor.first << ' ' << factor.second << '\n';
            }
        }
    }
    
    fout.close();
    return 0;
}
```

This solution factorizes each number in the input file, and then combines the prime factors into a total count. It checks if the total count of each prime factor is divisible by `m`, as this would indicate that the mth root of the product of all numbers is an integer. If the count is not divisible by `m` for any prime factor, the program outputs `0`. Otherwise, it outputs `1` and the prime factorization of the resulting integer.
