---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `ucif.in` and write to `ucif.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Fie $n$ un număr natural și $s = 1^1 + 2^2 + 3^3 + \dots + n^n$.

# Cerință

Scrieți un program care să afișeze ultima cifră a lui $s$.

# Date de intrare


De pe prima linie a fișierului de intrare `ucif.in` se citește numărul $n$.


# Date de ieșire


Pe prima linie a fișierului de ieșire `ucif.out` se va afișa numai ultima cifră a lui $s$.


# Restricții și precizări

* $1 \leq n \leq 100$

---

Example:
`ucif.in`
```
3
```

`ucif.out`
```
2
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```cpp
#include <fstream>

int main() {
    std::ifstream inFile("ucif.in");
    std::ofstream outFile("ucif.out");
    int n, lastDigit = 0;

    inFile >> n;

    int pows[] = {0, 1, 4, 4, 2, 2, 2, 8, 8, 8};
    for (int i = 1; i <= n; ++i) {
        lastDigit = (lastDigit + pows[i % 10]) % 10;
    }

    outFile << lastDigit;
    inFile.close();
    outFile.close();
    return 0;
}
```
---------- user ----------


Program result did not match expected result.
Input data:
```
3
```
Expected output:
```
2
```
Found output:
```
9
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

Upon reviewing the error in the original solution, it's clear that I made a mistake in the computation of the last digits. Instead of using a precomputed array of powers, which is incorrect because the power to which each number is raised changes and is not a fixed pattern, I should calculate the last digit of each $i^i$ term directly and efficiently, considering that powers of a number from 1 to 9 repeat their last digits in a cycle.

Here is the corrected solution taking this into account:

```cpp
#include <fstream>

int powLastDigit(int base, int exponent) {
    // The last digit of any number raised to the power of 4k+1 is itself.
    // The last digit of any number raised to the power of 4k+2 is the last digit of the square of the number.
    // The last digit of any number raised to the power of 4k+3 is the last digit of the number * last digit of the square of the number.
    // The last digit of any number raised to the power of 4k is 6 if the number is even and 1 if the number is odd (except for 0 which is always 0).
    if (exponent == 0) return 1;
    base %= 10;
    exponent %= 4;
    if (exponent == 0) return base == 0 ? 0 : 6;
    else if (exponent == 1) return base;
    else if (exponent == 2) return (base * base) % 10;
    return (base * base * base) % 10;
}

int main() {
    std::ifstream inFile("ucif.in");
    std::ofstream outFile("ucif.out");
    int n, sumLastDigit = 0;

    inFile >> n;

    for (int i = 1; i <= n; ++i) {
        sumLastDigit = (sumLastDigit + powLastDigit(i, i)) % 10;
    }

    outFile << sumLastDigit;

    inFile.close();
    outFile.close();
    return 0;
}
```

This code defines a function `powLastDigit` that computes the last digit of $i^i$ using the properties of the cycle of last digits in powers. Then, it adds this last digit to a running sum to maintain only the last digit of the sum $s$. The result should now be correct for the provided input data.
