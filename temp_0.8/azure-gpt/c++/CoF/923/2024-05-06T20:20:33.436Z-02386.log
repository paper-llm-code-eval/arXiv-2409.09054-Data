---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `foto.in` and write to `foto.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

O fotografie alb-negru a surprins imaginea fulgerelor pe cerul întunecat în timpul unei furtuni electrice. Mărită, fotografia arată ca un caroiaj format din mici pătrate identice, albe sau negre, dispuse alăturat pe $N$ rânduri și $M$ coloane, câte $M$ pe fiecare rând. **Pătratele albe** formează fulgerele din fotografie, iar **pătratele negre** reprezintă cerul. În fotografie, nu există două pătrate albe dispuse alăturat pe același rând. **Un fulger** este format din pătrate albe situate pe rânduri consecutive care respectă următoarele condiții:
- pătratele albe situate pe două rânduri consecutive au un vârf comun sau o latură comună;
- un fulger poate avea un singur pătrat alb pe un rând.

În fotografie, fulgerele sunt **distincte**, ele neavând pătrate albe cu laturi sau vârfuri comune. **Înălțimea unui fulger** este dată de numărul de pătrate albe ale acelui fulger.

\
~[foto.png|align=right|width=30em]
Pentru a putea fi analizată de către programatori, fotografia este codificată cu ajutorul unui tablou bidimensional cu $N$ linii și $M$ coloane, ale cărui elemente sunt $0$ și $1$. Valoarea $0$ este codificarea pătratului negru, iar valoarea $1$ este codificarea pătratului alb.

Având codificarea, programatorii trebuie să găsească numărul maxim $P$ de pătrate negre dispuse alăturat pe același rând, numărul de fulgere $F$ precum și înălțimea maximă $H$ a unui fulger din fotografie. De exemplu, fotografia alăturată este codificată de tabloul $T$ alăturat fotografiei.

# Cerință
Scrieţi un program care citeşte numerele $N$ și $M$, cele $N \cdot M$ elemente ale tabloului $T$ care codifică fotografia, și rezolvă următoarele cerințe:
1) afișează numărul maxim $P$ de pătrate negre dispuse alăturat pe un rând în fotografie;
2) afișează numărul $F$ de fulgere și înălțimea maximă $H$ a unui fulger din fotografie.

# Date de intrare
Fișierul de intrare `foto.in` conține pe prima linie un număr natural $C$ reprezentând cerința care trebuie rezolvată ($1$ sau $2$). Pe a doua linie se află cele două numere naturale $N$ și $M$, separate printr-un spațiu, cu semnificația din enunț. Pe fiecare dintre următoarele $N$ linii se află câte $M$ valori $0$ sau $1$, separate prin câte un spațiu, reprezentând elementele tabloului care codifică fotografia, în ordinea parcurgerii lor pe rânduri, de sus în jos, și de la stânga la dreapta în cadrul unui rând.

# Date de ieșire
Fişierul de ieşire `foto.out` va conţine, pe o singură linie:
- dacă $C=1$, numărul $P$, reprezentând răspunsul la cerinţa $1$;
- dacă $C=2$, cele două numere $F$ și $H$, în această ordine, separate printr-un singur spațiu, reprezentând răspunsul la cerinţa $2$.

# Restricții și precizări
- $N$ număr natural, $4 \leq N \leq 100$.
- $M$ număr natural, $4 \leq M \leq 100$.
- Pentru rezolvarea cerinței 1:
	- Se acordă 20 de puncte.
	- Fiecare test este în valoare de 2 puncte.
- Pentru rezolvarea cerinței 2:
	- Se acordă 70 de puncte.
	- Fiecare test pentru această cerință este în valoare de 7 puncte:
		- 3 puncte pentru valoarea corectă a lui $F$;
		- 4 puncte pentru valoarea corectă a lui $H$.
	- Această cerință necesită ca **în fișierul de ieșire să existe exact 2 numere**.

---

Example:
`foto.in`
```
1
6 7
0 1 0 0 1 0 0
1 0 0 0 1 0 0
0 0 1 0 0 0 1
0 1 0 0 0 1 0
0 1 0 0 1 0 0
0 0 1 0 1 0 1
```

`foto.out`
```
3
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:Here's an efficient C++ solution to the given problem. The code reads from `foto.in` and writes to `foto.out` using file streams and bypasses the use of `cin`, `cout`, `printf`, and `scanf`. The code efficiently calculates the maximum number of consecutive black squares on a row for task 1, and for task 2, counts the number of lightnings and finds the maximum height of a lightning.

```cpp
#include <fstream>
#include <vector>
#include <algorithm>

std::ifstream fin("foto.in");
std::ofstream fout("foto.out");

const int MAX_SIZE = 100;

int main() {
    int C, N, M;
    fin >> C >> N >> M;
    std::vector<std::vector<int>> grid(N, std::vector<int>(M));

    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            fin >> grid[i][j];
        }
    }

    if (C == 1) {
        int max_black = 0;
        for (int i = 0; i < N; i++) {
            int black_count = 0;
            for (int j = 0; j < M; j++) {
                if (grid[i][j] == 0) {
                    black_count++;
                } else {
                    max_black = std::max(max_black, black_count);
                    black_count = 0;
                }
            }
            max_black = std::max(max_black, black_count);
        }
        fout << max_black;
    } else if (C == 2) {
        int num_lightnings = 0;
        int max_height = 0;
        std::vector<std::vector<bool>> visited(N, std::vector<bool>(M, false));

        for (int i = 0; i < N; i++) {
            for (int j = 0; j < M; j++) {
                if (grid[i][j] == 1 && !visited[i][j]) {
                    num_lightnings++;
                    int height = 0;
                    for (int k = i; k < N && grid[k][j] == 1; k++) {
                        visited[k][j] = true;
                        height++;
                    }
                    max_height = std::max(max_height, height);
                }
            }
        }

        fout << num_lightnings << " " << max_height;
    }

    fin.close();
    fout.close();
    return 0;
}
```

This code employs depth-first search (DFS) for task 2, which is unnecessary due to the problem's constraints. Since we need to check just vertically adjacent squares, a simple linear pass is sufficient, which the code above demonstrates.
---------- user ----------


Program result did not match expected result.
Input data:
```
2
6 7
0 1 0 0 1 0 0
1 0 0 0 1 0 0
0 0 1 0 0 0 1
0 1 0 0 0 1 0
0 1 0 0 1 0 0
0 0 1 0 1 0 1
```
Expected output:
```
5 4
```
Found output:
```
10 2
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The original code for task 2 counts every white square as part of a new lightning bolt, which is incorrect. Instead, a lightning bolt is a sequence of white squares that are connected vertically and possibly horizontally. The code also incorrectly calculates the number of lightnings and the maximum height for each lightning.

To fix this, we should apply a flood-fill algorithm to count each distinct lightning bolt and calculate its height correctly. We will use a depth-first search (DFS) algorithm to explore the grid and mark the visited white squares, ensuring we don't count them more than once.

Here is the corrected solution:

```cpp
#include <fstream>
#include <vector>
#include <algorithm>

std::ifstream fin("foto.in");
std::ofstream fout("foto.out");

const int MAX_SIZE = 100;

int N, M;

void dfs(int i, int j, std::vector<std::vector<int>>& grid, int& height) {
    if (i < 0 || i >= N || j < 0 || j >= M || grid[i][j] != 1)
        return;
    grid[i][j] = 2; // Mark as visited
    height = std::max(height, i + 1);
    dfs(i - 1, j, grid, height); // check above
    dfs(i + 1, j, grid, height); // check below
    if (j > 0 && grid[i][j - 1] == 0) // check left, only if it's preceded by a black square, to avoid counting adjacent lightning bolts
        dfs(i, j - 1, grid, height);
    if (j < M - 1 && grid[i][j + 1] == 0) // check right, only if it's followed by a black square, to avoid counting adjacent lightning bolts
        dfs(i, j + 1, grid, height);
}

int main() {
    int C;
    fin >> C >> N >> M;
    std::vector<std::vector<int>> grid(N, std::vector<int>(M));

    for (int i = 0; i < N; i++)
        for (int j = 0; j < M; j++)
            fin >> grid[i][j];

    if (C == 1) {
        int max_black = 0;
        for (int i = 0; i < N; i++) {
            int black_count = 0;
            for (int j = 0; j < M; j++) {
                if (grid[i][j] == 0) {
                    black_count++;
                } else {
                    max_black = std::max(max_black, black_count);
                    black_count = 0;
                }
            }
            max_black = std::max(max_black, black_count); // Account for a sequence of black squares ending at the row's end
        }
        fout << max_black << '\n';
    } else if (C == 2) {
        int num_lightnings = 0, max_height = 0;
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < M; j++) {
                if (grid[i][j] == 1) {
                    int height = 0;
                    dfs(i, j, grid, height);
                    num_lightnings++;
                    max_height = std::max(max_height, height);
                }
            }
        }
        fout << num_lightnings << " " << max_height << '\n';
    }

    fin.close();
    fout.close();
    return 0;
}
```

This updated code should correctly identify distinct lightning bolts and their heights, complying with the problem's requirements. The DFS algorithm is invoked only when a white square is encountered, and it checks only the white squares above and below the current square, and left or right only if a black square precedes or follows, respectively. This ensures we count each distinct lightning bolt exactly once and calculate its correct height.
---------- user ----------


Program result did not match expected result.
Input data:
```
2
6 7
0 1 0 0 1 0 0
1 0 0 0 1 0 0
0 0 1 0 0 0 1
0 1 0 0 0 1 0
0 1 0 0 1 0 0
0 0 1 0 1 0 1
```
Expected output:
```
5 4
```
Found output:
```
10 6
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

It appears that the previous solution still does not correctly identify distinct lightning bolts and their heights. To solve the problem correctly, we need to be careful about how we traverse the grid and mark the cells that are part of a lightning bolt. 

The main issues are:

1. The previous DFS algorithm calls were incorrectly including left and right movements, potentially counting a single bolt multiple times.
2. The algorithm was not accurately calculating the height of the lightning bolts.

To fix these issues, we need to do a vertical DFS traversal for each white cell that has not been visited. We should also keep track of the cells that have been visited to avoid double-counting. For each lightning bolt, we need to calculate its height by counting the number of consecutive white cells that form a bolt from top to bottom.

Here is the revised solution with the required fixes:

```cpp
#include <fstream>
#include <vector>

std::ifstream fin("foto.in");
std::ofstream fout("foto.out");

const int MAX_N = 100;
const int MAX_M = 100;

int N, M;
int max_black = 0;
int num_lightnings = 0, max_height = 0;
std::vector<std::vector<int>> grid(MAX_N, std::vector<int>(MAX_M));
std::vector<std::vector<bool>> visited(MAX_N, std::vector<bool>(MAX_M, false));

int dfs(int i, int j) {
    if (i < 0 || i >= N || j < 0 || j >= M || visited[i][j] || grid[i][j] == 0)
        return 0;
    visited[i][j] = true;
    return 1 + dfs(i + 1, j); // Only move vertically down
}

int main() {
    int C;
    fin >> C >> N >> M;

    for (int i = 0; i < N; i++)
        for (int j = 0; j < M; j++)
            fin >> grid[i][j];

    if (C == 1) {
        for (int i = 0; i < N; i++) {
            int current_black = 0;
            for (int j = 0; j < M; j++) {
                if (grid[i][j] == 0) {
                    current_black++;
                    max_black = std::max(max_black, current_black);
                } else {
                    current_black = 0;
                }
            }
        }
        fout << max_black << '\n';
    } else if (C == 2) {
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < M; j++) {
                if (grid[i][j] == 1 && !visited[i][j]) {
                    num_lightnings++;
                    int height = dfs(i, j);
                    max_height = std::max(max_height, height);
                }
            }
        }
        fout << num_lightnings << " " << max_height << '\n';
    }

    fin.close();
    fout.close();
    return 0;
}
```

The `dfs` function now only moves vertically downwards, as lightning bolts are defined as vertical sequences of white squares. The `visited` matrix ensures that each white square is only counted once. The `max_height` calculation has been fixed to correctly measure the height of each lightning bolt.
---------- user ----------


Program result did not match expected result.
Input data:
```
2
6 7
0 1 0 0 1 0 0
1 0 0 0 1 0 0
0 0 1 0 0 0 1
0 1 0 0 0 1 0
0 1 0 0 1 0 0
0 0 1 0 1 0 1
```
Expected output:
```
5 4
```
Found output:
```
10 2
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The issue lies in the fact that the previous solution only considered vertical connections of white squares as lightnings, without allowing for diagonal connections. According to the problem statement, lightning can be formed by squares on consecutive rows as long as they have a common vertex or a common side. Hence, diagonal connections are also valid. 

The algorithm needs to take into account not only vertical but also diagonal connections, and track visited squares properly to avoid double-counting. Here's the corrected solution:

```cpp
#include <fstream>
#include <vector>
#include <algorithm>

std::ifstream fin("foto.in");
std::ofstream fout("foto.out");

int N, M;
std::vector<std::vector<int>> grid;
std::vector<std::vector<bool>> visited;

// The DFS will search vertically and diagonally.
int dfs(int i, int j) {
    if (i < 0 || i >= N || j < 0 || j >= M || visited[i][j] || grid[i][j] == 0)
        return 0;
    visited[i][j] = true;

    int height = 1; // Each white square contributes to the height
    // Search downwards and diagonally (but not upwards or horizontally to avoid double-counting)
    height = std::max(height, dfs(i + 1, j)); // down
    height = std::max(height, dfs(i + 1, j - 1)); // down and left
    height = std::max(height, dfs(i + 1, j + 1)); // down and right

    return height;
}

int main() {
    int C;
    fin >> C >> N >> M;
    grid.assign(N, std::vector<int>(M));
    visited.assign(N, std::vector<bool>(M, false));

    for (int i = 0; i < N; ++i)
        for (int j = 0; j < M; ++j)
            fin >> grid[i][j];

    if (C == 1) {
        int max_black_seq = 0;
        for (int i = 0; i < N; ++i) {
            int current_black_seq = 0;
            for (int j = 0; j < M; ++j) {
                if (grid[i][j] == 0) {
                    ++current_black_seq;
                } else {
                    max_black_seq = std::max(max_black_seq, current_black_seq);
                    current_black_seq = 0;
                }
            }
            // Check at the end of the row
            max_black_seq = std::max(max_black_seq, current_black_seq);
        }
        fout << max_black_seq << '\n';
    } else if (C == 2) {
        int num_lightnings = 0, max_height = 0;
        for (int i = 0; i < N; ++i) {
            for (int j = 0; j < M; ++j) {
                if (grid[i][j] == 1 && !visited[i][j]) {
                    ++num_lightnings;
                    int height = dfs(i, j);
                    max_height = std::max(max_height, height);
                }
            }
        }
        fout << num_lightnings << " " << max_height << '\n';
    }

    fin.close();
    fout.close();
    return 0;
}
```

This solution should now correctly identify distinct lightning bolts by allowing vertical and diagonal connections, while also ensuring that the same white square (or part of a lightning) is not counted twice. The DFS algorithm is initiated for each unvisited white square and expands downwards and diagonally to determine the height of each lightning bolt.
---------- user ----------


Program result did not match expected result.
Input data:
```
2
6 7
0 1 0 0 1 0 0
1 0 0 0 1 0 0
0 0 1 0 0 0 1
0 1 0 0 0 1 0
0 1 0 0 1 0 0
0 0 1 0 1 0 1
```
Expected output:
```
5 4
```
Found output:
```
5 1
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

It seems that the previous solutions did not handle diagonal connections correctly. The DFS should not continue to neighboring white squares that are diagonally connected because, by the problem's definition, while a lightning bolt can span diagonally, it can only have one white square per row.

Moreover, the height of a lightning bolt is the number of rows it spans, regardless of whether the white squares are diagonally connected to each other or not. Hence, we should only move down to the next row if the next row has a white square in the same column or the columns immediately to the left or right.

Here's the corrected solution that fully respects the problem's definition of a lightning bolt:

```cpp
#include <fstream>

std::ifstream fin("foto.in");
std::ofstream fout("foto.out");

const int MAX_N = 100;
const int MAX_M = 100;

int N, M;
int grid[MAX_N][MAX_M];
bool visited[MAX_N][MAX_M] = {false};

// Recursive function to find the height of a lightning bolt
int get_lightning_height(int row, int col) {
    if (row < 0 || row >= N || col < 0 || col >= M || grid[row][col] == 0 || visited[row][col])
        return 0;

    visited[row][col] = true;  // Mark the current cell as visited
    int height = 1;  // The current row contributes to the height

    // Check for a white square in the same column in the next row
    height += get_lightning_height(row + 1, col);

    // Check the diagonally adjacent cells in the next row
    if (col > 0)
        height += get_lightning_height(row + 1, col - 1);
    if (col < M - 1)
        height += get_lightning_height(row + 1, col + 1);

    // We only return a positive height for the first row of the lightning bolt,
    // so we set it back to 0 for the recursive calls to prevent double counting.
    return row == 0 ? height : 0;
}

int main() {
    int C, i, j;
    fin >> C >> N >> M;

    // Read the grid from the input file
    for (i = 0; i < N; ++i) {
        for (j = 0; j < M; ++j) {
            fin >> grid[i][j];
        }
    }

    if (C == 1) {
        int P = 0, curr_black = 0;
        for (i = 0; i < N; ++i) {
            curr_black = 0;
            for (j = 0; j < M; ++j) {
                if (grid[i][j] == 0) {
                    curr_black++;
                    P = std::max(P, curr_black);
                } else {
                    curr_black = 0;
                }
            }
        }
        fout << P << '\n';
    } else if (C == 2) {
        int F = 0, H = 0, height;
        for (i = 0; i < N; ++i) {
            for (j = 0; j < M; ++j) {
                if (grid[i][j] == 1 && !visited[i][j]) {
                    height = get_lightning_height(i, j);
                    if (height > 0) {  // Valid lightning bolt
                        F++;
                        H = std::max(H, height);
                    }
                }
            }
        }
        fout << F << ' ' << H << '\n';
    }

    fin.close();
    fout.close();
    return 0;
}
```

In this code, we only consider a cell part of a lightning bolt if it's white, not visited, and either in the same column, or the column to the immediate left or right of the last cell in the bolt. This way, we can count the correct number of lightning bolts and calculate their correct height. The `get_lightning_height` function only adds to the height if it's the first row of a new lightning bolt and will return 0 for subsequent recursive calls to prevent double counting.
---------- user ----------


Program result did not match expected result.
Input data:
```
2
6 7
0 1 0 0 1 0 0
1 0 0 0 1 0 0
0 0 1 0 0 0 1
0 1 0 0 0 1 0
0 1 0 0 1 0 0
0 0 1 0 1 0 1
```
Expected output:
```
5 4
```
Found output:
```
2 1
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The previous solutions did not correctly handle the lightning bolt definitions given in the problem statement. The critical realization is that a lightning bolt can have a single white square on a row and can span to adjacent (left, right, or down) white squares on the next row.

To correctly determine the height of a lightning bolt, we need to explore from each white square down and potentially diagonally left or right if there is a directly adjacent white square on the next row. The height of the lightning bolt is the count of rows through which the bolt passes.

Given that the lightning bolts are distinct (i.e., they do not share any common white square), we can perform a DFS each time we encounter a white square that has not been visited. To ensure we don't process the same bolt more than once, we should mark all parts of it as visited during the DFS.

Here is the corrected C++ solution:

```cpp
#include <fstream>
#include <vector>
#include <algorithm>

std::ifstream fin("foto.in");
std::ofstream fout("foto.out");

int N, M;
std::vector<std::vector<int>> grid;
std::vector<std::vector<bool>> visited;

void dfs(int i, int j, int& height) {
    if (i < 0 || i >= N || j < 0 || j >= M || visited[i][j] || grid[i][j] == 0)
        return;
    visited[i][j] = true;
    height++; // Increment height for each new row reached by the lightning
    // Check the same column in the next row
    dfs(i + 1, j, height);
    // Check diagonally left and right, but only if there's a white square directly below
    if (i + 1 < N && grid[i + 1][j] == 1) {
        if (j - 1 >= 0 && grid[i][j - 1] == 1) dfs(i + 1, j - 1, height);
        if (j + 1 < M && grid[i][j + 1] == 1) dfs(i + 1, j + 1, height);
    }
}

int main() {
    int C;
    fin >> C >> N >> M;
    grid.assign(N, std::vector<int>(M));
    visited.assign(N, std::vector<bool>(M, false));

    for (int i = 0; i < N; i++)
        for (int j = 0; j < M; j++)
            fin >> grid[i][j];

    if (C == 1) {
        int max_black = 0;
        for (int i = 0; i < N; i++) {
            int black_count = 0;
            for (int j = 0; j < M; j++) {
                if (grid[i][j] == 0) {
                    black_count++;
                } else {
                    max_black = std::max(max_black, black_count);
                    black_count = 0;
                }
            }
            max_black = std::max(max_black, black_count);
        }
        fout << max_black << '\n';
    } else if (C == 2) {
        int num_lightnings = 0, max_height = 0;
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < M; j++) {
                if (!visited[i][j] && grid[i][j] == 1) {
                    int height = 0;
                    dfs(i, j, height);
                    num_lightnings++;
                    max_height = std::max(max_height, height);
                }
            }
        }
        fout << num_lightnings << " " << max_height << '\n';
    }

    fin.close();
    fout.close();
    return 0;
}
```

This solution should now accurately count the number of lightning bolts and find the correct maximum height based on the problem's specifications.
---------- user ----------


Program result did not match expected result.
Input data:
```
2
6 7
0 1 0 0 1 0 0
1 0 0 0 1 0 0
0 0 1 0 0 0 1
0 1 0 0 0 1 0
0 1 0 0 1 0 0
0 0 1 0 1 0 1
```
Expected output:
```
5 4
```
Found output:
```
10 2
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

Upon reviewing the past responses and the problem statement, it's clear that the previous solutions did not correctly account for the height of a lightning bolt. Specifically, they were not checking for diagonally adjacent white squares correctly. The height of a lightning bolt is given by the number of white squares on consecutive rows, each potentially having a common vertex or side. Thus, we need to adjust the algorithm to correctly traverse and count the height of each lightning bolt.

Here's the corrected solution that should meet the challenge requirements:

```cpp
#include <fstream>
#include <vector>
#include <algorithm>

std::ifstream fin("foto.in");
std::ofstream fout("foto.out");

int N, M;
std::vector<std::vector<int>> grid;
std::vector<std::vector<bool>> visited;

// Function to find the height of a lightning bolt
int get_height(int row, int col) {
    if (row >= N || col < 0 || col >= M || grid[row][col] == 0)
        return 0;
    if (visited[row][col]) // If already visited, return 0 to not count it again
        return 0;
    visited[row][col] = true; // Mark the square as visited
    // To ensure we get the height, we increment for the current row and try to move to adjacent squares in the next row
    return 1 + std::max({get_height(row + 1, col), get_height(row + 1, col - 1), get_height(row + 1, col + 1)});
}

int main() {
    int C;
    fin >> C >> N >> M;
    grid.assign(N, std::vector<int>(M));
    visited.assign(N, std::vector<bool>(M, false));

    for (int i = 0; i < N; ++i)
        for (int j = 0; j < M; ++j)
            fin >> grid[i][j];

    if (C == 1) {
        int max_black = 0, count_black;
        for (int i = 0; i < N; ++i) {
            count_black = 0;
            for (int j = 0; j < M; ++j) {
                if (grid[i][j] == 0) {
                    ++count_black;
                } else {
                    max_black = std::max(max_black, count_black);
                    count_black = 0;
                }
            }
            max_black = std::max(max_black, count_black); // Check at the end of the row
        }
        fout << max_black << '\n';
    } else if (C == 2) {
        int total_lightnings = 0, max_height = 0;
        for (int i = 0; i < N; ++i) {
            for (int j = 0; j < M; ++j) {
                if (grid[i][j] == 1 && !visited[i][j]) {
                    int height = get_height(i, j);
                    max_height = std::max(max_height, height);
                    ++total_lightnings;
                }
            }
        }
        fout << total_lightnings << " " << max_height << '\n';
    }

    fin.close();
    fout.close();
    return 0;
}
```

This solution performs a DFS-like traversal for each unvisited white square to calculate the height of lightning bolts, considering both vertical and diagonal connections to subsequent rows. It then returns the largest height found during the traversal, ensuring that each square is only visited once to prevent double-counting. The number of lightnings is incremented for each DFS call that starts from an unvisited white square.
