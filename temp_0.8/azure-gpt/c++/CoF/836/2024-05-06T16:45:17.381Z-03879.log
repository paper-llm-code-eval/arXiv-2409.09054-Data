---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `maxp.in` and write to `maxp.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Considerăm un șir de numere $a_1, a_2, \dots, a_N$. O secvență nevidă în acest șir este de forma $a_i, a_{i+1}, \dots, a_j$, unde $i \leq j$. De exemplu, pentru $N = 4$ și șirul $2 \ 3 \ 4 \ 3$, secvențele nevide sunt: $2, 2 \ 3, 2 \ 3 \ 4, 2 \ 3 \ 4 \ 3, 3, 3 \ 4, 3 \ 4 \ 3, 4, 4 \ 3, 3$. Definim puterea unui element $a_i$ ca fiind numărul de secvențe care-l conțin pe $a_i$ și în care $a_i$ este strict mai mare decât celelalte elemente ale fiecăreia dintre respectivele secvențe. Astfel în șirul $2 \ 3 \ 4 \ 3$ puterea elementului $a_1$ este $1$ (fiind maxim doar în secvența formată din el însuși), a elementului $a_2$ este $2$ ($a_2$ fiind maxim în secvențele $2 \ 3$ și $3$), a elementului $a_3$ este $6$ (fiind maxim în secvențele $2 \ 3 \ 4, 2 \ 3 \ 4 \ 3, 3 \ 4, 3 \ 4 \ 3, 4$ și $4 \ 3$), iar a elementului $a_4$ este $1$.

# Cerință

Scrieți un program care determină puterea cea mai mare a unui element din șirul dat, precum și numărul de elemente din șir care au cea mai mare putere.

# Date de intrare

Fișierul `maxp.in` conține pe prima linie numărul natural $N$, iar pe a doua linie, în ordine, numerele naturale $a_1, a_2, \dots, a_N$ separate prin câte un spațiu.

# Date de ieșire

Fișierul `maxp.out` va conține pe prima linie un număr natural ce reprezintă puterea cea mai mare a unui element din șirul dat și pe a doua linie va conține un număr natural ce reprezintă numărul de elemente din șir care au cea mai mare putere.

# Restricții și precizări

* $2 \leq N \leq 200 \ 000$;
* Elementele șirului sunt numere naturale și au cel mult $6$ cifre
* Se acordă 50% din punctaj pentru determinarea corectă a celei mai mari puteri a unui element din șir și 50% din punctaj pentru determinarea numărului de elemente din şir care au cea mai mare putere.

---

Example:
`maxp.in`
```
7
9 3 4 5 1 2 2
```

`maxp.out`
```
12
1
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```cpp
#include <fstream>
#include <vector>
#include <stack>

int main() {
    std::ifstream fin("maxp.in");
    std::ofstream fout("maxp.out");

    int N;
    fin >> N;
    std::vector<int> a(N);
    for (int i = 0; i < N; ++i) {
        fin >> a[i];
    }
    
    // Stacks to maintain the indices of the elements for which a[i] is the maximum
    std::stack<int> s_left, s_right;
    std::vector<long long> left(N, 0), right(N, 0);

    // Computing the number of subarrays for which a[i] is the maximum towards the left
    for (int i = 0; i < N; ++i) {
        while (!s_left.empty() && a[s_left.top()] < a[i]) {
            s_left.pop();
        }
        left[i] = (s_left.empty() ? i + 1 : i - s_left.top());
        s_left.push(i);
    }

    // Computing the number of subarrays for which a[i] is the maximum towards the right
    for (int i = N - 1; i >= 0; --i) {
        while (!s_right.empty() && a[s_right.top()] <= a[i]) {
            s_right.pop();
        }
        right[i] = (s_right.empty() ? N - i : s_right.top() - i);
        s_right.push(i);
    }
    
    long long max_power = 0, count = 0;
    
    // Find the maximum power and the count of elements with that power
    for (int i = 0; i < N; ++i) {
        long long power = left[i] * right[i];
        if (power > max_power) {
            max_power = power;
            count = 1;
        } else if (power == max_power) {
            count++;
        }
    }

    fout << max_power << '\n' << count << '\n';

    fin.close();
    fout.close();
    return 0;
}
```

This code computes the maximum power of an element in the array and the count of elements with that power in an efficient way by using stacks to calculate the number of subarrays extending to the left and right for each element. It reads from the file `maxp.in` and writes to the file `maxp.out` using file streams `std::ifstream` and `std::ofstream` respectively.
---------- user ----------


Program result did not match expected result.
Input data:
```
6
1 0 7 7 2 6
```
Expected output:
```
3
2
```
Found output:
```
12
1
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The discrepancy between the expected and the found output is due to an error in the algorithm. The original solution incorrectly calculates the number of subarrays where each element is the maximum. The problem lies in not considering the subarrays properly. Specifically, the original solution does not account for the case when there are equal adjacent elements, and as such, it overcounts the number of subarrays for which an element is the maximum.

To fix the bug, we must change the conditions within the while loops that pop elements off the stacks. For `s_left`, we should pop elements if `a[s_left.top()] <= a[i]` instead of `<`. For `s_right`, we should pop elements if `a[s_right.top()] < a[i]` instead of `<=`. This corrects the condition and accounts for the equal adjacent elements correctly.

Below is the revised solution:

```cpp
#include <fstream>
#include <vector>
#include <stack>

int main() {
    std::ifstream fin("maxp.in");
    std::ofstream fout("maxp.out");

    int N;
    fin >> N;
    std::vector<int> a(N);
    for (int i = 0; i < N; ++i) {
        fin >> a[i];
    }

    // Stacks to maintain the indices of the elements where a[i] is the maximum
    std::stack<int> s_left, s_right;
    std::vector<long long> left(N, 0), right(N, 0);

    // Computing the number of subarrays for which a[i] is the maximum towards the left
    for (int i = 0; i < N; ++i) {
        while (!s_left.empty() && a[s_left.top()] <= a[i]) {
            s_left.pop();
        }
        left[i] = (s_left.empty() ? i + 1 : i - s_left.top());
        s_left.push(i);
    }

    // Computing the number of subarrays for which a[i] is the maximum towards the right
    for (int i = N - 1; i >= 0; --i) {
        while (!s_right.empty() && a[s_right.top()] < a[i]) {
            s_right.pop();
        }
        right[i] = (s_right.empty() ? N - i : s_right.top() - i);
        s_right.push(i);
    }

    long long max_power = 0, count = 0;

    // Find the maximum power and the count of elements with that power
    for (int i = 0; i < N; ++i) {
        long long power = left[i] * right[i];
        if (power > max_power) {
            max_power = power;
            count = 1;
        } else if (power == max_power) {
            count++;
        }
    }

    fout << max_power << '\n' << count << '\n';

    fin.close();
    fout.close();
    return 0;
}
```

This revised solution should produce the correct output for the given input. The error in the original solution was related to the handling of equal adjacent elements when calculating the left and right contributions to the power of each element. The condition in the `while` loop was fixed for both left and right stacks to account for this correctly.
---------- user ----------


Program result did not match expected result.
Input data:
```
6
1 0 7 7 2 6
```
Expected output:
```
3
2
```
Found output:
```
12
1
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The discrepancy between the expected and found output indicates that the revised solution still contains a bug. The error is the same as before; the algorithm is incorrectly counting the number of subarrays where the element is the largest. The expected result indicates that there are two elements with the highest power of 3, but the algorithm is still not accounting for equal elements correctly.

To fix this bug, we should adjust the conditions while popping elements from the stacks to correctly handle equal adjacent elements. When computing left subarrays, we should exclude equal elements that appear to the left of the current element. When computing right subarrays, we should exclude equal elements that appear to the right of the current element.

Here's the corrected solution:

```cpp
#include <fstream>
#include <vector>
#include <stack>

int main() {
    std::ifstream fin("maxp.in");
    std::ofstream fout("maxp.out");

    int N;
    fin >> N;
    std::vector<int> a(N);
    for (int i = 0; i < N; ++i) {
        fin >> a[i];
    }

    // Stacks to maintain the indices of the elements for which a[i] is the maximum
    std::stack<int> s_left, s_right;
    std::vector<long long> count_left(N, 1), count_right(N, 1);

    // Computing the left count for each element
    for (int i = 0; i < N; ++i) {
        while (!s_left.empty() && a[s_left.top()] <= a[i]) {
            if (a[s_left.top()] == a[i]) {
                count_left[i] += count_left[s_left.top()];
            }
            s_left.pop();
        }
        s_left.push(i);
    }

    // Computing the right count for each element
    for (int i = N - 1; i >= 0; --i) {
        while (!s_right.empty() && a[s_right.top()] <= a[i]) {
            if (a[s_right.top()] == a[i]) {
                count_right[i] += count_right[s_right.top()];
            }
            s_right.pop();
        }
        s_right.push(i);
    }

    long long max_power = 0;
    long long count = 0;

    // Find the maximum power and the count of elements with that power
    for (int i = 0; i < N; ++i) {
        long long power = count_left[i] * count_right[i];
        if (a[i] > (i > 0 ? a[i - 1] : 0) && a[i] > (i < N - 1 ? a[i + 1] : 0)) {
            power--;
        }
        if (power > max_power) {
            max_power = power;
            count = 1;
        } else if (power == max_power) {
            count++;
        }
    }

    fout << max_power << '\n' << count << '\n';

    fin.close();
    fout.close();
    return 0;
}
```

This corrected solution maintains two additional vectors `count_left` and `count_right` to store the counts of how many times an element appears consecutively to the left and right, respectively. Elements are only counted in these vectors if they are equal to the current element, which properly handles the case of adjacent equal elements. When calculating the power, if an element is the same as its neighbor, it should not be counted twice, so we subtract one if it's the largest element in the sequence. This should yield the correct output and fix the discrepancy.
---------- user ----------


Program result did not match expected result.
Input data:
```
7
9 3 4 5 1 2 2
```
Expected output:
```
12
1
```
Found output:
```
2
2
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The discrepancy between the expected and found results indicates that the previous solutions have a bug that still does not correctly handle the constraints of the problem, particularly when dealing with consecutive equal elements.

Let's re-analyze the problem and re-implement the solution correctly:

1. We need to calculate the number of subarrays where each element `a[i]` is the maximum.
2. For each element, we want to count how many subarrays can be extended to the left and to the right before hitting an element greater than or equal to `a[i]`.

Here's the new implementation, fixing the logic by maintaining the correct indices stack for both left and right scans and calculating the power properly:

```cpp
#include <fstream>
#include <vector>
#include <stack>

int main() {
    std::ifstream fin("maxp.in");
    std::ofstream fout("maxp.out");

    int N;
    fin >> N;
    std::vector<int> a(N);
    for (int i = 0; i < N; ++i) {
        fin >> a[i];
    }

    std::vector<int> left(N, 0), right(N, 0);

    // Use stacks to find the next greater element to the left and right
    std::stack<int> s;
    for (int i = 0; i < N; ++i) {
        while (!s.empty() && a[s.top()] <= a[i]) {
            s.pop();
        }
        left[i] = s.empty() ? -1 : s.top();
        s.push(i);
    }

    while (!s.empty()) {
        s.pop();
    }

    for (int i = N - 1; i >= 0; --i) {
        while (!s.empty() && a[s.top()] < a[i]) {
            s.pop();
        }
        right[i] = s.empty() ? N : s.top();
        s.push(i);
    }

    long long max_power = 0;
    int count = 0;
    for (int i = 0; i < N; ++i) {
        // Calculate the power of a[i]
        long long power = (i - left[i]) * (right[i] - i);
        if (power > max_power) {
            max_power = power;
            count = 1;
        } else if (power == max_power) {
            ++count;
        }
    }

    fout << max_power << '\n' << count << '\n';

    fin.close();
    fout.close();
    return 0;
}
```

In this implementation, two stacks are maintained to find the next greater element for each index to the left and to the right. The `left` array stores the index of the next greater element to the left, and the `right` array stores the index of the next greater element to the right. If there is no such greater element, `-1` or `N` is stored for the left and right arrays, respectively. Using these indices, we compute the power of each element as the product of the number of subarrays extending to the left and right. We then find the maximum power and the count of elements with that power, which should produce the correct output.
---------- user ----------


Program result did not match expected result.
Input data:
```
6
1 0 7 7 2 6
```
Expected output:
```
3
2
```
Found output:
```
12
1
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

Let's carefully evaluate the issue in the previous solutions and revise the algorithm to match the expected output, accounting for the constraints of the problem.

To reiterate, we need to calculate the power of each element—defined as the number of subarrays where the element is the maximum—and then find the maximum power and the count of elements with that power. We need to consider that when there are two identical maximum elements in a row, they should not overcount each other's subarrays.

Here is the fixed solution:

```cpp
#include <fstream>
#include <vector>
#include <stack>

int main() {
    std::ifstream fin("maxp.in");
    std::ofstream fout("maxp.out");

    int N;
    fin >> N;
    std::vector<int> a(N);
    for (int i = 0; i < N; ++i) {
        fin >> a[i];
    }

    std::vector<long long> left(N, 1), right(N, 1);

    // Calculate left
    for (int i = 1; i < N; ++i) {
        int j = i - 1;
        while (j >= 0 && a[i] > a[j]) {
            left[i] += left[j];
            j -= left[j];
        }
    }

    // Calculate right
    for (int i = N - 2; i >= 0; --i) {
        int j = i + 1;
        while (j < N && a[i] >= a[j]) {
            right[i] += right[j];
            j += right[j];
        }
    }

    long long max_power = 0;
    int count = 0;

    // Find the maximum power and the count of elements with that power
    for (int i = 0; i < N; ++i) {
        long long power = left[i] * right[i];
        if (power > max_power) {
            max_power = power;
            count = 1;
        } else if (power == max_power) {
            count++;
        }
    }

    fout << max_power << '\n' << count << '\n';

    fin.close();
    fout.close();
    return 0;
}
```

In this solution, we use two vectors `left` and `right` to calculate how many subarrays each element can extend towards the left and right, where they remain the maximum value. When counting towards the left, we skip over elements less than the current one in a single jump using the pre-calculated left values. We do the same when counting towards the right, but we ensure that we skip over elements that are less than or equal to the current one, to prevent double-counting subarrays where two equal maximum elements exist. We then find the maximum power and the count of elements with that power to provide the expected output.
---------- user ----------


Program result did not match expected result.
Input data:
```
6
1 0 7 7 2 6
```
Expected output:
```
3
2
```
Found output:
```
12
1
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
