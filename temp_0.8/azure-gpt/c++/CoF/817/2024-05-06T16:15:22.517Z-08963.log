---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `elicop.in` and write to `elicop.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Un teren de fotbal este folosit pentru aterizarea elicopterelor. Gazonul de pe stadion este parcelat în pătrăţele de aceeaşi dimensiune, cu laturile paralele cu marginile terenului. Liniile cu pătrăţele de gazon sunt numerotate de sus în jos cu numerele $1, 2, \dots, m$, iar coloanele cu pătrăţele de gazon sunt numerotate de la stânga la dreapta cu numerele $1, 2, \dots, n$. Din cauza tipului diferit de iarbă se ştie care dintre pătrăţele de gazon sunt afectate sau nu de umbră. Acest lucru este precizat printr-un tablou bidimensional $a$ cu $m$ linii şi $n$ coloane, cu elemente $0$ şi $1$ ($a_{ij} = 0$ înseamnă că pătrăţelul aflat pe linia $i$ şi coloana $j$ este afectat de umbră, iar $a_{ij} = 1$ înseamnă că pătrăţelul aflat pe linia $i$ şi coloana $j$ nu este afectat de umbră). Fiecare elicopter are $3$ roţi pe care se sprijină. Roţile fiecărui elicopter determină un triunghi dreptunghic isoscel. Elicopterele aterizează, astfel încât triunghiurile formate să fie cu catetele paralele cu marginile terenului. În exemplul următor avem patru elicoptere.

~[elicop.png|width=30em]

Pentru a preciza poziţia unui elicopter pe teren este suficient să cunoaştem linia şi coloana vărfurilor ipotenuzei şi poziţia vârfului deasupra (codificată prin $1$) sau dedesubtul ipotenuzei (codificată prin $-1$). Pentru exemplu, elicopterul din stânga sus este dat prin $(1, 1), (3, 3)$ şi $-1$, cel din dreapta sus prin $(1, 9), (5, 5)$ şi $1$, cel din stânga jos prin $(5, 1), (6, 2)$ şi $1$, iar cel din dreapta jos prin $(5, 9), (6, 8)$ şi $1$.
Un elicopter se consideră că a aterizat *greşit*, dacă triunghiul format sub el (definit mai sus) are mai mult de jumătate din pătrăţele afectate de umbră.
Administratorul terenului de fotbal doreşte să determine numărul $N_1$ de elicoptere, care nu afectează nici un pătrăţel din teren şi numerele de ordine al elicopterelor, care au aterizat *greşit* în ordine crescătoare: $e_1, e_2, \dots, e_{N_2}$, ştiind că există $k$ elicoptere codificate prin numerele $1, 2, \dots, k$.

# Cerință

Scrieţi un program care să determine, pentru fişierul cu datele din enunţ: numărul de elicoptere $N_1$, care nu afectează nici un pătrăţel din teren şi numerele de ordine al elicopterelor, care au aterizat *greşit* în ordine crescătoare, precedate de numărul lor $N_2$.

# Date de intrare


Prima linie a fişierului de intrare `elicop.in` conţine două numere naturale $m$ şi $n$, separate printr-un spaţiu, cu semnificaţia din enunţ. Următoarele $m$ linii conţin câte $n$ numere $0$ sau $1$, separate prin câte un spaţiu cu semnificaţia $0$ – pătrăţel de gazon care este afectat de umbră, respectiv $1$ - pătrăţel care nu este afectat de umbră. Pe linia $m+2$ se află numărul de elicoptere $k$, iar pe următoarele $k$ linii (în ordinea codificării lor $1, 2, \dots, k$) câte cinci numere separate prin cate un spaţiu, pentru liniile şi coloanele ipotenuzelor şi poziţia vârfului ($1$ sau $-1$), triunghiurilor dreptunghice asociate elicopterelor: $L_1 \ C_1 \ L_2 \ C_2 \ p$.


# Date de ieșire


Fişierul de ieşire `elicop.out` va conţine două linii: prima linie numărul $N_1$ de elicoptere, pe care nu afectează nici un pătrăţel din teren, a doua linie cu numerele naturale $N_2, e_1, e_2, \dots, e_{N_2}$ separate prin câte un spaţiu, în ordine crescătoare.


# Restricții și precizări

* $2 \leq m, n \leq 100$
* $1 \leq k \leq 40$
* Nu există suprapuneri de triunghiuri asociate la două elicoptere.
* Triunghiurile asociate elicopterelor conţin cel puţin trei pătrăţele.
* Pentru determinarea corectă a valorilor $N_1$ se obţine $40$% din punctajul unui test, iar pentru determinarea corectă a valorilor $N_2, e_1, e_2, \dots, e_{N_2}$ se obţine $60$% din punctajul unui test.

---

Example:
`elicop.in`
```
7 9
1 1 1 1 1 1 1 1 1
0 0 0 0 1 1 1 1 0
0 0 1 0 1 1 1 0 0
1 1 1 0 1 1 0 1 1
0 0 1 1 1 1 0 1 1
1 1 1 1 1 1 0 1 1
1 1 1 1 1 1 0 0 1
4
1 1 3 3 -1
1 9 5 5 1
5 1 6 2 1
5 9 6 8 1
```

`elicop.out`
```
2
2 1 3
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```cpp
#include <fstream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    ifstream fin("elicop.in");
    ofstream fout("elicop.out");

    int m, n, k, l1, c1, l2, c2, p, ni = 0;
    fin >> m >> n;
    vector<vector<int>> grass(m + 1, vector<int>(n + 1));

    for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= n; ++j) {
            fin >> grass[i][j];
        }
    }

    fin >> k;
    vector<int> goodHelicopters;
    vector<int> wrongHelicopters;

    for (int heli = 1; heli <= k; ++heli) {
        fin >> l1 >> c1 >> l2 >> c2 >> p;
        int affected = 0, total = 0;
        if (p == -1) swap(l1, l2), swap(c1, c2);

        for (int i = l1; i <= l2; ++i) {
            for (int j = c1 - (i - l1); j <= c1 + (i - l1); ++j) {
                if (grass[i][j] == 0) affected++;
                total++;
            }
        }
        
        if (affected == 0) {
            ni++;
            goodHelicopters.push_back(heli);
        } else if (2 * affected > total) {
            wrongHelicopters.push_back(heli);
        }
    }

    fout << ni << '\n';
    fout << wrongHelicopters.size();
    for (int heli : wrongHelicopters) fout << ' ' << heli;
    fout << '\n';

    fin.close();
    fout.close();

    return 0;
}
```
---------- user ----------


Program result did not match expected result.
Input data:
```
7 9
1 1 1 1 1 1 1 1 1
0 0 0 0 1 1 1 1 0
0 0 1 0 1 1 1 0 0
1 1 1 0 1 1 0 1 1
0 0 1 1 1 1 0 1 1
1 1 1 1 1 1 0 1 1
1 1 1 1 1 1 0 0 1
4
1 1 3 3 -1
1 9 5 5 1
5 1 6 2 1
5 9 6 8 1
```
Expected output:
```
2
2 1 3
```
Found output:
```
2
0
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

After reevaluating the code, I identified a few issues:

1. The loop to calculate the affected and total squares in the triangle does not take into account the right direction and boundary conditions for triangles pointing downwards (when p == -1).
2. The `goodHelicopters` vector is being populated but never used, which is unnecessary as we only need to count helicopters that affect no grass squares.
3. The direction of triangles (up or down) is not correctly handled after swapping l1 and l2, c1 and c2 when p == -1.

I will fix these issues in the code block below:

```cpp
#include <fstream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    ifstream fin("elicop.in");
    ofstream fout("elicop.out");

    int m, n, k, l1, c1, l2, c2, p;
    fin >> m >> n;
    vector<vector<int>> grass(m + 1, vector<int>(n + 1));

    for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= n; ++j) {
            fin >> grass[i][j];
        }
    }

    fin >> k;
    int ni = 0;
    vector<int> wrongHelicopters;

    for (int heli = 1; heli <= k; ++heli) {
        fin >> l1 >> c1 >> l2 >> c2 >> p;
        int affected = 0, total = 0;
        int start_col, end_col;

        for (int i = l1; p == 1 ? i <= l2 : i >= l2; p == 1 ? ++i : --i) {
            start_col = p == 1 ? (c1 - (i - l1)) : (c1 + (i - l1));
            end_col = p == 1 ? (c1 + (i - l1)) : (c1 - (i - l1));
            
            for (int j = start_col; j <= end_col; ++j) {
                if (grass[i][j] == 0) affected++;
                total++;
            }
        }

        if (affected == 0) {
            ni++;
        } else if (2 * affected > total) {
            wrongHelicopters.push_back(heli);
        }
    }

    fout << ni << '\n';
    fout << wrongHelicopters.size();
    for (int heli : wrongHelicopters) fout << ' ' << heli;
    fout << '\n';

    fin.close();
    fout.close();

    return 0;
}
```

This corrected version now correctly handles the direction of triangles, and thus should provide the expected output. The unnecessary `goodHelicopters` vector has been removed, and the logic for processing the input and output has been adjusted to reflect the problem statement accurately.
---------- user ----------


Program result did not match expected result.
Input data:
```
7 9
1 1 1 1 1 1 1 1 1
0 0 0 0 1 1 1 1 0
0 0 1 0 1 1 1 0 0
1 1 1 0 1 1 0 1 1
0 0 1 1 1 1 0 1 1
1 1 1 1 1 1 0 1 1
1 1 1 1 1 1 0 0 1
4
1 1 3 3 -1
1 9 5 5 1
5 1 6 2 1
5 9 6 8 1
```
Expected output:
```
2
2 1 3
```
Found output:
```
2
0
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

Upon reviewing the code again, it seems that the error is in the way the boundaries of the triangle are being calculated. The corrected loop should iterate over the rows of the triangle and then calculate the correct start and end columns for each row, which differ depending on whether the triangle points upwards or downwards (determined by the value of `p`).

Let's fix this by rewriting the code to properly handle the triangles:

```cpp
#include <fstream>
#include <vector>

using namespace std;

int main() {
    ifstream fin("elicop.in");
    ofstream fout("elicop.out");

    int m, n, k;
    fin >> m >> n;
    vector<vector<int>> grass(m + 1, vector<int>(n + 1));

    // Read the grass matrix
    for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= n; ++j) {
            fin >> grass[i][j];
        }
    }

    fin >> k;
    int ni = 0; // Count of helicopters that do not affect any grass squares
    vector<int> wrongHelicopters; // Vector to store the indices of wrongly landed helicopters

    for (int heli = 1; heli <= k; ++heli) {
        int l1, c1, l2, c2, p;
        fin >> l1 >> c1 >> l2 >> c2 >> p;
        int affected = 0, total = 0;

        if (p == 1) {
            // Triangle pointing upwards
            for (int row = l1; row <= l2; ++row) {
                for (int col = c1 - (row - l1); col <= c1 + (row - l1); ++col) {
                    if (grass[row][col] == 0) affected++;
                    total++;
                }
            }
        } else {
            // Triangle pointing downwards
            for (int row = l1; row >= l2; --row) {
                for (int col = c1 - (l1 - row); col <= c1 + (l1 - row); ++col) {
                    if (grass[row][col] == 0) affected++;
                    total++;
                }
            }
        }

        if (affected == 0) {
            ni++;
        } else if (2 * affected > total) {
            wrongHelicopters.push_back(heli);
        }
    }

    // Output the results to the file
    fout << ni << '\n'; // The count of helicopters that do not affect any grass squares
    fout << wrongHelicopters.size(); // The count of helicopters that landed wrongly
    for (int heli : wrongHelicopters) {
        fout << ' ' << heli; // The indices of wrongly landed helicopters
    }
    fout << '\n';

    fin.close();
    fout.close();

    return 0;
}
```

This code should now correctly calculate the affected squares for triangles pointing in both directions and provide the correct output. The list of helicopters that do not affect any grass squares is now correctly counted, and the indices of wrongly landed helicopters are stored and output in increasing order.
---------- user ----------


Program result did not match expected result.
Input data:
```
7 9
1 1 1 1 1 1 1 1 1
0 0 0 0 1 1 1 1 0
0 0 1 0 1 1 1 0 0
1 1 1 0 1 1 0 1 1
0 0 1 1 1 1 0 1 1
1 1 1 1 1 1 0 1 1
1 1 1 1 1 1 0 0 1
4
1 1 3 3 -1
1 9 5 5 1
5 1 6 2 1
5 9 6 8 1
```
Expected output:
```
2
2 1 3
```
Found output:
```
2
0
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

It seems that my previous solution did not correctly handle the checking of affected squares within the triangle. I'll need to rewrite the code to accurately compute the affected squares considering the direction of the helicopter's triangle and correct any logical errors in the previous attempt.

Here is the rewritten solution:

```cpp
#include <fstream>
#include <vector>

using namespace std;

int main() {
    ifstream fin("elicop.in");
    ofstream fout("elicop.out");

    int m, n;
    fin >> m >> n;
    vector<vector<int>> grid(m + 1, vector<int>(n + 1));
    vector<int> wrong_helicopters;
    int unaffected_helicopters = 0;

    // Read the grass matrix
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            fin >> grid[i][j];
        }
    }

    int k;
    fin >> k;

    for (int heli = 1; heli <= k; heli++) {
        int l1, c1, l2, c2, pos;
        fin >> l1 >> c1 >> l2 >> c2 >> pos;

        // Determine the direction of the triangle
        int start_row = (pos == -1) ? l2 : l1;
        int end_row = (pos == -1) ? l1 : l2;
        int col_offset = (pos == -1) ? -1 : 1;
        int affected = 0, total = 0;

        for (int row = start_row; pos == -1 ? row <= end_row : row >= end_row; row += col_offset) {
            int col_start = c1 - abs(row - l1);
            int col_end = c1 + abs(row - l1);
            for (int col = col_start; col <= col_end; col++) {
                affected += (grid[row][col] == 0) ? 1 : 0;
                total++;
            }
        }

        // Check if the helicopter has landed incorrectly
        if (affected == 0) {
            unaffected_helicopters++;
        } else if (affected > total / 2) {
            wrong_helicopters.push_back(heli);
        }
    }

    // Output the counts and indices
    fout << unaffected_helicopters << '\n' << wrong_helicopters.size();
    for (int index : wrong_helicopters) {
        fout << ' ' << index;
    }
    fout << '\n';

    fin.close();
    fout.close();

    return 0;
}
```

This corrected solution keeps track of the starting and ending rows of the triangle based on whether the triangle points upwards or downwards. For each row within the triangle, I compute the starting and ending columns to iterate through and count affected squares. The helicopter is considered to have landed incorrectly if more than half of the squares in the triangle are affected. The counts of unaffected and wrongly landed helicopters are then written to the output file.
---------- user ----------


Program result did not match expected result.
Input data:
```
7 9
1 1 1 1 1 1 1 1 1
0 0 0 0 1 1 1 1 0
0 0 1 0 1 1 1 0 0
1 1 1 0 1 1 0 1 1
0 0 1 1 1 1 0 1 1
1 1 1 1 1 1 0 1 1
1 1 1 1 1 1 0 0 1
4
1 1 3 3 -1
1 9 5 5 1
5 1 6 2 1
5 9 6 8 1
```
Expected output:
```
2
2 1 3
```
Found output:
```
4
0
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

It appears that the previous solutions have not handled the triangles' directions and the calculation of affected squares correctly. To solve this, we need to ensure that we correctly identify the cells affected by shadows for both upward and downward pointing triangles, as well as correctly count helicopters that do not affect any grass squares.

Here is the corrected solution:

```cpp
#include <fstream>
#include <vector>

using namespace std;

int main() {
    ifstream fin("elicop.in");
    ofstream fout("elicop.out");

    int m, n, k;
    fin >> m >> n;
    vector<vector<int>> field(m+1, vector<int>(n+1, 0));
    vector<int> wrong_helicopters;

    // Reading the field
    for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= n; ++j) {
            fin >> field[i][j];
        }
    }

    fin >> k;
    int unaffected_count = 0;

    for (int heli = 1; heli <= k; ++heli) {
        int l1, c1, l2, c2, p, affected = 0, total = 0;
        fin >> l1 >> c1 >> l2 >> c2 >> p;

        // Normalize the coordinates to always start from the top point of triangle
        if (p == -1) {
            swap(l1, l2);
            swap(c1, c2);
        }
        
        // Calculate the area of the triangle and check the number of affected squares
        for (int i = 0; i <= l2 - l1; ++i) {
            for (int j = c1 - i; j <= c1 + i; ++j) {
                affected += (field[l1 + i][j] == 0);
                total++;
            }
        }

        // Check if the helicopter is unaffected or wrong positioned
        if (affected == 0) {
            unaffected_count++;
        } else if (affected * 2 > total) {
            wrong_helicopters.push_back(heli);
        }
    }

    // Write the results to the output file
    fout << unaffected_count << "\n" << wrong_helicopters.size();
    for (int heli : wrong_helicopters) {
        fout << " " << heli;
    }
    fout << "\n";

    fin.close();
    fout.close();

    return 0;
}
```

This revised solution makes sure to normalize the triangle coordinates so that the loop always starts from the top of the triangle and moves downward. It calculates the total and affected squares for each helicopter's landing area and then decides if a helicopter is unaffected or wrongly positioned. The results are then written to the output file as specified. This solution should now provide the expected output.
---------- user ----------


Program result did not match expected result.
Input data:
```
7 9
1 1 1 1 1 1 1 1 1
0 0 0 0 1 1 1 1 0
0 0 1 0 1 1 1 0 0
1 1 1 0 1 1 0 1 1
0 0 1 1 1 1 0 1 1
1 1 1 1 1 1 0 1 1
1 1 1 1 1 1 0 0 1
4
1 1 3 3 -1
1 9 5 5 1
5 1 6 2 1
5 9 6 8 1
```
Expected output:
```
2
2 1 3
```
Found output:
```
2
0
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The previous solutions failed to correctly determine the helicopters that landed wrongly. The logic used to calculate the affected and total squares in the triangles is incorrect and does not take into account the proper orientation of the triangles. Let's implement this correctly:

- We should iterate over each row in the triangle, starting from the row of the right-angle vertex (l1 or l2, depending on p) and moving towards the hypotenuse.
- For each row, we calculate the range of columns that are part of the triangle.
- We count the number of squares affected by the shadow (where `grass[i][j] == 0`).
- Then, we determine if a helicopter landed wrongly by checking if more than half of the squares in its triangle are affected.

Let's now rewrite the solution, ensuring that we properly account for the direction of the triangle and the affected squares:

```cpp
#include <fstream>
#include <vector>

std::ifstream fin("elicop.in");
std::ofstream fout("elicop.out");

int main() {
    int m, n;
    fin >> m >> n;
    std::vector<std::vector<int>> grass(m + 1, std::vector<int>(n + 1));

    // Read grass matrix
    for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= n; ++j) {
            fin >> grass[i][j];
        }
    }

    int k;
    fin >> k;
    int unaffected_helicopters = 0;
    std::vector<int> wrong_helicopters;

    for (int heli = 1; heli <= k; ++heli) {
        int l1, c1, l2, c2, pos;
        fin >> l1 >> c1 >> l2 >> c2 >> pos;

        // Normalize coordinates for unified logic (triangle pointing upwards)
        if (pos == -1) {
            std::swap(l1, l2);
            std::swap(c1, c2);
        }

        int affected = 0, total = 0, row_length;
        for (int row = l1; row <= l2; ++row) {
            // Calculate the length of the current row in the triangle
            row_length = (row - l1) * 2 + 1;
            total += row_length;
            for (int col = c1 - (row - l1); col <= c1 + (row - l1); ++col) {
                // Count the affected squares
                if (grass[row][col] == 0) ++affected;
            }
        }

        // Unaffected helicopters
        if (affected == 0) ++unaffected_helicopters;

        // Helicopters landed wrongly if more than half of the squares in the triangle are affected
        if (affected * 2 > total) wrong_helicopters.push_back(heli);
    }

    // Write output
    fout << unaffected_helicopters << '\n';
    fout << wrong_helicopters.size();
    for (int heli : wrong_helicopters) {
        fout << ' ' << heli;
    }
    fout << '\n';

    return 0;
}
```

This code should now correctly identify helicopters that have landed without affecting any grass squares and those that have landed wrongly (with more than half of the squares in their triangle being affected). The results are then written to the output file, as required by the problem statement.
---------- user ----------


Program result did not match expected result.
Input data:
```
7 9
1 1 1 1 1 1 1 1 1
0 0 0 0 1 1 1 1 0
0 0 1 0 1 1 1 0 0
1 1 1 0 1 1 0 1 1
0 0 1 1 1 1 0 1 1
1 1 1 1 1 1 0 1 1
1 1 1 1 1 1 0 0 1
4
1 1 3 3 -1
1 9 5 5 1
5 1 6 2 1
5 9 6 8 1
```
Expected output:
```
2
2 1 3
```
Found output:
```
2
0
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

Reviewing the problem statement and the code, I can see that I overlooked an essential detail: the boundary checks for the matrix indices. In the current solution, when the code iterates over the positions of the triangles, it does not account for the possibility that these positions might be out of the bounds of the grass matrix. This could lead to accessing elements out of range and thus considering unaffected squares as affected or vice versa.

To fix this, we need to add boundary checks to ensure that we only count squares that are within the bounds of the grass matrix. I will rewrite the solution with these necessary checks:

```cpp
#include <fstream>
#include <vector>

int main() {
    std::ifstream fin("elicop.in");
    std::ofstream fout("elicop.out");

    int m, n, k;
    fin >> m >> n;
    std::vector<std::vector<int>> grass(m + 1, std::vector<int>(n + 1, 0));

    // Read the grass matrix
    for (int i = 1; i <= m; ++i)
        for (int j = 1; j <= n; ++j)
            fin >> grass[i][j];

    fin >> k;
    int unaffected_helicopters = 0;
    std::vector<int> wrong_helicopters;

    for (int heli = 1; heli <= k; ++heli) {
        int l1, c1, l2, c2, p, affected = 0, total = 0;
        fin >> l1 >> c1 >> l2 >> c2 >> p;

        // Normalize coordinates for a unified logic (triangle pointing upwards)
        if (p == -1) {
            swap(l1, l2);
            swap(c1, c2);
        }

        // Calculate the area of the triangle and check the number of affected squares
        for (int row = l1, length = 1; row <= l2; row++, length += 2) {
            for (int col = c1 - (row - l1), count = 0; count < length; col++, count++) {
                // Check if within bounds
                if (col >= 1 && col <= n && row >= 1 && row <= m) {
                    affected += (grass[row][col] == 0);
                    total++;
                }
            }
        }

        // Determine whether the helicopter has landed incorrectly or not
        if (total > 0 && affected == 0) {
            unaffected_helicopters++;
        } else if (2 * affected > total) {
            wrong_helicopters.push_back(heli);
        }
    }

    // Write the output
    fout << unaffected_helicopters << '\n';
    fout << wrong_helicopters.size();
    for (int heli : wrong_helicopters) {
        fout << ' ' << heli;
    }
    fout << '\n';

    fin.close();
    fout.close();

    return 0;
}
```

This solution adds boundary checks for the column and row indices to ensure we only count squares within the bounds of the grass matrix, thus avoiding out-of-range errors. The unaffected helicopter count is only incremented if the total number of squares checked in the triangle is greater than 0 and if no affected squares are found. Helicopters that have landed incorrectly are added to the list if more than half their triangle's squares are affected.
