---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `primprim.in` and write to `primprim.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Pentru un număr natural `a` definim *costul* ca fiind valoarea absolută (modulul) diferenței dintre `a` și numărul prim cel mai apropiat de `a`. Asupra unui șir de $n$ numere naturale, situate pe poziții numerotate de la $1$ la $n$, se aplică, în ordine, o succesiune de $q$ operații. O operație constă dintr-o înlocuire și o afișare și este descrisă sub forma `i x p`, cu semnificația:
* mai întâi înlocuim cu $x$ elementul din șir de pe poziția $i$;
* apoi afișăm suma minimă totală a costurilor unor elemente convenabil selectate de pe $p$ poziții distincte din șir.

# Cerință

Cunoscând $n$ și cele $n$ elemente ale șirului, scrieți un program care să determine:
1. suma costurilor tuturor elementelor din șirul dat;
2. rezultatele afișate în urma aplicării fiecăreia dintre cele $q$ operații, date în forma precizată.

# Date de intrare

Fișierul de intrare `primprim.in` va conține pe prima linie un număr natural $C$, reprezentând cerința care trebuie să fie rezolvată ($1$ sau $2$), pe a doua linie numărul natural $n$, cu semnificația din enunț, iar pe a treia linie cele $n$ elemente din șir, în ordinea din șir. 
Dacă $C = 2$, pe a patra linie se află numărul natural $q$, reprezentând numărul de operații, iar pe următoarele $q$ linii se află cele $q$ operații, câte o operație pe linie, în forma descrisă în enunț. Numerele scrise pe aceeași linie sunt separate prin câte un spațiu.

# Date de ieșire
Dacă $C = 1$, fișierul de ieșire `primprim.out` va conține o singură linie pe care va fi afișată suma costurilor tuturor elementelor din șir. 
Dacă $C = 2$, fișierul de ieșire `primprim.out` va conține $q$ linii, pe linia $i$ fiind scris rezultatul afișat după executarea celei de a $i$-a operații din fișierul de intrare.

# Restricții și precizări
* $1 \leq q \leq 2 * 10^5$;
* $1 \leq i,p \leq n \leq 10^6$; $1 \leq x \leq 10^6$;
* Elementele șirului sunt numere naturale nenule $\leq 10^6$;
* Pentru $20$ de puncte, $C = 1$, $n = 1$;
* Pentru $22$ de puncte, $C = 1$, $1 \lt n \leq 1 \ 000$;
* Pentru $28$ de puncte, $C = 2$, $n \leq 1 \ 000$, $q \leq 10$;
* Pentru $30$ de puncte, $C = 2$ și nu există restricții suplimentare.

---

Example:
`primprim.in`
```
1
5
8 1 3 5 9
```

`primprim.out`
```
4
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```cpp
#include <fstream>
#include <vector>
#include <algorithm>
#include <cmath>

using namespace std;

const int MAX_VAL = 1000000;
int prime[MAX_VAL + 1];
vector<int> primes;

void sieve() {
    for (int i = 2; i <= MAX_VAL; ++i) prime[i] = 1;
    for (int i = 2; i * i <= MAX_VAL; ++i)
        if (prime[i])
            for (int j = i * i; j <= MAX_VAL; j += i)
                prime[j] = 0;
    for (int i = 2; i <= MAX_VAL; ++i)
        if (prime[i])
            primes.push_back(i);
}

int nearestPrimeCost(int a) {
    if (prime[a]) return 0;
    auto lb = lower_bound(primes.begin(), primes.end(), a);
    int cost = INT_MAX;
    if (lb != primes.end()) cost = *lb - a;
    if (lb != primes.begin()) cost = min(cost, a - *prev(lb));
    return cost;
}

int main() {
    ifstream fin("primprim.in");
    ofstream fout("primprim.out");
    int C, n;
    fin >> C >> n;
    vector<int> sequence(n), cost(n);
    for (int i = 0; i < n; ++i) {
        fin >> sequence[i];
    }
    sieve();

    if (C == 1) {
        int total_cost = 0;
        for (int i = 0; i < n; ++i) {
            total_cost += nearestPrimeCost(sequence[i]);
        }
        fout << total_cost << '\n';
    } else {
        int q;
        fin >> q;
        while (q--) {
            int i, x, p;
            fin >> i >> x >> p;
            --i; // Convert to 0-based index
            sequence[i] = x;
            vector<int> costs;
            for (int j = 0; j < n; ++j) {
                costs.push_back(nearestPrimeCost(sequence[j]));
            }
            nth_element(costs.begin(), costs.begin() + p, costs.end());
            int sum = 0;
            for (int j = 0; j < p; ++j) {
                sum += costs[j];
            }
            fout << sum << '\n';
        }
    }

    fin.close();
    fout.close();
    return 0;
}
```
This C++ solution implements the sieve of Eratosthenes to find all the prime numbers up to `MAX_VAL`, which is 1,000,000. It then calculates the cost of each number by finding the nearest prime using binary search on the precomputed prime numbers vector. If the task `C` is `1`, it calculates and outputs the total cost of the entire sequence. If `C` is `2`, it processes each query by replacing an element in the sequence, recalculating the costs, and outputting the sum of the minimum total costs of `p` distinct elements selected from the sequence. The code doesn't use `cin`, `cout`, `printf`, or `scanf` and reads/writes directly from/to files using `ifstream` and `ofstream`.
---------- user ----------


Failed to compile the program.
```
main.cpp: In function 'int nearestPrimeCost(int)':
main.cpp:26:16: error: 'INT_MAX' was not declared in this scope
   26 |     int cost = INT_MAX;
      |                ^~~~~~~
main.cpp:5:1: note: 'INT_MAX' is defined in header '<climits>'; did you forget to '#include <climits>'?
    4 | #include <cmath>
  +++ |+#include <climits>
    5 | 

```

Evaluate the error message. Think of a solution to fix the program and return the entire source code with the fix.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The error message indicates that the `INT_MAX` constant was not declared in the scope, which is indeed the case because the `<climits>` header file where `INT_MAX` is defined was not included. I will include the necessary header file and rewrite the entire source code with the fix:

```cpp
#include <fstream>
#include <vector>
#include <algorithm>
#include <climits>
#include <cmath>

using namespace std;

const int MAX_VAL = 1000000;
int prime[MAX_VAL + 1];
vector<int> primes;

void sieve() {
    for (int i = 2; i <= MAX_VAL; ++i) prime[i] = 1;
    for (int i = 2; i * i <= MAX_VAL; ++i)
        if (prime[i])
            for (int j = i * i; j <= MAX_VAL; j += i)
                prime[j] = 0;
    for (int i = 2; i <= MAX_VAL; ++i)
        if (prime[i])
            primes.push_back(i);
}

int nearestPrimeCost(int a) {
    if (prime[a]) return 0;
    auto lb = lower_bound(primes.begin(), primes.end(), a);
    int cost = INT_MAX;
    if (lb != primes.end()) cost = *lb - a;
    if (lb != primes.begin()) cost = min(cost, a - *prev(lb));
    return cost;
}

int main() {
    ifstream fin("primprim.in");
    ofstream fout("primprim.out");
    int C, n;
    fin >> C >> n;
    vector<int> sequence(n), cost(n);
    for (int i = 0; i < n; ++i) {
        fin >> sequence[i];
    }
    sieve();

    if (C == 1) {
        int total_cost = 0;
        for (int i = 0; i < n; ++i) {
            total_cost += nearestPrimeCost(sequence[i]);
        }
        fout << total_cost << '\n';
    } else {
        int q;
        fin >> q;
        while (q--) {
            int i, x, p;
            fin >> i >> x >> p;
            --i; // Convert to 0-based index
            sequence[i] = x;
            vector<int> costs;
            for (int j = 0; j < n; ++j) {
                costs.push_back(nearestPrimeCost(sequence[j]));
            }
            nth_element(costs.begin(), costs.begin() + p - 1, costs.end());
            int sum = 0;
            for (int j = 0; j < p; ++j) {
                sum += costs[j];
            }
            fout << sum << '\n';
        }
    }

    fin.close();
    fout.close();
    return 0;
}
```

This updated program includes the `<climits>` header file, which declares the `INT_MAX` constant. The program should now compile and run correctly.
