---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `stdin` and write to `stdout`.
The solution must use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

~[polihroniade.png|align=right]

O matrice pătratică de dimensiuni `N × N` cu `N` par și elemente din mulțimea `{0, 1}` se numește **tablă de șah** dacă oricare două celule vecine pe o linie sau pe o coloană au valori diferite (cu alte cuvinte, dacă nu există două valori egale alăturate).

De ziua ei, Victor i-a cumpărat Elisabetei o astfel de matrice `A`, care nu este *neapărat* tablă de șah. Aflând despre pasiunea ei, acesta vrea acum să transforme matricea `A` într-o tablă de șah. Timpul fiind limitat, el poate efectua doar următoarele tipuri de operații asupra matricii:

- Interschimbă liniile `i` și `j` din `A` (celelalte linii rămân neschimbate, iar valorile din interiorul liniilor `i` și `j` rămân neschimbate și își păstrează ordinea). Operația are sens pentru `1 ≤ i, j ≤ N`.
- Interschimbă coloanele `i` și `j` din `A` (celelalte coloane rămân neschimbate, iar valorile din interiorul coloanelor `i` și `j` rămân neschimbate și își păstrează ordinea). Operația are sens pentru `1 ≤ i, j ≤ N`.

Dorind să o impresioneze pe Elisabeta, Victor apelează la voi, programatori renumiți, să îl ajutați în a transforma matricea `A` într-o tablă de șah. Pentru aceasta, Victor are nevoie de următoarele informații:
- Poate fi transformată matricea `A` în tablă de șah?
- Care este numărul minim de operații necesare pentru a duce la îndeplinire acest scop?
- Care ar fi o succesiune de operații care transformă matricea `A` într-o tablă de șah?

În cazul ultimei cerințe, pentru a intra în grațiile lui Victor va trebui ca numărul de operații efectuate să fie minim. Totuși, chiar și un număr neminim de operații va fi răsplătit, însă nu într-atât de mult.

Vi se dau două numere `P, T` și `T` matrici `A`, reprezentând mai multe instanțe ale problemei. Pentru fiecare matrice `A` dintre cele `T` va trebui să rezolvați cerința cu numărul `P ∈ {1, 2, 3}` dintre cele listate mai sus.

# Date de intrare
Pe prima linie se găsesc două numere întregi pozitive `P` și `T`, reprezentând numarul cerinței de rezolvat și, respectiv, numărul de scenarii pentru care va trebui să rezolvați problema.
Urmează cele `T` instanțe ale problemei, fiecare fiind compusă din `N + 1` linii: pe prima linie se va afla numărul `N`, iar pe următoarele `N` linii câte `N` cifre binare **neseparate** prin spații, reprezentând câte o linie a matricii `A`.

# Date de ieșire
Pentru fiecare dintre cele `T` instanțe se va afișa răspunsul, începând de la o linie nouă, după cum urmează:

1. Dacă `P = 1`, atunci se va afișa pe o singură linie `1` dacă matricea `A` poate fi transformată în tablă de șah, și `0` altfel.
2. Dacă `P = 2`, atunci se va afișa pe o singură linie un întreg reprezentând numărul minim de interschimbări de linii și/sau coloane necesare pentru a transforma matricea `A` în tablă de șah.
3. Dacă `P = 3`, atunci se va afișa pe o linie un număr `X`. Apoi, pe fiecare dintre următoarele `X` linii se va afișa câte o interschimbare de linii sau coloane, după următorul format: `L i j` are semnificația că liniile `i` și `j` se interschimbă, iar `C i j` are semnificația că coloanele `i` și `j` se interschimbă. Matricea obținută după aplicarea celor `X` operații asupra lui `A` în ordinea dată trebuie să fie o tablă de șah.

# Restricții și precizări
* `1 ≤ T ≤ 350`
* `1 ≤ N ≤ 1 000`
* `N` este par.
* Pentru cerințele de tip `P = 2` și `P = 3` se garantează că matricea `A` poate fi transformată în tablă de șah folosind interschimbări de linii și/sau coloane.
* Suma valorilor `N` pentru cele `T` scenarii nu depășește `2 000`.

## Pentru 40 de puncte
* `P = 1`
## Pentru alte 34 de puncte
* `P = 2`
## Pentru alte 26 de puncte
* `P = 3`
* Dacă există mai multe soluții, oricare este considerată corectă.
* Dacă numărul `X` de operații folosite nu este minim, atunci se acordă `50%` din punctajul pe test.

---

Example:
`stdin`
```
1 3
2
11
11
4
1100
1100
0011
0011
2
10
01
```

`stdout`
```
0
1
1
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// Function to check if the matrix can be transformed into a chessboard
bool canBeChessboard(vector<vector<int>> &A) {
    int N = A.size();
    for (int i = 0; i < N; ++i) {
        for (int j = 0; j < N; ++j) {
            if (A[i][j] == A[(i+1)%N][j] || A[i][j] == A[i][(j+1)%N]) {
                return false;
            }
        }
    }
    return true;
}

// Function to count swaps required to transform the matrix into a chessboard
int countSwapsToChessboard(vector<vector<int>> &A) {
    int N = A.size();
    int rowSwap = 0, colSwap = 0;

    // Reference patterns for rows and columns
    vector<int> refRow(N), refCol(N);
    for (int i = 0; i < N; ++i) {
        refRow[i] = i % 2;
        refCol[i] = (i % 2) ^ 1;
    }

    // Count misplaced rows and columns
    vector<int> misplacedRows, misplacedCols;
    for (int i = 0; i < N; ++i) {
        if (A[i] != refRow && A[i] != refCol) misplacedRows.push_back(i);
        int col = 0, ref = refRow[i];
        for (int j = 0; j < N; ++j) {
            if (A[j][i] != ref) ++col;
            ref ^= 1;
        }
        if (col != 0 && col != N) misplacedCols.push_back(i);
    }

    // Count swaps required
    rowSwap += misplacedRows.size() / 2;
    colSwap += misplacedCols.size() / 2;

    return rowSwap + colSwap;
}

// Function to generate swaps to transform the matrix into a chessboard
vector<pair<char, pair<int, int>>> generateSwaps(vector<vector<int>> &A) {
    int N = A.size();
    vector<int> rowPermutation(N), colPermutation(N);
    iota(rowPermutation.begin(), rowPermutation.end(), 0);
    iota(colPermutation.begin(), colPermutation.end(), 0);

    // Find the correct permutation of rows and columns
    for (int i = 0; i < N; ++i) {
        for (int j = i + 1; j < N; ++j) {
            if ((A[i][0] == A[j][0] && i % 2 != j % 2) || (A[i][0] != A[j][0] && i % 2 == j % 2)) {
                swap(A[i], A[j]);
                swap(rowPermutation[i], rowPermutation[j]);
            }
            if ((A[0][i] == A[0][j] && i % 2 != j % 2) || (A[0][i] != A[0][j] && i % 2 == j % 2)) {
                for (int k = 0; k < N; ++k) swap(A[k][i], A[k][j]);
                swap(colPermutation[i], colPermutation[j]);
            }
        }
    }

    // Generate the list of swaps
    vector<pair<char, pair<int, int>>> swaps;
    for (int i = 0; i < N; ++i) {
        if (rowPermutation[i] != i) {
            swaps.push_back({'L', {i + 1, rowPermutation[i] + 1}});
        }
        if (colPermutation[i] != i) {
            swaps.push_back({'C', {i + 1, colPermutation[i] + 1}});
        }
    }

    return swaps;
}

int main() {
    int P, T;
    cin >> P >> T;

    while (T--) {
        int N;
        cin >> N;
        vector<vector<int>> A(N, vector<int>(N));

        for (int i = 0; i < N; ++i) {
            for (int j = 0; j < N; ++j) {
                char c;
                cin >> c;
                A[i][j] = c - '0';
            }
        }

        if (P == 1) {
            cout << (canBeChessboard(A) ? 1 : 0) << '\n';
        } else if (P == 2) {
            cout << countSwapsToChessboard(A) << '\n';
        } else if (P == 3) {
            vector<pair<char, pair<int, int>>> swaps = generateSwaps(A);
            cout << swaps.size() << '\n';
            for (auto &swap : swaps) {
                cout << swap.first << ' ' << swap.second.first << ' ' << swap.second.second << '\n';
            }
        }
    }

    return 0;
}
```

This code snippet is a C++ solution that should efficiently handle the given problem. It contains three functions, one for each part of the challenge: checking if the matrix can be transformed into a chessboard (P = 1), counting the minimum number of swaps needed (P = 2), and generating the sequence of swaps to achieve a chessboard (P = 3). The main function reads the input, determines which part of the problem to solve, and prints the results accordingly.
---------- user ----------


Failed to compile the program.
```
main.cpp: In function 'std::vector<std::pair<char, std::pair<int, int> > > generateSwaps(std::vector<std::vector<int> >&)':
main.cpp:55:5: error: 'iota' was not declared in this scope
   55 |     iota(rowPermutation.begin(), rowPermutation.end(), 0);
      |     ^~~~

```

Evaluate the error message. Think of a solution to fix the program and return the entire source code with the fix.

---

Rewrite the entire solution applying necessary fixes.
