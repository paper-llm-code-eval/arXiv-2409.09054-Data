---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `vase.in` and write to `vase.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

~[0.jpg|align=right|width=12em]

Specialiştii chimişti au reuşit crearea în laborator a unei game diversificate de substanţe lichide nemiscibile (care nu se amestecă între ele), de aceeaşi densitate şi de culori diferite.

Acest rezultat a fost utilizat de către specialiştii fizicieni pentru studiul principiului vaselor comunicante. Conform acestui principiu „*într-un sistem de vase comunicante nivelul lichidului este acelaşi, indiferent de forma vaselor*”.

\
Experimentele fizicienilor se desfăşoară astfel:

Într-un sistem cu **două** vase comunicante, gradat identic pe fiecare ramură cu $0$, $1$, $2$, $3$, $\dots$, fizicienii introduc un număr de $n$ lichide, pe ramura din stânga sau pe ramura din dreapta. Volumele introduse din fiecare lichid, notate cu $V_i$ ($1 \leq i \leq n$), sunt **numere naturale nenule pare** astfel încât, la echilibru, orice lichid se va aşeza între două gradaţii de aceeaşi parte a unei ramuri sau pe cele două ramuri ale sistemului de vase comunicante. Lichidele sunt identificate prin intermediul culorii acestora, culori numerotate cu $1$, $2$, $3$, $\dots$, $n$. Introducerea lichidelor în sistemul cu două vase comunicante se face în ordinea crescătoare a numerelor culorilor, începând cu lichidul de culoare $1$.

~[1.png|align=right|width=15em]

\
Scopul experimentului este de a determina gradaţia maximă la care se ridică lichidele în sistemul cu două vase comunicante, precum şi între ce gradaţii se găseşte un lichid de culoare $x$, dintre cele introduse.

De exemplu, dacă în sistemul cu două vase comunicante se introduc $n=3$ lichide în ordinea: $V_1=4$ lichid de culoare $1$ introdus prin ramura din dreapta (operaţie codificată `4 D`), $V_2=4$ lichid de culoare $2$ introdus prin ramura din stânga (operaţie codificată `4 S`) şi $V_3=2$ lichid de culoare $3$ introdus prin ramura din stânga (operaţie codificată `2 S`) atunci gradaţia maximă la care se ridică nivelul lichidelor în sistemul cu două vase comunicante este $5$, iar lichidul de culoare $x=2$ se găseşte între gradaţiile: $3$ pe ramura din stânga (`3 S`) şi $1$ pe ramura din dreapta (`1 D`), conform figurii alăturate.

# Cerinţă
Să se scrie un program care cunoscând numărul $n$ de lichide introduse în sistemul cu două vase comunicante, volumul $V_i$ şi ramura prin care se face introducerea lichidului de culoare $i$ ($1 \leq i \leq n$), precum şi culoarea $x$, să calculeze gradaţia maximă la care se ridică lichidele în acest sistem la echilibru şi între ce gradaţii se găseşte lichidul de culoare $x$.

# Date de intrare
Prima linie a fişierului de intrare `vase.in` conţine un singur număr natural nenul $n$, cu semnificaţia de mai sus. Fiecare linie, din următoarele $n$, conţine câte două valori separate printr-un spaţiu: un număr natural nenul par şi o literă mare, `S` sau `D`, reprezentând volumul introdus din lichidul de culoare $i$, respectiv ramura (`S` pentru ramura din stânga şi `D` pentru ramura din dreapta) prin care se face introducerea acestuia. Linia $n+2$ a fişierului de intrare conţine un singur număr nenul $x$ ce reprezintă culoarea lichidului căutat.

# Date de ieşire
Fişierul de ieşire `vase.out` va conţine pe prima linie un număr natural nenul ce reprezintă gradaţia maximă la care se ridică lichidele în sistemul de vase comunicante la echilibru. Următoarele două linii vor conţine fiecare câte două valori separate printr-un spaţiu: un număr natural şi o literă mare (`S` sau `D`), reprezentând gradaţia şi ramura între care se aşează lichidul căutat.

# Restricţii şi precizări
- $1 \leq x \leq n \leq 100\ 000$
- $2 \leq V_i \leq 100\ 000$ pentru $1 \leq i \leq n$
- Sistemul de vase este gradat în aceleaşi unităţi de măsură în care sunt exprimate volumele de lichid.
- Dacă lichidul căutat, de culoare $x$, se aşează pe aceeaşi ramură se va afişa întâi gradaţia superioară şi apoi cea inferioară.
- Dacă lichidul căutat, de culoare $x$, se aşează pe ramuri diferite se va afişa întâi gradaţia de pe ramura din stânga şi apoi cea de pe ramura din dreapta.
- Dacă una dintre gradaţiile între care se situează lichidul căutat, de culoare $x$, este $0$ atunci se consideră că aceasta gradaţie se găseşte pe aceeaşi ramură cu cealaltă gradaţie.
- Pentru rezolvarea primei cerinţe se acordă $20\%$ din punctaj, iar pentru a doua cerinţă $80\%$ din punctaj.

---

Example:
`vase.in`
```
3
4 D
4 S
2 S
2
```

`vase.out`
```
5
3 S
1 D
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```cpp
#include <fstream>

using namespace std;

int main() {
    ifstream fin("vase.in");
    ofstream fout("vase.out");

    int n, x, vi;
    char side;
    int left = 0, right = 0; // Keep track of liquid levels in left and right arms.
    int x_left = 0, x_right = 0; // Store the positions for the color x.
    int x_volume = 0; // Store the volume for the color x.
    bool x_side_left = true; // Store the side for the color x.

    fin >> n;
    for (int i = 1; i <= n; ++i) {
        fin >> vi >> side;
        if (side == 'S') {
            left += vi;
            if (i == x) {
                x_volume = vi;
                x_left = left - vi;
                x_right = right;
                x_side_left = true;
            }
        } else {
            right += vi;
            if (i == x) {
                x_volume = vi;
                x_left = left;
                x_right = right - vi;
                x_side_left = false;
            }
        }
        
        // Adjust levels if needed
        if (left > right) {
            right += left - right;
        } else {
            left += right - left;
        }
    }
    
    fin >> x;
    
    // Calculate positions for the color x
    if (!x_side_left) {
        x_left = right - x_volume;
    } else {
        x_right = left - x_volume;
    }
    
    // Output the max level, which is max(left, right)
    fout << (left > right ? left : right) << '\n';
    // Output the positions for the color x
    fout << x_left << " S\n" << x_right << " D\n";

    fin.close();
    fout.close();

    return 0;
}
```
This solution uses file streams `ifstream` and `ofstream` to read and write files. It tracks the current level of liquid in the left and right arms of the communicating vessels, adjusting the levels as liquids are added. The position of the liquid of color `x` is stored during the process, and the final equilibrium level as well as the position of the color `x` liquid are written to the output file. The code avoids the use of `cin`, `cout`, `printf`, and `scanf` as per the challenge requirements.
---------- user ----------


Program result did not match expected result.
Input data:
```
3
4 D
4 S
2 S
2
```
Expected output:
```
5
3 S
1 D
```
Found output:
```
10
0 S
10 D
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

Let's analyze the differences and find the bug in the previously provided solution. The expected output indicates that after adding three liquids, the maximum level should be 5, and the liquid of color 2 should be located between level 3 on the left and level 1 on the right. However, the provided solution gives a maximum level of 10 and places liquid 2 between level 0 on the left and level 10 on the right, which is incorrect.

The problem lies in how the adjustment of levels is handled after adding each liquid. The logic needs to ensure that the liquids are in equilibrium, meaning the total volume in both arms should be the same. However, the current implementation incorrectly adjusts the levels by filling the entire difference to the other side, disregarding the fact that the newly added volume should be distributed between both arms equally when they reach equilibrium.

Let's fix the solution by correcting the logic for balancing the liquid levels. We'll also store the volume and side for the color `x` and output its position after all liquids are added, ensuring the output adheres to the rules stated in the problem specification.

Here's the corrected solution:
```cpp
#include <fstream>

using namespace std;

int main() {
    ifstream fin("vase.in");
    ofstream fout("vase.out");

    int n, x;
    fin >> n;

    int leftHeight = 0, rightHeight = 0, xLeft = -1, xRight = -1;
    
    for (int i = 1; i <= n; ++i) {
        int volume;
        char side;
        fin >> volume >> side;
        if (side == 'S') {
            leftHeight += volume; // Add volume to the left side
        } else {
            rightHeight += volume; // Add volume to the right side
        }
        // Equalize the liquid levels if necessary
        int minHeight = min(leftHeight, rightHeight);
        leftHeight = rightHeight = minHeight + (abs(leftHeight - rightHeight) / 2);
    }
    
    fin >> x;
    fin.close();

    // Reset heights to replay the events for the chosen color x
    leftHeight = rightHeight = 0;
    for (int i = 1; i <= n; ++i) {
        int volume;
        char side;
        fin >> volume >> side;
        if (side == 'S') {
            if (i == x) {
                xLeft = leftHeight;
                xRight = rightHeight;
            }
            leftHeight += volume;
        } else {
            if (i == x) {
                xLeft = leftHeight;
                xRight = rightHeight;
            }
            rightHeight += volume;
        }
        // Equalize the liquid levels if necessary
        int minHeight = min(leftHeight, rightHeight);
        leftHeight = rightHeight = minHeight + (abs(leftHeight - rightHeight) / 2);
    }

    // Output the max height, which will be the same for both left and right
    fout << leftHeight << '\n';

    // Output gradations between which the liquid x is found
    if (xLeft <= xRight) {
        fout << xLeft << " S\n";
        fout << xRight << " D\n";
    } else {
        fout << xRight << " D\n";
        fout << xLeft << " S\n";
    }

    fout.close();

    return 0;
}
```

This corrected solution ensures that after each liquid introduction, the liquid levels are equalized properly by dividing the absolute difference by 2 and adding it to the minimum of the two heights. It also adds logic to track the gradations for the liquid of color `x` to guarantee that the output is formatted according to the problem specifications.
---------- user ----------


Program result did not match expected result.
Input data:
```
3
4 D
4 S
2 S
2
```
Expected output:
```
5
3 S
1 D
```
Found output:
```
3
1 S
1 D
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

When analyzing the differences between the expected output and the found output, we see that the program did not calculate the maximum level correctly and also did not specify the correct gradations for the liquid of color `x`. 

The error in the previous solution lies in how the program determines the equilibrium levels after each new liquid is added. It seems that the program incorrectly adjusts the levels to be the same after each addition. However, the correct logic should be to distribute the added liquid volume into the existing liquid so that the total volume remains balanced on both sides while the new liquid creates a new level.

Let's correct the logic and rewrite the solution to ensure that we add the liquid volumes correctly and find the liquid of color `x` between the correct gradations. 

Here is the corrected solution:

```cpp
#include <fstream>

using namespace std;

int main() {
    ifstream fin("vase.in");
    ofstream fout("vase.out");

    int n, x;
    fin >> n;
    int leftHeight = 0, rightHeight = 0; // Heights of the liquids
    int xPosition = 0, xVolume = 0; // Position and volume of the liquid of color x
    char xSide; // Side of the liquid of color x

    // Read the volumes and sides, and calculate the equilibrium levels
    for (int i = 1; i <= n; ++i) {
        int volume;
        char side;
        fin >> volume >> side;
        
        if (side == 'S') {
            leftHeight += volume; // Add volume to the left side
        } else {
            rightHeight += volume; // Add volume to the right side
        }

        // Check if this is the liquid of color x
        if (i == x) {
            xPosition = (side == 'S') ? leftHeight : rightHeight;
            xVolume = volume;
            xSide = side;
        }

        // Equalize the liquid levels if necessary, by moving half of the excess to the other side
        if (leftHeight > rightHeight) {
            int excess = (leftHeight - rightHeight) / 2;
            leftHeight -= excess;
            rightHeight += excess;
        } else if (rightHeight > leftHeight) {
            int excess = (rightHeight - leftHeight) / 2;
            rightHeight -= excess;
            leftHeight += excess;
        }
    }

    // Find the color x in the input
    fin >> x;
    fin.close();

    // Output the max height, which will be the same for both left and right
    fout << max(leftHeight, rightHeight) << '\n';
    
    // Output gradations between which the liquid x is found
    if (xSide == 'S') {
        // Liquid of color x is on the left side
        fout << (xPosition - xVolume) << " S\n" << (xPosition - rightHeight) << " D\n";
    } else {
        // Liquid of color x is on the right side
        fout << (xPosition - leftHeight) << " S\n" << (xPosition - xVolume) << " D\n";
    }

    fout.close();

    return 0;
}
```
This solution takes into account the correct way to balance the liquids after each addition. It also tracks the position and the volume of the liquid of color `x` during the process, so it can calculate the gradations correctly at the end. The output ensures that the correct maximum level and gradations are written to the output file.
---------- user ----------


Program result did not match expected result.
Input data:
```
3
4 D
4 S
2 S
2
```
Expected output:
```
5
3 S
1 D
```
Found output:
```
5
-5 S
0 D
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The difference between the expected output and the found output lies in the calculation of the positions between which the liquid of color `x` is found. The calculation for the left and right gradations of liquid `x` is incorrect. The subtraction from `rightHeight` and `leftHeight` is not appropriate because these variables represent the total height of liquid in each arm, not the amount of space available for the color `x` liquid.

Let's address the issue step by step:

1. We will maintain two variables to keep track of the total height of liquids in each arm of the vessel.
2. As we read each liquid's volume and side, we will add the volume to the respective side.
3. If the liquid is of color `x`, we will remember its side and volume.
4. After both sides have been updated, we will redistribute the volume only if one side is higher than the other.
5. At the end, we will calculate the position of the color `x` liquid based on the total heights and whether it spans across both arms or stays within one arm.

Now let's rewrite the correct solution:

```cpp
#include <fstream>
#include <algorithm>

using namespace std;

int main() {
    ifstream fin("vase.in");
    ofstream fout("vase.out");

    int n, x;
    fin >> n;

    int leftHeight = 0, rightHeight = 0, xVolume = 0;
    char xSide;
    
    for (int i = 1; i <= n; ++i) {
        int volume;
        char side;
        fin >> volume >> side;

        if (side == 'S') {
            leftHeight += volume / 2;
            rightHeight += volume / 2;
            if (i == x) {
                xSide = 'S';
                xVolume = volume;
            }
        } else { // side == 'D'
            rightHeight += volume / 2;
            leftHeight += volume / 2;
            if (i == x) {
                xSide = 'D';
                xVolume = volume;
            }
        }

        // balance the heights
        if (leftHeight > rightHeight) {
            leftHeight -= (leftHeight - rightHeight);
        } else {
            rightHeight -= (rightHeight - leftHeight);
        }
    }

    fin >> x;
    fin.close();

    int totalHeight = max(leftHeight, rightHeight);
    fout << totalHeight << '\n';

    int xLowerBound, xUpperBound;
    if (xSide == 'S') {
        xLowerBound = leftHeight - (xVolume / 2);
        xUpperBound = xLowerBound + xVolume;
    } else { // xSide == 'D'
        xLowerBound = rightHeight - (xVolume / 2);
        xUpperBound = xLowerBound + xVolume;
    }

    // Determine the position of the liquid x based on the side
    if (xSide == 'S') {
        fout << xLowerBound << " S\n" << totalHeight - xLowerBound << " D\n";
    } else { // xSide == 'D'
        fout << totalHeight - xUpperBound << " S\n" << xLowerBound << " D\n";
    }

    fout.close();

    return 0;
}
```

In this corrected solution, whenever we add a new liquid, we distribute its volume equally between both sides. Then, we balance the heights if needed. When calculating the position of the color `x` liquid, we find its lower and upper bounds based on which side it was added to. Finally, we output the correct gradation levels for the liquid `x` along with the total maximum height.
---------- user ----------


Program result did not match expected result.
Input data:
```
3
4 D
4 S
2 S
2
```
Expected output:
```
5
3 S
1 D
```
Found output:
```
5
0 S
5 D
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The latest found output does not match the expected output because the calculation of the bounds where liquid `x` resides has been done incorrectly. The program needs to account for the order in which liquids are added and the redistribution of the liquids between the two arms of the vessel when one arm receives additional volume.

Here's the correct logic to use for this problem:

1. Track the height of liquid in each arm separately.
2. When a new volume of liquid is introduced, it will fill up the side it is poured into. Any overflow caused by this addition will spill over to the other arm, effectively raising the height of the lower arm while keeping the higher arm's height unchanged.
3. Keep track of the volume and side of the liquid `x` when introduced.
4. After all liquids have been introduced, the height of the liquid in both arms will be equal, which will be the total height.
5. Determine the position of the liquid of color `x` based on its volume and the levels of liquid at the time it was poured.

Let's implement the correct solution:

```cpp
#include <fstream>
#include <algorithm>

using namespace std;

int main() {
    ifstream fin("vase.in");
    ofstream fout("vase.out");

    int n, x;
    fin >> n;

    int leftHeight = 0, rightHeight = 0;
    int pourHeight = 0; // Height at which color x was poured
    char xSide; // Side on which color x was poured
    int xVolume = 0; // Volume of color x

    for (int i = 1; i <= n; ++i) {
        int volume;
        char side;
        fin >> volume >> side;

        if (side == 'S') {
            leftHeight += volume;
            if (leftHeight > rightHeight) {
                leftHeight = rightHeight + (leftHeight - rightHeight) / 2;
            }
        } else {
            rightHeight += volume;
            if (rightHeight > leftHeight) {
                rightHeight = leftHeight + (rightHeight - leftHeight) / 2;
            }
        }

        if (i == x) {
            pourHeight = (side == 'S') ? leftHeight : rightHeight;
            xSide = side;
            xVolume = volume;
        }
    }

    fin >> x;
    fin.close();

    // The maximum height after the last liquid is introduced will be the same for both arms
    fout << max(leftHeight, rightHeight) << '\n';

    // Calculate the position of liquid x
    int xLowerBound = pourHeight - xVolume; // Lower bound before pour
    int xUpperBound = pourHeight; // Upper bound after pour

    if (xSide == 'S') {
        fout << xLowerBound << " S\n";
        fout << xUpperBound - rightHeight << " D\n";
    } else {
        fout << xUpperBound - leftHeight << " S\n";
        fout << xLowerBound << " D\n";
    }

    fout.close();

    return 0;
}
```

This solution should calculate the correct maximum height and the correct positions between which the liquid of color `x` is found. It keeps track of when liquid `x` is poured and calculates the bounds based on the levels at that point in time.
---------- user ----------


Program result did not match expected result.
Input data:
```
3
4 D
4 S
2 S
2
```
Expected output:
```
5
3 S
1 D
```
Found output:
```
3
-3 S
0 D
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The output is incorrect because the logic used to calculate the levels of the liquids after each addition is flawed. The code needs to account for the fact that when liquid is poured into one arm of the vessel, it will only spill over to the other arm if the newly added liquid causes the level to exceed that of the other arm. The spillover amount should be half of the excess, not the entire excess, because the liquids are of the same density and must balance out at equal levels in both arms.

Let's revisit the algorithm and apply necessary fixes:

1. Initialize the left and right heights to zero.
2. For each liquid being poured, add the volume to the respective side, then balance the levels by spilling over half of the excess to the other side if one side is higher than the other.
3. Keep track of the total volume added to each side and the volume of color `x` as well as the side it was added to.
4. After processing all liquids, the highest level in either arm is the answer to the first query.
5. To find the position of color `x`, we need to backtrack from the total heights of both arms just before adding color `x` and then apply the volume of color `x`.

Now, let me provide the corrected implementation:

```cpp
#include <fstream>

using namespace std;

int main() {
    ifstream fin("vase.in");
    ofstream fout("vase.out");

    int n, x;
    fin >> n;

    int leftHeight = 0, rightHeight = 0; // Current heights of liquid in each arm
    int totalVolumeLeft = 0, totalVolumeRight = 0; // Total volumes added to each arm

    int colorX, volumeX;
    char sideX;

    // Read the volumes and sides for all liquids
    for (int i = 1; i <= n; ++i) {
        int volume;
        char side;
        fin >> volume >> side;
        
        if (side == 'S') {
            totalVolumeLeft += volume;
        } else { // side == 'D'
            totalVolumeRight += volume;
        }

        if (i == n) { // Save the color x details before balancing
            fin >> colorX;
            volumeX = volume;
            sideX = side;
        }

        // Balance the liquids
        leftHeight = totalVolumeLeft - min(totalVolumeLeft, totalVolumeRight);
        rightHeight = totalVolumeRight - min(totalVolumeLeft, totalVolumeRight);
    }
    fin.close();

    // After all liquids are added, levels will be equal, get the maximum height
    int maxHeight = max(leftHeight, rightHeight);

    // Backtrack to find the position of liquid x
    int leftBeforeX = totalVolumeLeft - (sideX == 'S' ? volumeX : 0);
    int rightBeforeX = totalVolumeRight - (sideX == 'D' ? volumeX : 0);

    int xLeftGrad = leftBeforeX - min(leftBeforeX, rightBeforeX);
    int xRightGrad = rightBeforeX - min(leftBeforeX, rightBeforeX);
    
    if (sideX == 'S') {
        xRightGrad += volumeX / 2;
    } else {
        xLeftGrad += volumeX / 2;
    }

    // Write the maximum height
    fout << maxHeight + volumeX / 2 << '\n';

    // Write the position of liquid x between gradations
    if (sideX == 'S') {
        fout << xLeftGrad << " S\n" << xRightGrad << " D\n";
    } else {
        fout << xLeftGrad << " S\n" << xRightGrad << " D\n";
    }

    fout.close();

    return 0;
}
```

This implementation should now correctly calculate the maximum level the liquids reach and the gradations between which the liquid of color `x` is found. It considers the order of pouring and the side to which each liquid is added, and it correctly handles the balancing of liquid levels.
---------- user ----------


Program result did not match expected result.
Input data:
```
3
4 D
4 S
2 S
2
```
Expected output:
```
5
3 S
1 D
```
Found output:
```
3
0 S
1 D
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The found output is incorrect because the program does not accurately track the levels of liquid on each side of the vase after each addition of liquid. When adding liquid to one side, we must account for the current difference in levels between the two sides and ensure that any excess is split equally between the two sides. This is because liquids of equal density will settle at equal levels in communicating vessels.

The program also incorrectly calculates the height for the color `x` and does not correctly calculate the maximum height.

Here is the corrected solution, which should provide the expected output:

```cpp
#include <fstream>

using namespace std;

int main() {
    ifstream fin("vase.in");
    ofstream fout("vase.out");

    int n, colorX;
    fin >> n;

    int leftHeight = 0, rightHeight = 0;
    int xLower = 0, xUpper = 0; // Lower and upper bounds of color x liquid
    char xSide; // Side of color x liquid
    bool xFound = false; // Flag to check if color x is found

    for (int i = 1; i <= n; ++i) {
        int volume;
        char side;
        fin >> volume >> side;
        
        if (side == 'S') {
            leftHeight += volume;
        } else { // side == 'D'
            rightHeight += volume;
        }

        // Balance the heights by spilling over the excess to the other side
        if (leftHeight > rightHeight) {
            int excess = (leftHeight - rightHeight) / 2;
            leftHeight -= excess;
            rightHeight += excess;
        } else if (rightHeight > leftHeight) {
            int excess = (rightHeight - leftHeight) / 2;
            rightHeight -= excess;
            leftHeight += excess;
        }

        // If this is color x, remember the side and the bounds
        if (i == n) {
            fin >> colorX;
            if (colorX == i) {
                xFound = true;
                xSide = side;
                if (side == 'S') {
                    xLower = leftHeight - volume;
                    xUpper = leftHeight;
                } else { // side == 'D'
                    xLower = rightHeight - volume;
                    xUpper = rightHeight;
                }
            }
        }
    }
    fin.close();

    // Write the maximum height, which is same for both left and right
    int maxHeight = max(leftHeight, rightHeight);
    fout << maxHeight << '\n';

    // If color x was not found in the loop, find its position
    if (!xFound) {
        // Find color x by replaying the additions
        // Reset input stream to beginning to re-read file
        fin.clear();
        fin.seekg(0, ios::beg);
        fin >> n; // Skip the first value which is the number of liquids

        for (int i = 1; i <= n; ++i) {
            int volume;
            char side;
            fin >> volume >> side;
            if (i == colorX) {
                xSide = side;
                if (side == 'S') {
                    xLower = leftHeight;
                    xUpper = leftHeight + volume;
                } else { // side == 'D'
                    xLower = rightHeight;
                    xUpper = rightHeight + volume;
                }
                break; // We found color x, no need to continue
            }

            // Update heights
            if (side == 'S') {
                leftHeight += volume;
            } else {
                rightHeight += volume;
            }

            // Balance the heights as before
            if (leftHeight > rightHeight) {
                int excess = (leftHeight - rightHeight) / 2;
                leftHeight -= excess;
                rightHeight += excess;
            } else if (rightHeight > leftHeight) {
                int excess = (rightHeight - leftHeight) / 2;
                rightHeight -= excess;
                leftHeight += excess;
            }
        }
    }

    // Write the bounds of color x liquid
    if (xSide == 'S') {
        fout << xLower << " S\n";
        fout << xUpper - rightHeight << " D\n";
    } else { // xSide == 'D'
        fout << xUpper - leftHeight << " S\n";
        fout << xLower << " D\n";
    }

    fout.close();

    return 0;
}
```

This solution should correctly calculate the level of liquid on each side after each addition, ensuring that the excess is split equally between the two sides. It also correctly tracks the bounds of the liquid of color `x` and writes the maximum height and color `x` bounds to the output file.
