---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `charlie.in` and write to `charlie.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

*Charlie* a decis să se joace cu literele dintr-un șir de caractere, șir ce conține doar **literele mici** ale alfabetului englez de la `a` la `z`. Jocul constă în a elimina litere din șir după următoarea regulă: fie $L_1$, $L_2$, $L_3$ trei litere aflate pe poziții consecutive în șir, atunci litera $L_2$ poate fi eliminată dacă și numai dacă este strict mai mică lexicografic decât literele $L_1$ și $L_3$.
\
Pentru a face jocul mai interesant, *Charlie* atașează eliminării literei $L_2$ un cost egal cu valoarea maximă dintre $f(L_1)$ și $f(L_3)$, unde prin $f($`literă`$)$ înțelegem numărul de ordine al literei respective în alfabet ($f($`a`$) = 1, f($`b`$) = 2, \dots, f($`z`$) = 26$). *Charlie* aplică în mod repetat procedeul de eliminare și calculează suma costurilor eliminărilor efectuate.

# Cerințe	
Fiind dat un șir de caractere să se determine:
1) Lungimea maximă a unei secvențe de litere alternante, adică o secvență pentru care literele aflate pe poziții consecutive sunt de forma: $L_i > L_{i+1} < L_{i+2} > L_{i+3} < L_{i+4} > \dots < L_j$.
2) Suma maximă pe care o poate obține *Charlie* aplicând în mod repetat procedeul de eliminare a literelor, precum și șirul obținut în final.

# Date de intrare 
Fișierul de intrare `charlie.in` conține pe prima linie un număr natural $p$. Pentru toate testele de intrare, numărul $p$ poate avea doar valoarea $1$ sau valoarea $2$. Pe următoarea linie se află un șir de caractere.

# Date de ieșire
Dacă valoarea lui $p$ este $1$, **se va rezolva numai prima cerință**.
În acest caz, în fișierul de ieșire `charlie.out` se va scrie un singur număr natural $L$ ce reprezintă lungimea maximă a unei secvențe de litere alternante.
\
Dacă valoarea lui $p$ este $2$, **se va rezolva numai a doua cerință**.
În acest caz, fișierul de ieșire `charlie.out` va conține două linii. Pe prima linie se va afla șirul rezultat în urma eliminărilor repetate de litere respectând regula enunțată, iar pe cea de-a doua linie suma maximă obținută.

# Restricții și precizări
- Numărul de litere ale șirului inițial este cuprins între $3$ și $100\ 000$ inclusiv.
- Pentru rezolvarea corectă a primei cerințe se acordă 25 de puncte, iar pentru cerința a doua se acordă 75 de puncte.
- Pentru $30\%$ dintre teste, numărul de litere ale șirului este $\leq 1\ 000$.

---

Example:
`charlie.in`
```
1
cadgfacbda
```

`charlie.out`
```
5
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```cpp
#include <fstream>
#include <vector>
#include <cstring>

using namespace std;

ifstream fin("charlie.in");
ofstream fout("charlie.out");

int main() {
    int p;
    fin >> p;
    fin.ignore(); // Skip new line after integer p

    char str[100001];
    fin.getline(str, 100001);
    int len = strlen(str);

    if (p == 1) {
        // Finding the longest alternating sequence
        int count = 1, max_count = 1;
        for (int i = 1; i < len - 1; ++i) {
            if ((str[i] > str[i-1] && str[i] > str[i+1]) || (str[i] < str[i-1] && str[i] < str[i+1])) {
                count++;
                max_count = max(max_count, count);
            } else {
                count = 1;
            }
        }
        fout << max_count << '\n';
    } else {
        // Removing characters and calculating the sum
        vector<char> s(str, str + len);
        vector<int> score;
        int total_score = 0, max_score;
        bool erased;

        do {
            erased = false;
            score.clear();
            for (int i = 1; i < (int)s.size() - 1; ++i) {
                if (s[i] < s[i - 1] && s[i] < s[i + 1]) {
                    score.push_back(max(s[i-1], s[i+1]) - 'a' + 1);
                    erased = true;
                } else {
                    score.push_back(0);
                }
            }

            for (int i = score.size() - 1; i >= 0; --i) {
                if (score[i] != 0) {
                    total_score += score[i];
                    s.erase(s.begin() + i + 1);
                }
            }
        } while (erased);

        for (char c : s) {
            fout << c;
        }
        fout << '\n' << total_score << '\n';
    }

    fin.close();
    fout.close();
    return 0;
}
```

Explanation of the solution:

- Read the problem type `p` and the string from the input file `charlie.in`.
- If `p == 1`, calculate the length of the longest alternating sequence by iterating through the string and using a counter variable.
- If `p == 2`, repeatedly remove characters according to the game rules. Use two loops: an outer do-while loop to perform the removals until no more can be done, and an inner for loop to identify which characters can be removed. Keep track of scores in a vector and the total score.
- Write the appropriate output to `charlie.out` depending on the value of `p`.
