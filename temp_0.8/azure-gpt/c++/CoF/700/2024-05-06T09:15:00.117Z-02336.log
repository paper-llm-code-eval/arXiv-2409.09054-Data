---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `mouse.in` and write to `mouse.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Un experiment urmărește comportarea unui șoricel pus într-o cutie dreptunghiulară, împărțită în $m \times n$ cămăruțe egale de formă pătrată. Fiecare cămăruță conține o anumită cantitate de hrană. Șoricelul trebuie să pornească din colțul $(1,1)$ al cutiei și să ajungă în colțul opus, mâncând cât mai multă hrană. El poate trece dintr-o cameră în una alăturată (două camere sunt alăturate dacă au un perete comun), mănâncă toată hrana din cămăruță atunci când intră și nu intră niciodată într-o cameră în care a mai intrat înainte. 

# Cerință

Stabiliți care este cantitatea maximă de hrană pe care o poate mânca și traseul pe care îl poate urma pentru a culege această cantitate maximă.

# Date de intrare
Fișierul de intrare `mouse.in` conține pe prima linie două numere $m$ și $n$ reprezentând numărul de linii respectiv numărul de coloane ale cutiei, iar pe următoarele $m$ linii cele $m \cdot n$ numere reprezentând cantitatea de hrană existentă în fiecare cămăruță, câte $n$ numere pe fiecare linie, separate prin spații.

# Date de ieșire
În fișierul de ieșire `mouse.out` se vor scrie pe prima linie două numere separate printr-un spațiu: numărul de cămăruțe vizitate și cantitatea de hrană maximă culeasă. Pe următoarele linii se va scrie un traseu posibil pentru cantitatea dată, sub formă de perechi de numere, începând cu $(1, 1)$ și terminând cu $(m, n)$.

# Restricții și precizări
- Toate valorile din fișier sunt numere naturale între $1$ și $100$.
- Veți primi 40 de puncte pentru afișarea primelor două numere.

---

Example:
`mouse.in`
```
2 4
1 2 6 3
3 4 1 2
```

`mouse.out`
```
7 21
1 1
2 1
2 2
1 2
1 3
1 4
2 4
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```cpp
#include <fstream>
#include <vector>
#include <algorithm>

using namespace std;

ifstream fin("mouse.in");
ofstream fout("mouse.out");

const int dx[] = {0, 1, 0, -1};
const int dy[] = {1, 0, -1, 0};

int m, n;
vector<vector<int>> grid;
vector<pair<int, int>> path;
vector<vector<int>> max_food;
vector<vector<pair<int, int>>> previous;

bool valid(int x, int y) {
    return x >= 0 && x < m && y >= 0 && y < n;
}

void find_path(int x, int y) {
    if (x != 0 || y != 0) {  // Not the start cell (1,1)
        find_path(previous[x][y].first, previous[x][y].second);
    }
    path.push_back({x + 1, y + 1});  // Convert to 1-based index
}

int main() {
    // Read input
    fin >> m >> n;
    grid.resize(m, vector<int>(n, 0));
    max_food.resize(m, vector<int>(n, 0));
    previous.resize(m, vector<pair<int, int>>(n, {-1, -1}));

    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            fin >> grid[i][j];
        }
    }

    // Dynamic programming to find max food from (1,1) to (m,n)
    max_food[0][0] = grid[0][0];
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            for (int dir = 0; dir < 4; dir++) {
                int prev_x = i + dx[dir];
                int prev_y = j + dy[dir];
                if (valid(prev_x, prev_y) && max_food[i][j] < max_food[prev_x][prev_y] + grid[i][j]) {
                    max_food[i][j] = max_food[prev_x][prev_y] + grid[i][j];
                    previous[i][j] = {prev_x, prev_y};
                }
            }
        }
    }

    // Backtrack to get the path
    find_path(m - 1, n - 1);

    // Output the result
    fout << path.size() << ' ' << max_food[m - 1][n - 1] << '\n';
    for (auto &cell : path) {
        fout << cell.first << ' ' << cell.second << '\n';
    }

    fin.close();
    fout.close();
    return 0;
}
```
This is a C++ solution that reads from "mouse.in" and writes to "mouse.out", using dynamic programming and backtracking.
---------- user ----------


Program result did not match expected result.
Input data:
```
2 4
1 2 6 3
3 4 1 2
```
Expected output:
```
7 21
1 1
2 1
2 2
1 2
1 3
1 4
2 4
```
Found output:
```
5 14
1 1
1 2
1 3
1 4
2 4
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
