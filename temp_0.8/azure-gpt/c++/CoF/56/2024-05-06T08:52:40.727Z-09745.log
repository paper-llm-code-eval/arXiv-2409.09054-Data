---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `zmeu.in` and write to `zmeu.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Un zmeu cu $n$ capete călătoreşte din poveste în poveste, iar în poveştile tradiţionale întâlneşte câte un Făt Frumos care-l mai scurtează de câteva capete, în timp ce în poveştile moderne salvează omenirea mâncând în timp record, cu toate capetele lui, insecte ucigaşe apărute prin mutaţii genetice. Într-o seară, el îşi planifică o succesiune de poveşti cărora să le dea viaţă. El ştie $p$ poveşti numerotate de la $1$ la $p$, durata fiecăreia şi numărul de capete pe care le pierde în fiecare poveste. Mai ştie o mulţime de $k$ perechi de poveşti, semnificând faptul că a doua poveste din pereche nu poate fi spusă după prima poveste din pereche.

# Cerinţă
Ştiind că trebuie să înceapă cu povestea $1$ şi să încheie succesiunea cu povestea $p$, ajutaţi bietul zmeu să aleagă una sau mai multe poveşti intermediare astfel încât durata totală să fie minimă şi să rămână cu cel puţin un cap la sfârşitul tuturor poveştilor.

# Date de intrare
Fişierul de intrare `zmeu.in` conţine pe prima linie numerele $n, p$ şi $k$ despărţite prin câte un spaţiu. Pe fiecare din următoarele $p$ linii se află câte o pereche de numere $d_i$ şi $c_i$ (separate prin câte un spaţiu) ce reprezintă durata şi numărul de capete tăiate pentru fiecare poveste. Iar pe ultimele $k$ linii se află câte o pereche de numere $p_i$ şi $p_j$ (separate prin câte un spaţiu) ce semnifică faptul că povestea $p_j$ nu poate fi spusă după povestea $p_i$.

# Date de ieşire
Fişierul de ieşire `zmeu.out` conţine o singură linie pe care se află un număr natural reprezentând durata (minimă) a succesiunii de poveşti sau valoarea $–1$ dacă nu există o astfel de succesiune.

# Restricţii şi precizări
* $2 ≤ N ≤ 500$
* $1 ≤ P ≤ 200$
* $1 ≤ k ≤ 30 \ 000$
* Valorile reprezentând duratele şi numărul de capete sunt numere naturale (duratele fiind strict pozitive), nedepăşind valoarea $10$.

---

Example:
`zmeu.in`
```
10 4 2
2 6
4 0
1 3
3 3
3 2
4 3
```

`zmeu.out`
```
9
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```cpp
#include <fstream>
#include <vector>
#include <queue>
#include <cstring>

using namespace std;

ifstream fin("zmeu.in");
ofstream fout("zmeu.out");

struct Story {
    int duration;
    int headsCut;
};

struct State {
    int storyIndex;
    int time;
    int remainingHeads;
};

bool operator>(const State &a, const State &b) {
    return a.time > b.time;
}

const int MAX_P = 201;
const int MAX_N = 501;
const int INF = 0x3f3f3f3f;

Story stories[MAX_P];
vector<int> graph[MAX_P];
int dist[MAX_P][MAX_N];
bool visited[MAX_P][MAX_N];

int main() {
    int n, p, k;
    fin >> n >> p >> k;

    for (int i = 0; i < p; ++i) {
        fin >> stories[i].duration >> stories[i].headsCut;
    }

    for (int i = 0; i < k; ++i) {
        int pi, pj;
        fin >> pi >> pj;
        // Adjust indices to be zero-based
        pi--; pj--;
        graph[pi].push_back(pj);
    }

    memset(dist, INF, sizeof dist);
    priority_queue<State, vector<State>, greater<State>> pq;

    pq.push({0, stories[0].duration, n - stories[0].headsCut});
    dist[0][n - stories[0].headsCut] = stories[0].duration;

    while (!pq.empty()) {
        State current = pq.top();
        pq.pop();

        if (visited[current.storyIndex][current.remainingHeads]) continue;
        visited[current.storyIndex][current.remainingHeads] = true;

        if (current.storyIndex == p - 1) {
            fout << current.time << endl;
            return 0;
        }

        for (int nextStory : graph[current.storyIndex]) {
            int nextHeads = current.remainingHeads - stories[nextStory].headsCut;
            if (nextHeads <= 0) continue;
            int nextTime = current.time + stories[nextStory].duration;

            if (nextTime < dist[nextStory][nextHeads]) {
                dist[nextStory][nextHeads] = nextTime;
                pq.push({nextStory, nextTime, nextHeads});
            }
        }
    }

    fout << -1 << endl;
    return 0;
}
```
This C++ solution uses a priority queue to implement a variant of Dijkstra's algorithm, considering the stories as nodes and maintaining the remaining heads and time spent. The state struct is used to store the state of the zmeu at each step, and a min-heap priority queue is used to prioritize the shortest duration paths. The solution reads from `zmeu.in` and writes to `zmeu.out` as per the constraints, without using `cin`, `cout`, `printf`, or `scanf`.
---------- user ----------


Program result did not match expected result.
Input data:
```
10 4 2
2 6
4 0
1 3
3 3
3 2
4 3
```
Expected output:
```
9
```
Found output:
```
-1
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

I apologize for the oversight. Upon examining the failure to produce the expected output, it appears that there's an issue with the way the graph was constructed or the way the states are being processed. The `graph` should represent a directed acyclical graph (DAG) where each node can point to one or more successor nodes, and not predecessors. Additionally, the distances should be initialized and updated correctly.

It seems the current algorithm has a logic error where it does not correctly account for the constraints on the story order, as it allows jumping from any story to any story, without following the constraints given by the `k` pairs of stories. It's important to build the graph correctly using the constraints and then perform a modified shortest path search.

Let's fix the code by properly initializing the graph and making sure we consider the constraints while traversing the stories.

```cpp
#include <fstream>
#include <vector>
#include <cstring>
#include <algorithm>

using namespace std;

ifstream fin("zmeu.in");
ofstream fout("zmeu.out");

struct Story {
    int duration;
    int headsCut;
};

const int MAX_P = 201;
const int INF = 0x3f3f3f3f;

Story stories[MAX_P];
vector<int> graph[MAX_P];
int minTime[MAX_P][MAX_P];  // Minimum time to reach story i with j heads left

int main() {
    int n, p, k;
    fin >> n >> p >> k;

    for (int i = 1; i <= p; ++i) {
        fin >> stories[i].duration >> stories[i].headsCut;
    }

    for (int i = 0; i < k; ++i) {
        int pi, pj;
        fin >> pi >> pj;
        graph[pi].push_back(pj);
    }

    // Initialize minTime with INF
    for (int i = 0; i <= p; ++i) {
        fill(minTime[i], minTime[i] + MAX_P, INF);
    }

    // Base case: starting with story 1
    minTime[1][n - stories[1].headsCut] = stories[1].duration;

    for (int i = 1; i < p; ++i) {
        for (int heads = 0; heads <= n; ++heads) {
            if (minTime[i][heads] == INF) continue;  // Skip if no way to reach this state

            for (int nextStory : graph[i]) {
                int nextHeads = heads - stories[nextStory].headsCut;
                if (nextHeads > 0) {  // Ensure we have at least one head left
                    int time = minTime[i][heads] + stories[nextStory].duration;
                    minTime[nextStory][nextHeads] = min(minTime[nextStory][nextHeads], time);
                }
            }
        }
    }

    // Find the minimum time to end the stories with any number of heads
    int result = *min_element(minTime[p] + 1, minTime[p] + n + 1);
    if (result == INF) {
        fout << -1 << endl;  // No way to reach the last story
    } else {
        fout << result << endl;
    }

    return 0;
}
```

This fixed solution now correctly constructs the graph, considering the constraints on the order of the stories. It uses a dynamic programming approach with `minTime` matrix, updating the minimum time for each story with a given number of heads remaining, ensuring that at least one head is left at the end. If there's no way to reach the last story with at least one head, the result is `-1`. Otherwise, the result is the minimum time found to reach the last story.
---------- user ----------


Program result did not match expected result.
Input data:
```
10 4 2
2 6
4 0
1 3
3 3
3 2
4 3
```
Expected output:
```
9
```
Found output:
```
-1
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

Let's investigate why the output is `-1` instead of the expected `9`. Our current solution attempts to use dynamic programming to find the minimum duration, but it seems that the graph constraints are not being handled correctly, or the dynamic programming state transitions are incorrect.

Upon reviewing the dynamic programming approach, I noticed that I used `minTime` as a two-dimensional array with the second dimension representing the number of remaining heads. However, the constraints indicate that stories cannot be told in certain orders, and this condition wasn't being enforced properly.

To address this, we need to first correctly build the graph of valid story transitions, respecting the $k$ constraints. Then, we'll run a dynamic programming algorithm that keeps track of the minimum time required to end each story with a certain number of heads remaining, ensuring we don't transition to a story that isn't allowed to follow the current one.

Let's rewrite the solution to correctly handle story order constraints and reattempt the dynamic programming approach.

```cpp
#include <fstream>
#include <vector>
#include <climits>
#include <queue>

using namespace std;

ifstream fin("zmeu.in");
ofstream fout("zmeu.out");

const int MAX_N = 501;
const int MAX_P = 201;
const int INF = INT_MAX;

vector<pair<int, int>> stories(MAX_P);  // Pair of duration and heads cut
vector<int> graph[MAX_P];               // Adjacency list of stories
int dp[MAX_P][MAX_N];                   // dp[i][j] = min time to reach story i with j heads

int main() {
    int n, p, k;
    fin >> n >> p >> k;
    for (int i = 1; i <= p; ++i) {
        fin >> stories[i].first >> stories[i].second;
    }

    for (int i = 0; i < k; ++i) {
        int a, b;
        fin >> a >> b;
        graph[a].push_back(b);
    }

    // Initialize the dp array with INF
    for (int i = 0; i <= p; ++i) {
        fill(dp[i], dp[i] + n + 1, INF);
    }

    // Starting story
    dp[1][n - stories[1].second] = stories[1].first;

    // Process all stories in order
    for (int i = 1; i < p; ++i) {
        for (int h = 0; h <= n; ++h) {
            if (dp[i][h] == INF) continue;  // If this state isn't reachable, skip it

            // Try all possible next stories
            for (int next : graph[i]) {
                int nextHeads = h - stories[next].second;
                if (nextHeads > 0) {  // Still have heads left
                    dp[next][nextHeads] = min(dp[next][nextHeads], dp[i][h] + stories[next].first);
                }
            }
        }
    }

    // Find the minimum time to finish the last story with any heads remaining
    int answer = INF;
    for (int h = 1; h <= n; ++h) {
        if (dp[p][h] < answer) {
            answer = dp[p][h];
        }
    }

    fout << (answer == INF ? -1 : answer) << "\n";

    return 0;
}
```

In this corrected solution, we perform dynamic programming on a two-dimensional array `dp` where `dp[i][j]` represents the minimum time to reach story `i` with `j` heads remaining. We iterate through all stories and update the `dp` array based on the adjacency list `graph`, which encodes the valid transitions between stories considering the constraints. If we find a valid minimum time to finish the last story with at least one head remaining, we output that time. If no such path exists, we output `-1`.
---------- user ----------


Program result did not match expected result.
Input data:
```
10 4 2
2 6
4 0
1 3
3 3
3 2
4 3
```
Expected output:
```
9
```
Found output:
```
-1
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

Analyzing the discrepancy in the results, it appears there is a logical fault in the dynamic programming implementation. The constraints specified by the problem suggest that certain stories cannot be told after others, and this dictates the order in which the stories can be processed. This relationship forms a directed acyclic graph (DAG), which can be traversed using a topological sort.

The dynamic programming solution should consider each story in the sorted order and calculate the minimum time to reach that story, while also accounting for the heads cut in each story.

Let me rewrite the solution with a correct implementation:

```cpp
#include <fstream>
#include <vector>
#include <algorithm>
#include <queue>

using namespace std;

struct Story {
    int duration, headsCut;
};

const int MAX_P = 201;
const int MAX_N = 501;
const int INF = INT_MAX / 2;  // Avoid integer overflow during addition
int n, p, k;
Story stories[MAX_P];
vector<int> adj[MAX_P], sortedStories;
int inDegree[MAX_P];
int dp[MAX_P][MAX_N]; // dp[i][j] represents the minimum time to reach story i with j heads remaining

bool topologicalSort() {
    queue<int> q;
    for (int i = 1; i <= p; ++i) {
        if (inDegree[i] == 0) q.push(i);
    }
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        sortedStories.push_back(u);
        for (int v : adj[u]) {
            if (--inDegree[v] == 0) q.push(v);
        }
    }
    return sortedStories.size() == p; // Check if the topological sort includes all stories
}

int main() {
    ifstream fin("zmeu.in");
    ofstream fout("zmeu.out");

    fin >> n >> p >> k;
    for (int i = 1; i <= p; ++i) {
        fin >> stories[i].duration >> stories[i].headsCut;
    }

    int a, b;
    for (int i = 0; i < k; ++i) {
        fin >> a >> b;
        adj[a].push_back(b);
        inDegree[b]++;
    }

    if (!topologicalSort()) {
        // If we cannot sort, a cycle exists which means the input is invalid
        fout << -1 << endl;
        return 0;
    }

    // Initialize dp array with INF
    for (int i = 0; i <= p; ++i) {
        fill(dp[i], dp[i] + n + 1, INF);
    }
    dp[1][n - stories[1].headsCut] = stories[1].duration;

    for (int u : sortedStories) {
        for (int heads = 0; heads <= n; ++heads) {
            if (dp[u][heads] == INF) continue;
            for (int v : adj[u]) {
                int nextHeads = heads - stories[v].headsCut;
                if (nextHeads > 0) {
                    dp[v][nextHeads] = min(dp[v][nextHeads], dp[u][heads] + stories[v].duration);
                }
            }
        }
    }

    int minTime = *min_element(dp[p] + 1, dp[p] + n + 1);
    if (minTime == INF) {
        fout << -1 << endl;
    } else {
        fout << minTime << endl;
    }

    fin.close();
    fout.close();
    return 0;
}
```

This revised solution implements a topological sort to process the stories in the correct order imposed by the constraints. The dynamic programming array `dp` is then filled by considering the sorted stories and the transitions between them allowed by the `adj` adjacency list. We then find the minimum time to finish the last story while ensuring that at least one head remains. If no such path is possible, we output `-1`. Otherwise, we output the minimum time calculated.
---------- user ----------


Failed to compile the program.
```
main.cpp:14:17: error: 'INT_MAX' was not declared in this scope
   14 | const int INF = INT_MAX / 2;  // Avoid integer overflow during addition
      |                 ^~~~~~~
main.cpp:5:1: note: 'INT_MAX' is defined in header '<climits>'; did you forget to '#include <climits>'?
    4 | #include <queue>
  +++ |+#include <climits>
    5 | 

```

Evaluate the error message. Think of a solution to fix the program and return the entire source code with the fix.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The error message indicates that `INT_MAX` is not declared in the scope. This is because we didn't include the header that defines `INT_MAX`. The solution to this is to include the `<climits>` header which contains the definition of `INT_MAX`.

Let's include the necessary header and rewrite the entire solution with this fix:

```cpp
#include <fstream>
#include <vector>
#include <algorithm>
#include <queue>
#include <climits> // Include for INT_MAX

using namespace std;

struct Story {
    int duration, headsCut;
};

const int MAX_P = 201;
const int MAX_N = 501;
const int INF = INT_MAX / 2;  // Avoid integer overflow during addition
int n, p, k;
Story stories[MAX_P];
vector<int> adj[MAX_P], sortedStories;
int inDegree[MAX_P];
int dp[MAX_P][MAX_N]; // dp[i][j] represents the minimum time to reach story i with j heads remaining

bool topologicalSort() {
    queue<int> q;
    for (int i = 1; i <= p; ++i) {
        if (inDegree[i] == 0) q.push(i);
    }
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        sortedStories.push_back(u);
        for (int v : adj[u]) {
            if (--inDegree[v] == 0) q.push(v);
        }
    }
    return sortedStories.size() == p; // Check if the topological sort includes all stories
}

int main() {
    ifstream fin("zmeu.in");
    ofstream fout("zmeu.out");

    fin >> n >> p >> k;
    for (int i = 1; i <= p; ++i) {
        fin >> stories[i].duration >> stories[i].headsCut;
    }

    for (int i = 0; i < k; ++i) {
        int a, b;
        fin >> a >> b;
        adj[a].push_back(b);
        inDegree[b]++;
    }

    if (!topologicalSort()) {
        // If we cannot sort, a cycle exists which means the input is invalid
        fout << -1 << endl;
        return 0;
    }

    // Initialize dp array with INF
    for (int i = 0; i <= p; ++i) {
        fill(dp[i], dp[i] + n + 1, INF);
    }
    dp[1][n - stories[1].headsCut] = stories[1].duration;

    for (int u : sortedStories) {
        for (int heads = 0; heads <= n; ++heads) {
            if (dp[u][heads] == INF) continue;
            for (int v : adj[u]) {
                int nextHeads = heads - stories[v].headsCut;
                if (nextHeads > 0) {
                    dp[v][nextHeads] = min(dp[v][nextHeads], dp[u][heads] + stories[v].duration);
                }
            }
        }
    }

    int minTime = *min_element(dp[p] + 1, dp[p] + n + 1);
    if (minTime == INF) {
        fout << -1 << endl;
    } else {
        fout << minTime << endl;
    }

    fin.close();
    fout.close();
    return 0;
}
```

Now, with the inclusion of the `<climits>` header, the `INT_MAX` should be defined, and the program should compile successfully. The rest of the code logic remains the same as the previous attempt, including topological sorting of the stories and dynamic programming to find the minimum time to reach the last story with at least one head remaining.
---------- user ----------


Program result did not match expected result.
Input data:
```
10 4 2
2 6
4 0
1 3
3 3
3 2
4 3
```
Expected output:
```
9
```
Found output:
```
-1
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The discrepancy between the expected and found result suggests that there might be a logical issue with the algorithm. Let's analyze the problem again:

1. We need to find the shortest path from story 1 to story p without the zmeu losing all its heads.
2. The graph of stories is directed and can contain cycles, which means we need to consider the possibility of visiting a story more than once, but with a different number of heads. This invalidates the use of a topological sort, as it is intended for acyclic graphs.
3. We have a constraint that certain stories cannot be followed by others.

Given these conditions, we need to modify our approach. We can use a variant of Dijkstra's algorithm specifically designed for this problem, to keep track of the minimum time required to tell each story while maintaining enough heads to continue.

Let's rewrite the solution considering these points:

```cpp
#include <fstream>
#include <vector>
#include <queue>
#include <algorithm>
#include <climits>

using namespace std;

const int MAX_P = 201;
const int MAX_N = 501;
const int INF = INT_MAX;

struct Story {
    int duration, headsCut;
};

struct Node {
    int story, heads, time;
    bool operator<(const Node& o) const {
        return time > o.time;
    }
};

int main() {
    ifstream fin("zmeu.in");
    ofstream fout("zmeu.out");

    int n, p, k;
    fin >> n >> p >> k;
    vector<Story> stories(p + 1);
    for (int i = 1; i <= p; i++) {
        fin >> stories[i].duration >> stories[i].headsCut;
    }

    vector<vector<int>> graph(p + 1);
    for (int i = 0, a, b; i < k; i++) {
        fin >> a >> b;
        graph[a].push_back(b);
    }

    vector<vector<int>> time(p + 1, vector<int>(n + 1, INF));
    priority_queue<Node> pq;
    time[1][n - stories[1].headsCut] = stories[1].duration;
    pq.push({1, n - stories[1].headsCut, stories[1].duration});

    while (!pq.empty()) {
        Node current = pq.top();
        pq.pop();

        if (current.story == p) {
            fout << current.time << "\n";
            return 0;
        }

        for (int next : graph[current.story]) {
            int nextHeads = current.heads - stories[next].headsCut;
            if (nextHeads <= 0) continue;  // Not enough heads to continue to the next story

            int nextTime = current.time + stories[next].duration;
            if (nextTime < time[next][nextHeads]) {
                time[next][nextHeads] = nextTime;
                pq.push({next, nextHeads, nextTime});
            }
        }
    }

    fout << -1 << "\n";  // No path was found

    fin.close();
    fout.close();
    return 0;
}
```

In this revised solution, we use a priority queue to keep track of the current state of the zmeu (i.e., the current story, number of heads left, and time spent) and process the stories in the order of increasing time. The `time` vector keeps track of the minimum time to reach each story with a given number of heads remaining. If we can reach the last story with at least one head remaining, we output the corresponding time; otherwise, we output `-1`. This algorithm ensures that we find the shortest path that observes the constraints on the order in which stories can be told.
---------- user ----------


Program result did not match expected result.
Input data:
```
10 4 2
2 6
4 0
1 3
3 3
3 2
4 3
```
Expected output:
```
9
```
Found output:
```
-1
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The reason for the incorrect output appears to be a flaw in the current approach to the problem. The algorithm needs to consider not just the shortest path by time but also the constraints of the story sequence and the condition that the zmeu must end with at least one head remaining. If we're reaching the last story without satisfying this condition, the algorithm should continue searching for other possible paths.

Let's reconsider the algorithm and fix the implementation:

1. We will use a breadth-first search (BFS) approach.
2. We need to maintain a queue of states, where each state consists of the current story, the remaining number of heads, and the total time spent so far.
3. When processing each state, we will check all possible next stories that can follow.
4. We will use a visited array to keep track of the minimum time visited for each story with a given number of heads.
5. The search continues until we either find the end story with at least one head or exhaust all possibilities.

Here's the corrected solution:

```cpp
#include <fstream>
#include <vector>
#include <queue>
#include <cstring>

using namespace std;

const int MAX_P = 201;
const int MAX_N = 501;
const int INF = INT_MAX;

struct Story {
    int duration, headsCut;
};

struct State {
    int story, heads, time;
};

int n, p, k;
Story stories[MAX_P];
vector<int> graph[MAX_P];
int visited[MAX_P][MAX_N]; // To keep track of the best time we reached a story with a certain number of heads

int main() {
    ifstream fin("zmeu.in");
    ofstream fout("zmeu.out");

    fin >> n >> p >> k;
    for (int i = 1; i <= p; i++) {
        fin >> stories[i].duration >> stories[i].headsCut;
    }

    while (k--) {
        int a, b;
        fin >> a >> b;
        graph[a].push_back(b);
    }

    memset(visited, -1, sizeof(visited));
    queue<State> q;

    // Start from the first story with n heads
    q.push({1, n - stories[1].headsCut, stories[1].duration});
    visited[1][n - stories[1].headsCut] = stories[1].duration;

    while (!q.empty()) {
        State current = q.front();
        q.pop();

        // If we're at the last story and have heads left, we can end here
        if (current.story == p && current.heads > 0) {
            fout << current.time << "\n";
            return 0;
        }

        // Try all possible next stories
        for (int next : graph[current.story]) {
            int nextHeads = current.heads - stories[next].headsCut;
            int nextTime = current.time + stories[next].duration;

            // Only consider valid states where we haven't been with more time before
            if (nextHeads > 0 && (visited[next][nextHeads] == -1 || visited[next][nextHeads] > nextTime)) {
                visited[next][nextHeads] = nextTime;
                q.push({next, nextHeads, nextTime});
            }
        }
    }

    // If we haven't found a path, return -1
    fout << -1 << "\n";

    fin.close();
    fout.close();
    return 0;
}
```
This solution maintains a queue to process states, represented by the story number, remaining heads, and time taken. We traverse the graph of stories and keep track of the visited states, ensuring that we only process states that are better (i.e., take less time) than previously visited ones. We continue searching until we find a valid path or determine that no path exists, at which point we return -1.
