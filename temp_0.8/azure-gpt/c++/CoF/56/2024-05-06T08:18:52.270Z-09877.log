---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `zmeu.in` and write to `zmeu.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Un zmeu cu $n$ capete călătoreşte din poveste în poveste, iar în poveştile tradiţionale întâlneşte câte un Făt Frumos care-l mai scurtează de câteva capete, în timp ce în poveştile moderne salvează omenirea mâncând în timp record, cu toate capetele lui, insecte ucigaşe apărute prin mutaţii genetice. Într-o seară, el îşi planifică o succesiune de poveşti cărora să le dea viaţă. El ştie $p$ poveşti numerotate de la $1$ la $p$, durata fiecăreia şi numărul de capete pe care le pierde în fiecare poveste. Mai ştie o mulţime de $k$ perechi de poveşti, semnificând faptul că a doua poveste din pereche nu poate fi spusă după prima poveste din pereche.

# Cerinţă
Ştiind că trebuie să înceapă cu povestea $1$ şi să încheie succesiunea cu povestea $p$, ajutaţi bietul zmeu să aleagă una sau mai multe poveşti intermediare astfel încât durata totală să fie minimă şi să rămână cu cel puţin un cap la sfârşitul tuturor poveştilor.

# Date de intrare
Fişierul de intrare `zmeu.in` conţine pe prima linie numerele $n, p$ şi $k$ despărţite prin câte un spaţiu. Pe fiecare din următoarele $p$ linii se află câte o pereche de numere $d_i$ şi $c_i$ (separate prin câte un spaţiu) ce reprezintă durata şi numărul de capete tăiate pentru fiecare poveste. Iar pe ultimele $k$ linii se află câte o pereche de numere $p_i$ şi $p_j$ (separate prin câte un spaţiu) ce semnifică faptul că povestea $p_j$ nu poate fi spusă după povestea $p_i$.

# Date de ieşire
Fişierul de ieşire `zmeu.out` conţine o singură linie pe care se află un număr natural reprezentând durata (minimă) a succesiunii de poveşti sau valoarea $–1$ dacă nu există o astfel de succesiune.

# Restricţii şi precizări
* $2 ≤ N ≤ 500$
* $1 ≤ P ≤ 200$
* $1 ≤ k ≤ 30 \ 000$
* Valorile reprezentând duratele şi numărul de capete sunt numere naturale (duratele fiind strict pozitive), nedepăşind valoarea $10$.

---

Example:
`zmeu.in`
```
10 4 2
2 6
4 0
1 3
3 3
3 2
4 3
```

`zmeu.out`
```
9
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```cpp
#include <fstream>
#include <vector>
#include <queue>
#include <cstring>

using namespace std;

struct Edge {
    int to, weight, headsLost;
};

const int MAX_P = 201;
const int MAX_N = 501;
const int INF = 2000; // MAX_P * max duration (10), as the max possible duration
int n, p, k;
vector<Edge> graph[MAX_P];
int dist[MAX_N][MAX_P]; // dist[remainingHeads][story]

void readInput(const char* filename) {
    ifstream fin(filename);
    fin >> n >> p >> k;
    int d, c;
    for (int i = 1; i <= p; ++i) {
        fin >> d >> c;
        graph[i].push_back({i, d, c});
    }
    int pi, pj;
    for (int i = 0; i < k; ++i) {
        fin >> pi >> pj;
        graph[pi].push_back({pj, 0, 0}); // no weight, no heads lost for constraints
    }
    fin.close();
}

void writeOutput(const char* filename, int answer) {
    ofstream fout(filename);
    fout << answer << endl;
    fout.close();
}

void dijkstra() {
    for (int i = 0; i <= n; ++i) {
        for (int j = 1; j <= p; ++j) {
            dist[i][j] = INF;
        }
    }

    priority_queue<pair<int, pair<int, int>>> pq; // (-duration, (remainingHeads, story))
    dist[n][1] = 0;
    pq.push({0, {n, 1}});

    while (!pq.empty()) {
        int duration = -pq.top().first;
        int heads = pq.top().second.first;
        int story = pq.top().second.second;
        pq.pop();

        if (dist[heads][story] < duration) continue;

        for (auto &e : graph[story]) {
            int nextStory = e.to;
            int nextDuration = duration + e.weight;
            int nextHeads = heads - e.headsLost;

            if (nextHeads >= 0 && dist[nextHeads][nextStory] > nextDuration) {
                dist[nextHeads][nextStory] = nextDuration;
                pq.push({-nextDuration, {nextHeads, nextStory}});
            }
        }
    }
}

int main() {
    readInput("zmeu.in");

    dijkstra();

    int answer = INF;
    for (int i = 1; i <= n; ++i) {
        if (dist[i][p] < answer) {
            answer = dist[i][p];
        }
    }

    writeOutput("zmeu.out", answer == INF ? -1 : answer);

    return 0;
}
```
---------- user ----------


Program result did not match expected result.
Input data:
```
10 4 2
2 6
4 0
1 3
3 3
3 2
4 3
```
Expected output:
```
9
```
Found output:
```
-1
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
