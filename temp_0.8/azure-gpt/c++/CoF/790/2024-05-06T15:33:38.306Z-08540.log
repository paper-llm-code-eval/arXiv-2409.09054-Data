---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `235.in` and write to `235.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Definim o putere a lui $3$ un număr de forma $3^k$, ($k$ număr natural strict pozitiv), o putere a lui $5$ un număr de forma $5^k$ (k număr natural strict pozitiv), iar o putere a lui $2$ un număr de forma $2^k$ ($k$ număr natural strict pozitiv).
Se dă un șir de $n$ numere naturale. Plecând de la acest șir, formăm un nou șir prin eliminarea tuturor numerele care nu sunt puteri ale lui $3$ și nici puteri ale lui $5$. Ordinea relativă între numerele care nu sunt eliminate se păstrează.

# Cerințe

- Să se determine câte numere conține șirul nou format.
- Să se determine de asemenea numărul de secvențe având lungimea egală cu o putere a lui $2$ existente în șirul nou format în care numărul de puteri ale lui $3$ este egal cu numărul de puteri ale lui $5$. O secvență este formată din elemente aflate pe poziții consecutive în acest șir nou format, iar lungimea unei secvențe este egală cu numărul de elemente pe care aceasta îl conține.

# Date de intrare

Pe prima linie in fișierul `235.in` se afla un număr natural $n$. Pe fiecare dintre următoarele $n$ linii câte un număr natural mai mare decât $1$ reprezentând numerele șirului inițial.

# Date de ieșire

Pe prima linie a fișierului `235.out` se va afla o valoare naturală $m$ care va reprezenta numărul de elemente rămase în șir după eliminare. Pe a doua linie se va afla o valoare naturală $S$ reprezentând numărul de secvențe din șirul nou format care au proprietățile cerute.

# Restricții și precizări

* $2 \leq n \leq 500 \ 000$;
* Numerele din șirul inițial sunt numere naturale din intervalul [$2, 2 \cdot 10^9$].
* Se garantează că $m \leq 40 \ 000$; pentru fiecare set de date de intrare.
* Pentru determinarea corectă a valorii numărului $m$ se acordă $30$% din punctaj iar pentru determinarea corectă a ambelor valori ($m$ şi $s$) se acordă $100$% din punctaj.

---

Example:
`235.in`
```
8
625
125
5
9
15
81
100
125
```

`235.out`
```
6
4
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```cpp
#include <fstream>
#include <vector>
#include <cmath>

bool is_power_of(int n, int base) {
    double log_res = std::log(n) / std::log(base);
    return std::abs(log_res - std::round(log_res)) < 1e-10;
}

bool is_power_of_2(int n) {
    return n && !(n & (n - 1));
}

int main() {
    std::ifstream fin("235.in");
    std::ofstream fout("235.out");
    
    int n, x, power_of_3_count = 0, power_of_5_count = 0, total_count = 0, seq_count = 0;
    fin >> n;
    std::vector<int> valid_numbers;

    while (n--) {
        fin >> x;
        if (is_power_of(x, 3) || is_power_of(x, 5)) {
            valid_numbers.push_back(x);
            if (is_power_of(x, 3))
                power_of_3_count++;
            else
                power_of_5_count++;
        }
    }

    total_count = valid_numbers.size();
    
    for (int len = 2; len <= total_count; len <<= 1) {
        int local_3_count = 0, local_5_count = 0;
        for (int i = 0; i < len; ++i) {
            if (is_power_of(valid_numbers[i], 3)) 
                local_3_count++;
            else 
                local_5_count++;
        }
        if (local_3_count == local_5_count) 
            seq_count++;
            
        for (int i = len; i < total_count; ++i) {
            if (is_power_of(valid_numbers[i - len], 3)) 
                local_3_count--;
            else 
                local_5_count--;
                
            if (is_power_of(valid_numbers[i], 3)) 
                local_3_count++;
            else 
                local_5_count++;
                
            if (local_3_count == local_5_count) 
                seq_count++;
        }
    }
    
    fout << total_count << std::endl;
    fout << seq_count << std::endl;
    
    fin.close();
    fout.close();
    
    return 0;
}
```

This program reads the input from `235.in`, processes the sequence according to the given constraints, and writes the output to `235.out`. It uses file streams (`ifstream` and `ofstream`) for file I/O, and it avoids using `cin`, `cout`, `printf`, and `scanf`. It reads the numbers, filters out those that are not powers of 3 or 5, checks for sequences of length power of 2 where the number of powers of 3 is equal to the number of powers of 5, and writes the final counts to the output file.
