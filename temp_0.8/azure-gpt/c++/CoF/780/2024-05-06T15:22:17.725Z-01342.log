---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `colaj.in` and write to `colaj.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

La etapa finală a **_Concursului pe Echipe al Micilor Artişti_**, pe primul loc s-au clasat două echipe $A$ şi $B$, cu acelaşi punctaj. Comisia de Evaluare, pentru a le departaja, a introdus o nouă probă de baraj care vizează atât talentul copiilor, cât şi isteţimea lor. 

Astfel, echipa $A$ trebuie să realizeze un colaj alb-negru având la dispoziţie o planşă dreptunghiulară de culoare albă şi n dreptunghiuri de culoare neagră. Membrii acestei echipe vor trebui să lipească pe planşă toate dreptunghiurile, cu laturile paralele cu laturile planşei. Pot exista şi dreptunghiuri lipite în interiorul altui dreptunghi, sau dreptunghiuri care se intersectează, sau dreptunghiuri cu laturi pe laturile planşei, precum şi suprafeţe din planşă neacoperite cu dreptunghiuri. 

După ce aşează toate dreptunghiurile, membrii echipei $A$ trebuie să comunice echipei $B$ numărul $n$ de dreptunghiuri negre primite, lungimea m a laturii orizontale a planşei, lungimea $p$ a laturii verticale a planşei, şi coordonatele vârfurilor din stânga-jos şi dreapta-sus ale fiecărui dreptunghi de pe planşă (coordonate referitoare la reperul cartezian $xOy$ cu originea $O$ în colţul din stânga-jos a planşei şi cu axa de coordonate $Ox$, respectiv $Oy$, pe dreapta suport a laturii orizontale, respectiv a laturii verticale a planşei). 

Pentru a câştiga concursul, echipa $B$ trebuie să ghicească numărul zonelor continue maximale de culoare albă, conţinute de colajul realizat de echipa $A$. O zonă albă este considerată continuă dacă oricare ar fi două puncte $P, Q$ din zona respectivă, se poate uni punctul $P$ de punctul $Q$ printr-o linie dreaptă sau frântă care să nu intersecteze interiorul nici unui dreptunghi negru. O zonă albă continuă este considerată maximală dacă nu există o altă zonă albă continuă de arie mai mare care să includă zona respectivă.

# Cerinţă

Scrieţi un program care să citească numărul n al dreptunghiurilor negre primite de echipa $A$, lungimile $m$ şi $p$ ale laturilor planşei, coordonatele vârfurilor din stânga-jos şi dreapta-sus ale fiecărui dreptunghi negru primit, şi care să determine numărul zonelor continue maximale de culoare albă  existente în colajul realizat de echipa $A$.

# Date de intrare


Fişierul de intrare `colaj.in` conţine:
- pe prima linie, o valoare naturală $n$, reprezentând numărul de dreptunghiuri negre date echipei $A$
-	pe a doua linie, $2$ numere naturale, separate prin spaţiu, reprezentând lungimile laturilor planşei
-	următoarele $n$ linii conţin câte patru numere naturale, separate prin câte un spaţiu, care reprezintă coordonatele $(a_1,b_1)$ şi $(c_1,d_1)$ ale vârfurilor din stânga-jos şi dreapta-sus ale primului dreptunghi,..., coordonatele $(a_n,b_n)$ şi $(c_n,d_n)$ ale vârfurilor din stânga-jos şi dreapta-sus ale celui de-al $n$-lea dreptunghi. 


# Date de ieșire


Fişierul de ieşire `colaj.out` va conţine o singură linie pe care se va scrie un singur număr natural reprezentând numărul zonelor continue maximale de culoare albă, conţinute de colaj.

# Restricții și precizări

* $1 \leq n \leq 100$
* $a_1 < c_1 \leq m, \ a_2 < c_2 \leq m, ..., \ a_n < c_n \leq m$
* $b_1 < d_1 \leq p, \ b_2 < d_2 \leq p, ..., \ b_n < d_n \leq p$
* Toate coordonatele vârfurilor dreptunghiurilor şi lungimile laturilor planşei sunt numere naturale, $0<m,p<8 \ 000$ 
* Dacă $(x,y)$ şi $(z,t)$ sunt coordonatele a două vârfuri din două dreptunghiuri distincte, atunci: $x≠z$ şi $y≠t$.
* În $40\%$ din teste:  $n < 30,  m \leq 180,  p \leq 180$
* în $40\%$ din teste: $70 \leq n \leq 100, 180 < p < 1 \ 000, 180 < m < 1 \ 000$
* în $20\%$ din teste: $50 < n < 80, 7 \ 000 < m < 8 \ 000, 7 \ 000 < p < 8 \ 000$

---

Example:
`colaj.in`
```
7
17 16
1 1 10 5
2 6 8 8
0 9 17 15
3 2 4 11
5 3 6 12
7 4 12 13
14 10 16 14
```

`colaj.out`
```
6
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```cpp
#include <fstream>
#include <vector>
#include <algorithm>

using namespace std;

struct Segment {
    int y, x1, x2, type;
};

bool operator<(const Segment& a, const Segment& b) {
    return a.y < b.y || (a.y == b.y && a.type < b.type);
}

int main() {
    ifstream fin("colaj.in");
    ofstream fout("colaj.out");

    int n, m, p, a, b, c, d;
    fin >> n >> m >> p;
    vector<Segment> segments;

    for (int i = 0; i < n; ++i) {
        fin >> a >> b >> c >> d;
        segments.push_back({b, a, c, 1}); // start of black rectangle
        segments.push_back({d, a, c, -1}); // end of black rectangle
    }
    
    // Sort the segments by Y-coordinate and type (start before end for same Y)
    sort(segments.begin(), segments.end());

    vector<int> sweepLine(m+1, 0);
    int whiteAreas = 0, activeSegments = 0;
    
    for (size_t i = 0; i < segments.size(); ++i) {
        const auto& seg = segments[i];
        int coverage = 0;

        // Update the sweep line coverage
        for (int x = seg.x1; x < seg.x2; ++x) {
            sweepLine[x] += seg.type;
            coverage += (sweepLine[x] == 0); // was white before this segment
        }

        // Count white areas if this segment started a new black rectangle
        if (seg.type == 1) {
            whiteAreas += (coverage > 0); // adds 1 if there was any white space before
            ++activeSegments;
        }

        // Check if there's no more segments or if the next Y is different
        if (i == segments.size() - 1 || segments[i + 1].y != seg.y) {
            // If no currently active segments, add one for the white space
            if (activeSegments == 0) {
                whiteAreas += 1;
            }
            activeSegments = 0; // reset active segments
        }
    }

    fout << whiteAreas << '\n';

    fin.close();
    fout.close();

    return 0;
}
```
This C++ code solves the problem by sweeping a line across the given rectangles and counting the number of maximal white areas. It uses segment-based sweep line algorithm where segments represent the start and end of black rectangles along the y-axis. The code reads the input from "colaj.in" and writes the output to "colaj.out".
---------- user ----------


Program result did not match expected result.
Input data:
```
7
17 16
1 1 10 5
2 6 8 8
0 9 17 15
3 2 4 11
5 3 6 12
7 4 12 13
14 10 16 14
```
Expected output:
```
6
```
Found output:
```
7
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

It seems that the original solution was flawed in the way it handled the sweep line algorithm. It did not correctly track the transitions between covered and uncovered areas. Let's rewrite the solution to correctly identify maximal white areas.

We will use a sweep-line algorithm, sweeping from top to bottom, and the line status will be represented by a segment tree to count the number of continuous white segments (uncovered by black rectangles) along the horizontal line.

Here is the revised solution:

```cpp
#include <fstream>
#include <algorithm>
#include <set>

using namespace std;

struct Rectangle {
    int x1, y1, x2, y2;
};

struct Event {
    int x, y1, y2, type;
};

bool operator<(const Event &a, const Event &b) {
    return (a.x < b.x) || (a.x == b.x && a.type > b.type);
}

int main() {
    ifstream fin("colaj.in");
    ofstream fout("colaj.out");

    int n, m, p;
    fin >> n >> m >> p;

    vector<Event> events;
    set<int> ys;
    
    for (int i = 0; i < n; ++i) {
        Rectangle rect;
        fin >> rect.x1 >> rect.y1 >> rect.x2 >> rect.y2;
        events.push_back({rect.x1, rect.y1, rect.y2, 1}); // Rectangle starts
        events.push_back({rect.x2, rect.y1, rect.y2, -1}); // Rectangle ends
        ys.insert(rect.y1);
        ys.insert(rect.y2);
    }

    vector<int> y_coords(ys.begin(), ys.end());
    
    sort(events.begin(), events.end());

    int last_x = 0, whiteAreas = 0;
    vector<int> activeSegments(y_coords.size() - 1, 0);
    
    for (auto &event : events) {
        int deltaY = 0;
        for (size_t i = 0; i < activeSegments.size(); ++i) {
            if (activeSegments[i] == 0) {
                deltaY += y_coords[i+1] - y_coords[i];
            }
        }
        if (deltaY > 0 && event.x > last_x) {
            ++whiteAreas;
        }
        last_x = event.x;
        
        int y1_idx = lower_bound(y_coords.begin(), y_coords.end(), event.y1) - y_coords.begin();
        int y2_idx = lower_bound(y_coords.begin(), y_coords.end(), event.y2) - y_coords.begin();
        
        for (int i = y1_idx; i < y2_idx; ++i) {
            activeSegments[i] += event.type;
        }
    }
    
    fout << whiteAreas << '\n';

    fin.close();
    fout.close();

    return 0;
}
```

In this revised solution, we use events to mark the start and end of rectangles, and we sweep through these events to count the number of white areas. We also maintain a set of y-coordinates to help us easily determine where the horizontal segments begin and end. The white area count is increased when we transition from a section with non-zero deltaY (indicating an uncovered area) to a section where rectangles overlap or the edge of the board is reached.
---------- user ----------


Program result did not match expected result.
Input data:
```
7
17 16
1 1 10 5
2 6 8 8
0 9 17 15
3 2 4 11
5 3 6 12
7 4 12 13
14 10 16 14
```
Expected output:
```
6
```
Found output:
```
9
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The previous solution did not correctly account for the maximal white areas, particularly when dealing with overlapping and adjacent rectangles. The sweep line algorithm needs to properly merge adjacent areas and not count overlapping regions multiple times.

We will fix the issue by using a different approach. Specifically, we will keep track of the active intervals using a line sweep algorithm and update the number of continuous white spaces accordingly.

Here's the updated solution incorporating these changes:

```cpp
#include <fstream>
#include <vector>
#include <algorithm>

using namespace std;

struct Event {
    int x, y1, y2, delta;
    bool operator<(const Event &other) const {
        return x < other.x || (x == other.x && delta > other.delta);
    }
};

void update_active(vector<int> &active, int y1, int y2, int delta, vector<pair<int, int>> &ys) {
    for (size_t i = 0; i < ys.size(); ++i) {
        if (ys[i].first >= y2) break;
        if (ys[i].second <= y1) continue;
        active[i] += delta;
    }
}

int main() {
    ifstream fin("colaj.in");
    ofstream fout("colaj.out");

    int n, m, p;
    fin >> n >> m >> p;

    vector<Event> events;
    set<int> coords; // Set to hold the unique y-coordinates

    for (int i = 0; i < n; ++i) {
        int x1, y1, x2, y2;
        fin >> x1 >> y1 >> x2 >> y2;
        events.push_back({x1, y1, y2, 1}); // Rectangle start event
        events.push_back({x2, y1, y2, -1}); // Rectangle end event
        coords.insert(y1);
        coords.insert(y2);
    }
    
    vector<pair<int, int>> ys;
    int last = 0;
    for (int y : coords) {
        if (last != y) ys.push_back({last, y});
        last = y;
    }
    
    sort(events.begin(), events.end());
    
    vector<int> active(ys.size(), 0); // Track active intervals
    int count = 0, cur_x = 0;

    for (auto &e : events) {
        int num_active = 0;
        for (size_t i = 0; i < ys.size(); ++i) {
            if (active[i] == 0) { 
                num_active += ys[i].second - ys[i].first;
            }
        }

        if (num_active > 0 && cur_x != e.x) {
            count++;
        }
        update_active(active, e.y1, e.y2, e.delta, ys);
        cur_x = e.x;
    }
    
    fout << count << '\n';

    fin.close();
    fout.close();

    return 0;
}
```

In this solution, we maintain a vector `ys` to track the segments of the y-axis between unique y-coordinates of the rectangles. The `active` vector indicates how many rectangles cover each segment. The `update_active` function is used to update the `active` vector when we encounter start and end events of rectangles. The main loop computes the number of active white areas and increments the `count` whenever we encounter an uncovered area between events.
---------- user ----------


Failed to compile the program.
```
main.cpp: In function 'int main()':
main.cpp:30:5: error: 'set' was not declared in this scope
   30 |     set<int> coords; // Set to hold the unique y-coordinates
      |     ^~~
main.cpp:4:1: note: 'std::set' is defined in header '<set>'; did you forget to '#include <set>'?
    3 | #include <algorithm>
  +++ |+#include <set>
    4 | 
main.cpp:30:9: error: expected primary-expression before 'int'
   30 |     set<int> coords; // Set to hold the unique y-coordinates
      |         ^~~
main.cpp:37:9: error: 'coords' was not declared in this scope
   37 |         coords.insert(y1);
      |         ^~~~~~
main.cpp:43:18: error: 'coords' was not declared in this scope
   43 |     for (int y : coords) {
      |                  ^~~~~~

```

Evaluate the error message. Think of a solution to fix the program and return the entire source code with the fix.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The error message indicates that the `set` header was not included. The `set` type and the `coords` variable are not recognized. To fix the issue, we need to include the `<set>` header at the beginning of the program. Here's the corrected source code:

```cpp
#include <fstream>
#include <vector>
#include <algorithm>
#include <set> // Include for std::set

using namespace std;

struct Event {
    int x, y1, y2, delta;
    bool operator<(const Event &other) const {
        return x < other.x || (x == other.x && delta > other.delta);
    }
};

void update_active(vector<int> &active, int y1, int y2, int delta, vector<pair<int, int>> &ys) {
    for (size_t i = 0; i < ys.size(); ++i) {
        if (ys[i].first >= y2) break;
        if (ys[i].second <= y1) continue;
        active[i] += delta;
    }
}

int main() {
    ifstream fin("colaj.in");
    ofstream fout("colaj.out");

    int n, m, p;
    fin >> n >> m >> p;

    vector<Event> events;
    set<int> coords; // Set to hold the unique y-coordinates

    for (int i = 0; i < n; ++i) {
        int x1, y1, x2, y2;
        fin >> x1 >> y1 >> x2 >> y2;
        events.push_back({x1, y1, y2, 1}); // Rectangle start event
        events.push_back({x2, y1, y2, -1}); // Rectangle end event
        coords.insert(y1);
        coords.insert(y2);
    }
    
    vector<pair<int, int>> ys;
    int last = 0;
    for (int y : coords) {
        if (last != y) ys.push_back({last, y});
        last = y;
    }
    
    sort(events.begin(), events.end());
    
    vector<int> active(ys.size(), 0); // Track active intervals
    int count = 0, cur_x = 0;

    for (auto &e : events) {
        int num_active = 0;
        for (size_t i = 0; i < ys.size(); ++i) {
            if (active[i] == 0) { 
                num_active += ys[i].second - ys[i].first;
            }
        }

        if (num_active > 0 && cur_x != e.x) {
            count++;
        }
        update_active(active, e.y1, e.y2, e.delta, ys);
        cur_x = e.x;
    }
    
    fout << count << '\n';

    fin.close();
    fout.close();

    return 0;
}
```

This code should now compile without issue since it properly includes all necessary headers, including `<set>` for using the `std::set` container.
---------- user ----------


Program result did not match expected result.
Input data:
```
7
17 16
1 1 10 5
2 6 8 8
0 9 17 15
3 2 4 11
5 3 6 12
7 4 12 13
14 10 16 14
```
Expected output:
```
6
```
Found output:
```
13
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The previous solution still did not correctly handle counting the maximal continuous white areas. One key complexity in the problem is that a white area can be bounded not only by the start and end of black rectangles but also by their sides.

To solve this, we need to improve the algorithm to correctly merge adjacent areas and count only the maximal continuous regions. We will use a scanline algorithm with active segments represented as a binary indexed tree (BIT) or Fenwick tree to efficiently query and update the covered intervals.

Here's the corrected solution:

```cpp
#include <fstream>
#include <vector>
#include <algorithm>
#include <set>

using namespace std;

struct Event {
    int x, y1, y2, type;
};

struct Rectangle {
    int x1, y1, x2, y2;
};

int maxVal;
vector<int> bit;

void update(int idx, int val) {
    while (idx <= maxVal) {
        bit[idx] += val;
        idx += (idx & -idx);
    }
}

int query(int idx) {
    int sum = 0;
    while (idx > 0) {
        sum += bit[idx];
        idx -= (idx & -idx);
    }
    return sum;
}

int main() {
    ifstream fin("colaj.in");
    ofstream fout("colaj.out");

    int n, m, p;
    fin >> n >> m >> p;

    vector<Event> events;
    set<int> ys;

    for (int i = 0; i < n; ++i) {
        int x1, y1, x2, y2;
        fin >> x1 >> y1 >> x2 >> y2;
        events.push_back({x1, y1, y2, 1});
        events.push_back({x2, y1, y2, -1});
        ys.insert(y1);
        ys.insert(y2);
    }

    vector<int> ySorted(ys.begin(), ys.end());
    maxVal = ySorted.size();
    bit.assign(maxVal + 1, 0);

    sort(events.begin(), events.end(), [](const Event &a, const Event &b) {
        if (a.x == b.x) return a.type > b.type;
        return a.x < b.x;
    });

    int whiteAreas = 0;
    for (size_t i = 0; i < events.size(); ++i) {
        int y1 = lower_bound(ySorted.begin(), ySorted.end(), events[i].y1) - ySorted.begin() + 1;
        int y2 = lower_bound(ySorted.begin(), ySorted.end(), events[i].y2) - ySorted.begin();

        if (events[i].type == 1) {
            if (query(y1) == 0 && (i == 0 || events[i - 1].x != events[i].x)) {
                whiteAreas++;
            }
            for (int j = y1; j <= y2; ++j) {
                update(j, 1);
            }
        } else {
            for (int j = y1; j <= y2; ++j) {
                update(j, -1);
            }
        }
    }

    fout << whiteAreas << '\n';

    fin.close();
    fout.close();

    return 0;
}
```

In this code, `bit` is a binary indexed tree that is used to maintain the number of rectangles covering each y-coordinate. When we reach the start of a new rectangle (`type == 1`), we check if the current y interval `[y1, y2]` has no rectangles covering it. If it has no coverage, it means we've found a new maximal white area, and we increment `whiteAreas`. Then we update the BIT for the new coverage. When we reach the end of a rectangle (`type == -1`), we simply update the BIT to remove the coverage.

This solution should now correctly count the number of maximal white areas.
---------- user ----------


Program result did not match expected result.
Input data:
```
7
17 16
1 1 10 5
2 6 8 8
0 9 17 15
3 2 4 11
5 3 6 12
7 4 12 13
14 10 16 14
```
Expected output:
```
6
```
Found output:
```
2
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The previous solution still does not correctly manage the counting of maximal white areas. The difficulty seems to stem from handling the vertical sides of rectangles correctly, as well as merging adjacent white areas into a single continuous white area.

To correctly solve this problem, we must consider the vertical edges of the rectangles as events, and while sweeping horizontally, we should keep track of the changes in the vertical intervals.

Here's the corrected solution using a sweep-line algorithm with a set to keep track of the active vertical intervals:

```cpp
#include <fstream>
#include <vector>
#include <algorithm>
#include <set>

using namespace std;

struct Event {
    int x, y1, y2, type;
};

bool operator<(const Event& a, const Event& b) {
    if (a.x == b.x) return a.type < b.type;
    return a.x < b.x;
}

int main() {
    ifstream fin("colaj.in");
    ofstream fout("colaj.out");

    int n, m, p;
    fin >> n >> m >> p;

    vector<Event> events;
    for (int i = 0; i < n; ++i) {
        int x1, y1, x2, y2;
        fin >> x1 >> y1 >> x2 >> y2;
        events.push_back({x1, y1, y2, 1}); // Rectangle start event
        events.push_back({x2, y1, y2, -1}); // Rectangle end event
    }

    sort(events.begin(), events.end());

    set<pair<int, int>> activeIntervals;
    int countWhiteAreas = 0;
    for (size_t i = 0; i < events.size(); ++i) {
        int x = events[i].x, y1 = events[i].y1, y2 = events[i].y2, type = events[i].type;

        if (type == 1) { // Starting a rectangle
            if (activeIntervals.empty() || (--activeIntervals.lower_bound({y1, 0}))->second < y1) {
                ++countWhiteAreas;  // This is a new white area if no overlap
            }
            activeIntervals.insert({y1, y2});
        } else { // Ending a rectangle
            auto it = activeIntervals.lower_bound({y1, y2});
            activeIntervals.erase(it);
            if (activeIntervals.empty() || activeIntervals.lower_bound({y1, 0})->first > y2) {
                if (i + 1 < events.size() && events[i + 1].x != x) {
                    ++countWhiteAreas;  // This is a new white area if no adjacent rectangle
                }
            }
        }
    }

    fout << countWhiteAreas << '\n';

    fin.close();
    fout.close();

    return 0;
}
```

In this code, we process events ordered by their x-coordinate (horizontal lines). When we start a rectangle (type == 1), we check if this rectangle creates a new white area by checking if there are any active intervals overlapping the new interval's y1 coordinate. If not, we increment the white area count. When we end a rectangle (type == -1), we remove the interval from the active set and check if it ends a white area by checking if there are any adjacent intervals. If not, and if the next event is not at the same x-coordinate, we increment the white area count.

This approach should correctly count the white areas, including all maximal continuous white regions, and handle the complexity of rectangles sharing edges correctly.
---------- user ----------


Program result did not match expected result.
Input data:
```
7
17 16
1 1 10 5
2 6 8 8
0 9 17 15
3 2 4 11
5 3 6 12
7 4 12 13
14 10 16 14
```
Expected output:
```
6
```
Found output:
```
3
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The previous solutions were incorrect because they did not account for the complexity of the problem, which involves determining the maximal continuous white areas while handling overlapping and adjacent black rectangles properly. This problem is akin to a two-dimensional version of the classic line sweep algorithm often used for rectangle intersection problems.

A correct approach would involve sweeping across the x-axis and keeping track of the vertical edges of rectangles as they appear and disappear from the sweep line. We would then need to maintain a data structure that allows us to quickly determine whether adding or removing an edge creates or eliminates a white area.

To achieve this, we will use a line sweep algorithm in combination with a set to track the active edges of the black rectangles. The set will help us identify when we have a continuous white space on the y-axis.

Let's rewrite the solution:

```cpp
#include <fstream>
#include <vector>
#include <algorithm>
#include <set>

using namespace std;

struct Event {
    int x, y, type;
};

int main() {
    ifstream fin("colaj.in");
    ofstream fout("colaj.out");

    int n, m, p;
    fin >> n >> m >> p;

    vector<Event> events;
    vector<int> ys; // This will be used for compression of y coordinates

    for (int i = 0; i < n; ++i) {
        int x1, y1, x2, y2;
        fin >> x1 >> y1 >> x2 >> y2;
        events.push_back({x1, y1, 1}); // Start of rectangle
        events.push_back({x1, y2, -1}); // End of rectangle
        events.push_back({x2, y1, -1}); // Start of white space
        events.push_back({x2, y2, 1}); // End of white space
        ys.push_back(y1);
        ys.push_back(y2);
    }

    // Compress y coordinates for efficient line sweep
    sort(ys.begin(), ys.end());
    ys.erase(unique(ys.begin(), ys.end()), ys.end());

    // Sort events by x coordinate
    sort(events.begin(), events.end(), [](const Event &a, const Event &b) {
        return a.x < b.x || (a.x == b.x && a.type < b.type);
    });

    int whiteAreas = 0;
    set<int> active;

    for (const Event &e : events) {
        // e.type == 1 means we are at the start of a rectangle
        // e.type == -1 means we are at the end of a rectangle or at the start of white space
        if (e.type == 1) {
            if (active.empty() || *active.rbegin() < e.y) {
                whiteAreas++; // Found a new white area
            }
            active.insert(e.y);
        } else {
            active.erase(e.y);
            if (active.empty() || *active.rbegin() < e.y) {
                whiteAreas++; // End of a rectangle or start of a new white area
            }
        }
    }

    fout << whiteAreas - 1 << '\n'; // Subtract 1 for the outermost white area

    fin.close();
    fout.close();

    return 0;
}
```

In this solution, we process start and end events for both black rectangles and potential white areas. By using a set, we can keep track of the current active y-coordinates we have encountered. When we insert a new y-coordinate, we check if it's higher than the current maximum in the set, which would indicate a new white area. Similarly, when we remove a y-coordinate and find the set empty or the next maximum lower than the removed y-coordinate, we know that we've ended a rectangle or started a new white area. Finally, we subtract 1 from the total count to exclude the white area surrounding all the rectangles.
