---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `culori.in` and write to `culori.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Pasiunea Mirunei este să coloreze. Vacanţa trecută şi-a petrecut-o la bunica ei la ţară şi pentru că se cam plictisea s-a gândit să vopsească gardul de la casa bunicii.

Gardul este compus din $N$ scânduri dispuse una lângă alta. Miruna a găsit în garajul bunicii $5$ cutii de vopsea de culori diferite: **albă**, **albastră**, **roşie**, **verde** şi **galbenă**. Când a vopsit gardul, Miruna a respectat următoarele reguli:
-	Dacă o scândură era vopsită cu **alb**, următoarea scândură o vopsea obligatoriu cu **albastru**
-	Dacă o scândură era vopsită cu **albastru**, atunci următoarea scândură o vopsea cu **alb** sau **roşu**
-	Dacă o scândură era vopsită cu **roşu**, atunci următoarea scândură o vopsea cu **albastru** sau **verde**
-	Dacă o scândură era vopsită cu **verde**, atunci următoarea scândură o vopsea cu **roșu** sau **galben**
-	Dacă o scândură era vopsită cu **galben**, atunci următoarea scândură o vopsea obligatoriu cu **verde**

După ce a și-a terminat treaba Miruna își admira “opera de artă” și se întreba în câte moduri diferite ar fi putut să vopsească gardul bunicii. 

# Cerinţă

Ajutați-o pe Miruna să găsească răspunsul la întrebarea sa.

# Date de intrare


Fişierul `culori.in` conţine pe prima sa linie un singur număr natural $N$.


# Date de ieșire


Fişierul de ieşire `culori.out` va conţine pe prima sa linie un singur număr întreg reprezentând numărul de moduri diferite în care Miruna ar fi putut să vopsească gardul bunicii.


# Restricții și precizări

* $1 \leq N \leq 5 \ 000$;
* Pentru $25\%$ dintre teste $N \leq 45$.

---

Example:
`culori.in`
```
4
```

`culori.out`
```
24
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```cpp
#include <fstream>
using namespace std;

long long dp[5001][5];

int main() {
    ifstream in("culori.in");
    ofstream out("culori.out");

    int N;
    in >> N;
    
    // Initialize our dp array
    dp[1][0] = dp[1][1] = dp[1][2] = dp[1][3] = dp[1][4] = 1;
    
    // Build up our dp table
    for (int i = 2; i <= N; ++i) {
        dp[i][0] = dp[i-1][1]; // White can only be followed by blue
        dp[i][1] = dp[i-1][0] + dp[i-1][2]; // Blue can be followed by white or red
        dp[i][2] = dp[i-1][1] + dp[i-1][3]; // Red can be followed by blue or green
        dp[i][3] = dp[i-1][2] + dp[i-1][4]; // Green can be followed by red or yellow
        dp[i][4] = dp[i-1][3]; // Yellow can only be followed by green
    }
    
    // Output the sum of all possibilities for the last plank
    long long result = dp[N][0] + dp[N][1] + dp[N][2] + dp[N][3] + dp[N][4];
    out << result << endl;

    in.close();
    out.close();
    return 0;
}
```
This C++ code reads the number of planks (N) from `culori.in` and writes the number of ways to paint the fence to `culori.out`. It uses dynamic programming (dp) to calculate the number of arrangements for each plank color and avoids using `cin`, `cout`, `printf`, or `scanf`.
