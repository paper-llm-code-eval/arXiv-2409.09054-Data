---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in python. The code must compile and be correct.
The solution must read from `tairos.in` and write to `tairos.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Se dă un arbore cu $N$ noduri, numerotate de la $1$ la $N$.

Arborele se va transforma astfel: la oricare etapă fiecare nod de gradul $1$ diferit de rădăcină din arborele actual se înlocuiește cu un arbore identic cu cel dat inițial, iar la următoarea etapă procedeul se va relua pentru arborele obținut, formându-se astfel un arbore infinit. În următoarele $3$ imagini se prezintă un exemplu de arbore dat inițial, arborele obținut după prima etapă de prelungire a frunzelor și arborele obținut după $2$ etape de prelungire a frunzelor.

~[tairos.jpg]

# Cerinţe
Să se determine câte noduri se află la distanță $D$ de rădăcina arborelui infinit.

# Date de intrare
Pe prima linie a fișierului de intrare `tairos.in` se va afla un număr natural $N$, reprezentând numărul de noduri din arborele dat inițial. Pe a doua linie se va afla numărul întreg $D$, cu semnificația de mai sus, iar fiecare dintre următoarele $N-1$ linii conține câte $2$ numere întregi $x$ și $y$ cu semnificația că în arborele dat inițíal există muchia $[x,y]$.

# Date de ieşire
Fișierul de ieșire `tairos.out` va conține un singur număr, și anume restul împărțirii numărului de noduri cerut la numărul $1 \ 000 \ 000 \ 007$.

# Restricţii și precizări
* $2 ≤ N ≤ 100$;
* $1 ≤ D ≤ 10 \ 000$;
* *Un arbore* este un graf neorientat, conex și fără cicluri.
* *Distanța dintre două noduri $x$ și $y$* ale unui arbore este egală cu *numărul de muchii* ale unui lanț cu extremitățile în nodurile $x$ și $y$, lanț format din noduri distincte.
* *Rădăcina* va fi considerată ca fiind nodul $1$;
* Pentru teste în valoare de $17$ puncte avem $N = 3$;
* Pentru teste în valoare de alte $22$ puncte răspunsul este $≤ 10 \ 000$;
* În concurs se acordau 10 puncte din oficiu, aici ultimele 6 teste valorează cu 10 puncte în plus.

---

Example:
`tairos.in`
```
4
3
1 2
3 1
3 4
```

`tairos.out`
```
5
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```markdown
```python
MOD = 1000000007

# Read the input data from tairos.in
with open("tairos.in", "r") as f:
    n = int(f.readline().strip())
    d = int(f.readline().strip())
    edges = [tuple(map(int, f.readline().split())) for _ in range(n - 1)]

# Initialize children and degrees lists
children = [[] for _ in range(n + 1)]
degrees = [0] * (n + 1)

# Populate the children and degrees lists based on the edges
for x, y in edges:
    children[x].append(y)
    children[y].append(x)
    degrees[x] += 1
    degrees[y] += 1

# Initialize a list for dp where dp[i] is the number of nodes at distance i
dp = [0] * (d + 1)
dp[0] = 1  # only the root node is at distance 0

# Populate the dp list
for i in range(1, d + 1):
    dp[i] = (dp[i - 1] * degrees[1]) % MOD
    for j in range(2, n + 1):
        if degrees[j] == 1:  # leaf node
            dp[i] = (dp[i] + dp[i - 1]) % MOD
        else:  # other nodes
            dp[i] = (dp[i] + dp[i - 1] * (degrees[j] - 1)) % MOD

# Write the result to tairos.out
with open("tairos.out", "w") as f:
    f.write(str(dp[d]))
```
```
---------- user ----------


Expected program to write result to `tairos.out` and read from `tairos.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
MOD = 1000000007

def read_input(filename):
    with open(filename, "r") as file:
        n, d = map(int, file.readline().split())
        edges = [list(map(int, line.split())) for line in file.readlines()]
    return n, d, edges

def build_tree(n, edges):
    tree = [[] for _ in range(n + 1)]
    for edge in edges:
        a, b = edge
        tree[a].append(b)
        tree[b].append(a)
    return tree

def count_leaves(tree):
    leaf_count = 0
    for neighbors in tree:
        if len(neighbors) == 1:
            leaf_count += 1
    return leaf_count

def write_output(filename, result):
    with open(filename, "w") as file:
        file.write(str(result))

def main():
    n, d, edges = read_input("tairos.in")
    tree = build_tree(n, edges)
    leaves = count_leaves(tree)

    # DP table where dp[i] is the number of nodes at distance i from the root
    dp = [0] * (d + 1)
    dp[0] = 1  # root node

    for i in range(1, d + 1):
        dp[i] = (dp[i - 1] * (n - 1)) % MOD
        if i <= n - 1:
            # Subtract the counts of nodes that are not leaves
            dp[i] -= (i - 1) * (n - 1 - leaves) % MOD
        dp[i] = (dp[i] + dp[i - 1] * leaves) % MOD

    write_output("tairos.out", dp[d])

if __name__ == "__main__":
    main()
```
```
---------- user ----------


Expected program to write result to `tairos.out` and read from `tairos.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
MOD = 1000000007

# Helper function to calculate powers of numbers modulo MOD
def pow_mod(base, exp, mod=MOD):
    result = 1
    while exp > 0:
        if exp % 2 == 1:
            result = (result * base) % mod
        base = (base * base) % mod
        exp //= 2
    return result

# Read input from file
with open("tairos.in", "r") as f:
    n = int(f.readline())
    d = int(f.readline())
    edges = [tuple(map(int, f.readline().split())) for _ in range(n - 1)]

# Build adjacency list
adjacency = [[] for _ in range(n + 1)]
for a, b in edges:
    adjacency[a].append(b)
    adjacency[b].append(a)

# Count leaf nodes
leaf_count = sum(1 for neighbours in adjacency if len(neighbours) == 1)

# Compute number of nodes at distance d using combinatorics
result = 0
if d < n:
    # All nodes at distance d in the original tree
    for i in range(1, n + 1):
        if len(adjacency[i]) <= d:
            result += 1
else:
    # Nodes at distance d in the infinite tree
    result = pow_mod(leaf_count, d // (n - 1), MOD)
    if d % (n - 1) != 0:
        result = (result * sum(pow_mod(len(adjacency[node]) - 1, d % (n - 1), MOD) for node in range(2, n + 1) if len(adjacency[node]) > 1)) % MOD

# Write output to file
with open("tairos.out", "w") as f:
    f.write(str(result))
```
```
---------- user ----------


Expected program to write result to `tairos.out` and read from `tairos.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
MOD = 1000000007

# Read data from file
with open("tairos.in", "r") as file:
    n = int(file.readline())
    d = int(file.readline())
    tree = [0] * (n + 1)
    degree = [0] * (n + 1)
    for _ in range(n - 1):
        x, y = map(int, file.readline().split())
        tree[x] += 1
        tree[y] += 1
        degree[x] += 1
        degree[y] += 1

# Calculate the number of nodes at each level of the tree
nodes_at_distance_d = [0] * (d + 1)
nodes_at_distance_d[0] = 1
for i in range(1, d + 1):
    for j in range(2, n + 1):
        if degree[j] == 1:  # Leaf node
            nodes_at_distance_d[i] += nodes_at_distance_d[i - 1]
        else:  # Internal node
            nodes_at_distance_d[i] += tree[j] * nodes_at_distance_d[i - 1]
    nodes_at_distance_d[i] -= (n - 1) * nodes_at_distance_d[i - 1]
    nodes_at_distance_d[i] %= MOD

# Write the result to the file
with open("tairos.out", "w") as file:
    file.write(str(nodes_at_distance_d[d]))
```
```
---------- user ----------


Expected program to write result to `tairos.out` and read from `tairos.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
MOD = 1000000007

def calc_nodes_at_distance_d(n, d, edges):
    # Initialize adjacency list and degree count
    adj = [[] for _ in range(n + 1)]
    degree = [0] * (n + 1)

    # Construct adjacency list and calculate node degrees
    for x, y in edges:
        adj[x].append(y)
        adj[y].append(x)
        degree[x] += 1
        degree[y] += 1

    # Dynamic programming table to store number of nodes at each distance
    dp = [0] * (d + 1)
    dp[0] = 1  # Only the root node is at distance 0

    for i in range(1, d + 1):
        for node in range(2, n + 1):
            if degree[node] == 1:  # Leaf node
                dp[i] = (dp[i] + dp[i - 1]) % MOD
            else:
                dp[i] = (dp[i] + dp[i - 1] * (degree[node] - 1)) % MOD

        # Multiply by the degree of the root node
        dp[i] = dp[i] * degree[1] % MOD

    return dp[d]

# Read input data
with open("tairos.in") as file:
    n = int(file.readline())
    d = int(file.readline())
    edges = [tuple(map(int, line.split())) for line in file]

# Calculate the result
result = calc_nodes_at_distance_d(n, d, edges)

# Write the result to output file
with open("tairos.out", "w") as file:
    file.write(str(result))
```
```
---------- user ----------


Expected program to write result to `tairos.out` and read from `tairos.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
MOD = 1000000007

# Read input from file
with open("tairos.in", "r") as f:
    N = int(f.readline().strip())
    D = int(f.readline().strip())
    adjacency = [[] for _ in range(N + 1)]
    for _ in range(N - 1):
        x, y = map(int, f.readline().strip().split())
        adjacency[x].append(y)
        adjacency[y].append(x)

# Initialize degree and leaves count
degree = [len(adjacency[i]) for i in range(N + 1)]
leaves = sum(1 for deg in degree if deg == 1)

# Initialize a list for dp where dp[i] is the number of nodes at distance i
dp = [1] + [0] * D

# Compute the number of nodes at each distance
for d in range(1, D + 1):
    dp[d] = dp[d - 1] * leaves % MOD
    if d < N:
        for node in range(2, N + 1):
            if degree[node] != 1:
                dp[d] += dp[d - 1] * (degree[node] - 1) % MOD
                dp[d] %= MOD

# Write the result to tairos.out
with open("tairos.out", "w") as f:
    f.write(f"{dp[D]}\n")
```
```
---------- user ----------


Expected program to write result to `tairos.out` and read from `tairos.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
MOD = 1000000007

def read_input_from_file(file_name):
    with open(file_name, 'r') as file:
        n = int(file.readline().strip())
        d = int(file.readline().strip())
        edges = [tuple(map(int, file.readline().strip().split())) for _ in range(n - 1)]
    return n, d, edges

def write_output_to_file(file_name, count):
    with open(file_name, 'w') as file:
        file.write(str(count) + '\n')

def count_nodes_at_distance_d(n, d, edges):
    # Create an adjacency list
    adjacency = [[] for _ in range(n + 1)]
    for x, y in edges:
        adjacency[x].append(y)
        adjacency[y].append(x)

    # Count leaves
    leaves = sum(1 for neighbours in adjacency if len(neighbours) == 1)
    
    # Initialize the dp array
    dp = [0] * (d + 1)
    dp[0] = 1
    for i in range(1, d + 1):
        dp[i] = (dp[i-1] * leaves) % MOD
        if i < n:
            dp[i] = (dp[i] + dp[i-1] * (n - 1 - leaves)) % MOD

    return dp[d]

# Read input data
n, d, edges = read_input_from_file("tairos.in")

# Process the data to find the number of nodes at distance d
result = count_nodes_at_distance_d(n, d, edges)

# Write output data
write_output_to_file("tairos.out", result)
```
```
