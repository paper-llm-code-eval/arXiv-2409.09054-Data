---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in python. The code must compile and be correct.
The solution must read from `cifre.in` and write to `cifre.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Ionel a primit temă de la profesorul său: să scrie pe hârtie numerele de la 1 la n. Cum numărul n era destul de mare el s-a cam plictisit şi a început să se joace numărând de câte ori a apărut o anumită cifră în numerele ce trebuiau scrise. Cum număratul era o activitate destul de lentă, el a găsit o metodă simplă de a calcula de câte ori a apărut o cifră în toate numerele tipărite.

# Cerință

Scrieţi un program care, citind numărul n şi o cifră nenulă c, afişează numărul de apariţii ale cifrei c în reprezentarea tuturor numerelor de la 1 la n.

# Date de intrare

Pe prima linie a fișierului de intrare `cifre.in` se găsesc două numere întregi, $n$ și $c$.

# Date de ieșire

Pe prima linie a fișierului de ieșire `cifre.out` se va găsi un singur număr întreg, numărul de apariţii al cifrei $c$ în reprezentarea tuturor numerelor de la $1$ la $n$.

# Restricții și precizări

* $1 \leq n \leq 10^9$;
* $1 \leq c \leq 9$;

---

Example:
`cifre.in`
```
15 1
```

`cifre.out`
```
8
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```markdown
```python
def count_digit_occurrences(n, c):
    count = 0
    for i in range(1, n + 1):
        count += str(i).count(str(c))
    return count

def main():
    with open('cifre.in', 'r') as fin:
        n, c = map(int, fin.readline().split())
    
    count = count_digit_occurrences(n, c)
    
    with open('cifre.out', 'w') as fout:
        fout.write(str(count))

if __name__ == "__main__":
    main()
```
```
---------- user ----------


Expected program to write result to `cifre.out` and read from `cifre.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
def count_digit_occurrences(n, c):
    count = 0
    power_of_10 = 1
    while power_of_10 <= n:
        next_power_of_10 = power_of_10 * 10
        right = n % power_of_10
        full_cycles = n // next_power_of_10
        count += full_cycles * power_of_10
        left = (n // power_of_10) % 10
        if left > c:
            count += power_of_10
        elif left == c:
            count += right + 1
        power_of_10 = next_power_of_10
    return count

def main():
    with open('cifre.in', 'r') as fin:
        n, c = map(int, fin.readline().split())
    
    count = count_digit_occurrences(n, c)
    
    with open('cifre.out', 'w') as fout:
        fout.write(str(count))

if __name__ == "__main__":
    main()
```
```
---------- user ----------


Expected program to write result to `cifre.out` and read from `cifre.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
# Read the input data
with open('cifre.in', 'r') as file:
    n, c = map(int, file.readline().split())

# Initialize the count and the variables used to keep track of the ranges
count = 0
factor = 1

# Iterate through ranges and calculate the occurrences of c
while factor <= n:
    # Determine the current range and the next range
    current_range = factor * 10
    # Count the number of complete cycles, the remainder, and the digit count at the current position
    complete_cycles = n // current_range
    remainder = n % current_range
    digit_count = (complete_cycles * factor) + min(max(remainder - (c - 1) * factor, 0), factor)

    if c == 0:
        # Adjust count for leading zeros which are not counted when c is 0
        digit_count -= factor
    count += digit_count

    # Prepare for the next digit place
    factor *= 10

# Write the output data
with open('cifre.out', 'w') as file:
    file.write(str(count))
```
```
---------- user ----------


Expected program to write result to `cifre.out` and read from `cifre.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
# Function to count the occurrences of the digit c in the range from 1 to n
def count_occurrences(n, c):
    count = 0
    # Start with the least significant digit and work towards the most significant
    k = 1  
    while k <= n:
        # Divide n by k to isolate the current digit place we are evaluating
        count += (n // (k * 10)) * k
        current_digit = (n // k) % 10
        if current_digit > c:
            count += k
        elif current_digit == c:
            count += n % k + 1
        k *= 10
    return count

# Read the input data from cifre.in
with open('cifre.in', 'r') as fin:
    n, c = map(int, fin.readline().split())

# Calculate the number of occurrences of the digit c
occurrences = count_occurrences(n, c)

# Write the result to cifre.out
with open('cifre.out', 'w') as fout:
    fout.write(str(occurrences))
```
```
---------- user ----------


Expected program to write result to `cifre.out` and read from `cifre.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
# Function to calculate the occurrences of digit c from 1 to n
def calculate_occurrences(n, c):
    count = 0
    # Initialize a multiplier to split the number into the digit we're inspecting
    multiplier = 1
    while n // multiplier > 0:
        # Increase multiplier by a factor of 10 to move to the next digit
        higher = n // (multiplier * 10)
        current = (n // multiplier) % 10
        lower = n - (n // multiplier) * multiplier
        
        if current > c:
            count += (higher + 1) * multiplier
        elif current < c:
            count += higher * multiplier
        else:
            count += higher * multiplier + lower + 1
        
        # Guard against overflow
        if higher == 0:
            break

        multiplier *= 10
    
    return count

# Read the number n and the digit c from 'cifre.in'
with open('cifre.in', 'r') as fin:
    n, c = map(int, fin.readline().strip().split())

# Calculate the number of occurrences of c in numbers from 1 to n
occurrences = calculate_occurrences(n, c)

# Write the result to 'cifre.out'
with open('cifre.out', 'w') as fout:
    fout.write(f"{occurrences}\n")
```
```
---------- user ----------


Expected program to write result to `cifre.out` and read from `cifre.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
# Function to count the occurrences of the digit c in numbers from 1 to n
def count_digit_occurrences(n, c):
    count = 0
    i = 1
    while i <= n:
        # Divide n by i to find the count of intervals
        interval_count = n // (i * 10)
        
        # Find the count of the digit in the current interval
        current_digit = (n // i) % 10
        if current_digit > c:
            count += (interval_count + 1) * i
        elif current_digit == c:
            count += interval_count * i + (n % i) + 1
        else:
            count += interval_count * i

        # Handle the case where the digit is zero
        if c == 0:
            count -= i

        i *= 10
    
    return count

# Read the input data from 'cifre.in'
with open('cifre.in', 'r') as file:
    n, c = map(int, file.readline().split())

# Calculate the number of occurrences of the digit c from 1 to n
occurrences = count_digit_occurrences(n, c)

# Write the output data to 'cifre.out'
with open('cifre.out', 'w') as file:
    file.write(str(occurrences))
```
```
---------- user ----------


Expected program to write result to `cifre.out` and read from `cifre.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
# Open the input file and read the values of n and c
with open('cifre.in', 'r') as fin:
    n, c = map(int, fin.readline().strip().split())

# Initialize the count of occurrences and a factor to determine the position of each digit
count = 0
factor = 1

# Loop to count the occurrences of c in each digit position
while factor <= n:
    # Calculate the number of complete cycles of 0 to 9 in the digit position
    complete_cycles = n // (factor * 10)
    count += complete_cycles * factor
    
    # Add the occurrences of c in the last partial cycle, if any
    # Calculate the value of the digit in the current factor position
    digit = (n // factor) % 10
    
    # If the digit is greater than c, c has occurred in every position of the last cycle
    if digit > c:
        count += factor
    # If the digit is the same as c, add the occurrences in the last partial cycle
    elif digit == c:
        count += (n % factor) + 1

    # Move to the next digit place
    factor *= 10

# Write the result to the output file
with open('cifre.out', 'w') as fout:
    fout.write(str(count))
```
```
