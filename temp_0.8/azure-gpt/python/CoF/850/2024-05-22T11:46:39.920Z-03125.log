---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in python. The code must compile and be correct.
The solution must read from `ferma.in` and write to `ferma.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Un fermier deține o fermă de formă dreptunghiulară cu lungimea $m$ metri și lățimea $n$ metri. Respectând principiul rotației culturilor, fermierul și a realizat un plan pentru semănarea culturilor în noul an. Astfel, el a desenat un dreptunghi pe care l-a împărțit în $m \cdot n$ celule, fiecare corespunzând unui metru pătrat, și a colorat în culori diferite zonele care corespund unor culturi diferite. O cultură poate fi semănată pe mai multe parcele. Două celule care au o latură comună aparțin aceleiași parcele dacă au aceeași culoare (sunt însămânțate cu aceeași cultură).  Fermierul are posibilitatea să irige o sigură parcelă și dorește să aleagă parcela cu cea mai mare suprafață. Nefiind mulțumit de suprafața rezultată, s-a întrebat dacă ar putea schimba cultura de pe o singură celulă, astfel încât să obțină o parcelă de suprafață mai mare.

Exemplu de fermă (_imagine 1_):

~[0.png]

# Cerință

Dându-se dimensiunile fermei și pentru fiecare celulă culoarea corespunzătoare culturii semănate, determinați:

1. **Varianta 1:** Suprafața maximă a unei parcele în planul inițial.
2. **Varianta 2:** Numărul liniei, respectiv al coloanei celulei pe care va semăna o altă cultură și culoarea corespunzătoare noii culturi în vederea obţinerii celei mai mari parcele posibile.


# Date de intrare


Fișierul de intrare `ferma.in` va conține:]

* pe prima linie un număr natural $v$ ($1 ≤ v ≤ 2$) indicând varianta cerinței de rezolvare
* pe a doua linie două numere naturale $m$ şi $n$ separate printr-un spațiu, cu semnificația din enunț
* pe fiecare dintre următoarele $m$ linii se găsesc câte $n$ caractere (litere mici), reprezentând codurile culturilor ce vor fi semănate pe cele $n$ celule corespunzătoare fiecărei linii. 


# Date de ieșire


Fișierul de ieșire `ferma.out` va conține:
**Varianta 1** – pentru $v=1$: 
* pe prima linie numărul natural $s$, reprezentând suprafața maximă a unei parcele.

**Varianta 2** – pentru $v=2$: 
* pe prima linie două numere naturale separate printr-un spațiu, reprezentând numărul liniei, respectiv al coloanei celulei pe care va semăna o altă cultură, în vederea obținerii unei parcele cu suprafața maximă; 
* pe a doua linie un caracter reprezentând codul culorii corespunzătoare noii culturi din celula determinată.


# Restricții și precizări

* $2 \leq n, m \leq 400$
* Numărul de culturi distincte este cel puţin $2$ şi cel mult $26$.
* $30\%$ din teste vor avea pe prima linie valoarea $1$, iar restul de $70\%$ din teste vor avea pe prima linie valoarea $2$.
* Pentru varianta $2$ se punctează orice soluție care conduce la obținerea unei parcele cu suprafața maximă. Nu se acordă punctaje parțiale.

---

Example:
`ferma.in`
```
1
7 8
rmmgggaa
mvvgggaa
mvvgvvvv
vvvrvvvv
vvrrrgga
vvrrrggg
aaaaaaag
```

`ferma.out`
```
11
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```markdown
```python
from collections import deque

# Read from 'ferma.in'
with open('ferma.in', 'r') as file:
    v = int(file.readline().strip())
    m, n = map(int, file.readline().split())
    farm = [list(file.readline().strip()) for _ in range(m)]

# Helper functions
def bfs(x, y, color, visited):
    area = 0
    queue = deque([(x, y)])
    visited[x][y] = True
    while queue:
        x, y = queue.popleft()
        area += 1
        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            nx, ny = x + dx, y + dy
            if 0 <= nx < m and 0 <= ny < n and farm[nx][ny] == color and not visited[nx][ny]:
                visited[nx][ny] = True
                queue.append((nx, ny))
    return area

def max_adjacent_area(x, y, color):
    total_adjacent_area = 0
    adjacent_areas = {}
    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
        nx, ny = x + dx, y + dy
        if 0 <= nx < m and 0 <= ny < n and farm[nx][ny] != color and not visited[nx][ny]:
            adjacent_area = bfs(nx, ny, farm[nx][ny], visited)
            total_adjacent_area += adjacent_area
            adjacent_areas[(nx, ny)] = adjacent_area
    return total_adjacent_area, adjacent_areas

# Find the max area parcel
visited = [[False]*n for _ in range(m)]
max_area = 0
for i in range(m):
    for j in range(n):
        if not visited[i][j]:
            max_area = max(max_area, bfs(i, j, farm[i][j], visited))

# Write output for Variant 1
if v == 1:
    with open('ferma.out', 'w') as file:
        file.write(str(max_area) + '\n')
# Solve for Variant 2
else:
    max_improvement = (0, 0, 0, '')
    visited = [[False]*n for _ in range(m)]
    for i in range(m):
        for j in range(n):
            if not visited[i][j]:
                current_area = bfs(i, j, farm[i][j], visited)
                total_adjacent_area, adjacent_areas = max_adjacent_area(i, j, farm[i][j])
                for (nx, ny), adjacent_area in adjacent_areas.items():
                    improvement = current_area + adjacent_area - 1
                    if improvement > max_improvement[0]:
                        max_improvement = (improvement, i + 1, j + 1, farm[nx][ny])
    # Write output for Variant 2
    with open('ferma.out', 'w') as file:
        file.write(f'{max_improvement[1]} {max_improvement[2]}\n{max_improvement[3]}\n')
```
```
---------- user ----------


Expected program to write result to `ferma.out` and read from `ferma.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

Here is the corrected Python solution, following your instructions to read from `ferma.in` and write to `ferma.out`, without using `input()` or `print()`:

```python
from collections import deque

def bfs(farm, x, y, visited):
    queue = deque([(x, y)])
    color = farm[x][y]
    area = 0
    while queue:
        cx, cy = queue.popleft()
        if visited[cx][cy]:
            continue
        visited[cx][cy] = True
        area += 1
        for dx, dy in [(-1, 0), (1, 0), (0, 1), (0, -1)]:
            nx, ny = cx + dx, cy + dy
            if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and farm[nx][ny] == color:
                queue.append((nx, ny))
    return area

def get_neighbors(farm, x, y):
    neighbors = {}
    for dx, dy in [(-1, 0), (1, 0), (0, 1), (0, -1)]:
        nx, ny = x + dx, y + dy
        if 0 <= nx < m and 0 <= ny < n and farm[nx][ny] != farm[x][y]:
            neighbors[(nx, ny)] = farm[nx][ny]
    return neighbors

# Read from 'ferma.in'
with open('ferma.in', 'r') as file:
    v = int(file.readline().strip())
    m, n = map(int, file.readline().strip().split())
    farm = [list(file.readline().strip()) for _ in range(m)]

visited = [[False] * n for _ in range(m)]
max_area = 0
max_area_cell = (-1, -1)

# Variant 1
if v == 1:
    for i in range(m):
        for j in range(n):
            if not visited[i][j]:
                area = bfs(farm, i, j, visited)
                max_area = max(max_area, area)
    with open('ferma.out', 'w') as file:
        file.write(f'{max_area}\n')
# Variant 2
else:
    border_cells = {}
    for i in range(m):
        for j in range(n):
            if not visited[i][j]:
                area = bfs(farm, i, j, visited)
                max_area = max(max_area, area)
                neighbors = get_neighbors(farm, i, j)
                for (nx, ny), color in neighbors.items():
                    if (nx, ny) not in border_cells:
                        border_cells[(nx, ny)] = set()
                    border_cells[(nx, ny)].add((i, j, color))

    best_cell = (-1, -1)
    best_color = ''
    best_improvement = 0
    for (bx, by), potentials in border_cells.items():
        current_color = farm[bx][by]
        improvement = 0
        for (px, py, pcolor) in potentials:
            if pcolor != current_color:
                visited = [[False] * n for _ in range(m)]
                farm[bx][by] = pcolor  # Temporarily change color
                improved_area = bfs(farm, px, py, visited)
                farm[bx][by] = current_color  # Revert color
                improvement = max(improvement, improved_area - max_area)

        if improvement > best_improvement:
            best_improvement = improvement
            best_cell = (bx + 1, by + 1)
            best_color = current_color

    with open('ferma.out', 'w') as file:
        file.write(f'{best_cell[0]} {best_cell[1]}\n{best_color}\n')
```

This program will read the input from `ferma.in` and write the output to `ferma.out` as requested.
---------- user ----------


Program result did not match expected result.
Input data:
```
2
7 8
rmmgggaa
mvvgggaa
mvvgvvvv
vvvrvvvv
vvrrrgga
vvrrrggg
aaaaaaag
```
Expected output:
```
3 4
v
```
Found output:
```
-1 -1
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

Upon evaluating the differences between the expected and found result, it's clear that the implementation did not provide the correct output for Variant 2. Specifically, the logic for determining the best cell to change the color of, to maximize the area of a contiguous parcel, has an issue.

The program has a bug in the section where it iterates over border cells and temporarily changes their color to simulate planting a different crop. The issue is that it only considers border cells of the current area being processed in the BFS, while it should consider all cells and check the potential increase in area for all neighboring parcels.

Here's the corrected and updated solution:

```python
from collections import deque

def bfs(farm, x, y, color, visited):
    queue = deque([(x, y)])
    area = 0
    while queue:
        cx, cy = queue.popleft()
        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            nx, ny = cx + dx, cy + dy
            if 0 <= nx < m and 0 <= ny < n and farm[nx][ny] == color and not visited[nx][ny]:
                visited[nx][ny] = True
                queue.append((nx, ny))
                area += 1
    return area

def get_largest_parcel(farm):
    visited = [[False] * n for _ in range(m)]
    max_area = 0
    for i in range(m):
        for j in range(n):
            if not visited[i][j]:
                area = bfs(farm, i, j, farm[i][j], visited)
                max_area = max(max_area, area)
    return max_area

def get_best_cell(farm):
    max_area = get_largest_parcel(farm)
    best_coords = (0, 0)
    best_color = ''
    largest_improvement = 0

    for i in range(m):
        for j in range(n):
            original_color = farm[i][j]
            neighbors = {}
            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                nx, ny = i + dx, j + dy
                if 0 <= nx < m and 0 <= ny < n and farm[nx][ny] != original_color:
                    neighbors[farm[nx][ny]] = neighbors.get(farm[nx][ny], 0) + 1

            for new_color, border_count in neighbors.items():
                if new_color != original_color:
                    farm[i][j] = new_color
                    improved_area = get_largest_parcel(farm)
                    improvement = improved_area - max_area
                    if improvement > largest_improvement:
                        largest_improvement = improvement
                        best_coords = (i + 1, j + 1)
                        best_color = new_color
                    farm[i][j] = original_color

    return best_coords, best_color

# Read from 'ferma.in'
with open('ferma.in', 'r') as file:
    v = int(file.readline().strip())
    m, n = map(int, file.readline().strip().split())
    farm = [list(file.readline().strip()) for _ in range(m)]

# Solve the problem
if v == 1:
    max_area = get_largest_parcel(farm)
    with open('ferma.out', 'w') as file:
        file.write(f'{max_area}\n')
else:
    best_coords, best_color = get_best_cell(farm)
    with open('ferma.out', 'w') as file:
        file.write(f'{best_coords[0]} {best_coords[1]}\n{best_color}\n')
```

This corrected solution should now provide the expected output for Variant 2 by scanning all cells, determining the potential increase in area when changing the color of a cell, and selecting the best one to maximize the area. The input is read from `ferma.in`, and the output is written to `ferma.out`.
