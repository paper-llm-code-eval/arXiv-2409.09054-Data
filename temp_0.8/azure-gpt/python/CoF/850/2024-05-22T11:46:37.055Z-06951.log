---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in python. The code must compile and be correct.
The solution must read from `ferma.in` and write to `ferma.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Un fermier deține o fermă de formă dreptunghiulară cu lungimea $m$ metri și lățimea $n$ metri. Respectând principiul rotației culturilor, fermierul și a realizat un plan pentru semănarea culturilor în noul an. Astfel, el a desenat un dreptunghi pe care l-a împărțit în $m \cdot n$ celule, fiecare corespunzând unui metru pătrat, și a colorat în culori diferite zonele care corespund unor culturi diferite. O cultură poate fi semănată pe mai multe parcele. Două celule care au o latură comună aparțin aceleiași parcele dacă au aceeași culoare (sunt însămânțate cu aceeași cultură).  Fermierul are posibilitatea să irige o sigură parcelă și dorește să aleagă parcela cu cea mai mare suprafață. Nefiind mulțumit de suprafața rezultată, s-a întrebat dacă ar putea schimba cultura de pe o singură celulă, astfel încât să obțină o parcelă de suprafață mai mare.

Exemplu de fermă (_imagine 1_):

~[0.png]

# Cerință

Dându-se dimensiunile fermei și pentru fiecare celulă culoarea corespunzătoare culturii semănate, determinați:

1. **Varianta 1:** Suprafața maximă a unei parcele în planul inițial.
2. **Varianta 2:** Numărul liniei, respectiv al coloanei celulei pe care va semăna o altă cultură și culoarea corespunzătoare noii culturi în vederea obţinerii celei mai mari parcele posibile.


# Date de intrare


Fișierul de intrare `ferma.in` va conține:]

* pe prima linie un număr natural $v$ ($1 ≤ v ≤ 2$) indicând varianta cerinței de rezolvare
* pe a doua linie două numere naturale $m$ şi $n$ separate printr-un spațiu, cu semnificația din enunț
* pe fiecare dintre următoarele $m$ linii se găsesc câte $n$ caractere (litere mici), reprezentând codurile culturilor ce vor fi semănate pe cele $n$ celule corespunzătoare fiecărei linii. 


# Date de ieșire


Fișierul de ieșire `ferma.out` va conține:
**Varianta 1** – pentru $v=1$: 
* pe prima linie numărul natural $s$, reprezentând suprafața maximă a unei parcele.

**Varianta 2** – pentru $v=2$: 
* pe prima linie două numere naturale separate printr-un spațiu, reprezentând numărul liniei, respectiv al coloanei celulei pe care va semăna o altă cultură, în vederea obținerii unei parcele cu suprafața maximă; 
* pe a doua linie un caracter reprezentând codul culorii corespunzătoare noii culturi din celula determinată.


# Restricții și precizări

* $2 \leq n, m \leq 400$
* Numărul de culturi distincte este cel puţin $2$ şi cel mult $26$.
* $30\%$ din teste vor avea pe prima linie valoarea $1$, iar restul de $70\%$ din teste vor avea pe prima linie valoarea $2$.
* Pentru varianta $2$ se punctează orice soluție care conduce la obținerea unei parcele cu suprafața maximă. Nu se acordă punctaje parțiale.

---

Example:
`ferma.in`
```
1
7 8
rmmgggaa
mvvgggaa
mvvgvvvv
vvvrvvvv
vvrrrgga
vvrrrggg
aaaaaaag
```

`ferma.out`
```
11
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```markdown

```python
from collections import deque

# Directions for traversing adjacent cells
directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]

def read_input(file_path):
    with open(file_path, 'r') as file:
        v = int(file.readline())
        m, n = map(int, file.readline().split())
        farm = [list(file.readline().strip()) for _ in range(m)]
    return v, m, n, farm

def write_output(file_path, result):
    with open(file_path, 'w') as file:
        if isinstance(result, int):
            file.write(str(result) + '\n')
        else:
            file.write(f"{result[0]} {result[1]}\n{result[2]}\n")

def bfs(farm, m, n, start, visited):
    queue = deque([start])
    visited[start[0]][start[1]] = True
    color = farm[start[0]][start[1]]
    size = 1
    
    while queue:
        x, y = queue.popleft()
        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and farm[nx][ny] == color:
                size += 1
                visited[nx][ny] = True
                queue.append((nx, ny))
    return size

def max_parcel_size(farm, m, n):
    visited = [[False] * n for _ in range(m)]
    max_size = 0
    for i in range(m):
        for j in range(n):
            if not visited[i][j]:
                size = bfs(farm, m, n, (i, j), visited)
                max_size = max(max_size, size)
    return max_size

def optimal_irrigation(farm, m, n):
    max_parcel = (0, 0, 'a')  # (size, cell, color)
    for i in range(m):
        for j in range(n):
            original_color = farm[i][j]
            neighbor_colors = set()
            for dx, dy in directions:
                ni, nj = i + dx, j + dy
                if 0 <= ni < m and 0 <= nj < n and farm[ni][nj] != original_color:
                    neighbor_colors.add(farm[ni][nj])
            for color in neighbor_colors:
                farm[i][j] = color
                size = max_parcel_size(farm, m, n)
                if size > max_parcel[0]:
                    max_parcel = (size, (i + 1, j + 1), color)
                farm[i][j] = original_color  # Reset to original color
    return max_parcel[1], max_parcel[2]

def solve_challenge(file_in, file_out):
    v, m, n, farm = read_input(file_in)

    if v == 1:
        result = max_parcel_size(farm, m, n)
    else:
        result = optimal_irrigation(farm, m, n)

    write_output(file_out, result)

# Define file names
file_in = 'ferma.in'
file_out = 'ferma.out'

# Solve the challenge
solve_challenge(file_in, file_out)
```

This code reads the input from `ferma.in`, computes either the size of the largest parcel or the optimal irrigation strategy (depending on the variant), and writes the result to `ferma.out`. It uses a breadth-first search (BFS) algorithm to find the size of parcels and then, for variant 2, iteratively changes the color of cells to determine the optimal irrigation strategy.
---------- user ----------


Expected program to write result to `ferma.out` and read from `ferma.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```python
from collections import deque

def bfs(farm, m, n, start, visited):
    queue = deque([start])
    visited[start[0]][start[1]] = True
    color = farm[start[0]][start[1]]
    size = 1
    
    while queue:
        x, y = queue.popleft()
        for dx, dy in [(0, 1), (1, 0), (-1, 0), (0, -1)]:
            nx, ny = x + dx, y + dy
            if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and farm[nx][ny] == color:
                size += 1
                visited[nx][ny] = True
                queue.append((nx, ny))
    return size, color

def find_largest_parcel(m, n, farm):
    visited = [[False for _ in range(n)] for _ in range(m)]
    max_size = 0
    max_color = None
    for i in range(m):
        for j in range(n):
            if not visited[i][j]:
                size, color = bfs(farm, m, n, (i, j), visited)
                if size > max_size:
                    max_size = size
                    max_color = color
    return max_size, max_color

def find_optimal_change(m, n, farm, max_parcel_size):
    optimal_coord = (0, 0)
    optimal_color = None
    for i in range(m):
        for j in range(n):
            for dx, dy in [(0, 1), (1, 0), (-1, 0), (0, -1)]:
                ni, nj = i + dx, j + dy
                if 0 <= ni < m and 0 <= nj < n and farm[i][j] != farm[ni][nj]:
                    original_color = farm[i][j]
                    farm[i][j] = farm[ni][nj]
                    current_size, _ = find_largest_parcel(m, n, farm)
                    if current_size > max_parcel_size:
                        max_parcel_size = current_size
                        optimal_coord = (i + 1, j + 1)
                        optimal_color = farm[ni][nj]
                    farm[i][j] = original_color
    return optimal_coord, optimal_color

with open('ferma.in', 'r') as file:
    v = int(file.readline())
    m, n = map(int, file.readline().split())
    farm = [list(file.readline().strip()) for _ in range(m)]

if v == 1:
    max_size, _ = find_largest_parcel(m, n, farm)
    with open('ferma.out', 'w') as file:
        file.write(f"{max_size}\n")
else:
    max_size, _ = find_largest_parcel(m, n, farm)
    optimal_coord, optimal_color = find_optimal_change(m, n, farm, max_size)
    with open('ferma.out', 'w') as file:
        file.write(f"{optimal_coord[0]} {optimal_coord[1]}\n{optimal_color}\n")
```

Please note that this code does not include detailed error handling for file operations, and for the purposes of this programming challenge, input files are assumed to be correctly formatted as per the problem statement. The solution implements a BFS algorithm to find the size of each parcel and then, in the second variant, iterates over potential changes to find the optimal irrigation strategy. The output for each variant is written to 'ferma.out'.
