---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in python. The code must compile and be correct.
The solution must read from `cursuri.in` and write to `cursuri.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Într-o tabără de vară se programează susținerea unor cursuri în $K$ săli de clasă. Sunt $N$ profesori care și-au exprimat dorința de a participa, fiecare dintre ei specificând intervalul de timp [$a_i, b_i$] în care își poate susține cursul. Programarea pe săli a profesorilor trebuie să țină cont de faptul că într-o clasă, la un moment dat, nu poate preda decât un singur profesor.

# Cerință

Cunoscându-se faptul că organizatorii doresc susținerea a cât mai multor cursuri, să se determine:

1) Numărul maxim de cursuri care pot fi programate în cele $K$ săli de clasă, ținând cont de restricția indicată.
2) În dorința de a programa toate cursurile, în cele $K$ săli, organizatorii decid să modifice durata cursurilor, păstrând însă neschimbată ora de început a lor. Astfel, ei hotărăsc ca toate cursurile să dureze un interval egal de timp, care însă nu va depăși durata celui mai lung curs propus inițial de unul dintre cei $N$ profesori. Determinați care poate fi durata maximă pe care o pot avea cursurile în aceste condiții.

# Date de intrare

În fișierul de intrare `cursuri.in` se găsește pe prima linie un număr natural $C$. Pentru toate testele, $C$ poate lua numai valorile $1$ sau $2$. Pe linia a doua se găsește o pereche de numere naturale $N \ K$, separate printr-un spațiu, reprezentând numărul profesorilor și numărul de săli de clasă. Pe următoarele $N$ linii se găsesc perechi de numere naturale $a_i \ b_i$, care reprezintă intervalele de timp în care cei $N$ profesori își susțin cursurile. Numerele în cadrul unei linii sunt separate printr-un spațiu.

# Date de ieșire

Dacă valoarea lui $C$ este $1$, se va rezolva numai punctul $1$) din cerințe. În acest caz, fişierul de ieşire `cursuri.out` va conține pe prima linie un număr natural reprezentând numărul maxim de cursuri care pot fi programate în cele K săli de clasă, ținând cont de restricția indicată.

Dacă valoarea lui $C$ este $2$, se va rezolva numai punctul $2$) din cerințe. În acest caz, fişierul de ieşire `cursuri.out` va conține pe prima linie un număr natural reprezentând durata maximă pe care o pot avea cele $N$ cursuri, astfel încât toate să poată fi susținute în cele $K$ săli disponibile.

# Restricții și precizări

* $1 \leq N \leq 1 \ 000$;
* $1 \leq K \leq 1 \ 000$;
* $1 \leq a_i < b_i \leq 100 \ 000$;
* În cazul cerinței $2$ se garantează că pentru toate testele există soluție
* Pentru rezolvarea corectă a primei cerinţe se acordă $45$ de puncte, iar pentru rezolvarea corectă a celei de a doua cerințe se acordă $45$ de puncte. Se acordă $10$ puncte din oficiu.

---

Example:
`cursuri.in`
```
1
4 2
2 16
1 3
3 18
1 20
```

`cursuri.out`
```
3
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```python
# Read from input file
with open('cursuri.in', 'r') as file:
    C = int(file.readline().strip())
    N, K = map(int, file.readline().split())
    intervals = [tuple(map(int, file.readline().split())) for _ in range(N)]

# Write to output file
with open('cursuri.out', 'w') as file:
    if C == 1:
        # Sort intervals by end time
        intervals.sort(key=lambda x: x[1])

        # Initialize counters
        count = 0
        last_end_time = 0
        rooms = [0] * K

        # Iterate through intervals
        for start, end in intervals:
            for i in range(K):
                # Find an available room
                if rooms[i] <= start:
                    # Update the room's end time and increment count
                    rooms[i] = end
                    count += 1
                    break

        # Write the number of courses that can be scheduled
        file.write(f"{count}\n")
    elif C == 2:
        # The maximum course duration is the minimum end time minus the start time
        min_end = min(interval[1] for interval in intervals)
        max_duration = min_end - max(interval[0] for interval in intervals)

        # Write the maximum duration
        file.write(f"{max_duration}\n")
```
---------- user ----------


Program result did not match expected result.
Input data:
```
2
4 2
5 12
9 18
1 3
1 7
```
Expected output:
```
4
```
Found output:
```
-6
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The provided solution for case 2 has a logic error. It tries to determine the maximum course duration by subtracting the maximum start time from the minimum end time, which is not correct. The maximum duration should instead be determined by finding the smallest time slot that all courses can fit into when all start at their individual starting times, and extend for the same maximum duration, without overlapping more than K courses at any point in time.

The correct approach for case 2 is more involved and typically requires a binary search to find the maximum possible duration that satisfies the constraints. Here is the revised and correct solution that will output the maximum duration for case 2:

```python
def can_schedule(intervals, K, duration):
    events = []
    for start, _ in intervals:
        events.append((start, 'start'))
        events.append((start + duration, 'end'))
    events.sort()

    ongoing = 0  # Number of ongoing courses
    for _, event_type in events:
        if event_type == 'start':
            ongoing += 1
            if ongoing > K:
                return False
        else:
            ongoing -= 1
    return True

def find_max_duration(intervals, K):
    low, high = 1, max(end - start for start, end in intervals)
    while low < high:
        mid = (low + high + 1) // 2
        if can_schedule(intervals, K, mid):
            low = mid
        else:
            high = mid - 1
    return low

# Read from input file
with open('cursuri.in', 'r') as file:
    C = int(file.readline().strip())
    N, K = map(int, file.readline().split())
    intervals = [tuple(map(int, file.readline().split())) for _ in range(N)]

# Write to output file
with open('cursuri.out', 'w') as file:
    if C == 1:
        # Sort intervals by end time
        intervals.sort(key=lambda x: x[1])
        # Initialize counters
        count = 0
        last_end_time = 0
        rooms = [0] * K
        # Iterate through intervals
        for start, end in intervals:
            for i in range(K):
                # Find an available room
                if rooms[i] <= start:
                    # Update the room's end time and increment count
                    rooms[i] = end
                    count += 1
                    break
        # Write the number of courses that can be scheduled
        file.write(f"{count}\n")
    elif C == 2:
        # Find the maximum duration for which all courses can be scheduled
        max_duration = find_max_duration(intervals, K)
        # Write the maximum duration
        file.write(f"{max_duration}\n")
```

This revised solution introduces a binary search in the `find_max_duration` function and a helper function `can_schedule` to check if it's possible to schedule all courses with a given duration. The binary search iteratively narrows down the possible maximum duration until it finds the highest duration that still allows all courses to fit within the available rooms without overlapping more than K courses at any time.
