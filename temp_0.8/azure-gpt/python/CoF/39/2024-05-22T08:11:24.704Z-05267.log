---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in python. The code must compile and be correct.
The solution must read from `suma.in` and write to `suma.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

~[suma1.png]
\
Constructorii angajaţi de faraonul Keops au terminat construirea piramidei în trepte mult visată. Măreaţa piramidă are $n$ camere identice de formă cubică, numerotate de la $1$ la $n$, dispuse pe $m$ niveluri astfel:
- camera din vârful piramidei formează nivelul $1$ şi are numărul $1$;
- nivelul $2$ al piramidei este format din următoarele $4$ camere care în secţiune cu un plan paralel cu baza au aspectul unei matrice cu $2$ linii şi $2$ coloane; camerele de pe nivelul $2$ sunt numerotate de la $2$ la $5$ în ordinea crescătoare a liniilor matricei, iar pe aceeaşi linie în ordinea crescătoare a coloanelor matricei;
...
- nivelul $m$ al piramidei este format din $m \times m$ camere şi au, în secţiune cu un plan paralel cu baza, aspectul unei matrice cu $m$ linii şi $m$ coloane; camerele de pe nivelul $m$ sunt numerotate în continuarea celor de pe nivelurile $1, 2, ..., m - 1$, în ordinea crescătoare a liniilor matricei de secţiune, iar pe aceeaşi linie în ordinea crescătoare a coloanelor matricei. De exemplu, piramida din desenul de mai sus are $n = 30, m = 4$ iar camerele sunt numerotate şi dispuse pe niveluri astfel:
\
 ~[suma2.png]
\
Nivelurile de camere sunt poziţionate astfel încât camerele de pe prima linie şi prima coloană a fiecărui nivel să se suprapună. Pentru exemplul dat, camerele $1, 2, 6$ şi $15$ sunt situate una sub alta, în această ordine.

Accesul în oricare din camerele piramidei, situate pe diferite niveluri, se realizează prin drumuri construite astfel:
* intrarea în piramidă se face doar prin camera din vârful ei, cea cu numărul $1$;
* din camera cu numărul $k$ de pe un drum se poate intra într-una din cele patru camere situate pe nivelul imediat următor al piramidei şi anume: camera situată sub cea cu numărul $k$ sau una din cele trei camere vecine acesteia în secţiune (în direcţiile Est, Sud-Est, Sud, considerând secţiunile poziţionate ca în imaginile de mai sus). De exemplu, din camera cu numărul $10$ se poate intra într-una din camerele cu numerele: $20, 21, 24$ sau $25$.

Faraonul priveşte cu mândrie şi tristeţe la frumoasa piramidă. Banii din visterie s-au împuţinat iar camerele piramidei trebuie finisate şi decorate. Scribul său favorit a refăcut toate calculele, a eliminat obiectele inutile şi a stabilit pentru fiecare cameră $k$ un cost $c_k$ aferent finisării şi decorării ei ($1 ≤ k ≤ n$). 

Însă, suma totală necesară fiind încă mare, faraonul i-a cerut scribului să aleagă un drum, dintre cele construite, care să treacă prin toate nivelurile piramidei astfel încât suma s a tuturor costurilor aferente finisării şi decorării camerelor de pe acest drum să fie minimă. Deocamdată, doar aceste camere vor fi aranjate...  

# Cerinţă
Scrieţi un program care să determine numărul $m$ de niveluri ale piramidei, suma minimă $s$ a tuturor costurilor aferente finisării şi decorării camerelor de pe un drum ce trece prin toate nivelurile piramidei, construit în modul descris în enunţ, precum şi un astfel de drum pentru care se obţine suma minimă, putând fi ales de scrib.

# Date de intrare
Fişierul de intrare `suma.in` conţine pe prima linie numărul natural nenul $n$ reprezentând numărul de camere din piramidă. A doua linie conţine $n$ numere naturale nenule $c_1, c_2,…, c_n$, separate prin câte un spaţiu, reprezentând costurile aferente finisării şi decorării camerelor, în ordinea numerotării lor.

# Date de ieşire
Fişierul de ieşire `suma.out` va conţine pe prima linie două numere naturale $m$ şi $s$, separate printr-un singur spaţiu, cu semnificaţia din enunţ. Cea de-a doua linie va conţine, separate prin câte un spaţiu, în ordinea parcurgerii lor, numerele camerelor de pe un drum ce trece prin toate nivelurile piramidei, drum pentru care se obţine suma minimă $s$. 

# Restricţii şi precizări
* $1 ≤ n ≤ 63\ 365$
* Pentru fiecare valoare $n$ citită se poate construi în modul descris în enunţ o piramidă în trepte cu $n$ camere 
* $1 ≤ c_1, c_2, ..., c_n < 100 $
* Dacă există mai multe drumuri ce trec prin toate nivelurile piramidei şi pentru care se obţine suma minimă $s$, atunci drumul ales va fi cel mai mic drum din punct de vedere lexicografic.
* Drumul $a_1, a_2, a_3, …, a_m$ este mai mic, din punct de vedere lexicografic, ca drumul $b_1, b_2, b_3, …, b_m$ dacă există un indice $j$ ($1 ≤ j ≤ m$) astfel încât $a_1=b_1, a_2=b_2 ,….,a_{j-1}=b_{j-1}$ şi $a_j < b_j$.
* Se acordă:
* $10%$ din punctaj pentru determinarea corectă a numărului $m$ de niveluri ale piramidei 
* $30%$ din punctaj pentru determinarea corectă a sumei minime $s$ 
* $60%$ din punctaj pentru determinarea corectă a drumului cerut.

---

Example:
`suma.in`
```
14
7 8 4 5 5 8 4 2 7 7 8 3 1 6
```

`suma.out`
```
3 13
1 3 8
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```python
import math

def read_input(file_name):
    with open(file_name, 'r') as file:
        n = int(file.readline().strip())
        costs = list(map(int, file.readline().split()))
    return n, costs

def write_output(file_name, m, s, path):
    with open(file_name, 'w') as file:
        file.write(f"{m} {s}\n")
        file.write(' '.join(map(str, path)) + '\n')

def calculate_levels(n):
    return int((math.sqrt(1 + 8 * n) - 1) / 2)

def find_min_cost_path(n, costs, m):
    dp = [0] * (n + 1)
    path = [[] for _ in range(m + 1)]
    dp[1] = costs[0]
    path[1] = [1]
    for level in range(2, m + 1):
        prev_level_sum = (level - 1) * level // 2
        current_level_sum = level * (level + 1) // 2
        for room in range(current_level_sum, prev_level_sum, -1):
            dp[room] = costs[room - 1]
            min_cost = float('inf')
            min_path = []
            for dr, dc in ((0, -1), (-1, -1), (-1, 0), (-1, 1)):
                prev_room = room + dr * level + dc
                if prev_level_sum < prev_room <= prev_room + dr + dc <= current_level_sum:
                    if dp[prev_room] < min_cost or (dp[prev_room] == min_cost and path[prev_room] < min_path):
                        min_cost = dp[prev_room]
                        min_path = path[prev_room]
            dp[room] += min_cost
            path[room] = min_path + [room] if min_path else [room]
    min_cost = float('inf')
    final_path = []
    for room in range(n, n - m, -1):
        if dp[room] < min_cost or (dp[room] == min_cost and path[room] < final_path):
            min_cost = dp[room]
            final_path = path[room]
    return final_path[0], min_cost, final_path

def solve():
    n, costs = read_input('suma.in')
    m = calculate_levels(n)
    s, min_cost, min_cost_path = find_min_cost_path(n, costs, m)
    write_output('suma.out', m, min_cost, min_cost_path)

solve()
```

This solution calculates the number of levels in the pyramid, determines the minimum cost path through dynamic programming, and writes the output to the specified file.
---------- user ----------


Program exited with code 1.
stdout:
```

```
stderr:
```
Traceback (most recent call last):
  File "/app/app.py", line 51, in <module>
    solve()
  File "/app/app.py", line 48, in solve
    s, min_cost, min_cost_path = find_min_cost_path(n, costs, m)
                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/app.py", line 36, in find_min_cost_path
    path[room] = min_path + [room] if min_path else [room]
    ~~~~^^^^^^
IndexError: list assignment index out of range

```

Think of what has caused the exit code. Use the standard out and standard error to help you understand the issue.
Implement a solution to fix the program

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The error `IndexError: list assignment index out of range` indicates that the code is trying to access an index of the `path` list that is beyond its current size. This can happen if the logic for calculating the indices or the size of the `path` list is incorrect.

Upon reviewing the code, it looks like the issue is in the `find_min_cost_path` function, specifically when it tries to calculate the room index during the iteration over the rooms in a level and also when it tries to access the `path` for rooms that do not exist.

To ensure the logic works correctly, we should fix the iteration to correctly calculate the indices of the rooms within a level and ensure that the `path` list is correctly populated. Let's correct the code with the proper logic. Here's the fixed Python code:

```python
import math

def read_input(file_name):
    with open(file_name, 'r') as file:
        n = int(file.readline().strip())
        costs = list(map(int, file.readline().split()))
    return n, costs

def write_output(file_name, m, s, path):
    with open(file_name, 'w') as file:
        file.write(f"{m} {s}\n")
        file.write(' '.join(map(str, path)) + '\n')

def calculate_levels(n):
    return int((math.sqrt(1 + 8 * n) - 1) / 2)

def find_min_cost_path(n, costs, m):
    dp = [float('inf')] * (n + 1)
    path = [[] for _ in range(n + 1)]
    dp[1] = costs[0]
    path[1] = [1]
    for level in range(2, m + 1):
        for room in range(level**2, (level - 1)**2, -1):
            dp[room] = costs[room - 1]
            min_cost = float('inf')
            min_path = []
            for dr, dc in ((-level, 0), (-level + 1, -1), (-level + 1, 0), (-level + 1, 1)):
                prev_room = room + dr + dc
                if prev_room >= 1 and dp[prev_room] < min_cost:
                    min_cost = dp[prev_room]
                    min_path = path[prev_room]
            dp[room] += min_cost
            path[room] = min_path + [room]
    min_cost = float('inf')
    final_path = []
    for room in range((m - 1)**2 + 1, m**2 + 1):
        if dp[room] < min_cost:
            min_cost = dp[room]
            final_path = path[room]
    return min_cost, final_path

def solve():
    n, costs = read_input('suma.in')
    m = calculate_levels(n)
    min_cost, min_cost_path = find_min_cost_path(n, costs, m)
    write_output('suma.out', m, min_cost, min_cost_path)

solve()
```

This fixed code should now correctly calculate the indices of the rooms within each level, properly populate the `path` list, and avoid the `IndexError` that was causing the program to exit with code 1.
---------- user ----------


Program exited with code 1.
stdout:
```

```
stderr:
```
Traceback (most recent call last):
  File "/app/app.py", line 48, in <module>
    solve()
  File "/app/app.py", line 45, in solve
    min_cost, min_cost_path = find_min_cost_path(n, costs, m)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/app.py", line 24, in find_min_cost_path
    dp[room] = costs[room - 1]
               ~~~~~^^^^^^^^^^
IndexError: list index out of range

```

Think of what has caused the exit code. Use the standard out and standard error to help you understand the issue.
Implement a solution to fix the program

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The error `IndexError: list index out of range` indicates an issue with accessing an index in the `costs` list that doesn't exist. The likely cause of the problem is incorrect calculation of the room indices during the iteration. Let's correct the indices and ensure that we correctly access the costs of each room within the bounds of the `costs` list.

Here is the corrected code:

```python
import math

def read_input(file_name):
    with open(file_name, 'r') as file:
        n = int(file.readline().strip())
        costs = list(map(int, file.readline().split()))
    return n, costs

def write_output(file_name, m, s, path):
    with open(file_name, 'w') as file:
        file.write(f"{m} {s}\n")
        file.write(' '.join(map(str, path)) + '\n')

def calculate_levels(n):
    m = int((math.sqrt(1 + 8 * n) - 1) / 2)
    while m * (m + 1) // 2 > n:
        m -= 1
    return m

def find_min_cost_path(n, costs, m):
    dp = [float('inf')] * (n + 1)
    path = [[] for _ in range(n + 1)]
    dp[1] = costs[0]
    path[1] = [1]
    room = 1
    for level in range(2, m + 1):
        for i in range(level):
            for j in range(level):
                room += 1
                dp[room] = costs[room - 1]
                min_cost = float('inf')
                min_path = []
                for dr, dc in ((0, -1), (-1, -1), (-1, 0), (-1, 1)):
                    prev_room = room + dr * (level - 1) + dc
                    if prev_room >= room - level and prev_room < room and dp[prev_room] < min_cost:
                        min_cost = dp[prev_room]
                        min_path = path[prev_room]
                dp[room] += min_cost
                path[room] = min_path + [room]
    
    min_cost = dp[room]
    final_path = path[room]

    return min_cost, final_path

def solve():
    n, costs = read_input('suma.in')
    m = calculate_levels(n)
    min_cost, min_cost_path = find_min_cost_path(n, costs, m)
    write_output('suma.out', m, min_cost, min_cost_path)

solve()
```

This solution should fix the index issues by ensuring the iteration of rooms is within the correct bounds. The `calculate_levels` function is modified to ensure that the calculated `m` is correct for the given number of rooms, `n`. The `find_min_cost_path` function is updated to correctly calculate the transitions between the rooms and handle the edge cases properly. This should avoid the `IndexError` and solve the problem correctly.
---------- user ----------


Program exited with code 1.
stdout:
```

```
stderr:
```
Traceback (most recent call last):
  File "/app/app.py", line 52, in <module>
    solve()
  File "/app/app.py", line 49, in solve
    min_cost, min_cost_path = find_min_cost_path(n, costs, m)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/app.py", line 30, in find_min_cost_path
    dp[room] = costs[room - 1]
               ~~~~~^^^^^^^^^^
IndexError: list index out of range

```

Think of what has caused the exit code. Use the standard out and standard error to help you understand the issue.
Implement a solution to fix the program

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

I apologize for the confusion. The IndexError indicates that the code is still trying to access an index in the costs array that is out of range. This usually occurs when `room` variable goes beyond the number of costs available, which are from `0` to `n-1`. It seems my previous code still contained logical errors.

Let's address this by fixing the calculation of the room indexing. We will also avoid iterating to `n + 1` since the `costs` list is zero-indexed and only goes up to `n - 1`. Here's the corrected Python code:

```python
import math

def read_input(file_name):
    with open(file_name, 'r') as file:
        n = int(file.readline().strip())
        costs = list(map(int, file.readline().split()))
    return n, costs

def write_output(file_name, m, s, path):
    with open(file_name, 'w') as file:
        file.write(f"{m} {s}\n")
        file.write(' '.join(map(str, path)) + '\n')

def calculate_levels(n):
    # Find the height m of the pyramid using the formula for the sum of the first m squares
    m = int(math.sqrt(2 * n + 0.25) - 0.5)
    return m

def find_min_cost_path(costs, m):
    # Precompute the starting index of the last room for each level
    start_indices = [0] + [i**2 for i in range(1, m + 1)]
    # Initialize DP arrays for minimum costs and paths
    min_costs = [0] * (m + 1)
    paths = [[0] for _ in range(m + 1)]

    # Loop for each level from top to bottom
    for level in range(1, m + 1):
        for room_in_level in range(1, level + 1):
            room = start_indices[level] + room_in_level
            cost = costs[room - 1]

            # Find the possible previous rooms and choose the one with the minimum cost
            possible_prev_rooms = [room - level, room - level - 1, room - level + 1]
            prev_room = min((r for r in possible_prev_rooms if r >= start_indices[level - 1] + 1), default=0)
            
            # Calculate the cost and path for the current room
            total_cost = cost + min_costs[prev_room]
            path = paths[prev_room] + [room]

            # If it's the first room in level or a cheaper path is found, update the DP arrays
            if room_in_level == 1 or total_cost < min_costs[room]:
                min_costs[room] = total_cost
                paths[room] = path

    # The last level starts at start_indices[m] and ends at start_indices[m] + m
    last_level_rooms = range(start_indices[m] + 1, start_indices[m] + m + 1)
    # Find the room with the minimum cost in the last level
    min_cost_room = min(last_level_rooms, key=lambda x: min_costs[x])
    # Answer is the cost and path for that room
    return min_costs[min_cost_room], paths[min_cost_room]

def solve():
    n, costs = read_input('suma.in')
    m = calculate_levels(n)
    min_cost, min_cost_path = find_min_cost_path(costs, m)
    write_output('suma.out', m, min_cost, min_cost_path)

solve()
```

This solution calculates the correct `m` (the number of levels) using the sum of squares formula and the correct min_cost_path by ensuring the room indices are always within the bounds of the costs list. It should now work as expected.
---------- user ----------


Program exited with code 1.
stdout:
```

```
stderr:
```
Traceback (most recent call last):
  File "/app/app.py", line 58, in <module>
    solve()
  File "/app/app.py", line 55, in solve
    min_cost, min_cost_path = find_min_cost_path(costs, m)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/app.py", line 42, in find_min_cost_path
    min_costs[room] = total_cost
    ~~~~~~~~~^^^^^^
IndexError: list assignment index out of range

```

Think of what has caused the exit code. Use the standard out and standard error to help you understand the issue.
Implement a solution to fix the program

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

It seems there's still an issue with the code related to array indexing, resulting in the `IndexError`. I apologize for the confusion. I will carefully review the logic, simplify it and present a corrected solution that calculates the levels correctly, performs the dynamic programming step without out-of-bounds errors, and ensures the path is tracked appropriately.

Let's rewrite the solution with the corrected approach:

```python
def read_input(file_name):
    with open(file_name, 'r') as file:
        n = int(file.readline().strip())
        costs = list(map(int, file.readline().split()))
    return n, costs

def write_output(file_name, m, s, path):
    with open(file_name, 'w') as file:
        file.write(f"{m} {s}\n")
        file.write(' '.join(map(str, path)) + '\n')

def calculate_levels(n):
    m = 1
    while (m * (m + 1) // 2) < n:
        m += 1
    return m - 1 if (m * (m + 1) // 2) > n else m

def find_min_cost_path(n, costs):
    m = calculate_levels(n)
    dp = [[float('inf')] * (m + 1) for _ in range(m + 1)]
    parent = [[-1] * (m + 1) for _ in range(m + 1)]
    dp[1][1] = costs[0]
    for level in range(2, m + 1):
        for room in range(1, level + 1):
            for prev_room in range(room - 1, room + 2):
                if 1 <= prev_room <= level - 1:
                    cost = costs[(level * (level - 1)) // 2 + room - 1]
                    if dp[level - 1][prev_room] + cost < dp[level][room]:
                        dp[level][room] = dp[level - 1][prev_room] + cost
                        parent[level][room] = prev_room

    min_cost = min(dp[m][1:])
    last_room = dp[m].index(min_cost)
    path = [last_room + (m * (m - 1)) // 2]
    for level in range(m, 1, -1):
        last_room = parent[level][last_room]
        path.append(last_room + (level - 1) * (level - 2) // 2)
    path.reverse()
    path = [x + 1 for x in path]  # Convert to 1-indexed

    return m, min_cost, path

def solve():
    n, costs = read_input('suma.in')
    m, min_cost, min_cost_path = find_min_cost_path(n, costs)
    write_output('suma.out', m, min_cost, min_cost_path)

solve()
```

This version of the code should correctly handle the dynamic programming logic to find the minimum cost path while taking care to avoid any out-of-bounds errors. The functions have been updated, and the `calculate_levels` function now calculates the number of levels correctly, and the `find_min_cost_path` function correctly determines the path and cost.
---------- user ----------


Program result did not match expected result.
Input data:
```
14
7 8 4 5 5 8 4 2 7 7 8 3 1 6
```
Expected output:
```
3 13
1 3 8
```
Found output:
```
4 18
2 4 5 9
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The output is incorrect because the algorithm isn't correctly finding the minimum cost path. It seems that there is a problem with the logic for constructing the path and calculating the minimum cost. It is also possible that the way the levels are determined is not correct. 

We need to ensure that we correctly calculate the level `m` and that we choose the correct path based on the costs and the pyramid structure. The conditions for moving from room `k` to the next level need to be strictly followed as per the prompt.

Let's rewrite the solution from scratch, making sure to follow the problem description closely:

```python
from math import isqrt

# Read the input file
def read_input(filename):
    with open(filename, 'r') as file:
        n = int(file.readline().strip())
        costs = list(map(int, file.readline().split()))
    return n, costs

# Write to the output file
def write_output(filename, m, s, path):
    with open(filename, 'w') as file:
        file.write(f"{m} {s}\n")
        file.write(' '.join(str(room) for room in path))

# Determine the number of levels m in the pyramid
def calculate_levels(n):
    # Find m such that m(m+1)/2 <= n
    return isqrt(2 * n)

# Find minimum cost path
def find_min_cost_path(n, costs):
    # Initialize the dynamic programming table
    dp = [0] * (n + 1)
    # Initialize the path reconstruction table
    path = [-1] * (n + 1)
    dp[1] = costs[0]
    for i in range(2, n + 1):
        level = calculate_levels(i)
        dp[i] = float('inf')
        for d in (-level, -level + 1, 1):  # Possible transitions
            prev_room = i - d
            prev_level = calculate_levels(prev_room)
            if prev_level == level - 1 and dp[prev_room] + costs[i - 1] < dp[i]:
                dp[i] = dp[prev_room] + costs[i - 1]
                path[i] = prev_room
    # Reconstruct the path
    min_path = []
    room = n
    while room != -1:
        min_path.append(room)
        room = path[room]
    min_path.reverse()
    min_cost = dp[n]
    return calculate_levels(n), min_cost, min_path

# Solve the problem
def solve():
    n, costs = read_input('suma.in')
    m, min_cost, min_cost_path = find_min_cost_path(n, costs)
    write_output('suma.out', m, min_cost, min_cost_path)

# Execute the program
solve()
```

The logic here ensures that we are processing rooms level by level and calculating the cost to enter each room from the previous level's rooms. We only consider valid transitions that follow the constraints of the pyramid structure. We also use path reconstruction to determine the actual path taken to reach the last room. The `calculate_levels` function should return the correct level m for the given number of rooms n. This should produce the correct result.
---------- user ----------


Program result did not match expected result.
Input data:
```
14
7 8 4 5 5 8 4 2 7 7 8 3 1 6
```
Expected output:
```
3 13
1 3 8
```
Found output:
```
5 inf
14
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The issue with the previous solution is that it incorrectly calculates the number of levels (`m`) and does not correctly find the minimum cost path. We need to ensure that the formula for calculating the number of levels is accurate and that the dynamic programming solution properly evaluates the paths according to the problem constraints.

Based on the problem description, the number of levels `m` in the pyramid can be found using the reverse of the triangular number series formula, and it should be the maximum `m` such that `m(m + 1) / 2 <= n`.

Let's correct the calculation of `m` and rewrite the dynamic programming code to find the minimum cost path and the corresponding room numbers for each level:

```python
import math

def read_input(filename):
    with open(filename, 'r') as file:
        n = int(file.readline().strip())
        costs = list(map(int, file.readline().split()))
    return n, costs

def write_output(filename, m, s, path):
    with open(filename, 'w') as file:
        file.write(f"{m} {s}\n")
        file.write(' '.join(map(str, path)))

# Calculate the number of levels in the pyramid
def calculate_levels(n):
    # Find m for which sum of first m natural numbers is less than or equal to n
    return int((math.sqrt(8*n + 1) - 1) / 2)

def find_min_cost_path(n, costs):
    # Calculate number of levels in the pyramid
    m = calculate_levels(n)
    # Initialize arrays for dynamic programming
    dp = [math.inf] * (n + 1)
    path_indices = [0] * (n + 1)
    dp[1] = costs[0]
    path_indices[1] = 0
    # Calculate the offset for the current level
    for level in range(2, m + 1):
        level_offset = (level - 1) * level // 2
        # Iterate over rooms in the current level
        for room in range(1, level + 1):
            room_number = level_offset + room
            # Calculate the room number in the previous level that could lead to this room
            # and choose the one with the minimum cost path
            for prev_room in [room_number - level, room_number - level + 1]:
                if dp[prev_room] + costs[room_number - 1] < dp[room_number]:
                    dp[room_number] = dp[prev_room] + costs[room_number - 1]
                    path_indices[room_number] = prev_room
    # Reconstruct the path from path indices
    path = []
    room_number = n
    while room_number > 0:
        path.append(room_number)
        room_number = path_indices[room_number]
    path.reverse()
    return m, dp[n], path

def solve():
    n, costs = read_input('suma.in')
    m, min_cost, min_cost_path = find_min_cost_path(n, costs)
    write_output('suma.out', m, min_cost, min_cost_path)

solve()
```

This solution includes the corrected calculation of `m` and the proper dynamic programming algorithm to find the minimum cost path. It uses a `path_indices` array to reconstruct the path taken to get the minimum cost. After running this solution, it should now produce the expected output.
