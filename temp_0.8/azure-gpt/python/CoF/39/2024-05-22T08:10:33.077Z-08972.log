---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in python. The code must compile and be correct.
The solution must read from `suma.in` and write to `suma.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

~[suma1.png]
\
Constructorii angajaţi de faraonul Keops au terminat construirea piramidei în trepte mult visată. Măreaţa piramidă are $n$ camere identice de formă cubică, numerotate de la $1$ la $n$, dispuse pe $m$ niveluri astfel:
- camera din vârful piramidei formează nivelul $1$ şi are numărul $1$;
- nivelul $2$ al piramidei este format din următoarele $4$ camere care în secţiune cu un plan paralel cu baza au aspectul unei matrice cu $2$ linii şi $2$ coloane; camerele de pe nivelul $2$ sunt numerotate de la $2$ la $5$ în ordinea crescătoare a liniilor matricei, iar pe aceeaşi linie în ordinea crescătoare a coloanelor matricei;
...
- nivelul $m$ al piramidei este format din $m \times m$ camere şi au, în secţiune cu un plan paralel cu baza, aspectul unei matrice cu $m$ linii şi $m$ coloane; camerele de pe nivelul $m$ sunt numerotate în continuarea celor de pe nivelurile $1, 2, ..., m - 1$, în ordinea crescătoare a liniilor matricei de secţiune, iar pe aceeaşi linie în ordinea crescătoare a coloanelor matricei. De exemplu, piramida din desenul de mai sus are $n = 30, m = 4$ iar camerele sunt numerotate şi dispuse pe niveluri astfel:
\
 ~[suma2.png]
\
Nivelurile de camere sunt poziţionate astfel încât camerele de pe prima linie şi prima coloană a fiecărui nivel să se suprapună. Pentru exemplul dat, camerele $1, 2, 6$ şi $15$ sunt situate una sub alta, în această ordine.

Accesul în oricare din camerele piramidei, situate pe diferite niveluri, se realizează prin drumuri construite astfel:
* intrarea în piramidă se face doar prin camera din vârful ei, cea cu numărul $1$;
* din camera cu numărul $k$ de pe un drum se poate intra într-una din cele patru camere situate pe nivelul imediat următor al piramidei şi anume: camera situată sub cea cu numărul $k$ sau una din cele trei camere vecine acesteia în secţiune (în direcţiile Est, Sud-Est, Sud, considerând secţiunile poziţionate ca în imaginile de mai sus). De exemplu, din camera cu numărul $10$ se poate intra într-una din camerele cu numerele: $20, 21, 24$ sau $25$.

Faraonul priveşte cu mândrie şi tristeţe la frumoasa piramidă. Banii din visterie s-au împuţinat iar camerele piramidei trebuie finisate şi decorate. Scribul său favorit a refăcut toate calculele, a eliminat obiectele inutile şi a stabilit pentru fiecare cameră $k$ un cost $c_k$ aferent finisării şi decorării ei ($1 ≤ k ≤ n$). 

Însă, suma totală necesară fiind încă mare, faraonul i-a cerut scribului să aleagă un drum, dintre cele construite, care să treacă prin toate nivelurile piramidei astfel încât suma s a tuturor costurilor aferente finisării şi decorării camerelor de pe acest drum să fie minimă. Deocamdată, doar aceste camere vor fi aranjate...  

# Cerinţă
Scrieţi un program care să determine numărul $m$ de niveluri ale piramidei, suma minimă $s$ a tuturor costurilor aferente finisării şi decorării camerelor de pe un drum ce trece prin toate nivelurile piramidei, construit în modul descris în enunţ, precum şi un astfel de drum pentru care se obţine suma minimă, putând fi ales de scrib.

# Date de intrare
Fişierul de intrare `suma.in` conţine pe prima linie numărul natural nenul $n$ reprezentând numărul de camere din piramidă. A doua linie conţine $n$ numere naturale nenule $c_1, c_2,…, c_n$, separate prin câte un spaţiu, reprezentând costurile aferente finisării şi decorării camerelor, în ordinea numerotării lor.

# Date de ieşire
Fişierul de ieşire `suma.out` va conţine pe prima linie două numere naturale $m$ şi $s$, separate printr-un singur spaţiu, cu semnificaţia din enunţ. Cea de-a doua linie va conţine, separate prin câte un spaţiu, în ordinea parcurgerii lor, numerele camerelor de pe un drum ce trece prin toate nivelurile piramidei, drum pentru care se obţine suma minimă $s$. 

# Restricţii şi precizări
* $1 ≤ n ≤ 63\ 365$
* Pentru fiecare valoare $n$ citită se poate construi în modul descris în enunţ o piramidă în trepte cu $n$ camere 
* $1 ≤ c_1, c_2, ..., c_n < 100 $
* Dacă există mai multe drumuri ce trec prin toate nivelurile piramidei şi pentru care se obţine suma minimă $s$, atunci drumul ales va fi cel mai mic drum din punct de vedere lexicografic.
* Drumul $a_1, a_2, a_3, …, a_m$ este mai mic, din punct de vedere lexicografic, ca drumul $b_1, b_2, b_3, …, b_m$ dacă există un indice $j$ ($1 ≤ j ≤ m$) astfel încât $a_1=b_1, a_2=b_2 ,….,a_{j-1}=b_{j-1}$ şi $a_j < b_j$.
* Se acordă:
* $10%$ din punctaj pentru determinarea corectă a numărului $m$ de niveluri ale piramidei 
* $30%$ din punctaj pentru determinarea corectă a sumei minime $s$ 
* $60%$ din punctaj pentru determinarea corectă a drumului cerut.

---

Example:
`suma.in`
```
14
7 8 4 5 5 8 4 2 7 7 8 3 1 6
```

`suma.out`
```
3 13
1 3 8
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:Here's the optimized Python code solution for the given challenge:

```python
# Read from 'suma.in' and write to 'suma.out'
with open('suma.in', 'r') as file:
    n = int(file.readline().strip())
    cost = list(map(int, file.readline().split()))

# Calculate the number of levels in the pyramid
m = 1
while m * (m + 1) * (2 * m + 1) // 6 < n:
    m += 1

# Initialize the DP table
dp = [float('inf')] * n
dp[0] = cost[0]

# Initialize the parent table
parent = [-1] * n

# Populate the DP table with the minimum costs
for level in range(1, m):
    for room in range(level**2, (level+1)**2):
        room_index = sum(range(1, level+1))**2 + room - level**2
        if room_index >= n:
            break
        for d in (-(level+1), -1, 0, 1):
            prev_room_index = room_index - level - d
            if 0 <= prev_room_index < n and dp[prev_room_index] + cost[room_index] < dp[room_index]:
                dp[room_index] = dp[prev_room_index] + cost[room_index]
                parent[room_index] = prev_room_index

# Backtrack to find the path
path = []
min_cost_index = dp.index(min(dp[-m**2:]))
while min_cost_index != -1:
    path.append(min_cost_index)
    min_cost_index = parent[min_cost_index]
path.reverse()

# Correct the room numbers
path = [i + sum(range(1, int((1 + (8 * i + 1)**0.5) / 2))**2) for i in path]

# Write to 'suma.out'
with open('suma.out', 'w') as file:
    file.write(f"{m} {dp[path[-1]]}\n")
    file.write(' '.join(map(str, path)) + '\n')
```

This code calculates the number of levels in the pyramid, uses dynamic programming to find the minimum cost path, and backtracks to retrieve the path. It then writes the results to `suma.out`. Note that the room numbers are corrected to account for the way they are numbered in the pyramid before writing the path to the file.
---------- user ----------


Program exited with code 1.
stdout:
```

```
stderr:
```
Traceback (most recent call last):
  File "/app/app.py", line 39, in <module>
    path = [i + sum(range(1, int((1 + (8 * i + 1)**0.5) / 2))**2) for i in path]
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/app.py", line 39, in <listcomp>
    path = [i + sum(range(1, int((1 + (8 * i + 1)**0.5) / 2))**2) for i in path]
                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^~
TypeError: unsupported operand type(s) for ** or pow(): 'range' and 'int'

```

Think of what has caused the exit code. Use the standard out and standard error to help you understand the issue.
Implement a solution to fix the program

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

It appears that there was an error in the calculation of the room numbers in the previous code. The correct formula to adjust the room index to the numbering used in the pyramid should have been applied differently. Let's fix the program by correcting the calculation of room numbers. Here's the revised Python solution:

```python
# Read from 'suma.in' and write to 'suma.out'
with open('suma.in', 'r') as file:
    n = int(file.readline().strip())
    cost = list(map(int, file.readline().split()))

# Calculate the number of levels in the pyramid
m = 1
while m * (m + 1) * (2 * m + 1) // 6 < n:
    m += 1

# Initialize the DP table
dp = [[float('inf')] * m for _ in range(m)]
dp[0][0] = cost[0]

# Populate the DP table with the minimum costs
for level in range(1, m):
    base = sum([i * i for i in range(1, level + 1)])
    for room in range(level * level):
        room_index = base + room
        if room_index >= n:
            break
        # Determine parent rooms in the previous level
        parents = [room_index - (level - 1) - 1, room_index - (level - 1), room_index - level, room_index - level + 1]
        for p in parents:
            if p >= base - level * level and p < base and p < n:
                dp[level][room % level] = min(dp[level][room % level], dp[level - 1][p % (level - 1)] + cost[room_index])

# Find the minimum cost in the last level
min_cost = min(dp[-1][:len(cost) - sum([i * i for i in range(1, m)])])

# Backtrack to find the path
path = []
min_index = dp[-1][:len(cost) - sum([i * i for i in range(1, m)])].index(min_cost)
path.append(min_index + sum([i * i for i in range(1, m)]))
for level in range(m - 1, 0, -1):
    base = sum([i * i for i in range(1, level + 1)])
    room = path[-1] - base
    # Find the parent with the corresponding cost
    parents = [(room + (level - 1) + 1, room + level, room + level - 1), (room + (level - 1),), (room + (level - 1) - 1, room + level, room + level - 1)]
    for p in parents[room % level]:
        if dp[level - 1][p % (level - 1)] == dp[level][room % level] - cost[path[-1]]:
            path.append(p + base - level * level)
            break

path = [i + 1 for i in reversed(path)]

# Write to 'suma.out'
with open('suma.out', 'w') as file:
    file.write(f"{m} {min_cost}\n")
    file.write(' '.join(map(str, path)) + '\n')
```

This revised version fixes the calculation of the room numbers and uses dynamic programming to calculate the minimal path cost. It includes backtracking from the last level to the first to find the path. The output is then written to `suma.out`.
---------- user ----------


Program exited with code 1.
stdout:
```

```
stderr:
```
Traceback (most recent call last):
  File "/app/app.py", line 26, in <module>
    dp[level][room % level] = min(dp[level][room % level], dp[level - 1][p % (level - 1)] + cost[room_index])
                                                                         ~~^~~~~~~~~~~~~
ZeroDivisionError: integer modulo by zero

```

Think of what has caused the exit code. Use the standard out and standard error to help you understand the issue.
Implement a solution to fix the program

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The error occurred because of an attempt to calculate modulo by zero. This is caused by the incorrect indexing logic for parent rooms. Instead of using a 2D array for dynamic programming, it's better to use a 1D array where each index represents a room number. I'll also correct the backtracking logic to account for the shape of the pyramid.

Here's the corrected Python solution:

```python
# Read from 'suma.in' and write to 'suma.out'
with open('suma.in', 'r') as file:
    n = int(file.readline().strip())
    cost = list(map(int, file.readline().split()))

# Find m, the number of levels in the pyramid
m = 1
while (m * (m + 1) // 2) ** 2 < n:
    m += 1

# Initialize the DP table
dp = [None] * n
dp[0] = cost[0]

# Fill the DP table
for i in range(1, n):
    current_level = int(((-1 + (1 + 8 * i) ** 0.5) / 2))  # Inverse triangular number formula
    start_of_level = current_level * (current_level + 1) // 2
    candidates = [i - current_level]  # Directly above
    if i - start_of_level > 0:  # Not on the first column
        candidates.append(i - current_level - 1)
    if i - start_of_level < current_level:  # Not on the last column
        candidates += [i - current_level + 1, i - 1]

    min_cost = min([dp[x] for x in candidates if dp[x] is not None])
    dp[i] = min_cost + cost[i]

# Backtrack to find the path
path = [n - 1]
while path[-1] > 0:
    i = path[-1]
    current_level = int(((-1 + (1 + 8 * i) ** 0.5) / 2))
    start_of_level = current_level * (current_level + 1) // 2
    candidates = [i - current_level]  # Directly above
    if i - start_of_level > 0:  # Not on the first column
        candidates.append(i - current_level - 1)
    if i - start_of_level < current_level:  # Not on the last column
        candidates += [i - current_level + 1, i - 1]

    for x in candidates:
        if dp[i] == dp[x] + cost[i]:
            path.append(x)
            break

path.reverse()
path = [x + 1 for x in path]  # Convert to 1-indexed

# Write to 'suma.out'
with open('suma.out', 'w') as file:
    file.write(f"{m} {dp[n - 1]}\n")
    file.write(' '.join(map(str, path)) + '\n')
``` 

This code properly calculates the number of levels `m`, uses dynamic programming (DP) to find the minimum cost path, backtracks to find the path, and writes the resulting level count and path to `suma.out`. The indexing of the rooms is adjusted according to the given numbering in the problem statement.
---------- user ----------


Program result did not match expected result.
Input data:
```
14
7 8 4 5 5 8 4 2 7 7 8 3 1 6
```
Expected output:
```
3 13
1 3 8
```
Found output:
```
3 25
1 3 5 8 13 14
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The discrepancy in the results is due to an incorrect interpretation of the pyramid structure and the DP state transitions. In particular, the previous code does not account for the specific rules of movement through the pyramid correctly.

The problem requires a specific DP approach due to the unique way in which the rooms are connected. Below is the corrected Python solution to the problem:

```python
def get_level(index):
    level = 1
    while index > level * (level + 1) // 2:
        level += 1
    return level

# Read from 'suma.in' and write to 'suma.out'
with open('suma.in', 'r') as file:
    n = int(file.readline().strip())
    cost = list(map(int, file.readline().split()))

# Determine the number of levels m in the pyramid
m = 1
while m * (m + 1) * (2 * m + 1) // 6 < n:
    m += 1

# Initialize DP array
dp = [float('inf')] * n
dp[0] = cost[0]

# Store the parent room for path reconstruction
parent = [-1] * n

# DP to calculate minimum cost path
for i in range(1, n):
    level = get_level(i)
    start = level * (level - 1) // 2
    for j in range(start, start + level):
        if j < i:
            if dp[j] + cost[i] < dp[i]:
                dp[i] = dp[j] + cost[i]
                parent[i] = j
        else:
            break

# Reconstruct path from parent array
path = []
index = n - 1
while index != -1:
    path.append(index)
    index = parent[index]

path.reverse()

# Write results to 'suma.out'
with open('suma.out', 'w') as file:
    file.write(f"{m} {dp[n - 1]}\n")
    file.write(' '.join(str(x + 1) for x in path) + '\n')
```

This solution uses a dynamic programming approach where `dp[i]` stores the minimum cost to reach the `i-th` room. The `parent` array is used to reconstruct the path after the DP calculation. The `get_level` function calculates the level of a room given its index in the pyramid. The DP calculation is then performed, ensuring that we only consider the rooms that can be reached from the current room, following the rules of the pyramid. Finally, the path is reconstructed in reverse, from the last room to the first one, and the result (with room indices incremented by 1 to match the problem's 1-indexing) is written to 'suma.out'.
---------- user ----------


Program result did not match expected result.
Input data:
```
14
7 8 4 5 5 8 4 2 7 7 8 3 1 6
```
Expected output:
```
3 13
1 3 8
```
Found output:
```
3 38
1 2 4 7 11 14
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The algorithm still seems to have an issue with correctly calculating the minimum path cost and reconstructing the path. The previous code does not handle the connectivity rules between rooms within and across levels correctly.

To fix the solution, we need to properly calculate the possible next room indices that can be reached from the current room based on the given rules. At each level, we must consider only the rooms that can be reached from the current room (directly below, southeast, south, or east).

Here's the fixed and improved solution:

```python
def room_to_level(room):
    level = 1
    while room > level*(level + 1)//2:
        level += 1
    return level

# Read from 'suma.in' and write to 'suma.out'
with open('suma.in', 'r') as file:
    n = int(file.readline().strip())
    costs = list(map(int, file.readline().split()))

# Determine the number of levels m in the pyramid
m = 1
while (m * (m + 1) // 2) ** 2 < n:
    m += 1

# Initialize DP and parent arrays
dp = [float('inf')] * n
dp[0] = costs[0]
parent = [-1] * n

# Populate the DP array with minimum costs
for room in range(1, n):
    level = room_to_level(room)
    start_index = (level - 1) * level // 2
    end_index = level * (level + 1) // 2
    prev_level_end_index = start_index
    
    for prev_room in range(prev_level_end_index - level, prev_level_end_index):
        if prev_room < 0:
            continue
        # Directly above
        if dp[prev_room] + costs[room] < dp[room]:
            dp[room] = dp[prev_room] + costs[room]
            parent[room] = prev_room
        # South-East or South or East (in the same level)
        for next_room in (prev_room + 1, prev_room + level, prev_room + level + 1):
            if start_index <= next_room < end_index and dp[prev_room] + costs[next_room] < dp[next_room]:
                dp[next_room] = dp[prev_room] + costs[next_room]
                parent[next_room] = prev_room

# Backtrack to find the path
room = n - 1
path = []
while room != -1:
    path.append(room + 1)  # Convert to 1-based indexing
    room = parent[room]

path = path[::-1]  # Reverse path

# Write to 'suma.out'
with open('suma.out', 'w') as file:
    file.write(f"{m} {dp[n - 1]}\n")
    file.write(' '.join(map(str, path)) + '\n')
```

This corrected solution should now properly handle the connectivity between rooms in the pyramid and calculate the correct minimum path cost. The `parent` array is used to store the previous room for each room that leads to the minimum path cost, which allows us to reconstruct the path by backtracking from the last room. The final path is then written to `suma.out`.
---------- user ----------


Program exited with code 1.
stdout:
```

```
stderr:
```
Traceback (most recent call last):
  File "/app/app.py", line 38, in <module>
    if start_index <= next_room < end_index and dp[prev_room] + costs[next_room] < dp[next_room]:
                                                                ~~~~~^^^^^^^^^^^
IndexError: list index out of range

```

Think of what has caused the exit code. Use the standard out and standard error to help you understand the issue.
Implement a solution to fix the program

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The error is caused by trying to access an index in the `costs` list that is out of range, which is due to incorrect indexing when considering the rooms in the southeast, south, or east directions. The index `next_room` might exceed the total number of rooms `n`, so we need to add a condition to ensure we do not access an out-of-range index in the `costs` list.

Let's fix the issue by adding a condition to check if `next_room` is less than `n` before accessing `costs[next_room]`. Here is the revised solution with this fix:

```python
# Helper function to find the level of a given room
def find_level(room):
    level = 1
    while (level * (level + 1)) // 2 < room:
        level += 1
    return level

# Read the input file
with open('suma.in', 'r') as file:
    n = int(file.readline().strip())
    costs = list(map(int, file.readline().split()))

# Initialize DP array and parent pointers
dp = [float('inf')] * n
dp[0] = costs[0]
parent = [-1] * n

# Fill the DP array
for room in range(1, n):
    level = find_level(room)
    start = (level - 1) * level // 2
    for prev_room in range(start, start + level):
        for j, offset in enumerate([0, level, level + 1, 1]):  # Current, South, SE, East
            next_room = prev_room + offset
            if next_room < n and next_room >= start + (offset != 1) * level and dp[prev_room] + costs[next_room] < dp[next_room]:
                dp[next_room] = dp[prev_room] + costs[next_room]
                parent[next_room] = prev_room

# Backtrack to find the path
path = [n]
while path[-1] != 1:
    path.append(parent[path[-1] - 1] + 1)

# Write to the output file
with open('suma.out', 'w') as file:
    file.write(f"{find_level(n)} {dp[n - 1]}\n")
    file.write(' '.join(map(str, reversed(path))) + '\n')
```

In this corrected solution, we ensure that `next_room` is always within bounds before attempting to access the `costs` array. We also start by initializing the DP array with `inf` and set the first room's cost. The main loop computes the minimum cost for each room using the rooms directly above and the three rooms to the southeast, south, and east (if within the correct bounds). We then backtrack from the last room to find the minimum cost path, ensuring that we don't go out of bounds when accessing the `parent` list. Finally, we write the calculated minimum number of levels, minimum cost, and the path to the output file `suma.out`.
---------- user ----------


Program result did not match expected result.
Input data:
```
14
7 8 4 5 5 8 4 2 7 7 8 3 1 6
```
Expected output:
```
3 13
1 3 8
```
Found output:
```
5 25
1 3 4 8 13 14
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The output is incorrect because the program calculated the wrong number of levels (5 instead of 3) and did not correctly identify the minimum cost path.

The problem seems to be in the `find_level` function, which should correctly identify the level of a room within the pyramid. Additionally, the DP update step does not correctly handle the fact that you can only move to a room directly below or to the rooms in the east, southeast, and south directions of the room above.

Let's first correct the calculation for the number of levels and then adjust the DP step to correctly handle the allowed movements through the pyramid:

```python
def get_level(room, n):
    # Calculate level based on room index, where n is the total number of rooms
    level = 1
    while (level * (level + 1)) // 2 < room:
        level += 1
    return level

# Read the input file
with open('suma.in', 'r') as file:
    n = int(file.readline().strip())
    costs = list(map(int, file.readline().split()))

# Calculate the number of levels m in the pyramid
m = 0
while (m * (m + 1) // 2) < n:
    m += 1

# Initialize the DP array with costs
dp = [float('inf')] * n
dp[0] = costs[0]

# Initialize parent array for path reconstruction
parent = [-1] * n

# Dynamic programming to compute the minimum cost for each room
for room in range(1, n):
    level = get_level(room, n)
    prev_level = level - 1
    prev_level_start = (prev_level * (prev_level + 1)) // 2
    prev_level_end = (level * level) // 2
    range_start = max(prev_level_start, room - level)
    range_end = min(prev_level_end, room)

    for prev_room in range(range_start, range_end):
        # Check the allowed movements (below, southeast, south, east)
        for next_room in [room, room - prev_level, room - prev_level - 1]:
            if next_room >= n:
                continue  # Skip out-of-bound indices
            if dp[prev_room] + costs[next_room] < dp[next_room]:
                dp[next_room] = dp[prev_room] + costs[next_room]
                parent[next_room] = prev_room

# Backtracking to find the minimum cost path
path = []
current_room = n - 1
while current_room != -1:
    path.append(current_room + 1)
    current_room = parent[current_room]

# Write to the output file
with open('suma.out', 'w') as file:
    file.write(f"{m} {dp[n - 1]}\n")
    file.write(' '.join(map(str, reversed(path))) + '\n')
```

In this revised solution, we correct the number of levels `m` using the proper while loop condition. We then calculate the DP array by considering the correct range of rooms that can be moved to from the current room. The parent array is updated accordingly during this process. Once we have the minimum cost for the last room, we backtrack using the parent array to reconstruct the minimum cost path. The path and the results are then written to the file `suma.out`.
