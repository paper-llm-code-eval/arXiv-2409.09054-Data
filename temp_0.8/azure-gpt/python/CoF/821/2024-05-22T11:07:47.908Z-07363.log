---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in python. The code must compile and be correct.
The solution must read from `cifru.in` and write to `cifru.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Costel a descoperit într-o debara servieta cu cifru a tatălui său. Cifrul este compus din $4$ discuri metalice pe care sunt inscripționate cifrele de la $0$ la $9$. Fiecare disc se poate mișca individual, de sus în jos sau de jos în sus, formându-se combinații de cifre. De multe ori, datorită comodității, combinația ce permite deschiderea servietei este formată numai din cifre identice: $0000, 1111$ etc.

Costel își imaginează un cifru compus din $N$ discuri metalice, fiecare având inscripționate cifrele de la $0$ la $9$, fiecare putând fi deplasat în cele două direcții specificate anterior. Prin mutare Costel înțelege deplasarea unui disc în sus sau în jos, cu o singură poziție, adică deplasarea discului până la cifra precedentă, respectiv următoare celei curente.

# Cerință

Realizați un program care, cunoscând poziția inițială a fiecărui disc dintre cele N discuri ale cifrului, determină și afișează:

1. cifra cea mai mare care apare pe discurile cifrului în forma inițială;
2. numărul minim de mutări necesare pentru ca numărul obținut pe cifru să fie compus numai din cifre identice, număr necesar deschiderii servietei;
3. cifra cea mai mică ce se poate obține în urma efectuării numărului minim de mutări determinat;
4. numărul de combinații formate din cifre identice, care se poate obține în urma efectuării numărului minim de mutări determinat.

# Date de intrare

Fișierul `cifru.in` conține:

* pe prima linie numărul natural $N$ reprezentând numărul discurilor;
* pe următoarele $N$ linii câte o cifră, reprezentând cifra curentă de pe fiecare disc al cifrului.

# Date de ieșire

În fișierul de ieșire `cifru.out` se vor afișa, pe linii separate, cele $4$ valori solicitate.

# Restricții și precizări

* $1 < N \leq 100 \ 000$;
* Un disc poate să rămână nemișcat.
* Pentru rezolvarea corectă a cerinței $1$ se acordă $20\%$ din punctajul fiecărui test
* Pentru rezolvarea corectă a cerinței $2$ se acordă $40\%$ din punctajul fiecărui test
* Pentru rezolvarea corectă a cerinței $3$ se acordă $20\%$ din punctajul fiecărui test
* Pentru rezolvarea corectă a cerinței $4$ se acordă $20\%$ din punctajul fiecărui test

---

Example:
`cifru.in`
```
4
7
3
9
0
```

`cifru.out`
```
9
7
0
2
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```markdown
```python
# Read the input data from cifru.in
with open('cifru.in', 'r') as file:
    N = int(file.readline().strip())
    disks = [int(file.readline().strip()) for _ in range(N)]

# Calculate the highest digit
highest_digit = max(disks)

# Calculate the number of moves to make all disks show the same digit
# and find the smallest digit that can be obtained after the moves
moves = [10 - disk if disk > 4 else disk for disk in disks]
min_moves = sum(moves)
smallest_digit_after_moves = min(moves) % 10
moves_to_make_all_equal = min(min_moves // N, 10 - (min_moves // N)) * N
if min_moves % N != 0:
    moves_to_make_all_equal += N

# Calculate the number of combinations of identical digits
combinations = 1
if min_moves % N == 0:
    combinations = 10
else:
    if min_moves // N + 1 <= 4:
        combinations += 1
    if 10 - (min_moves // N + 1) <= 4:
        combinations += 1

# Write the output data to cifru.out
with open('cifru.out', 'w') as file:
    file.write(f"{highest_digit}\n{moves_to_make_all_equal}\n{smallest_digit_after_moves}\n{combinations}\n")
```
```
---------- user ----------


Expected program to write result to `cifru.out` and read from `cifru.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
# Read the input data from cifru.in
with open('cifru.in', 'r') as file:
    N = int(file.readline().strip())
    disks = [int(file.readline().strip()) for _ in range(N)]

# Calculate the highest digit
highest_digit = max(disks)

# Calculate the frequencies of each digit
frequencies = [0] * 10
for disk in disks:
    frequencies[disk] += 1

# Calculate the smallest number of moves to make all disks show the same digit
min_moves = float('inf')
for target_digit in range(10):
    moves = 0
    for digit in range(10):
        diff = abs(digit - target_digit)
        moves += min(diff, 10 - diff) * frequencies[digit]
    min_moves = min(min_moves, moves)

# Find the smallest digit that can be obtained after making the smallest number of moves
smallest_digit_after_moves = 0
for i in range(1, 10):
    if frequencies[i] > frequencies[smallest_digit_after_moves]:
        smallest_digit_after_moves = i

# Calculate the number of combinations of identical digits that can be obtained
# Find the distance of each digit to its nearest identical digit after moves
distances = [min(digit, 10 - digit) for digit in range(10)]
target_digit_after_moves = (smallest_digit_after_moves + distances[smallest_digit_after_moves]) % 10
combinations = 0
for digit in range(10):
    if distances[digit] == distances[smallest_digit_after_moves]:
        combinations += 1

# Write the output data to cifru.out
with open('cifru.out', 'w') as file:
    file.write(f"{highest_digit}\n{min_moves}\n{target_digit_after_moves}\n{combinations}\n")
```
```
---------- user ----------


Expected program to write result to `cifru.out` and read from `cifru.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
# Read the input data from cifru.in
with open('cifru.in', 'r') as file:
    N = int(file.readline())
    disks = [int(file.readline()) for _ in range(N)]

# Calculate the highest digit
highest_digit = max(disks)

# Calculate the total moves for each possible identical digit and find the minimum
total_moves = [0] * 10
for disk in disks:
    for i in range(10):
        move = min(abs(disk - i), 10 - abs(disk - i))
        total_moves[i] += move

# Determine the minimum number of moves and the digits that can be formed
min_moves = min(total_moves)
identical_digits = [i for i, moves in enumerate(total_moves) if moves == min_moves]

# Calculate the number of combinations of identical digits that can be obtained
combinations = len(identical_digits)

# Determine the smallest digit that can be obtained after the minimum number of moves
smallest_digit_after_moves = min(identical_digits)

# Write the output data to cifru.out
with open('cifru.out', 'w') as file:
    file.write(f"{highest_digit}\n{min_moves}\n{smallest_digit_after_moves}\n{combinations}\n")
```
```
---------- user ----------


Expected program to write result to `cifru.out` and read from `cifru.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
def calculate_outcomes(disks):
    # Calculate the highest digit
    highest_digit = max(disks)

    # Initialize list to count moves for each final digit from 0 to 9
    moves_count = [0] * 10
    for disk in disks:
        for final_digit in range(10):
            # Calculate the minimum moves to turn the current disk to the final_digit
            moves_count[final_digit] += min(abs(final_digit - disk), 10 - abs(final_digit - disk))

    # Determine the minimum number of moves and which final digit(s) achieve this
    min_moves = min(moves_count)
    min_digit = moves_count.index(min_moves)

    # Calculate the number of combinations of identical digits that can be obtained
    # It's always 1 if we can reach different digits with the same number of moves
    combinations = moves_count.count(min_moves)

    return highest_digit, min_moves, min_digit, combinations

# Read the input data from cifru.in
with open('cifru.in', 'r') as file:
    N = int(file.readline().strip())
    disks = [int(file.readline().strip()) for _ in range(N)]

# Calculate outcomes
highest_digit, min_moves, smallest_digit_after_moves, combinations = calculate_outcomes(disks)

# Write the output data to cifru.out
with open('cifru.out', 'w') as file:
    file.writelines([
        f"{highest_digit}\n",
        f"{min_moves}\n",
        f"{smallest_digit_after_moves}\n",
        f"{combinations}\n"
    ])
```
```
---------- user ----------


Expected program to write result to `cifru.out` and read from `cifru.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
# Read input data from cifru.in
with open('cifru.in', 'r') as fin:
    N = int(fin.readline())
    disks = [int(fin.readline()) for _ in range(N)]

# Find the highest digit on the disks
highest_digit = max(disks)

# Calculate the moves required to make all disks display the same digit
moves = [0] * 10
for disk in disks:
    for d in range(10):
        moves[d] += min(abs(disk - d), 10 - abs(disk - d))

# Determine the minimum number of moves and the corresponding digit
min_moves = min(moves)
target_digit = moves.index(min_moves)

# Calculate the number of possible combinations and the smallest digit
# The smallest digit is the one with the minimum moves required
smallest_digit = target_digit
combinations = moves.count(min_moves)

# Write output data to cifru.out
with open('cifru.out', 'w') as fout:
    fout.write(f"{highest_digit}\n")
    fout.write(f"{min_moves}\n")
    fout.write(f"{smallest_digit}\n")
    fout.write(f"{combinations}\n")
```
```
---------- user ----------


Expected program to write result to `cifru.out` and read from `cifru.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
# Read the input data from cifru.in
with open('cifru.in', 'r') as file:
    N = int(file.readline())
    initial_positions = [int(file.readline()) for _ in range(N)]

# Find the highest digit on the disks
highest_digit = max(initial_positions)

# Initialize the move counter for each digit
move_counter = [0] * 10

# Calculate the total number of moves needed for each digit to become identical
for position in initial_positions:
    for digit in range(10):
        move_counter[digit] += min(abs(position - digit), 10 - abs(position - digit))

# Find the minimum number of moves and corresponding digit(s)
min_moves = min(move_counter)
target_digits = [digit for digit, moves in enumerate(move_counter) if moves == min_moves]

# Find the smallest digit that can be formed by making the minimum number of moves
smallest_digit = min(target_digits)

# Calculate the number of combinations of identical digits
combinations = len(target_digits)

# Write the output data to cifru.out
with open('cifru.out', 'w') as file:
    file.write(f"{highest_digit}\n")
    file.write(f"{min_moves}\n")
    file.write(f"{smallest_digit}\n")
    file.write(f"{combinations}\n")
```
```
---------- user ----------


Expected program to write result to `cifru.out` and read from `cifru.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```markdown
```python
# Read from cifru.in
with open('cifru.in', 'r') as file:
    N = int(file.readline())
    disks = [int(file.readline()) for _ in range(N)]

# Determine the highest digit
highest_digit = max(disks)

# Calculate number of moves to set all disks to each possible digit (0-9)
moves_to_digits = [0] * 10
for disk in disks:
    for digit in range(10):
        moves_to_digits[digit] += min(abs(disk - digit), 10 - abs(disk - digit))

# Determine the minimum number of moves and to which digit
min_moves = min(moves_to_digits)
target_digit = moves_to_digits.index(min_moves)

# Since we want the smallest digit for the same number of moves, we'll traverse the moves_to_digits
# array from start to end, and choose the first (smallest) digit with the same move count.
for digit, moves in enumerate(moves_to_digits):
    if moves == min_moves:
        smallest_digit = digit
        break

# Calculate the number of combinations of identical digits (digits with same no. of moves as min_moves)
combinations = moves_to_digits.count(min_moves)

# Write to cifru.out
with open('cifru.out', 'w') as file:
    file.write(f"{highest_digit}\n{min_moves}\n{smallest_digit}\n{combinations}\n")
```
```
