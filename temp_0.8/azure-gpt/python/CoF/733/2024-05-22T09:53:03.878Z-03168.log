---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in python. The code must compile and be correct.
The solution must read from `perle.in` and write to `perle.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Graniţa nu se trece uşor. Asta pentru că Balaurul Arhirel (mare pasionat de informatică) nu lasă pe nimeni să treacă decât după ce răspunde la nişte întrebări...

În acea ţară există $3$ tipuri de perle normale (le vom nota cu $1$, $2$ şi $3$) şi $3$ tipuri de perle magice (le vom nota cu $A$, $B$ şi $C$). Perlele magice sunt deosebite prin faptul că se pot transforma în alte perle (una sau mai multe, normale sau magice):
- Perla magică de tipul $A$ se poate transforma în orice perlă normală (una singură);
- Perla magică de tipul $B$ se poate transforma într-o perlă normală de tipul $2$ şi una magică de tipul $B$, sau într-o perlă normală de tipul $1$, una magică de tipul $A$, una normală de tipul $3$, una magică de tipul $A$ şi una magică de tipul $C$;
- Perla magică de tipul $C$ se poate transforma într-o perlă normală de tipul $2$ sau într-o perlă normală de tipul $3$, una magică de tipul $B$ şi una magică de tipul $C$ sau într-o perlă normală de tipul $1$, una normală de tipul $2$ şi una magică de tipul $A$.

Ca să rezumăm cele de mai sus putem scrie:
```
A -> 1  | 2     | 3
B -> 2B | 1A3AC
C -> 2  | 3BC   | 12A
```

Balaurul Arhirel ne lasă la început să ne alegem o perlă magică (una singură), iar apoi folosind numai transformările de mai sus trebuie să obţinem un anumit şir de perle normale. Când o perlă magică se transformă, perlele din stânga şi din dreapta ei rămân la fel (şi în aceeaşi ordine). De asemenea ordinea perlelor rezultate din transformare este chiar cea prezentată mai sus.

De exemplu, dacă balaurul ne cere să facem şirul de perle `21132123`, putem alege o perlă magică de tipul $B$ şi următorul şir de transformări: `B -> 2B -> 21A3AC -> 21A3A12A -> 21132123`.

Întrucât Balaurul nu are prea multă răbdare, el nu ne cere decât să spunem dacă se poate sau nu obţine şirul respectiv de perle.

# Cerință

Să se determine pentru fiecare şir de intrare dacă se poate obţine prin transformările de mai sus sau nu (alegând orice primă perlă magică, la fiecare şir).

# Date de intrare

Fişierul de intrare `perle.in` are următoarea structură:
* Pe prima linie numărul $N$, reprezentând numărul de şiruri din fişierul de intrare;
* Urmează $N$ linii; a $i$-a linie dintre cele $N$ descrie şirul $i$, printr-o succesiune de numere naturale despărţite de câte un spaţiu. Primul număr reprezintă lungimea şirului $L_i$, iar următoarele $L_i$ numere sunt tipurile de perle normale, în ordine, de la stânga la dreapta.

# Date de ieșire

Fişierul `perle.out` va conţine $N$ linii. Pe linia $i$ se va scrie un singur număr $1$ sau $0$ ($1$ dacă se poate obţine şirul respectiv (al $i$-lea) şi $0$ dacă nu se poate).

# Restricții și precizări

* $1 \leq N \leq 10$;
* $1 \leq L_i \leq 10 \ 000$, pentru oricare $i$;

---

Example:
`perle.in`
```
3
8 2 1 1 3 2 1 2 3
2 2 2
1 3
```

`perle.out`
```
1
0
1
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```python
# perle.py
def check_sequence(seq):
    # Initialize counters for the number of each normal pearl type.
    count_1, count_2, count_3 = 0, 0, 0
    for pearl in seq:
        if pearl == 1:
            count_1 += 1
        elif pearl == 2:
            count_2 += 1
        elif pearl == 3:
            count_3 += 1
        else:
            return False  # Invalid pearl type detected.

    # Check if the sequence can be generated by the rules specified.
    # The number of pearls of type 2 must be equal or greater than the number of type 1 and type 3 pearls.
    # This is because type A can generate all normal pearls, 
    # type B can generate 2s and replicate itself and type C can eventually generate 1s and 2s.
    # So, for every 1 or 3, we need at least one 2 to allow A or B to create the 1 or 3.
    return count_2 >= count_1 and count_2 >= count_3

def main():
    with open('perle.in', 'r') as fin:
        n = int(fin.readline().strip())
        # Read each sequence and check if it can be obtained.
        results = []
        for _ in range(n):
            # Split sequence and convert to integers except the first one which is the length.
            seq = list(map(int, fin.readline().strip().split()))[1:]
            results.append(1 if check_sequence(seq) else 0)

    with open('perle.out', 'w') as fout:
        # Write out the results, each on a new line.
        fout.write('\n'.join(map(str, results)))

if __name__ == "__main__":
    main()
```

**Note:** The code block above contains Python code intended to be saved as `perle.py` and run with the input file `perle.in` in the same directory. Ensure that the two files are placed correctly before running the code. The output will be written to `perle.out`.
---------- user ----------


Program result did not match expected result.
Input data:
```
3
8 2 1 1 3 2 1 2 3
2 2 2
1 3
```
Expected output:
```
1
0
1
```
Found output:
```
1
1
0
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The original algorithm incorrectly assumes that the presence of a sufficient number of 2s compared to 1s and 3s is the only condition needed to satisfy the transformation requirements. This is incorrect because the transformation rules for magical pearls also dictate the order of the resulting normal pearls. For example, the sequence `2 2 2` cannot be obtained because there is no magical pearl transformation that can produce three consecutive 2s without producing either 1s or 3s in between.

To correctly handle the problem, we must consider both the count and the arrangement of the pearls. A proper algorithm needs to try to construct the given sequence by considering the transformations—it must not only count the pearls but also use the transformation rules to see if we can achieve the sequence from a single magical pearl.

Here's an updated solution that takes into account the transformation rules:

```python
# Function to check if the sequence can be obtained
def can_obtain(sequence):
    # Given the rules, a sequence can be obtained if it can be broken down into parts that match
    # the transformation rules for A, B, and C pearls.
    # - A can become any single pearl
    # - B can become 2B or 1A3AC
    # - C can become 2, 3BC, or 12A
    # So if we can find a way to decompose the sequence into valid parts, it's obtainable.
    # Since A can become any single pearl, we only need to check for B and C transformations.

    # A valid sequence can only end with A, 2B or 3BC transformation, since any additional pearls
    # would have needed another magical pearl to follow.
    # So, we'll look for these endings, and if we find a valid one, we remove it and repeat the process.

    while sequence:
        if sequence.endswith("2B"):
            sequence = sequence[:-2]
        elif sequence.endswith("1A3AC"):
            sequence = sequence[:-5]
        elif sequence.endswith("3BC"):
            sequence = sequence[:-3]
        elif sequence.endswith("12A"):
            sequence = sequence[:-3]
        else:
            # If we can't find a valid ending, the sequence can't be obtained.
            return False

    # If we've managed to completely break down the sequence, it's valid.
    return True

# Main function to read, process, and write data
def main():
    with open('perle.in', 'r') as fin:
        n = int(fin.readline().strip())
        results = []

        # Read each sequence and check if it can be obtained
        for _ in range(n):
            data = list(map(int, fin.readline().strip().split()))
            length, sequence = data[0], ''.join(['AB' if num == 2 else 'AAC' if num == 1 else 'ABC' for num in data[1:]])

            # Check if the sequence is obtainable
            results.append(1 if can_obtain(sequence) else 0)

    # Write the results to the output file
    with open('perle.out', 'w') as fout:
        fout.write('\n'.join(map(str, results)))

if __name__ == "__main__":
    main()
``` 

This solution involves checking for the valid transformation endings and iteratively reducing the sequence until it is either completely reduced or until no valid transformation can be found, indicating that the sequence is not obtainable. The mappings in the sequence creation `['AB' if num == 2 else 'AAC' if num == 1 else 'ABC' for num in data[1:]]` are placeholders for the real pearls, they are not actual transformations but simple unique markers to conduct the substring checks and simulate the removal of a valid transformation sequence.
---------- user ----------


Program result did not match expected result.
Input data:
```
3
8 2 1 1 3 2 1 2 3
2 2 2
1 3
```
Expected output:
```
1
0
1
```
Found output:
```
0
0
0
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

I apologize for the confusion. It seems the previous solution attempted to simulate transformations in a way that did not correctly represent the rules given in the prompt. To correct this, we need to revisit the rules and create an algorithm that properly checks whether a sequence can be obtained from a single magical pearl.

Let's revise our approach by considering the following:
- A magical pearl of type A can turn into any single normal pearl.
- A magical pearl of type B can replicate itself while producing a normal pearl of type 2 or produce a sequence of 1A3AC.
- A magical pearl of type C can produce a normal pearl of type 2, a sequence of 3BC, or a sequence of 12A.

From these rules, we can conclude that:
- A single type A can produce a sequence with an equal number of 1s, 2s, and 3s.
- A single type B or C can produce a sequence with at least one more 2 than the sum of 1s and 3s.
- No magical pearl can produce three consecutive 2s without producing at least one 1 or 3 in between them.

With this in mind, let's implement a solution that checks the sequence for these patterns:

```python
def can_transform(seq):
    # Counts of 1s, 2s, and 3s needed to check against the rules
    count_1, count_2, count_3 = 0, 0, 0

    # Calculate the counts
    for pearl in seq:
        if pearl == 1:
            count_1 += 1
        elif pearl == 2:
            count_2 += 1
        elif pearl == 3:
            count_3 += 1

    # Check if the counts satisfy the conditions for transformation
    # A single magical pearl can only make sequences where:
    # - The count of 2s is at least the count of 1s and at least the count of 3s (for B or C transformations)
    # - There cannot be three consecutive 2s without a 1 or a 3 in between (as no transformation can produce this)
    if count_2 < count_1 or count_2 < count_3:
        return False
    for i in range(len(seq) - 2):
        if seq[i] == seq[i + 1] == seq[i + 2] == 2:
            return False
    return True

# Main function to read, process, and write data
def main():
    with open('perle.in', 'r') as fin:
        n = int(fin.readline().strip())
        results = []

        for _ in range(n):
            data = list(map(int, fin.readline().strip().split()))[1:]
            results.append(1 if can_transform(data) else 0)

    with open('perle.out', 'w') as fout:
        fout.write('\n'.join(map(str, results)))

if __name__ == "__main__":
    main()
```

This implementation checks that the count of 2s is enough to enable the transformations and that there are no illegal patterns (such as three consecutive 2s) which would be impossible to generate according to the given rules. If these conditions are satisfied, the sequence can be produced by a single magical pearl; otherwise, it cannot.
---------- user ----------


Program result did not match expected result.
Input data:
```
3
8 2 1 1 3 2 1 2 3
2 2 2
1 3
```
Expected output:
```
1
0
1
```
Found output:
```
1
1
0
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

I apologize for the oversight. It appears that the previous implementation failed to consider the specific transformation sequences that can be produced by each magical pearl type. The solution is not as simple as counting pearls and checking for consecutive 2s, as the transformation rules allow for more complex sequences.

In particular, the sequence of three 2s is deemed impossible by the last implementation, but there are valid transformations that could lead to three 2s such as "B -> 2B -> 22B -> 222B -> ..." However, these transformations would also involve generating corresponding 1s and 3s around the 2s, as per the transformation rules for the magical pearls.

It is important to realize that the presence of a single 2 alone is not enough to warrant a transformation from a magical pearl type B or C, as it could be part of a sequence that was generated by a transformation from a magical pearl of type A (as A -> 1 | 2 | 3).

To accurately determine whether a sequence can be produced by a single magical pearl, we need to consider a few key points:

1. The total number of pearls of type 1 and 3 must not exceed the number of pearls of type 2, as each transformation that generates a 1 or 3 also generates a 2 (except for the initial transformation from a magical pearl).
2. If the sequence starts or ends with a 1 or a 3, it implies that a transformation from a type A or C must have occurred, as type B cannot create a sequence starting or ending with 1 or 3 without additional 2s.
3. Transformations from type B and C should not leave behind a sequence of three consecutive 2s without an accompanying 1 or 3, as such a transformation would require an additional magical pearl.
4. Let's re-implement the solution with a better understanding of these rules:

```python
def can_transform(seq):
    # Counts of 1s, 2s, and 3s needed to check against the rules
    count_1, count_2, count_3 = 0, 0, 0
    prev_pearl = 0

    for pearl in seq:
        if pearl == 1:
            count_1 += 1
        elif pearl == 2:
            count_2 += 1
        elif pearl == 3:
            count_3 += 1

        # Check if there are three consecutive 2s
        if pearl == 2:
            if prev_pearl == 2:  # This is the second consecutive 2
                if count_1 == 0 and count_3 == 0:  # Must be preceded by a 1 or a 3
                    return False
            prev_pearl = 2
        else:
            prev_pearl = 0  # Reset consecutive 2s count

    # Count of 2s cannot be less than the sum of 1s and 3s
    if count_2 < count_1 + count_3:
        return False

    # If the sequence starts or ends with 1 or 3, count of 2s must be greater than the sum of 1s and 3s
    if (seq[0] in (1, 3) or seq[-1] in (1, 3)) and count_2 == count_1 + count_3:
        return False

    return True

def main():
    with open('perle.in', 'r') as fin:
        n = int(fin.readline().strip())
        results = []

        for _ in range(n):
            data = list(map(int, fin.readline().strip().split()))[1:]
            results.append(1 if can_transform(data) else 0)

    with open('perle.out', 'w') as fout:
        fout.write('\n'.join(map(str, results)))

if __name__ == "__main__":
    main()
```

In this implementation, we consider the count of each pearl type, the possibility of consecutive 2s, and the start and end of the sequence to ensure it adheres to all possible transformations. This solution should now provide the correct output for the given input data.
---------- user ----------


Program result did not match expected result.
Input data:
```
3
8 2 1 1 3 2 1 2 3
2 2 2
1 3
```
Expected output:
```
1
0
1
```
Found output:
```
0
0
0
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The current approach has several flaws. Specifically, it imposes restrictions on the sequence that the transformation rules do not necessarily enforce (such as prohibiting three consecutive 2s). The fundamental issue here is that the transformation rules allow for the growth of the sequence in non-linear ways, especially due to the recursive nature of the transformation for the B and C pearls.

To determine whether a sequence can be formed, it's necessary to recognize that the problem can be solved using a greedy approach. This approach should start by picking one of the magical pearls A, B, or C, and then trying to obtain the target sequence through the allowed transformations.

Here are the key realizations for this problem:
1. A magical pearl of type A can be converted to any single normal pearl.
2. A magical pearl of type B can be converted to a sequence starting with a 2, followed by any sequence that a B can make. Alternatively, it can be converted into 1A3AC, which means a sequence starting with a 1 and ending with a 3 can be created as long as there is at least one 2 in the middle.
3. A magical pearl of type C can be converted into a 2, or a sequence 3BC, which means a sequence ending in a 3 can be created as long as it is followed by a 2, or a sequence 12A, meaning a sequence starting with a 1 and followed by a 2 can be made.

Based on these rules, a sequence can be created by a magical pearl if:
- There is at least as many 2s as there are 1s and 3s since a 2 is created for every 1 or 3 created from a transformation.
- The sequence does not contain three consecutive 2s unless it is at the end of the sequence and has been created by B transformations.
- There can't be two consecutive 1s or 3s because no transformation by a magical pearl creates two consecutive 1s or 3s without a 2 in between.

Let's rewrite the solution based on these insights:

```python
def can_transform(seq):
    # Count the number of each type of pearl
    count_1, count_2, count_3 = seq.count(1), seq.count(2), seq.count(3)

    # Check if there's at least as many 2s as the sum of 1s and 3s.
    if count_2 < count_1 + count_3:
        return False

    # Check for the sequence of three consecutive 2s not at the end of the sequence.
    for i in range(len(seq) - 2):
        if seq[i] == seq[i + 1] == seq[i + 2] == 2:
            # Allow for the case where the sequence ends with 2s generated by B transformations
            if i + 2 != len(seq) - 1:
                return False

    # Check for two consecutive 1s or 3s.
    for i in range(len(seq) - 1):
        if (seq[i] == 1 and seq[i + 1] == 1) or (seq[i] == 3 and seq[i + 1] == 3):
            return False

    # If all checks pass, the sequence is valid.
    return True

def main():
    with open('perle.in', 'r') as fin:
        n = int(fin.readline().strip())
        results = []

        for _ in range(n):
            _, *seq = map(int, fin.readline().strip().split())
            results.append(1 if can_transform(seq) else 0)

    with open('perle.out', 'w') as fout:
        fout.writelines(f"{result}\n" for result in results)

if __name__ == "__main__":
    main()
```

This solution checks the sequence for the necessary conditions to be formed from a single magical pearl. If these conditions are met, we output that the sequence can be obtained; otherwise, we output that it cannot.
---------- user ----------


Program result did not match expected result.
Input data:
```
3
8 2 1 1 3 2 1 2 3
2 2 2
1 3
```
Expected output:
```
1
0
1
```
Found output:
```
0
1
0
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

It seems the previous attempts did not correctly capture the essence of the transformation rules, which is critical for determining whether a given sequence of normal pearls can be obtained from a single magical pearl. Upon re-examining the problem, it is clear that the transformation rules allow for the following:

- A single type A can transform into any normal pearl.
- B can keep reproducing itself while generating a normal pearl 2, which means any number of 2s can be followed by a single B.
- B can also transform into a sequence starting with a 1 and ending with a 3, with a B (and thus any number of 2s) in between.
- C can become a 2, or it can become a sequence starting with a 3 and ending with a 2 (with a C in between which can then become a 2), or it can become a sequence starting with a 1 and ending with 2As (which can both become any normal pearl).

Given these rules, we need to revise the algorithm with the following considerations:

1. If there are more 1s and 3s than 2s, it is not possible to form the sequence, as each transformation that generates a 1 or a 3 also generates a 2.
2. If the sequence starts with 1s, those 1s can only be generated by a C transforming into a 12A sequence, or by an A, which means that for each starting 1 (except possibly the first), there must be a following 2 to match the 12A transformation.
3. If the sequence ends with 3s, those 3s can only be generated by a C transforming into a 3BC sequence, or by an A, which means that for each ending 3 (except possibly the last), there must be a preceding 2 to match the 3BC transformation.
4. For any internal 1 or 3 that is not at the beginning or end of the sequence, there must be a 2 on both sides.
5. Since a B can replicate itself and generate a 2, any number of 2s in the sequence can be generated by a series of Bs.

Let's implement the solution now:

```python
def can_transform(seq):
    # Calculate the counts of 1s, 2s, and 3s
    count_1 = seq.count(1)
    count_2 = seq.count(2)
    count_3 = seq.count(3)
    
    # Check if there are enough 2s to satisfy the 1s and 3s generated
    if count_2 < count_1 + count_3:
        return False
    
    # Check the start of the sequence for the pattern 12A, which can only be generated by C or A
    idx = 0
    while idx < len(seq) and seq[idx] == 1:
        if (idx + 1 < len(seq) and seq[idx + 1] != 2) and (idx > 0 and seq[idx - 1] != 2):
            return False
        idx += 1
        
    # Check the end of the sequence for the pattern 3BC, which can only be generated by C or A
    idx = len(seq) - 1
    while idx >= 0 and seq[idx] == 3:
        if (idx - 1 >= 0 and seq[idx - 1] != 2) and (idx < len(seq) - 1 and seq[idx + 1] != 2):
            return False
        idx -= 1
    
    # Check internal 1s and 3s to ensure they are surrounded by 2s
    for idx in range(1, len(seq) - 1):
        if seq[idx] == 1 or seq[idx] == 3:
            if seq[idx - 1] != 2 or seq[idx + 1] != 2:
                return False
    
    # If all checks pass, the sequence can be generated
    return True

def main():
    with open('perle.in', 'r') as fin:
        n = int(fin.readline().strip())
        results = []
        for _ in range(n):
            _, *seq = map(int, fin.readline().strip().split())
            results.append(1 if can_transform(seq) else 0)

    with open('perle.out', 'w') as fout:
        fout.writelines(f"{result}\n" for result in results)

if __name__ == "__main__":
    main()
```

This solution checks the sequence for patterns that can be generated by transformations from magical pearls A, B, and C, ensuring that each 1 and 3 is properly accounted for by a 2 and that the sequence adheres to all transformation rules. If these conditions are satisfied, the sequence is deemed obtainable.
---------- user ----------


Program result did not match expected result.
Input data:
```
3
8 2 1 1 3 2 1 2 3
2 2 2
1 3
```
Expected output:
```
1
0
1
```
Found output:
```
0
1
0
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The task at hand requires a careful examination of the transformation rules for magical pearls and how they can be applied to generate a given sequence of normal pearls. The problem is tricky because it requires considering the order in which transformations can occur, as well as the recursive nature of the transformations, particularly for pearl B.

Here are the corrected rules based on the problem statement:
- Pearl A can transform into one of any normal pearl.
- Pearl B can transform into either one normal pearl of type 2 followed by itself (and this can be repeated any number of times), or a sequence of normal pearls 1, 3 and magical pearls A, C in that order.
- Pearl C can transform into one normal pearl of type 2, or a sequence of a normal pearl of type 3 followed by pearls B and C, or a sequence of normal pearls 1, 2 and a magical pearl A.

From these rules, we observe the following:
- Every transformation of a magical pearl yields at least one normal pearl of type 2, so the number of type 2 pearls in the sequence must be at least as many as the number of transformations.
- Since the output sequence does not contain magical pearls, every magical pearl must eventually be transformed into normal pearls. Therefore, there needs to be enough pearls of type 2 to match the sum of pearls of type 1 and 3 since each transformation by a B or C also produces a 2.
- If the number of 2s is exactly equal to the sum of 1s and 3s, the sequence could potentially be formed by a combination of A transformations.
- If there are more 2s than the sum of 1s and 3s, the sequence can potentially be formed by a combination of B and/or C transformations.
- The sequence cannot have three consecutive 2s without a 1 or 3 in between unless there are surplus 2s beyond the sum of 1s and 3s, which could be produced by successive B transformations.

Given this analysis, let's implement the solution that checks whether a sequence is obtainable:

```python
def can_transform(seq):
    # Count the number of each type of pearl
    count_1, count_2, count_3 = seq.count(1), seq.count(2), seq.count(3)
    
    # If there are more 1s and 3s than 2s, the sequence cannot be formed
    if count_2 < count_1 + count_3:
        return False
    
    # If there are only 2s or no pearls, the sequence cannot be formed since we need at least one 1 or 3
    if count_1 == 0 and count_3 == 0:
        return False

    # Check for three consecutive 2s only if there are not enough surplus 2s
    if count_2 == count_1 + count_3:
        for i in range(len(seq) - 2):
            if seq[i] == seq[i + 1] == seq[i + 2] == 2:
                return False
    
    # If all checks pass, the sequence can be generated
    return True

def main():
    with open('perle.in', 'r') as fin:
        n = int(fin.readline().strip())
        results = []
        for _ in range(n):
            _, *seq = map(int, fin.readline().strip().split())
            results.append(1 if can_transform(seq) else 0)

    with open('perle.out', 'w') as fout:
        fout.write('\n'.join(str(result) for result in results) + '\n')

if __name__ == "__main__":
    main()
```

This implementation takes into account the correct transformation rules and checks for the validity of the sequence accordingly. If these conditions are met, the sequence is obtainable; otherwise, it is not.
