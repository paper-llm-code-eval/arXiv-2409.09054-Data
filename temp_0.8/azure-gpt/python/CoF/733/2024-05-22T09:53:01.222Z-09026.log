---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in python. The code must compile and be correct.
The solution must read from `perle.in` and write to `perle.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Graniţa nu se trece uşor. Asta pentru că Balaurul Arhirel (mare pasionat de informatică) nu lasă pe nimeni să treacă decât după ce răspunde la nişte întrebări...

În acea ţară există $3$ tipuri de perle normale (le vom nota cu $1$, $2$ şi $3$) şi $3$ tipuri de perle magice (le vom nota cu $A$, $B$ şi $C$). Perlele magice sunt deosebite prin faptul că se pot transforma în alte perle (una sau mai multe, normale sau magice):
- Perla magică de tipul $A$ se poate transforma în orice perlă normală (una singură);
- Perla magică de tipul $B$ se poate transforma într-o perlă normală de tipul $2$ şi una magică de tipul $B$, sau într-o perlă normală de tipul $1$, una magică de tipul $A$, una normală de tipul $3$, una magică de tipul $A$ şi una magică de tipul $C$;
- Perla magică de tipul $C$ se poate transforma într-o perlă normală de tipul $2$ sau într-o perlă normală de tipul $3$, una magică de tipul $B$ şi una magică de tipul $C$ sau într-o perlă normală de tipul $1$, una normală de tipul $2$ şi una magică de tipul $A$.

Ca să rezumăm cele de mai sus putem scrie:
```
A -> 1  | 2     | 3
B -> 2B | 1A3AC
C -> 2  | 3BC   | 12A
```

Balaurul Arhirel ne lasă la început să ne alegem o perlă magică (una singură), iar apoi folosind numai transformările de mai sus trebuie să obţinem un anumit şir de perle normale. Când o perlă magică se transformă, perlele din stânga şi din dreapta ei rămân la fel (şi în aceeaşi ordine). De asemenea ordinea perlelor rezultate din transformare este chiar cea prezentată mai sus.

De exemplu, dacă balaurul ne cere să facem şirul de perle `21132123`, putem alege o perlă magică de tipul $B$ şi următorul şir de transformări: `B -> 2B -> 21A3AC -> 21A3A12A -> 21132123`.

Întrucât Balaurul nu are prea multă răbdare, el nu ne cere decât să spunem dacă se poate sau nu obţine şirul respectiv de perle.

# Cerință

Să se determine pentru fiecare şir de intrare dacă se poate obţine prin transformările de mai sus sau nu (alegând orice primă perlă magică, la fiecare şir).

# Date de intrare

Fişierul de intrare `perle.in` are următoarea structură:
* Pe prima linie numărul $N$, reprezentând numărul de şiruri din fişierul de intrare;
* Urmează $N$ linii; a $i$-a linie dintre cele $N$ descrie şirul $i$, printr-o succesiune de numere naturale despărţite de câte un spaţiu. Primul număr reprezintă lungimea şirului $L_i$, iar următoarele $L_i$ numere sunt tipurile de perle normale, în ordine, de la stânga la dreapta.

# Date de ieșire

Fişierul `perle.out` va conţine $N$ linii. Pe linia $i$ se va scrie un singur număr $1$ sau $0$ ($1$ dacă se poate obţine şirul respectiv (al $i$-lea) şi $0$ dacă nu se poate).

# Restricții și precizări

* $1 \leq N \leq 10$;
* $1 \leq L_i \leq 10 \ 000$, pentru oricare $i$;

---

Example:
`perle.in`
```
3
8 2 1 1 3 2 1 2 3
2 2 2
1 3
```

`perle.out`
```
1
0
1
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```python
# Solution for the "Perle" challenge

def can_be_obtained(sequence):
    # Define the state of counts for each type of normal pearl
    count_1 = count_2 = count_3 = 0

    # Count the occurrences of each type of normal pearl
    for pearl in sequence:
        if pearl == 1:
            count_1 += 1
        elif pearl == 2:
            count_2 += 1
        else:
            count_3 += 1

    # Check if it's possible to construct the sequence with the given transformations
    while count_1 > 0 or count_3 > 0:
        if count_1 >= 1 and count_2 >= 1 and count_3 >= 1:
            count_1 -= 1
            count_2 -= 1
            count_3 -= 1
        elif count_1 >= 1 and count_3 >= 1:
            count_1 -= 1
            count_3 -= 1
            count_2 += 1
        elif count_1 >= 1:
            count_1 -= 1
        elif count_3 >= 1:
            count_3 -= 1
        else:
            return 0

    # The sequence can be obtained if we have only type 2 pearls left (or no pearls at all)
    return 1 if count_2 >= 0 else 0

# Read input from 'perle.in' file
with open('perle.in', 'r') as fin:
    N = int(fin.readline())
    sequences = [list(map(int, fin.readline().split()[1:])) for _ in range(N)]

# Process each sequence and generate output
results = [can_be_obtained(sequence) for sequence in sequences]

# Write output to 'perle.out' file
with open('perle.out', 'w') as fout:
    for result in results:
        fout.write(str(result) + '\n')
```

This code reads the input sequences from `perle.in`, processes each sequence to determine if it can be obtained through the given transformations, and writes the results (1 or 0) to `perle.out`. The `can_be_obtained` function encapsulates the logic for checking sequence validity, based on the transformation rules of the magical pearls.
---------- user ----------


Program result did not match expected result.
Input data:
```
3
8 2 1 1 3 2 1 2 3
2 2 2
1 3
```
Expected output:
```
1
0
1
```
Found output:
```
1
1
1
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

After analyzing the original solution and comparing it with the expected output, I realized that the given algorithm does not accurately represent the transformation rules of the magical pearls. Specifically, it does not account for the exact transformation rules given in the problem statement, which are complex and allow for different sequences of transformations starting from each of the magical pearls A, B, or C.

The issue lies in the fact that the original solution did not simulate the possibility of starting with different magical pearls and did not take into account the order of the pearls after transformation.

We need to write an algorithm that can backtrack and try different transformations starting from each of the magical pearls to see if it's possible to reach the target sequence.

Let's reimplement the solution with a correct approach considering the problem constraints:

```python
def check_sequence(seq):
    # Initialize the counts for normal pearls in a dictionary
    counts = {'1': 0, '2': 0, '3': 0}
    for pearl in seq:
        counts[str(pearl)] += 1

    # A function to apply the transformation rules and adjust the counts
    def apply_transformations(counts):
        # Apply transformations as long as there are pearls that can be transformed
        while counts['1'] > 0 or counts['3'] > 0:
            # Try transforming with C first
            if counts['3'] > 0 and counts['2'] > 0:
                counts['3'] -= 1
                counts['2'] -= 1
            elif counts['1'] > 0 and counts['2'] > 0 and counts['3'] > 0:
                counts['1'] -= 1
                counts['2'] -= 1
                counts['3'] -= 1
            # Try transforming with B
            elif counts['1'] > 1:
                counts['1'] -= 2
                counts['2'] += 1
                counts['3'] += 1
            # Try transforming with A
            elif counts['1'] > 0:
                counts['1'] -= 1
            elif counts['3'] > 0:
                counts['3'] -= 1
            else:
                # Cannot transform further
                return False
        return True

    # Apply the transformations
    return apply_transformations(counts)

# Read input from 'perle.in' file
with open('perle.in', 'r') as fin:
    N = int(fin.readline().strip())
    sequences = [[int(x) for x in fin.readline().strip().split()[1:]] for _ in range(N)]

# Process each sequence and generate output
results = [1 if check_sequence(seq) else 0 for seq in sequences]

# Write output to 'perle.out' file
with open('perle.out', 'w') as fout:
    for result in results:
        fout.write(f"{result}\n")
```

This updated solution checks the input sequence against the transformation rules. It tries to mimic the transformation process by decreasing the count of pearls that can be transformed and increasing the count of resulting pearls according to the rules laid out by the magical pearl transformations. If at any point it is impossible to make a valid transformation, the function returns false, indicating that the sequence cannot be obtained.
---------- user ----------


Program result did not match expected result.
Input data:
```
3
8 2 1 1 3 2 1 2 3
2 2 2
1 3
```
Expected output:
```
1
0
1
```
Found output:
```
1
1
1
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The provided solution is incorrect because it does not fully respect the rules of transformation for the magical pearls. The transformation process is not a simple matter of counting the occurrences of normal pearls and trying to reduce their counts in a greedy manner. The transformations are context-sensitive and involve recursive or iterative applications of the transformation rules on a sequence that can evolve in various ways.

Therefore, the problem is more complex, requiring us to simulate all possible transformations from each magical pearl type and check if any of these can lead to the desired sequence.

Let's try to approach this problem correctly:

1. We need to simulate the transformation process, starting with each type of magical pearl (A, B, or C).
2. We must ensure that all transformation rules are correctly applied and that they consider the sequence of pearls resulting from each transformation.
3. We should use a recursive or iterative method to handle the various branching paths of possible transformations.

Given the complexity of the transformation rules, a recursive approach with memoization or a breadth-first search (BFS) may be more suitable to explore all possible sequences that can be formed.

Below is an implementation of this approach using BFS:

```python
from collections import deque

# Function to check if a sequence can be obtained
def can_obtain_sequence(sequence):
    # Initialize the BFS queue with starting points (A, B, C)
    queue = deque([('A', ''), ('B', ''), ('C', '')])
    visited = set()  # To avoid revisiting the same sequences

    # Perform BFS to explore all sequences that can be obtained
    while queue:
        pearl, current_sequence = queue.popleft()
        if current_sequence == sequence:
            return 1  # Sequence can be obtained
        if (pearl, current_sequence) in visited:
            continue
        visited.add((pearl, current_sequence))

        # Branch out based on the current pearl type
        if pearl == 'A':
            for i in ['1', '2', '3']:
                queue.append(('', current_sequence + i))
        elif pearl == 'B':
            queue.append(('B', current_sequence + '2'))
            queue.append(('AC', current_sequence + '1A3'))
        elif pearl == 'C':
            queue.append(('', current_sequence + '2'))
            queue.append(('BC', current_sequence + '3'))
            queue.append(('A', current_sequence + '12'))
        if pearl == 'AC':
            queue.append(('A', current_sequence + '3A'))
            queue.append(('C', current_sequence + '1'))
        elif pearl == 'BC':
            queue.append(('B', current_sequence + '3'))
            queue.append(('C', current_sequence + '2'))
        elif pearl == 'C':
            queue.append(('C', current_sequence + '3B'))
            queue.append(('', current_sequence + '12'))

    return 0  # Sequence cannot be obtained

# Read input from 'perle.in' file
with open('perle.in', 'r') as fin:
    N = int(fin.readline())
    sequences = [fin.readline().split()[1:] for _ in range(N)]

# Process each sequence
results = [can_obtain_sequence(''.join(seq)) for seq in sequences]

# Write output to 'perle.out' file
with open('perle.out', 'w') as fout:
    fout.writelines('\n'.join(str(result) for result in results))
```

This solution uses BFS to generate all possible sequences obtained by the transformation rules of the magical pearls. If the desired sequence is ever formed, it returns 1. If the BFS completes without forming the desired sequence, it returns 0.
---------- user ----------


Program exited with code 137.
stdout:
```

```
stderr:
```

```

Think of what has caused the exit code. Use the standard out and standard error to help you understand the issue.
Implement a solution to fix the program

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

Exit code 137 indicates that the program was killed, typically due to using too much memory or taking too long to execute (which can be interpreted as the process being killed by the operating system due to exceeding resource limits). This is likely caused by the BFS algorithm attempting to enqueue a large number of sequences, which results in excessive memory consumption or a potentially infinite loop.

To address this issue, we need to reconsider our approach. We can attempt to optimize the BFS approach by pruning paths that cannot lead to a solution and reducing the memory footprint. However, given the nature of the problem, it might be better to use a different algorithmic approach that inherently has a smaller search space.

A more efficient way to solve the problem is to use a dynamic programming (DP) approach, where we count the number of each type of pearls that would be possible starting with each magical pearl. With DP, we can avoid recalculating the same state multiple times, which will reduce the time and memory complexity.

Let's reimplement the solution using a dynamic programming approach:

```python
# Helper function to convert a sequence to a count tuple
def sequence_to_counts(sequence):
    return sequence.count('1'), sequence.count('2'), sequence.count('3')

# Function to check if a sequence can be obtained using magical pearls
def can_obtain_sequence(sequence):
    target_counts = sequence_to_counts(sequence)

    # Base cases: sequences that can be obtained starting with a single magical pearl
    dp = {
        'A': {(1, 0, 0), (0, 1, 0), (0, 0, 1)},
        'B': {(0, 1, 0)},
        'C': {(0, 1, 0), (0, 0, 1)}
    }

    # Introduce a helper function for DP transitions
    def add_transitions(pearl, new_counts):
        if new_counts in dp[pearl]:
            return
        dp[pearl].add(new_counts)
        c1, c2, c3 = new_counts
        if pearl == 'A':
            add_transitions('A', (c1 - 1, c2, c3)) if c1 > 0 else None
            add_transitions('A', (c1, c2 - 1, c3)) if c2 > 0 else None
            add_transitions('A', (c1, c2, c3 - 1)) if c3 > 0 else None
        elif pearl == 'B':
            add_transitions('B', (c1, c2 + 1, c3))
            add_transitions('A', (c1 + 1, c2, c3))
            add_transitions('C', (c1, c2, c3 + 1))
        elif pearl == 'C':
            add_transitions('A', (c1, c2 + 1, c3))
            add_transitions('B', (c1, c2, c3 + 1))
            add_transitions('C', (c1 + 1, c2, c3))

    # Update DP tables with all possible counts
    for pearl in 'ABC':
        for counts in list(dp[pearl]):
            add_transitions(pearl, counts)

    # Check if the target sequence can be obtained
    for counts in dp['A'] | dp['B'] | dp['C']:
        if counts == target_counts:
            return 1
    return 0

# Read input from 'perle.in' file
with open('perle.in', 'r') as fin:
    N = int(fin.readline())
    sequences = [sequence_to_counts(list(map(int, fin.readline().split()[1:]))) for _ in range(N)]

# Process each sequence
results = [can_obtain_sequence(seq) for seq in sequences]

# Write output to 'perle.out' file
with open('perle.out', 'w') as fout:
    for result in results:
        fout.write(f"{result}\n")
```

In this DP approach, we only store the counts of each type of normal pearls that can be obtained from each magical pearl. Starting from the basic transformations, we recursively apply transformations and store the resulting counts of pearls. Finally, we check if the target sequence's counts match any of the stored counts. This approach should have a much smaller memory footprint and be much faster than the BFS approach.
---------- user ----------


Program result did not match expected result.
Input data:
```
3
8 2 1 1 3 2 1 2 3
2 2 2
1 3
```
Expected output:
```
1
0
1
```
Found output:
```
0
0
0
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The dynamic programming approach attempted in the previous solution is not correctly handling the transformation rules provided in the challenge. The transformation rules are complex and allow a magical pearl to transform into a sequence of pearls, which is not being accurately captured in the DP state transitions.

Given the complexity of the transformation rules and the potential combinations and sequences that can occur, a recursive approach that systematically tries each transformation in the proper sequence may be more suitable. Since there are only three types of magical pearls and each has a limited number of transformation rules, we can enumerate each possibility and recurse on the resulting sequences.

Since the recursive approach has the risk of exponential time complexity, memoization can be used to remember sequences that have already been determined to be impossible to save computation time.

Here's a rewritten solution using recursion and memoization:

```python
# Define the transformation rules for magical pearls
magical_transforms = {
    'A': ['1', '2', '3'],
    'B': ['2B', '1A3AC'],
    'C': ['2', '3BC', '12A']
}

# Recursive function to check if the target sequence can be obtained
def can_transform(start_pearl, sequence, memo):
    # Base case: if the sequence is empty, we have matched all pearls
    if not sequence:
        return True

    # Check if we have already computed this state
    if (start_pearl, sequence) in memo:
        return memo[(start_pearl, sequence)]

    # Try all possible transformations for the starting pearl
    for transform in magical_transforms[start_pearl]:
        if sequence.startswith(transform):
            # If the transformed sequence matches the start of the target,
            # recursively try to match the rest of the sequence
            next_pearl = transform[-1] if transform[-1] in 'ABC' else ''
            remaining_seq = sequence[len(transform):].lstrip('ABC')
            if can_transform(next_pearl, remaining_seq, memo):
                memo[(start_pearl, sequence)] = True
                return True

    # If no transformation leads to the target sequence, store and return False
    memo[(start_pearl, sequence)] = False
    return False

# Function to check if the target sequence can be obtained starting from any magical pearl
def can_obtain_sequence(sequence):
    # Remove spaces and convert the sequence to a string
    target_sequence = ''.join(sequence)

    # Initialize memoization dictionary
    memo = {}

    # Check if any magical pearl can be transformed into the target sequence
    for pearl in 'ABC':
        if can_transform(pearl, target_sequence, memo):
            return 1

    return 0

# Read input from 'perle.in' file
with open('perle.in', 'r') as fin:
    N = int(fin.readline())
    sequences = [fin.readline().split()[1:] for _ in range(N)]

# Process each sequence
results = [can_obtain_sequence(seq) for seq in sequences]

# Write output to 'perle.out' file
with open('perle.out', 'w') as fout:
    for result in results:
        fout.write(f"{result}\n")
```

In this solution, `can_transform` is a recursive function that tries to match each transformation rule for the starting magical pearl with the beginning of the target sequence. If a match is found, it recursively tries to match the rest of the sequence. The function uses memoization to record sequences that have already been checked to prevent redundant computations. The `can_obtain_sequence` function then checks if starting with any magical pearl A, B, or C can eventually lead to the desired sequence.
---------- user ----------


Program exited with code 1.
stdout:
```

```
stderr:
```
Traceback (most recent call last):
  File "/app/app.py", line 54, in <module>
    results = [can_obtain_sequence(seq) for seq in sequences]
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/app.py", line 54, in <listcomp>
    results = [can_obtain_sequence(seq) for seq in sequences]
               ^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/app.py", line 43, in can_obtain_sequence
    if can_transform(pearl, target_sequence, memo):
       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/app.py", line 25, in can_transform
    if can_transform(next_pearl, remaining_seq, memo):
       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/app.py", line 19, in can_transform
    for transform in magical_transforms[start_pearl]:
                     ~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^
KeyError: ''

```

Think of what has caused the exit code. Use the standard out and standard error to help you understand the issue.
Implement a solution to fix the program

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The error message indicates that there is a `KeyError` exception occurring because an empty string `''` is being used as a key to access the `magical_transforms` dictionary. This empty string key is not defined in the dictionary, as only 'A', 'B', and 'C' are valid keys.

This error can occur when the `next_pearl` variable is set to an empty string in the `can_transform` function, which happens when the last character of the transformation is not 'A', 'B', or 'C' (i.e., it is a normal pearl).

To fix the program, we need to appropriately handle the case when there is no next magical pearl in the transformation chain. We should only attempt to look up the next transformations in the dictionary if `next_pearl` is one of the magical pearls 'A', 'B', or 'C'.

Let's rewrite the solution to fix this issue:

```python
# Define the transformation rules for magical pearls
magical_transforms = {
    'A': ['1', '2', '3'],
    'B': ['2B', '1A3AC'],
    'C': ['2', '3BC', '12A']
}

# Recursive function to check if the target sequence can be obtained
def can_transform(start_pearl, sequence, memo):
    # Base case: if the sequence is empty, we have matched all pearls
    if not sequence:
        return True

    # If we are not starting with a magical pearl, we cannot make a transformation
    if start_pearl not in magical_transforms:
        return False

    # Check if we have already computed this state
    if (start_pearl, sequence) in memo:
        return memo[(start_pearl, sequence)]

    # Try all possible transformations for the starting pearl
    for transform in magical_transforms[start_pearl]:
        if sequence.startswith(transform):
            # If the transformed sequence matches the start of the target,
            # recursively try to match the rest of the sequence
            next_pearl = transform[-1] if transform[-1] in magical_transforms else ''
            remaining_seq = sequence[len(transform):]
            if can_transform(next_pearl, remaining_seq, memo):
                memo[(start_pearl, sequence)] = True
                return True

    # If no transformation leads to the target sequence, store and return False
    memo[(start_pearl, sequence)] = False
    return False

# Function to check if the target sequence can be obtained starting from any magical pearl
def can_obtain_sequence(sequence):
    # Remove spaces and convert the sequence to a string
    target_sequence = ''.join(sequence)

    # Initialize memoization dictionary
    memo = {}

    # Check if any magical pearl can be transformed into the target sequence
    for pearl in magical_transforms.keys():
        if can_transform(pearl, target_sequence, memo):
            return 1

    return 0

# Read input from 'perle.in' file
with open('perle.in', 'r') as fin:
    N = int(fin.readline())
    sequences = [fin.readline().split()[1:] for _ in range(N)]

# Process each sequence
results = [can_obtain_sequence(seq) for seq in sequences]

# Write output to 'perle.out' file
with open('perle.out', 'w') as fout:
    for result in results:
        fout.write(f"{result}\n")
```

In this corrected code, we added a check in the `can_transform` function to ensure that we only attempt to look up transformations for keys that are in the `magical_transforms` dictionary. This prevents the `KeyError` and allows for proper recursive exploration of transformation sequences.
---------- user ----------


Program result did not match expected result.
Input data:
```
3
8 2 1 1 3 2 1 2 3
2 2 2
1 3
```
Expected output:
```
1
0
1
```
Found output:
```
0
0
1
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The previous solutions attempted failed to yield the correct results because they did not account for the specific transformation rules given in the problem statement. This problem requires careful consideration of how magical pearls can transform into sequences of other pearls, taking into account both normal and magical pearls in the sequence. A key insight to solving this problem is the realization that the number of pearls of type 2 is critical, as it determines whether a sequence can be obtained or not.

The rules show that:
- Magical pearl A can only produce one normal pearl.
- Magical pearl B can produce one normal pearl of type 2 and potentially more pearls, including another B.
- Magical pearl C can produce either one normal pearl of type 2 or add pearls, including another C.

This means that any sequence we want to form must have at least as many type 2 pearls as the sum of type 1 and type 3 pearls, since only a B transformation can increase the count of type 2 pearls, and only it can do so while also being transformed into another magical pearl that allows the process to continue.

The algorithm can be simplified to counting the number of pearls of each type in the sequence. It is then possible to use a single magical pearl to form the sequence if and only if the count of type 2 pearls is greater than or equal to the sum of the counts of type 1 and type 3 pearls minus 1. The minus 1 accounts for the initial magical pearl chosen that can be of type B and thus produce an additional type 2 pearl.

Let's rewrite the solution based on this insight:

```python
# Function to check if a sequence can be obtained
def can_obtain_sequence(sequence):
    # Count the number of pearls of each type
    count_1, count_2, count_3 = 0, 0, 0
    for pearl in sequence:
        if pearl == '1':
            count_1 += 1
        elif pearl == '2':
            count_2 += 1
        else:  # pearl == '3':
            count_3 += 1

    # Check if the sequence can be obtained
    # The count of type 2 pearls must be at least as high as the sum of type 1 and type 3 pearls minus 1
    return 1 if count_2 >= count_1 + count_3 - 1 else 0

# Read input from 'perle.in' file
with open('perle.in', 'r') as fin:
    N = int(fin.readline())
    # Read and convert each sequence to a string without spaces, then pass to function
    sequences = [fin.readline().split()[1:] for _ in range(N)]

# Process each sequence
results = [can_obtain_sequence(seq) for seq in sequences]

# Write output to 'perle.out' file
with open('perle.out', 'w') as fout:
    for result in results:
        fout.write(f"{result}\n")
```

In this final solution, we only need to count the number of each type of normal pearl and compare the counts according to the rule we derived from the transformation possibilities. We write the result (1 if the sequence can be obtained and 0 otherwise) to 'perle.out'. This should produce the correct output for the given problem.
