---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in python. The code must compile and be correct.
The solution must read from `clepsidru.in` and write to `clepsidru.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

O **clepsidră** este un dispozitiv folosit pentru a măsura timpul. Clepsidra este alcatuită din două incinte de sticlă, conectate printr-un tub fin. Una dintre incinte este umplută cu nisip, acesta scurgându-se în cea de-a doua incintă, cu o viteză constantă. Clepsidra poate fi întoarsă, pentru a măsura o altă perioadă de timp.
Arheologii au descoperit un dispozitiv, pe care l-au denumit **clepsidru**, format din $n$ clepsidre identice, suprapuse, numerotate de la $1$ la $n$, prin care nisipul poate circula de la o clepsidră la alta datorită forței gravitaționale.
Studiind acest obiect, arheologii au constatat că:
* dispozitivul poate fi utilizat atât în pozitia $1$, când clepsidrele sunt în ordinea $1, 2,\dots, n$ cu clepsidra $n$ așezată pe sol, cât și în poziția $2$, cand clepsidrele sunt în ordinea $n, n-1, \dots, 1$ cu clepsidra $1$ așezată pe sol;
* viteza de trecere a nisipului de la o incintă la alta, a aceleiași clepsidre, este de **$1$ bob de nisip/secunda**, pentru toate clepsidrele, indiferent de poziție;
* trecerea clepsidrului dintr-o poziție în alta presupune răsturnarea acestuia și reașezarea boabelor de nisip;
* timpul de trecere a boabelor de nisip de la o clepsidră la alta este $0$.

Arheologii studiază comportarea clepsidrului realizând două experimente diferite, dupa cum urmează:

1. Se așează clepsidrul în poziția $1$, se introduc în incinta de sus a clepsidrei $1$ un numar $b$ de boabe de nisip și se determină dupa câte secunde vor ajunge toate boabele de nisip in incinta de jos a ultimei clepsidre;
2. Se așează clepsidrul în poziția $1$, se introduc în incinta de sus a clepsidrei $1$ un numar $b$ de boabe de nisip, apoi se așează clepsidrul în **$k$ stari** consecutive, o stare fiind caracterizată de valorile $S_i$ și $P_i$, ce reprezintă numărul de secunde, respectiv poziția, în care este menținut nemișcat clepsidrul, iar la final se determină numărul de boabe de nisip din incintele fiecărei clepsidre.

Spre exemplu, dacă clepsidrul este format din $n=2$ clepsidre, iar în incinta de sus a primei clepsidre se introduc $b=3$ boabe de nisip, la primul experiment se va obține valoarea $4$. La al doilea experiment se așează clepsidrul în $k=2$ stări, caracterizate prin $S_1=3, P_1=1$; $S_2=1, P_2=2$. Numărul de boabe de nisip din clepsidre va evolua ca în figura ce urmează:

~[clepsidru.png]

# Cerință

Să se scrie un program care citește valorile $n$ si $b$, precum și valorile $k, S_i, P_i$ și calculează valorile obținute de arheologi la realizarea celor două experimente.

# Date de intrare


Prima linie a fișierului de intrare `clepsidru.in` conține două numere naturale nenule $n$ si $b$, separate printr-un singur spațiu, cu semnificația din enunț; a doua linie conține numărul natural nenul $k$ având semnificația din enunț, iar următoarele $k$ linii conțin fiecare câte o pereche de valori $S_i$ și $P_i$, separate printr-un singur spațiu, cu semnificația din enunț.


# Date de ieșire


Fișierul de ieșire `clepsidru.out` va conține pe prima linie un număr natural ce reprezintă valoarea obținută la primul experiment, iar pe următoarele $n$ linii va conține câte o pereche de numere naturale, separate printr-un singur spațiu, ce reprezintă cantitățile de boabe de nisip din incintele de sus și jos ale celor $n$ clepsidre, scrise în ordinea de la $1$ la $n$ a clepsidrelor, după realizarea celui de-al doilea experiment.


# Restricții și precizări

* $1 \leq n \leq 1 \ 000$;
* $1 \leq b \leq 1 \ 000 \ 000 \ 000$;
* $1 \leq k \leq 1 \ 000$;
* $1 \leq S_i \leq 1 \ 000$;
* $P_i$ aparține mulțimii $\{1, 2\}$, $1 ≤ i ≤ k$;
* Pentru rezolvarea corectă a primei cerințe se acordă $25\%$ din punctaj, iar pentru rezolvarea corectă a celei de-a doua cerințe se acordă $75\%$ din punctaj. Acordarea punctajului pentru a doua cerință se face numai dacă in fișierul de ieșire există un răspuns pentru prima cerință, indiferent de corectitudinea acestuia.

---

Example:
`clepsidru.in`
```
2 3
2
3 1
1 2
```

`clepsidru.out`
```
4
1 1
0 1
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```python
# Solution for the programming challenge

def experiment_one(b, n):
    return (b + n - 1)

def experiment_two(n, b, k, states):
    positions = [[0, 0] for _ in range(n)]
    current_position = 1
    positions[0][0] = b

    for time, position in states:
        for _ in range(time):
            next_positions = [[0, 0] for _ in range(n)]
            for i in range(n):
                upper = positions[i][0]
                lower = positions[i][1]
                if current_position == 1:
                    if upper > 0:
                        upper -= 1
                        lower += 1
                    if i < n - 1:
                        next_positions[i + 1][0] += lower
                        lower = 0
                else:
                    if lower > 0:
                        upper += 1
                        lower -= 1
                    if i < n - 1:
                        next_positions[i + 1][1] += upper
                        upper = 0
                next_positions[i][0], next_positions[i][1] = upper, lower
            for i in range(n):
                positions[i][0] = next_positions[i][0]
                positions[i][1] = next_positions[i][1]
        current_position = 3 - current_position
    return positions

with open('clepsidru.in', 'r') as file:
    n, b = map(int, file.readline().split())
    k = int(file.readline())
    states = [tuple(map(int, file.readline().split())) for _ in range(k)]

result_one = experiment_one(b, n)
positions = experiment_two(n, b, k, states)

with open('clepsidru.out', 'w') as file:
    file.write(f"{result_one}\n")
    for upper, lower in positions:
        file.write(f"{upper} {lower}\n")
```

This Python code solves the challenge by defining two functions `experiment_one` and `experiment_two` for each of the experiments and then reading the input, applying the experiments, and writing the output as specified.

Make sure the file `clepsidru.in` is in the same directory as the Python script when you run it, and it will generate the `clepsidru.out` file with the correct output.
---------- user ----------


Program result did not match expected result.
Input data:
```
2 3
2
3 1
1 2
```
Expected output:
```
4
1 1
0 1
```
Found output:
```
4
0 0
0 0
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The found output does not match the expected output because the logic for transferring sand between the hourglasses in `experiment_two` is incorrect. Specifically, the logic does not properly handle the sand transfer when the clepsidru is in position 2, and it does not account for the instantaneous transfer of sand from the bottom of one hourglass to the top of the next one in the stack when in position 1.

Let's correct the solution with the proper logic:

1. When the clepsidru is in position 1, sand moves from the top to the bottom of the same hourglass. If there is sand at the bottom, it should instantly move to the top of the next hourglass.
2. When the clepsidru is in position 2, sand moves from the bottom to the top of the same hourglass. If there is sand at the top, it should instantly move to the bottom of the next hourglass (which was previously above it).

Here is the corrected solution with proper comments and logic:

```python
# Solution for the programming challenge

def experiment_two(n, b, k, states):
    hourglasses = [[0, 0] for _ in range(n)]
    hourglasses[0][0] = b  # Start with all sand in the top of the first hourglass

    for seconds, position in states:
        while seconds > 0:
            changes = True
            while changes:  # Continue transferring sand until no more changes occur
                changes = False
                if position == 1:
                    for i in range(n):
                        if hourglasses[i][0] > 0:  # Sand in the upper part moves down
                            hourglasses[i][0] -= 1
                            hourglasses[i][1] += 1
                            changes = True
                        if i < n - 1 and hourglasses[i][1] > 0:  # Sand in the lower part moves to the next hourglass
                            hourglasses[i+1][0] += hourglasses[i][1]
                            hourglasses[i][1] = 0
                else:  # When the clepsidru is inverted
                    for i in range(n - 1, -1, -1):
                        if hourglasses[i][1] > 0:  # Sand in the lower part moves up
                            hourglasses[i][1] -= 1
                            hourglasses[i][0] += 1
                            changes = True
                        if i > 0 and hourglasses[i][0] > 0:  # Sand in the upper part moves to the previous hourglass
                            hourglasses[i-1][1] += hourglasses[i][0]
                            hourglasses[i][0] = 0
            seconds -= 1  # Decrement the time
    return hourglasses

# The time for all sand to reach the bottom of the last hourglass
def experiment_one(b, n):
    return b + n - 1

# Read input data from file
with open('clepsidru.in', 'r') as file:
    n, b = map(int, file.readline().split())
    k = int(file.readline())
    states = [tuple(map(int, file.readline().split())) for _ in range(k)]

# Perform experiments
result_one = experiment_one(b, n)
positions = experiment_two(n, b, k, states)

# Write output data to file
with open('clepsidru.out', 'w') as file:
    file.write(f"{result_one}\n")
    for upper, lower in positions:
        file.write(f"{upper} {lower}\n")
```
This corrected solution should produce the expected output for the given input data. The algorithms for both experiments are revised to consider the instant sand transfer when an hourglass is full at the bottom.
---------- user ----------


Program result did not match expected result.
Input data:
```
2 3
2
3 1
1 2
```
Expected output:
```
4
1 1
0 1
```
Found output:
```
4
3 0
0 0
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The previous solution still did not correctly simulate the movement of sand in the hourglasses based on the given states and the position of the clepsidru. The main issue is that the while loop that continuously transfers sand until no more changes occur cannot work here, as the sand movement is not instantaneous and should only occur once per second as per the problem statement.

Here is the corrected solution that properly simulates the movement of sand in one-second intervals:

```python
# Solution for the programming challenge

# Function to simulate the second experiment
def experiment_two(n, b, k, states):
    # Initialize the hourglasses with no sand
    hourglasses = [[0, 0] for _ in range(n)]
    # Place all the initial sand in the first hourglass at the top
    hourglasses[0][0] = b

    # Go through each state and update the hourglasses accordingly
    for seconds, position in states:
        for _ in range(seconds):
            # Create a copy of the current state to calculate the next state
            new_state = [list(h) for h in hourglasses]
            for i in range(n):
                # Transfer sand within the hourglass
                if hourglasses[i][0] > 0:
                    new_state[i][0] -= 1
                    new_state[i][1] += 1
                # Transfer sand to the next hourglass based on position
                if position == 1 and i < n - 1 and hourglasses[i][1] > 0:
                    new_state[i + 1][0] += hourglasses[i][1]
                    new_state[i][1] -= hourglasses[i][1]
                elif position == 2 and i > 0 and hourglasses[i][0] > 0:
                    new_state[i - 1][1] += hourglasses[i][0]
                    new_state[i][0] -= hourglasses[i][0]
            hourglasses = new_state
    return hourglasses

# Function to calculate the result of the first experiment
def experiment_one(b, n):
    # Calculate time for all sand to reach the bottom of the last hourglass
    return b + n - 1

# Read input data from file
with open('clepsidru.in', 'r') as file:
    n, b = map(int, file.readline().split())
    k = int(file.readline())
    states = [tuple(map(int, file.readline().split())) for _ in range(k)]

# Perform experiments
result_one = experiment_one(b, n)
positions = experiment_two(n, b, k, states)

# Write output data to file
with open('clepsidru.out', 'w') as file:
    file.write(f"{result_one}\n")
    for upper, lower in positions:
        file.write(f"{upper} {lower}\n")
```

This code uses a `new_state` variable to calculate the state of the hourglasses after each second. It then assigns this new state back to the `hourglasses` variable to be used in the next iteration. The sand transfer is only applied once per second, and the transfer to neighboring hourglasses is also adjusted based on whether the clepsidru is in position 1 or position 2.

The corrected solution should now produce the expected output for the given input data.
---------- user ----------


Program result did not match expected result.
Input data:
```
2 3
2
3 1
1 2
```
Expected output:
```
4
1 1
0 1
```
Found output:
```
4
0 2
-1 2
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The previous solution still contains a logical error in the way the sand is being transferred between the hourglasses. The negative value in the results suggests that when the clepsidru is in position 2, the sand is being over-transferred from the top to the next hourglass below it (which is actually above it in the physical setup). Additionally, the transfer must not happen at the same time as transferring sand within the hourglass; it should happen after all possible transfers within the hourglasses have occurred.

Let's correct the solution with a step-by-step approach to handle the transfer of sand properly.

1. During each second, for each hourglass, move one grain of sand from the top to the bottom if available.
2. After moving sand within hourglasses, if the clepsidru is in position 1, transfer all sand from the bottom of each hourglass to the top of the next hourglass in sequence. If the clepsidru is in position 2, transfer all sand from the top of each hourglass to the bottom of the previous hourglass in sequence.
3. These transfers occur after the sand has moved within each hourglass and are based on the current position of the clepsidru.

Here is the rewritten solution with the correct logic:

```python
# Solution for the programming challenge

def experiment_one(n, b):
    # The time is the number of sand grains plus the number of hourglasses minus one
    return b + n - 1

def experiment_two(n, b, k, states):
    # Initialize hourglasses with 0 sand at the top and bottom
    hourglasses = [[0, 0] for _ in range(n)]
    hourglasses[0][0] = b  # Add all the sand to the first hourglass

    for seconds, position in states:
        for _ in range(seconds):
            # First, move sand within each hourglass
            for i in range(n):
                if hourglasses[i][0] > 0:  # If there's sand at the top, move one grain to the bottom
                    hourglasses[i][0] -= 1
                    hourglasses[i][1] += 1
            
            # Then, transfer sand between hourglasses based on the position
            if position == 1:  # Position 1: transfer bottom sand to the top of the next hourglass
                for i in range(n - 1):
                    hourglasses[i + 1][0] += hourglasses[i][1]
                    hourglasses[i][1] = 0
            else:  # Position 2: transfer top sand to the bottom of the previous hourglass
                for i in range(n - 1, 0, -1):
                    hourglasses[i - 1][1] += hourglasses[i][0]
                    hourglasses[i][0] = 0

    return hourglasses

# Read input data from file
with open('clepsidru.in', 'r') as file:
    n, b = map(int, file.readline().split())
    k = int(file.readline())
    states = [tuple(map(int, file.readline().split())) for _ in range(k)]

# Perform the experiments
result_one = experiment_one(n, b)
positions = experiment_two(n, b, k, states)

# Write output data to file
with open('clepsidru.out', 'w') as file:
    file.write(f"{result_one}\n")
    for upper, lower in positions:
        file.write(f"{upper} {lower}\n")
```

This corrected solution now properly handles the sand transfer between hourglasses and within each hourglass. It uses two separate steps during each second: one for the internal transfer within hourglasses and one for the transfer between hourglasses based on the clepsidru's position. This should provide the expected output for the given input data.
---------- user ----------


Program result did not match expected result.
Input data:
```
2 3
2
3 1
1 2
```
Expected output:
```
4
1 1
0 1
```
Found output:
```
4
0 0
0 3
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

It seems there was a misunderstanding in the sand transfer logic. We need to ensure that sand is transferred from one hourglass to another correctly, both within each second and between the seconds, following the rules of the clepsidru. The expected output indicates that, after the end of each second, if there is sand at the bottom of one hourglass in position 1, it should immediately fall to the next hourglass, and similar logic applies to position 2.

Let's apply these changes to the code and rewrite the solution:

```python
def distribute_sand(n, b):
    # Start from the top hourglass and distribute sand until it runs out
    sand = [0] * n
    for i in range(n):
        if b > 0:
            sand[i] = min(b, i + 1)
            b -= sand[i]
        else:
            break
    return sand

# Process the queries in experiment two
def process_queries(n, b, queries):
    sand_top = distribute_sand(n, b)
    sand_bottom = [0] * n

    for time, pos in queries:
        while time > 0:
            if pos == 1:
                # Move sand from top to bottom in each hourglass
                for i in range(n):
                    if sand_top[i] > 0:
                        sand_top[i] -= 1
                        sand_bottom[i] += 1
                # Move sand to next hourglass
                for i in range(n - 1):
                    sand_top[i + 1] += sand_bottom[i]
                    sand_bottom[i] = 0
            else:
                # Move sand from bottom to top in each hourglass
                for i in range(n):
                    if sand_bottom[i] > 0:
                        sand_bottom[i] -= 1
                        sand_top[i] += 1
                # Move sand to previous hourglass
                for i in range(1, n):
                    sand_bottom[i - 1] += sand_top[i]
                    sand_top[i] = 0
            time -= 1
    return sand_top, sand_bottom

# Read the input data
with open('clepsidru.in', 'r') as file:
    n, b = map(int, file.readline().split())
    k = int(file.readline())
    queries = [tuple(map(int, file.readline().split())) for _ in range(k)]

# Perform the experiments
sand_top, sand_bottom = process_queries(n, b, queries)
result_one = sand_bottom[-1]  # The sand in the bottom of the last hourglass after experiment one

# Write the output data
with open('clepsidru.out', 'w') as file:
    file.write(f"{result_one + n - 1}\n")
    for i in range(n):
        file.write(f"{sand_top[i]} {sand_bottom[i]}\n")
```

In this solution:
- `distribute_sand` is used to initially distribute the sand across the hourglasses as it falls through them.
- `process_queries` handles the movement of sand based on the states and time provided.
- Sand is transferred from the bottom to the top or vice versa within each hourglass and then transferred to the subsequent or preceding hourglass, depending on the position.

This solution should produce the correct output and match the expected results for the input data provided.
---------- user ----------


Program result did not match expected result.
Input data:
```
2 3
2
3 1
1 2
```
Expected output:
```
4
1 1
0 1
```
Found output:
```
3
0 1
0 2
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

Upon reviewing the expected results and the found output, it's evident that the results differ because the logic for transferring the sand between the hourglasses is not correctly implemented. Specifically, the code is not correctly simulating the behavior when the clepsidru is turned from position 1 to position 2 and vice versa.

Let's correct the logic step by step:

1. At the beginning of each second, first, transfer the sand from the bottom of each hourglass to either the top of the next (when in position 1) or the bottom of the previous (when in position 2).
2. Then move the sand from the top to the bottom within each hourglass.
3. At the end of each second, if there is sand at the bottom of an hourglass (in position 1) or at the top of an hourglass (in position 2), it should instantly transfer to the next or previous hourglass, respectively.

Here is the rewritten solution with the correct logic applied:

```python
# Opens the input file and reads the data for both experiments
with open('clepsidru.in') as f:
    n, b = map(int, f.readline().split())
    k = int(f.readline())
    states = [tuple(map(int, f.readline().split())) for _ in range(k)]

# Experiment 1: Calculate the time taken for all the sand to reach the bottom of the last hourglass in position 1.
time_to_last = b // n + (1 if b % n else 0)

# Experiment 2: Simulate the states and calculate the sand in each hourglass.
sand = [0] * n
sand[0] = b
for seconds, position in states:
    while seconds > 0:
        # First, transfer sand between hourglasses if needed.
        if position == 1:
            for i in range(n - 1, -1, -1):
                if sand[i] > i:
                    sand[i + 1] += sand[i] - i
                    sand[i] = i
        else:
            for i in range(1, n):
                if sand[i - 1] < i:
                    transfer = i - sand[i - 1]
                    sand[i] -= transfer
                    sand[i - 1] += transfer

        # Then, transfer sand within hourglasses for one second.
        for i in range(n):
            if position == 1 and i < n - 1:
                transfer = min(sand[i], 1)
                sand[i] -= transfer
                sand[i + 1] += transfer
            elif position == 2 and i > 0:
                transfer = min(sand[i], 1)
                sand[i] -= transfer
                sand[i - 1] += transfer

        seconds -= 1

# Prepare the data for the output file.
output = [str(time_to_last + n - 1) + '\n']
output.extend(['{} {}\n'.format(sand[i] if i % 2 == 0 else 0,
                                sand[i] if i % 2 == 1 else 0)
               for i in range(n)])

# Writes the output data to the output file.
with open('clepsidru.out', 'w') as f:
    f.writelines(output)
```

This solution follows the rules of the clepsidru rigidly: sand can only pass from the top to the bottom of an hourglass at a rate of one grain per second, and it can only pass from the bottom of one hourglass to the top of another (in position 1) or from the top of one to the bottom of another (in position 2) between seconds if there is excess sand.

It should now correctly calculate the number of sand grains in each top and bottom part of the hourglasses after conducting the experiments, matching the expected output.
---------- user ----------


Program exited with code 1.
stdout:
```

```
stderr:
```
Traceback (most recent call last):
  File "/app/app.py", line 19, in <module>
    sand[i + 1] += sand[i] - i
    ~~~~^^^^^^^
IndexError: list index out of range

```

Think of what has caused the exit code. Use the standard out and standard error to help you understand the issue.
Implement a solution to fix the program

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The `IndexError: list index out of range` error occurs because the code is trying to access an index that doesn't exist in the `sand` list. Specifically, this happens in the line `sand[i + 1] += sand[i] - i`, when `i` is equal to `n - 1` (the last index of the list); attempting to access `sand[i + 1]` will be out of the list's bounds.

To avoid this out-of-range error, we should perform the sand transfer between hourglasses only up to `n - 2` index for position 1 and start from index 1 for position 2. Additionally, the transfer logic is not correctly handling the movement of sand between hourglasses and within hourglasses.

Let's rewrite the solution with the correct logic and without going out of range:

```python
# Solution for the programming challenge
def distribute_sand(n, b, k, states):
    # Start with b grains of sand in the top section of the first hourglass
    hourglasses = [[b, 0] if i == 0 else [0, 0] for i in range(n)]
    # Perform state changes
    for s, p in states:
        for _ in range(s):
            # Move sand within each hourglass
            for i in range(n):
                if p == 1:  # Position 1
                    if hourglasses[i][0] > 0:
                        hourglasses[i][0] -= 1
                        hourglasses[i][1] += 1
                else:  # Position 2
                    if hourglasses[i][1] > 0:
                        hourglasses[i][1] -= 1
                        hourglasses[i][0] += 1
            # Transfer sand between hourglasses
            if p == 1:  # Position 1
                for i in range(n - 1):
                    hourglasses[i + 1][0] += hourglasses[i][1]
                    hourglasses[i][1] = 0
            else:  # Position 2
                for i in range(n - 1, 0, -1):
                    hourglasses[i - 1][1] += hourglasses[i][0]
                    hourglasses[i][0] = 0
    return hourglasses

# Read input data
with open('clepsidru.in', 'r') as file:
    n, b = map(int, file.readline().split())
    k = int(file.readline())
    states = [tuple(map(int, file.readline().split())) for _ in range(k)]

# Calculate results
hourglasses = distribute_sand(n, b, k, states)
experiment_one_result = b + n - 1
# Write output data
with open('clepsidru.out', 'w') as file:
    file.write(str(experiment_one_result) + '\n')
    for top, bottom in hourglasses:
        file.write(f"{top} {bottom}\n")
```

This solution introduces a function `distribute_sand` to simulate the state changes and movement of sand in each hourglass, taking care not to go beyond the bounds of the array. After distributing the sand according to the states, the solution calculates the time for all the sand to reach the bottom of the last hourglass (experiment one) and writes the results to the output file.
