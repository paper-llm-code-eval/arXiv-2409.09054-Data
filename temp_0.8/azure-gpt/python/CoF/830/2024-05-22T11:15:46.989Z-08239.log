---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in python. The code must compile and be correct.
The solution must read from `clepsidru.in` and write to `clepsidru.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

O **clepsidră** este un dispozitiv folosit pentru a măsura timpul. Clepsidra este alcatuită din două incinte de sticlă, conectate printr-un tub fin. Una dintre incinte este umplută cu nisip, acesta scurgându-se în cea de-a doua incintă, cu o viteză constantă. Clepsidra poate fi întoarsă, pentru a măsura o altă perioadă de timp.
Arheologii au descoperit un dispozitiv, pe care l-au denumit **clepsidru**, format din $n$ clepsidre identice, suprapuse, numerotate de la $1$ la $n$, prin care nisipul poate circula de la o clepsidră la alta datorită forței gravitaționale.
Studiind acest obiect, arheologii au constatat că:
* dispozitivul poate fi utilizat atât în pozitia $1$, când clepsidrele sunt în ordinea $1, 2,\dots, n$ cu clepsidra $n$ așezată pe sol, cât și în poziția $2$, cand clepsidrele sunt în ordinea $n, n-1, \dots, 1$ cu clepsidra $1$ așezată pe sol;
* viteza de trecere a nisipului de la o incintă la alta, a aceleiași clepsidre, este de **$1$ bob de nisip/secunda**, pentru toate clepsidrele, indiferent de poziție;
* trecerea clepsidrului dintr-o poziție în alta presupune răsturnarea acestuia și reașezarea boabelor de nisip;
* timpul de trecere a boabelor de nisip de la o clepsidră la alta este $0$.

Arheologii studiază comportarea clepsidrului realizând două experimente diferite, dupa cum urmează:

1. Se așează clepsidrul în poziția $1$, se introduc în incinta de sus a clepsidrei $1$ un numar $b$ de boabe de nisip și se determină dupa câte secunde vor ajunge toate boabele de nisip in incinta de jos a ultimei clepsidre;
2. Se așează clepsidrul în poziția $1$, se introduc în incinta de sus a clepsidrei $1$ un numar $b$ de boabe de nisip, apoi se așează clepsidrul în **$k$ stari** consecutive, o stare fiind caracterizată de valorile $S_i$ și $P_i$, ce reprezintă numărul de secunde, respectiv poziția, în care este menținut nemișcat clepsidrul, iar la final se determină numărul de boabe de nisip din incintele fiecărei clepsidre.

Spre exemplu, dacă clepsidrul este format din $n=2$ clepsidre, iar în incinta de sus a primei clepsidre se introduc $b=3$ boabe de nisip, la primul experiment se va obține valoarea $4$. La al doilea experiment se așează clepsidrul în $k=2$ stări, caracterizate prin $S_1=3, P_1=1$; $S_2=1, P_2=2$. Numărul de boabe de nisip din clepsidre va evolua ca în figura ce urmează:

~[clepsidru.png]

# Cerință

Să se scrie un program care citește valorile $n$ si $b$, precum și valorile $k, S_i, P_i$ și calculează valorile obținute de arheologi la realizarea celor două experimente.

# Date de intrare


Prima linie a fișierului de intrare `clepsidru.in` conține două numere naturale nenule $n$ si $b$, separate printr-un singur spațiu, cu semnificația din enunț; a doua linie conține numărul natural nenul $k$ având semnificația din enunț, iar următoarele $k$ linii conțin fiecare câte o pereche de valori $S_i$ și $P_i$, separate printr-un singur spațiu, cu semnificația din enunț.


# Date de ieșire


Fișierul de ieșire `clepsidru.out` va conține pe prima linie un număr natural ce reprezintă valoarea obținută la primul experiment, iar pe următoarele $n$ linii va conține câte o pereche de numere naturale, separate printr-un singur spațiu, ce reprezintă cantitățile de boabe de nisip din incintele de sus și jos ale celor $n$ clepsidre, scrise în ordinea de la $1$ la $n$ a clepsidrelor, după realizarea celui de-al doilea experiment.


# Restricții și precizări

* $1 \leq n \leq 1 \ 000$;
* $1 \leq b \leq 1 \ 000 \ 000 \ 000$;
* $1 \leq k \leq 1 \ 000$;
* $1 \leq S_i \leq 1 \ 000$;
* $P_i$ aparține mulțimii $\{1, 2\}$, $1 ≤ i ≤ k$;
* Pentru rezolvarea corectă a primei cerințe se acordă $25\%$ din punctaj, iar pentru rezolvarea corectă a celei de-a doua cerințe se acordă $75\%$ din punctaj. Acordarea punctajului pentru a doua cerință se face numai dacă in fișierul de ieșire există un răspuns pentru prima cerință, indiferent de corectitudinea acestuia.

---

Example:
`clepsidru.in`
```
2 3
2
3 1
1 2
```

`clepsidru.out`
```
4
1 1
0 1
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```python
# Read input data
with open('clepsidru.in', 'r') as file:
    n, b = map(int, file.readline().split())
    k = int(file.readline())
    states = [tuple(map(int, file.readline().split())) for _ in range(k)]

# Experiment 1
# Calculate the time it takes for all grains to reach the bottom of the last hourglass.
time_for_all_grains = (n - 1) + b

# Experiment 2
# Calculate the number of grains in each hourglass after k states
hourglasses = [[0, 0] for _ in range(n)]
hourglasses[0][0] = b
for S, P in states:
    # If in position 1, grains move down
    if P == 1:
        for _ in range(S):
            for i in range(n):
                if hourglasses[i][0] > 0:  # If there are grains in the top compartment
                    hourglasses[i][0] -= 1
                    if i < n - 1:  # Move grain down to the next hourglass
                        hourglasses[i + 1][0] += 1
                    else:  # Move grain to the bottom compartment of the last hourglass
                        hourglasses[i][1] += 1
                    break  # Only one grain moves per second
    # If in position 2, grains move up
    else:
        for _ in range(S):
            for i in reversed(range(n)):
                if hourglasses[i][1] > 0:  # If there are grains in the bottom compartment
                    hourglasses[i][1] -= 1
                    if i > 0:  # Move grain up to the previous hourglass
                        hourglasses[i - 1][1] += 1
                    else:  # Move grain to the top compartment of the first hourglass
                        hourglasses[i][0] += 1
                    break  # Only one grain moves per second

# Write output data
with open('clepsidru.out', 'w') as file:
    file.write(f"{time_for_all_grains}\n")
    for top, bottom in hourglasses:
        file.write(f"{top} {bottom}\n")
```

This python code should read the input from the `clepsidru.in` file, perform the calculations for both experiments, and write the results to the `clepsidru.out` file.
---------- user ----------


Program result did not match expected result.
Input data:
```
2 3
2
3 1
1 2
```
Expected output:
```
4
1 1
0 1
```
Found output:
```
4
0 0
3 0
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The initial solution has a mistake in the way it simulates the flow of sand in the hourglasses. The error occurs during the handling of the states, as the implementation incorrectly moves only one grain per second, even if there could be multiple grains moving at the same time due to the setup of the hourglasses. Additionally, the implementation does not correctly handle the reverse position of the hourglass.

Let's fix the logic for the second experiment to better simulate the flow of sand grains in the hourglasses. We need to properly account for the movement of sand grains based on the current position of the clepsidră and ensure that multiple sand grains can move at the same time when the hourglasses are switched.

Here's the corrected solution:```python
# Read input data
with open('clepsidru.in', 'r') as file:
    n, b = map(int, file.readline().split())
    k = int(file.readline())
    states = [tuple(map(int, file.readline().split())) for _ in range(k)]

# Experiment 1
# Calculate the time it takes for all grains to reach the bottom of the last hourglass.
time_for_all_grains = (2 * n - 1) + (b - 1)

# Experiment 2
# Calculate the number of grains in each hourglass after k states
hourglasses = [[0, 0] for _ in range(n)]
hourglasses[0][0] = b
current_position = 1

for S, P in states:
    for _ in range(S):
        if current_position == 1:
            # Move sand grains down
            for i in range(n):
                if hourglasses[i][0] > 0:
                    grains_to_move = min(n - i, hourglasses[i][0])
                    hourglasses[i][0] -= grains_to_move
                    if i < n - 1:
                        hourglasses[i + 1][0] += grains_to_move
                    else:
                        hourglasses[i][1] += grains_to_move
                    break
        else:
            # Move sand grains up
            for i in reversed(range(n)):
                if hourglasses[i][1] > 0:
                    grains_to_move = min(i + 1, hourglasses[i][1])
                    hourglasses[i][1] -= grains_to_move
                    if i > 0:
                        hourglasses[i - 1][1] += grains_to_move
                    else:
                        hourglasses[i][0] += grains_to_move
                    break
    # Change the current position of the clepsidră
    current_position = P

# Write output data
with open('clepsidru.out', 'w') as file:
    file.write(f"{time_for_all_grains}\n")
    for top, bottom in hourglasses:
        file.write(f"{top} {bottom}\n")
```

In the corrected solution, we now properly switch the position of the clepsidră based on the current state `P`. We also move the sand grains correctly based on the number of grains and the capacity in either top or bottom compartments. This solution should provide the correct number of grains in each compartment for each hourglass after the series of state changes.
---------- user ----------


Program result did not match expected result.
Input data:
```
2 3
2
3 1
1 2
```
Expected output:
```
4
1 1
0 1
```
Found output:
```
5
0 0
1 2
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

Upon evaluating the differences between the expected and found result, it is clear that the second attempt still incorrectly simulates the transfer of sand within the clepsidră.

The expected behavior is as follows:
- The sand grains should move one at a time each second.
- When the clepsidră is flipped, the sand should continue moving from the last hourglass affected before the flip.

The found output moves multiple grains at once, which does not match the behavior described in the problem statement. Additionally, the calculation of the first experiment result is also incorrect.

Let's revise the logic for both experiments:

1. For the first experiment, we need to calculate the time it takes for all sand grains to reach the bottom of the last hourglass. Each grain takes `n` seconds to pass through all hourglasses, except for the first grain, which takes `n - 1` seconds to reach the second hourglass.

2. For the second experiment, we need to simulate the movement of individual sand grains every second, considering the position of the clepsidră. Each second, only one grain can move from the top compartment to the bottom one if the clepsidră is in position 1, or from the bottom compartment to the top one if the clepsidră is in position 2.

Here's the corrected solution:```python
# Read input data
with open('clepsidru.in', 'r') as file:
    n, b = map(int, file.readline().split())
    k = int(file.readline())
    states = [tuple(map(int, file.readline().split())) for _ in range(k)]

# Experiment 1
# Calculate the time it takes for all grains to reach the bottom of the last hourglass.
time_for_all_grains = (n - 1) + (b - 1) * n

# Experiment 2
# Calculate the number of grains in each hourglass after k states
hourglasses = [(0, 0) for _ in range(n)]
hourglasses[0] = (b, 0)
current_position = 1

for seconds, position in states:
    while seconds > 0:
        moved = False
        if current_position == 1:
            for i in range(n):
                if hourglasses[i][0] > 0:
                    # Move one grain down
                    hourglasses[i] = (hourglasses[i][0] - 1, hourglasses[i][1])
                    if i < n - 1:
                        hourglasses[i + 1] = (hourglasses[i + 1][0] + 1, hourglasses[i + 1][1])
                    else:
                        hourglasses[i] = (hourglasses[i][0], hourglasses[i][1] + 1)
                    moved = True
                    break
        else:
            for i in reversed(range(n)):
                if hourglasses[i][1] > 0:
                    # Move one grain up
                    hourglasses[i] = (hourglasses[i][0], hourglasses[i][1] - 1)
                    if i > 0:
                        hourglasses[i - 1] = (hourglasses[i - 1][0], hourglasses[i - 1][1] + 1)
                    else:
                        hourglasses[i] = (hourglasses[i][0] + 1, hourglasses[i][1])
                    moved = True
                    break

        if not moved:
            # No more grains to move, we can break early
            break

        # Decrease the time after moving a grain
        seconds -= 1

    # Flip the clepsidră
    current_position = position

# Write output data
with open('clepsidru.out', 'w') as file:
    file.write(f"{time_for_all_grains}\n")
    for top, bottom in hourglasses:
        file.write(f"{top} {bottom}\n")
```

This corrected solution should now properly account for the movement of individual sand grains and will handle the flipping of the clepsidră correctly according to the problem statement. The output should match the expected results.
---------- user ----------


Program result did not match expected result.
Input data:
```
2 3
2
3 1
1 2
```
Expected output:
```
4
1 1
0 1
```
Found output:
```
5
0 0
2 1
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

Upon revisiting the problem, it's clear that there are multiple issues with the previous solution. Specifically, the solution does not correctly simulate the behavior of sand grains moving through the clepsidra when it is in different positions. The movement of sand must be simulated one second at a time, for each state, and the flipping of the clepsidra must be accounted for correctly.

Let's address the problems with a step-by-step approach:

1. For the first experiment, we must calculate the total time it takes for all `b` sand grains to reach the bottom of the last hourglass. The first grain takes `n` seconds to reach the bottom, and each subsequent grain will take 1 additional second. Therefore, the formula should be: `time_for_all_grains = n + (b - 1)`.

2. For the second experiment, we need to simulate each second of the sand moving through the hourglasses according to the states provided. We must keep track of the sand in the top and bottom of each hourglass, flipping the clepsidra as necessary and allowing only one grain of sand to move per second.

Here is the corrected solution:

```python
# Read input data
with open('clepsidru.in', 'r') as file:
    n, b = map(int, file.readline().split())
    k = int(file.readline())
    states = [list(map(int, file.readline().split())) for _ in range(k)]

# Experiment 1: Calculate the time it takes for all grains to reach the bottom of the last hourglass.
time_for_all_grains = n + (b - 1)

# Experiment 2: Calculate the number of grains in each hourglass after k states.
# Initialize the top compartment with b grains and bottom compartments with 0 grains.
hourglasses = [[0, 0] for _ in range(n)]
hourglasses[0][0] = b
position = 1  # Position 1 means top to bottom.

for S, P in states:
    while S > 0:
        # Move one grain per second.
        for i in range(n):
            if position == 1 and hourglasses[i][0] > 0:  # Sand flows down.
                hourglasses[i][0] -= 1
                if i < n - 1:
                    hourglasses[i + 1][0] += 1
                else:
                    hourglasses[i][1] += 1
                break
            elif position == 2 and hourglasses[n - 1 - i][1] > 0:  # Sand flows up.
                hourglasses[n - 1 - i][1] -= 1
                if n - 1 - i > 0:
                    hourglasses[n - 2 - i][1] += 1
                else:
                    hourglasses[n - 1 - i][0] += 1
                break
        S -= 1
    position = P

# Write output data
with open('clepsidru.out', 'w') as file:
    file.write(str(time_for_all_grains) + '\n')
    for top, bottom in hourglasses:
        file.write(f"{top} {bottom}\n")
```

This solution should now correctly simulate the movement of the sand grains for both experiments and produce the expected output.
---------- user ----------


Program result did not match expected result.
Input data:
```
2 3
2
3 1
1 2
```
Expected output:
```
4
1 1
0 1
```
Found output:
```
4
0 0
2 1
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The current output does not match the expected output because the logic used to simulate the sand flow is still flawed. Let's carefully analyze the problem and correct the solution:

1. In the first experiment, the time it takes for all `b` sand grains to reach the bottom of the last hourglass is the sum of `n - 1` seconds (for the sand to reach from the top of the first hourglass to the top of the last one) plus `b` seconds (for all sand grains to pass through the last hourglass). So the correct formula is `time_for_all_grains = (n - 1) + b`.

2. In the second experiment, we must simulate each state by moving one grain of sand per second. When the clepsidra is in position 1, sand falls from the top compartment to the bottom compartment of the next hourglass. When the clepsidra is in position 2, sand rises from the bottom compartment to the top compartment of the previous hourglass. The sand movement should stop when there are no more grains to move or when the time for a state has passed.

Let's rewrite the correct solution:

```python
# Read input data
with open('clepsidru.in', 'r') as file:
    n, b = map(int, file.readline().split())
    k = int(file.readline())
    states = [tuple(map(int, file.readline().split())) for _ in range(k)]

# Experiment 1: Calculate the time it takes for all grains to reach the bottom of the last hourglass.
time_for_all_grains = (n - 1) + b

# Experiment 2: Simulate the sand flow for each state.
hourglasses = [[0, 0] for _ in range(n)]  # Each hourglass holds a top and bottom compartment.
hourglasses[0][0] = b  # Place all b grains in the top compartment of the first hourglass.

# Process each state
for seconds, position in states:
    while seconds > 0:
        if position == 1:
            # Position 1: Check from top to bottom
            for i in range(n):
                if hourglasses[i][0] > 0:
                    # Move a grain down
                    hourglasses[i][0] -= 1
                    if i < n - 1:
                        hourglasses[i + 1][0] += 1
                    else:
                        hourglasses[i][1] += 1
                    break
        else:
            # Position 2: Check from bottom to top
            for i in range(n - 1, -1, -1):
                if hourglasses[i][1] > 0:
                    # Move a grain up
                    hourglasses[i][1] -= 1
                    if i > 0:
                        hourglasses[i - 1][1] += 1
                    else:
                        hourglasses[i][0] += 1
                    break
        seconds -= 1

# Write output data
with open('clepsidru.out', 'w') as file:
    file.write(f"{time_for_all_grains}\n")
    for top, bottom in hourglasses:
        file.write(f"{top} {bottom}\n")
```

This corrected solution should now properly simulate the sand movement in the clepsidra and produce the expected output as specified in the problem statement.
---------- user ----------


Program result did not match expected result.
Input data:
```
2 3
2
3 1
1 2
```
Expected output:
```
4
1 1
0 1
```
Found output:
```
4
0 0
3 0
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The provided solution is incorrect as it does not simulate the flow of sand through the clepsidra accurately according to the states. The expected output indicates that after the first state (3 seconds in position 1), there should be 1 grain of sand in the top of the first hourglass and 1 grain in the bottom of the first hourglass, and after the second state (1 second in position 2), there should be 1 grain of sand in the bottom of the second hourglass. The provided solution fails to manage the correct distribution of sand after the state changes.

Let us correct this by considering the following:

1. Sand falls from the top to the bottom of the same hourglass in one second if there is sand in the top.
2. If the sand reaches the bottom of an hourglass and the hourglass below has space in the top, it immediately falls into the next hourglass's top.
3. When the clepsidra is flipped, the sand in the bottom compartment of each hourglass should start moving to the top compartment of the hourglass above it (or become the top compartment's sand for the first hourglass when flipped).

This simulation needs to be carried out for each second over each state provided. Now, we will rewrite the solution with these corrections taken into account:

```python
# Read input data
with open('clepsidru.in', 'r') as file:
    n, b = map(int, file.readline().split())
    k = int(file.readline())
    states = [tuple(map(int, file.readline().split())) for _ in range(k)]

# Experiment 1: Calculate the time it takes for all grains to reach the bottom of the last hourglass.
# The first grain takes n seconds, and each subsequent grain takes 1 second longer.
time_for_all_grains = n + (b - 1)

# Experiment 2: Calculate the number of grains in each hourglass after k states.
# Initialize the hourglasses with all the sand in the top of the first hourglass.
hourglasses = [[0, 0] for _ in range(n)]  # Each hourglass has a top [0] and bottom [1] compartment.
hourglasses[0][0] = b  # Put b grains in the top compartment of the first hourglass.

# Function to simulate the sand moving for a given number of seconds in a given position.
def move_sand(seconds, position):
    while seconds > 0:
        # Keep track of whether any sand has moved during this second.
        sand_moved = False
        if position == 1:  # Position 1: Sand moves down.
            for i in range(n):
                if hourglasses[i][0] > 0:  # There's sand in the top compartment.
                    # Move sand from the top to the bottom compartment.
                    hourglasses[i][0] -= 1
                    if i < n - 1:
                        hourglasses[i + 1][0] += 1  # Move sand to the next hourglass's top.
                    else:
                        hourglasses[i][1] += 1  # Move sand to the bottom of the last hourglass.
                    sand_moved = True
                    break
        else:  # Position 2: Sand moves up.
            for i in reversed(range(n)):
                if hourglasses[i][1] > 0:  # There's sand in the bottom compartment.
                    # Move sand from the bottom to the top compartment.
                    hourglasses[i][1] -= 1
                    if i > 0:
                        hourglasses[i - 1][1] += 1  # Move sand to the previous hourglass's bottom.
                    else:
                        hourglasses[i][0] += 1  # Move sand to the top of the first hourglass.
                    sand_moved = True
                    break
        if not sand_moved:
            # If no sand moved, all remaining sand is settled and won't move anymore.
            break
        # Decrease the seconds after one second has passed in the simulation.
        seconds -= 1

# Simulate the movement of sand for each state.
for S, P in states:
    move_sand(S, P)

# Write output data
with open('clepsidru.out', 'w') as file:
    file.write(f"{time_for_all_grains}\n")
    for top, bottom in hourglasses:
        file.write(f"{top} {bottom}\n")
```

This corrected solution includes a function to simulate sand movement, which is called for each state. The function properly handles the movement of sand every second based on the position and ensures that all remaining sand is settled before prematurely ending the simulation for the current state. This solution should now produce the expected output.
---------- user ----------


Program result did not match expected result.
Input data:
```
2 3
2
3 1
1 2
```
Expected output:
```
4
1 1
0 1
```
Found output:
```
4
0 0
3 0
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The output of the program does not match the expected output because the logic for simulating the sand's movement is incorrect. Specifically, the bug is in how we handle the transition of sand between the hourglasses when they are flipped. We need to correctly simulate the sand's movement, considering the flipping between states which seems to have not been handled properly.

The expected behavior is as follows:

- During a one-second interval, a single grain of sand should move from the top compartment of one hourglass to the bottom of the next hourglass (or stay in the bottom if it's the last hourglass) if the clepsidra is in position 1. If in position 2, a single grain should move from the bottom compartment to the top compartment of the previous hourglass (or stay in the top if it's the first hourglass).
- When the clepsidra is flipped, the sand in the compartments stays in the same hourglass but the flow direction changes for the next state.

Let's write a new solution that correctly implements this logic:

```python
# Read input data
with open('clepsidru.in', 'r') as file:
    n, b = map(int, file.readline().split())
    k = int(file.readline())
    states = [tuple(map(int, file.readline().split())) for _ in range(k)]

# Experiment 1: Calculate the minimum time for all sand grains to reach the bottom of the last hourglass.
time_for_all_grains = n + (b - 1)

# Experiment 2: Simulate the sand movement by states.
hourglasses = [[0, 0] for _ in range(n)]  # Initialize hourglasses with no sand.
hourglasses[0][0] = b  # Place all b grains in the top of the first hourglass.

# Simulate the sand flow for each state.
for S, P in states:
    for _ in range(S):
        # Check for sand movement based on the current position.
        if P == 1:
            for i in range(n):
                if hourglasses[i][0] > 0:  # There is sand in the top to move down.
                    hourglasses[i][0] -= 1
                    if i == n - 1:
                        hourglasses[i][1] += 1  # Last hourglass, move to bottom.
                    else:
                        hourglasses[i + 1][0] += 1  # Move to top of next hourglass.
                    break  # Only one grain moves per second.
        elif P == 2:
            for i in range(n - 1, -1, -1):
                if hourglasses[i][1] > 0:  # There is sand in the bottom to move up.
                    hourglasses[i][1] -= 1
                    if i == 0:
                        hourglasses[i][0] += 1  # First hourglass, move to top.
                    else:
                        hourglasses[i - 1][1] += 1  # Move to bottom of previous hourglass.
                    break  # Only one grain moves per second.

# Write output data
with open('clepsidru.out', 'w') as file:
    file.write(f"{time_for_all_grains}\n")
    for top, bottom in hourglasses:
        file.write(f"{top} {bottom}\n")
```

This corrected solution includes the correct logic for both experiments: it calculates the time for all grains to reach the bottom and simulates the sand movement through the hourglasses for each state. It should now produce the expected output as specified in the problem statement.
