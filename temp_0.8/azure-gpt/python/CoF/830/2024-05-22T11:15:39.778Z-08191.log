---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in python. The code must compile and be correct.
The solution must read from `clepsidru.in` and write to `clepsidru.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

O **clepsidră** este un dispozitiv folosit pentru a măsura timpul. Clepsidra este alcatuită din două incinte de sticlă, conectate printr-un tub fin. Una dintre incinte este umplută cu nisip, acesta scurgându-se în cea de-a doua incintă, cu o viteză constantă. Clepsidra poate fi întoarsă, pentru a măsura o altă perioadă de timp.
Arheologii au descoperit un dispozitiv, pe care l-au denumit **clepsidru**, format din $n$ clepsidre identice, suprapuse, numerotate de la $1$ la $n$, prin care nisipul poate circula de la o clepsidră la alta datorită forței gravitaționale.
Studiind acest obiect, arheologii au constatat că:
* dispozitivul poate fi utilizat atât în pozitia $1$, când clepsidrele sunt în ordinea $1, 2,\dots, n$ cu clepsidra $n$ așezată pe sol, cât și în poziția $2$, cand clepsidrele sunt în ordinea $n, n-1, \dots, 1$ cu clepsidra $1$ așezată pe sol;
* viteza de trecere a nisipului de la o incintă la alta, a aceleiași clepsidre, este de **$1$ bob de nisip/secunda**, pentru toate clepsidrele, indiferent de poziție;
* trecerea clepsidrului dintr-o poziție în alta presupune răsturnarea acestuia și reașezarea boabelor de nisip;
* timpul de trecere a boabelor de nisip de la o clepsidră la alta este $0$.

Arheologii studiază comportarea clepsidrului realizând două experimente diferite, dupa cum urmează:

1. Se așează clepsidrul în poziția $1$, se introduc în incinta de sus a clepsidrei $1$ un numar $b$ de boabe de nisip și se determină dupa câte secunde vor ajunge toate boabele de nisip in incinta de jos a ultimei clepsidre;
2. Se așează clepsidrul în poziția $1$, se introduc în incinta de sus a clepsidrei $1$ un numar $b$ de boabe de nisip, apoi se așează clepsidrul în **$k$ stari** consecutive, o stare fiind caracterizată de valorile $S_i$ și $P_i$, ce reprezintă numărul de secunde, respectiv poziția, în care este menținut nemișcat clepsidrul, iar la final se determină numărul de boabe de nisip din incintele fiecărei clepsidre.

Spre exemplu, dacă clepsidrul este format din $n=2$ clepsidre, iar în incinta de sus a primei clepsidre se introduc $b=3$ boabe de nisip, la primul experiment se va obține valoarea $4$. La al doilea experiment se așează clepsidrul în $k=2$ stări, caracterizate prin $S_1=3, P_1=1$; $S_2=1, P_2=2$. Numărul de boabe de nisip din clepsidre va evolua ca în figura ce urmează:

~[clepsidru.png]

# Cerință

Să se scrie un program care citește valorile $n$ si $b$, precum și valorile $k, S_i, P_i$ și calculează valorile obținute de arheologi la realizarea celor două experimente.

# Date de intrare


Prima linie a fișierului de intrare `clepsidru.in` conține două numere naturale nenule $n$ si $b$, separate printr-un singur spațiu, cu semnificația din enunț; a doua linie conține numărul natural nenul $k$ având semnificația din enunț, iar următoarele $k$ linii conțin fiecare câte o pereche de valori $S_i$ și $P_i$, separate printr-un singur spațiu, cu semnificația din enunț.


# Date de ieșire


Fișierul de ieșire `clepsidru.out` va conține pe prima linie un număr natural ce reprezintă valoarea obținută la primul experiment, iar pe următoarele $n$ linii va conține câte o pereche de numere naturale, separate printr-un singur spațiu, ce reprezintă cantitățile de boabe de nisip din incintele de sus și jos ale celor $n$ clepsidre, scrise în ordinea de la $1$ la $n$ a clepsidrelor, după realizarea celui de-al doilea experiment.


# Restricții și precizări

* $1 \leq n \leq 1 \ 000$;
* $1 \leq b \leq 1 \ 000 \ 000 \ 000$;
* $1 \leq k \leq 1 \ 000$;
* $1 \leq S_i \leq 1 \ 000$;
* $P_i$ aparține mulțimii $\{1, 2\}$, $1 ≤ i ≤ k$;
* Pentru rezolvarea corectă a primei cerințe se acordă $25\%$ din punctaj, iar pentru rezolvarea corectă a celei de-a doua cerințe se acordă $75\%$ din punctaj. Acordarea punctajului pentru a doua cerință se face numai dacă in fișierul de ieșire există un răspuns pentru prima cerință, indiferent de corectitudinea acestuia.

---

Example:
`clepsidru.in`
```
2 3
2
3 1
1 2
```

`clepsidru.out`
```
4
1 1
0 1
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```markdown
```python
def run_experiment_1(n, b):
    # The time for sand to go through all hourglasses
    return b + n - 1

def run_experiment_2(n, b, k, states):
    # Initialize hourglasses with sand in the upper compartment only
    upper_sand = b
    lower_sand = 0
    hourglasses = [(0, 0) for _ in range(n)]
    
    # Process each state
    for seconds, position in states:
        # Calculate the sand movement based on position
        if position == 1:
            # From top to bottom
            for _ in range(seconds):
                for i in range(n):
                    if upper_sand > 0:
                        hourglasses[i] = (hourglasses[i][0] + 1, hourglasses[i][1])
                        upper_sand -= 1
                    elif hourglasses[i][0] > 0:
                        hourglasses[i] = (hourglasses[i][0] - 1, hourglasses[i][1] + 1)
                    if i > 0 and hourglasses[i - 1][0] == 0:
                        sand_to_move = min(hourglasses[i - 1][1], 1)
                        hourglasses[i - 1] = (hourglasses[i - 1][0], hourglasses[i - 1][1] - sand_to_move)
                        hourglasses[i] = (hourglasses[i][0] + sand_to_move, hourglasses[i][1])
        else:
            # From bottom to top
            for _ in range(seconds):
                for i in range(n-1, -1, -1):
                    if lower_sand > 0:
                        hourglasses[i] = (hourglasses[i][0], hourglasses[i][1] + 1)
                        lower_sand -= 1
                    elif hourglasses[i][1] > 0:
                        hourglasses[i] = (hourglasses[i][0] + 1, hourglasses[i][1] - 1)
                    if i < n - 1 and hourglasses[i + 1][1] == 0:
                        sand_to_move = min(hourglasses[i + 1][0], 1)
                        hourglasses[i + 1] = (hourglasses[i + 1][0] - sand_to_move, hourglasses[i + 1][1])
                        hourglasses[i] = (hourglasses[i][0], hourglasses[i][1] + sand_to_move)
    
    return hourglasses

# Read input data (without using input())
with open('clepsidru.in', 'r') as infile:
    n, b = map(int, infile.readline().split())
    k = int(infile.readline().strip())
    states = [tuple(map(int, infile.readline().split())) for _ in range(k)]

# Run experiments
experiment_1_result = run_experiment_1(n, b)
experiment_2_results = run_experiment_2(n, b, k, states)

# Write output data (without using print())
with open('clepsidru.out', 'w') as outfile:
    outfile.write(str(experiment_1_result) + '\n')
    for upper, lower in experiment_2_results:
        outfile.write(f'{upper} {lower}\n')
```
```
---------- user ----------


Expected program to write result to `clepsidru.out` and read from `clepsidru.in`.
Do not use `input()` or `print()` to read input data or write output data.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

```python
# Function to calculate time for all sand grains to reach the bottom in the first experiment
def time_to_bottom(n, b):
    return (b - 1) // n + n

# Function to calculate the distribution of sand grains in each hourglass after k states
def sand_distribution(n, b, k, states):
    hourglasses = [(0, 0) for _ in range(n)]  # Initialize hourglass states
    position = 1  # Start with position 1

    for S_i, P_i in states:
        # Reverse the hourglasses if position changes
        if P_i != position:
            position = P_i
            hourglasses = [(lower, upper) for upper, lower in hourglasses]

        # Allow sand to fall for S_i seconds
        for _ in range(S_i):
            # Update hourglasses from top to bottom
            for i in range(n):
                upper, lower = hourglasses[i]
                if i == 0:  # Top hourglass
                    if b > 0:  # If we still have sand to start with
                        upper += 1
                        b -= 1
                else:
                    # Move sand from upper part of hourglass above to this one
                    prev_upper, prev_lower = hourglasses[i-1]
                    if prev_lower > 0:
                        upper += 1
                        hourglasses[i-1] = (prev_upper, prev_lower - 1)
                # Move sand from upper to lower part of this hourglass
                if upper > 0:
                    lower += 1
                    upper -= 1
                hourglasses[i] = (upper, lower)

    # Reverse the hourglasses if ending position is 2
    if position == 2:
        hourglasses = [(lower, upper) for upper, lower in hourglasses]

    return hourglasses

# Read input from file
with open('clepsidru.in', 'r') as file:
    n, b = map(int, file.readline().split())
    k = int(file.readline())
    states = [tuple(map(int, file.readline().split())) for _ in range(k)]

# Calculate results for both experiments
time_to_reach_bottom = time_to_bottom(n, b)
distribution_after_k_states = sand_distribution(n, b, k, states)

# Write output to file
with open('clepsidru.out', 'w') as file:
    file.write(f'{time_to_reach_bottom}\n')
    for upper, lower in distribution_after_k_states:
        file.write(f'{upper} {lower}\n')
```
---------- user ----------


Program result did not match expected result.
Input data:
```
2 3
2
3 1
1 2
```
Expected output:
```
4
1 1
0 1
```
Found output:
```
3
0 0
1 2
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

It looks like there is an issue with how the sand grains are distributed across the hourglasses when transitioning between states, particularly when reversing the hourglasses. The logic to reverse the hourglasses and move sand between them needs to be carefully handled, especially when considering the transition from the upper to the lower part in the same hourglass and from the lower part of one hourglass to the upper part of the one below it.

Let's correct the implementation with the following adjustments:
- Fix the transition logic when the hourglass position changes.
- Ensure that the sand distribution correctly handles the movement of sand both within an hourglass and between adjacent hourglasses.

Here is the corrected solution:

```python
# Read input from file
with open('clepsidru.in', 'r') as file:
    n, b = map(int, file.readline().split())
    k = int(file.readline())
    states = [tuple(map(int, file.readline().split())) for _ in range(k)]

# Calculate time for the first experiment
time_to_reach_bottom = (b - 1) // n + n

# Prepare data structure for storing sand in hourglasses
hourglasses = [(0, 0)] * n

# Process states for the second experiment
for S_i, P_i in states:
    for _ in range(S_i):
        if P_i == 1:
            for i in range(n):
                if i == 0 and b > 0:
                    # Fill the top hourglass from the initial sand supply
                    b -= 1
                    hourglasses[i] = (hourglasses[i][0] + 1, hourglasses[i][1])
                elif i > 0 and hourglasses[i - 1][1] > 0:
                    # Move sand from the bottom of the upper hourglass to the top of the current one
                    hourglasses[i - 1] = (hourglasses[i - 1][0], hourglasses[i - 1][1] - 1)
                    hourglasses[i] = (hourglasses[i][0] + 1, hourglasses[i][1])
                # Move sand from the top to the bottom of the current hourglass
                if hourglasses[i][0] > 0:
                    hourglasses[i] = (hourglasses[i][0] - 1, hourglasses[i][1] + 1)
        else:
            for i in reversed(range(n)):
                if i == n - 1 and b > 0:
                    # Fill the bottom hourglass from the initial sand supply
                    b -= 1
                    hourglasses[i] = (hourglasses[i][0], hourglasses[i][1] + 1)
                elif i < n - 1 and hourglasses[i + 1][0] > 0:
                    # Move sand from the top of the lower hourglass to the bottom of the current one
                    hourglasses[i + 1] = (hourglasses[i + 1][0] - 1, hourglasses[i + 1][1])
                    hourglasses[i] = (hourglasses[i][0], hourglasses[i][1] + 1)
                # Move sand from the bottom to the top of the current hourglass
                if hourglasses[i][1] > 0:
                    hourglasses[i] = (hourglasses[i][0] + 1, hourglasses[i][1] - 1)

# Write output to file
with open('clepsidru.out', 'w') as file:
    file.write(f'{time_to_reach_bottom}\n')
    for upper, lower in hourglasses:
        file.write(f'{upper} {lower}\n')
```

This updated code should now handle the transitions between hourglasses correctly and match the expected output. It maintains the sand distribution for each state and updates the hourglasses' sand levels appropriately based on the current state's position.
---------- user ----------


Program result did not match expected result.
Input data:
```
2 3
2
3 1
1 2
```
Expected output:
```
4
1 1
0 1
```
Found output:
```
3
1 0
0 2
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

It seems my previous solution still did not handle the state transitions and sand movement correctly. Let's carefully analyze what went wrong and implement a correct solution.

The main issue seems to be the incorrect handling of the sand distribution during each second of the experiment. We need to ensure that within each second, the sand moves correctly from the upper to the lower chamber of the same hourglass, and then from the lower chamber of one hourglass to the upper chamber of the next one in sequence.

Here is the fixed implementation, taking into account the correct sand movement during each second and proper handling of state transitions:

```python
# Function to simulate the sand distribution during k states
def simulate(n, b, k, states):
    # Initialize hourglasses with no sand
    hourglasses = [(0, 0) for _ in range(n)]
    # We start with position 1
    position = 1
    for seconds, pos in states:
        # Check if we need to reverse the hourglasses
        if position != pos:
            hourglasses = [(lower, upper) for upper, lower in hourglasses]
            position = pos
        for _ in range(seconds):
            # Distribute the sand for one second
            new_hourglasses = []
            for i in range(n):
                upper, lower = hourglasses[i]
                # Move sand from the upper part to the lower part, if available
                if upper > 0:
                    upper -= 1
                    lower += 1
                # Get sand from the initial supply, if available
                elif i == 0 and b > 0:
                    b -= 1
                    upper += 1
                # Transfer sand from the lower part of the previous hourglass
                elif i > 0 and new_hourglasses[i-1][1] > 0:
                    new_hourglasses[i-1] = (new_hourglasses[i-1][0], new_hourglasses[i-1][1] - 1)
                    upper += 1
                new_hourglasses.append((upper, lower))
            hourglasses = new_hourglasses
    return hourglasses

# Function to calculate the time for all sand to reach the bottom hourglass
def calculate_time_to_bottom(n, b):
    return (b + n - 1) // n + (n - 1)

# Read input data
with open('clepsidru.in', 'r') as file:
    n, b = map(int, file.readline().split())
    k = int(file.readline())
    states = [tuple(map(int, file.readline().split())) for _ in range(k)]

# Run the experiments
time_to_bottom = calculate_time_to_bottom(n, b)
final_distribution = simulate(n, b, k, states)

# Write the results to the output file
with open('clepsidru.out', 'w') as file:
    file.write(str(time_to_bottom) + '\n')
    for upper, lower in final_distribution:
        file.write(f"{upper} {lower}\n")
```

This solution should now correctly calculate the time it takes for all the sand to reach the bottom hourglass in the first experiment and accurately simulate the sand distribution across all hourglasses in the second experiment after k states.
---------- user ----------


Program result did not match expected result.
Input data:
```
2 3
2
3 1
1 2
```
Expected output:
```
4
1 1
0 1
```
Found output:
```
3
1 1
0 1
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

It appears that the first part of the solution, which calculates the time for all sand to reach the bottom hourglass, is still incorrect. The correct formula to calculate this is the time it takes to empty the first hourglass (b) plus the time it takes for the rest of the sand to pass through the remaining hourglasses (n - 1), because once the first hourglass is empty, each subsequent hourglass adds one second to the total time as the sand passes through.

The second part of the solution, which simulates the sand distribution, seems to be correct, but I will review and rewrite the entire solution to make sure both parts are correct:

```python
# Function to calculate the time for all sand to reach the bottom hourglass
def calculate_time_to_bottom(n, b):
    # Time is the initial amount of sand b through the first hourglass plus (n - 1) seconds for the remaining hourglasses
    return b + n - 1

# Function to simulate the behavior of the hourglasses for the second experiment
def simulate_hourglasses(n, b, k, states):
    # Initialize the hourglasses
    hourglasses = [(0, 0) for _ in range(n)]
    sand_remaining = b

    for seconds, position in states:
        for _ in range(seconds):
            if position == 1:
                # Handling sand movement from top to bottom
                for i in range(n):
                    if i == 0 and sand_remaining > 0:
                        # Take sand from the initial pile if available
                        sand_remaining -= 1
                        hourglasses[i] = (hourglasses[i][0] + 1, hourglasses[i][1])
                    if hourglasses[i][0] > 0:
                        # Move sand from upper to lower chamber of the hourglass
                        hourglasses[i] = (hourglasses[i][0] - 1, hourglasses[i][1] + 1)
                    if i > 0 and hourglasses[i - 1][1] > 0:
                        # Move sand from lower chamber of the above hourglass to the upper chamber of the current one
                        hourglasses[i] = (hourglasses[i][0] + 1, hourglasses[i][1])
                        hourglasses[i - 1] = (hourglasses[i - 1][0], hourglasses[i - 1][1] - 1)
            else:
                # Handling sand movement from bottom to top
                for i in reversed(range(n)):
                    if i == n - 1 and sand_remaining > 0:
                        # Take sand from the initial pile if available
                        sand_remaining -= 1
                        hourglasses[i] = (hourglasses[i][0], hourglasses[i][1] + 1)
                    if hourglasses[i][1] > 0:
                        # Move sand from lower to upper chamber of the hourglass
                        hourglasses[i] = (hourglasses[i][0] + 1, hourglasses[i][1] - 1)
                    if i < n - 1 and hourglasses[i + 1][0] > 0:
                        # Move sand from upper chamber of the below hourglass to the lower chamber of the current one
                        hourglasses[i] = (hourglasses[i][0], hourglasses[i][1] + 1)
                        hourglasses[i + 1] = (hourglasses[i + 1][0] - 1, hourglasses[i + 1][1])

    return hourglasses

# Read input data
with open('clepsidru.in', 'r') as file:
    n, b = map(int, file.readline().split())
    k = int(file.readline())
    states = [tuple(map(int, file.readline().split())) for _ in range(k)]

# Solve the problem
time_to_bottom = calculate_time_to_bottom(n, b)
final_distribution = simulate_hourglasses(n, b, k, states)

# Write the results to the output file
with open('clepsidru.out', 'w') as file:
    file.write(f"{time_to_bottom}\n")
    for upper, lower in final_distribution:
        file.write(f"{upper} {lower}\n")
```

This solution should correctly calculate the time for all the sand to reach the bottom in the first experiment and simulate the sand distribution correctly in the second experiment.
---------- user ----------


Program result did not match expected result.
Input data:
```
2 3
2
3 1
1 2
```
Expected output:
```
4
1 1
0 1
```
Found output:
```
4
0 1
1 1
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

It seems there is a mistake in the sand distribution logic during the state transitions. In the given example, after 3 seconds with the clepsidru in position 1, the 3 grains of sand should have moved to the bottom chamber of the first hourglass and the top chamber of the second hourglass. Then, after 1 second with the clepsidru in position 2, one grain of sand should move from the top chamber of the first hourglass to the bottom chamber, resulting in 1 grain in each chamber of the first hourglass and 1 grain in the bottom chamber of the second hourglass.

Let's correct the logic for the simulation of the behavior of the hourglasses for the second experiment:

```python
# Function to calculate the time for all sand to reach the bottom hourglass
def calculate_time_to_bottom(n, b):
    return b + n - 1

# Function to simulate the behavior of the hourglasses for the second experiment
def simulate_hourglasses(n, b, k, states):
    # Initialize the hourglasses
    hourglasses = [(0, 0) for _ in range(n)]
    # Start with the first position and fill the top hourglass
    hourglasses[0] = (b, 0)

    # Process each state
    for seconds, position in states:
        for _ in range(seconds):
            if position == 1:
                # Allow the sand to fall from the upper to the lower compartment
                for i in range(n - 1, -1, -1):
                    if hourglasses[i][0] > 0:
                        # Sand falls to the lower compartment
                        hourglasses[i] = (hourglasses[i][0] - 1, hourglasses[i][1] + 1)
                    if i > 0 and hourglasses[i - 1][1] > 0:
                        # Sand falls from the lower compartment of the hourglass above
                        hourglasses[i - 1] = (hourglasses[i - 1][0], hourglasses[i - 1][1] - 1)
                        hourglasses[i] = (hourglasses[i][0] + 1, hourglasses[i][1])
            else:
                # Allow the sand to fall from the lower to the upper compartment in reverse
                for i in range(n):
                    if hourglasses[i][1] > 0:
                        # Sand falls to the upper compartment
                        hourglasses[i] = (hourglasses[i][0] + 1, hourglasses[i][1] - 1)
                    if i < n - 1 and hourglasses[i + 1][0] > 0:
                        # Sand falls from the upper compartment of the hourglass below
                        hourglasses[i + 1] = (hourglasses[i + 1][0] - 1, hourglasses[i + 1][1])
                        hourglasses[i] = (hourglasses[i][0], hourglasses[i][1] + 1)

    # Return the final distribution of sand in the hourglasses
    return hourglasses

# Read input data
with open('clepsidru.in', 'r') as file:
    n, b = map(int, file.readline().split())
    k = int(file.readline())
    states = [tuple(map(int, file.readline().split())) for _ in range(k)]

# Solve the problem
time_to_bottom = calculate_time_to_bottom(n, b)
final_distribution = simulate_hourglasses(n, b, k, states)

# Write the results to the output file
with open('clepsidru.out', 'w') as file:
    file.write(f"{time_to_bottom}\n")
    for upper, lower in final_distribution:
        file.write(f"{upper} {lower}\n")
```

This solution should now correctly calculate the time it takes for all the sand to reach the bottom in the first experiment and reflect the accurate final distribution of sand for the second experiment.
---------- user ----------


Program result did not match expected result.
Input data:
```
2 3
2
3 1
1 2
```
Expected output:
```
4
1 1
0 1
```
Found output:
```
4
1 1
1 0
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

There is a flaw in the logic for the sand distribution simulation, specifically in how the sand moves between hourglasses in different positions. When in position 1, the sand should move from the upper chamber of one hourglass to the lower chamber of the next hourglass. When in position 2, the sand should move from the lower chamber of one hourglass to the upper chamber of the next. It's important to check for remaining sand in the input, and the transfer of sand should take place from top to bottom or bottom to top depending on the state.

Let's fix the simulate_hourglasses function to correctly handle these transitions:

```python
# Function to simulate the behavior of the hourglasses for the second experiment
def simulate_hourglasses(n, b, k, states):
    # Initialize the hourglasses with zero sand in both the upper and lower chambers
    hourglasses = [(0, 0) for _ in range(n)]
    # Add the initial sand to the top hourglass
    hourglasses[0] = (b, 0)

    for seconds, position in states:
        while seconds > 0:
            # Create a new state for the hourglasses to track changes within this second
            new_state = [(0, 0) for _ in range(n)]

            # Transfer sand within each hourglass from the upper to lower chamber
            for i in range(n):
                upper, lower = hourglasses[i]
                if upper > 0:
                    upper -= 1
                    lower += 1
                new_state[i] = (upper, lower)

            # Transfer sand between hourglasses depending on the position
            if position == 1:
                # Transfer sand from the lower chamber of one hourglass to the upper chamber of the next
                for i in range(n - 1):
                    if new_state[i][1] > 0:
                        new_state[i] = (new_state[i][0], new_state[i][1] - 1)
                        new_state[i + 1] = (new_state[i + 1][0] + 1, new_state[i + 1][1])
            else:
                # Transfer sand from the upper chamber of one hourglass to the lower chamber of the previous
                for i in range(n - 1, 0, -1):
                    if new_state[i][0] > 0:
                        new_state[i] = (new_state[i][0] - 1, new_state[i][1])
                        new_state[i - 1] = (new_state[i - 1][0], new_state[i - 1][1] + 1)

            # Update the hourglasses to the new state after 1 second has passed
            hourglasses = new_state
            seconds -= 1

    return hourglasses

# Read input data
with open('clepsidru.in', 'r') as file:
    n, b = map(int, file.readline().split())
    k = int(file.readline())
    states = [tuple(map(int, file.readline().split())) for _ in range(k)]

# Solve the problem
time_to_bottom = calculate_time_to_bottom(n, b)
final_distribution = simulate_hourglasses(n, b, k, states)

# Write the results to the output file
with open('clepsidru.out', 'w') as file:
    file.write(f"{time_to_bottom}\n")
    for upper, lower in final_distribution:
        file.write(f"{upper} {lower}\n")
```

This solution should now correctly simulate the sand distribution across the hourglasses after k states, considering the proper movement of sand both within an hourglass and between hourglasses. It should produce the correct output for both the first and second experiments.
