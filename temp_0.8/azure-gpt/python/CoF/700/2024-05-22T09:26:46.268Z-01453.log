---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in python. The code must compile and be correct.
The solution must read from `mouse.in` and write to `mouse.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Un experiment urmărește comportarea unui șoricel pus într-o cutie dreptunghiulară, împărțită în $m \times n$ cămăruțe egale de formă pătrată. Fiecare cămăruță conține o anumită cantitate de hrană. Șoricelul trebuie să pornească din colțul $(1,1)$ al cutiei și să ajungă în colțul opus, mâncând cât mai multă hrană. El poate trece dintr-o cameră în una alăturată (două camere sunt alăturate dacă au un perete comun), mănâncă toată hrana din cămăruță atunci când intră și nu intră niciodată într-o cameră în care a mai intrat înainte. 

# Cerință

Stabiliți care este cantitatea maximă de hrană pe care o poate mânca și traseul pe care îl poate urma pentru a culege această cantitate maximă.

# Date de intrare
Fișierul de intrare `mouse.in` conține pe prima linie două numere $m$ și $n$ reprezentând numărul de linii respectiv numărul de coloane ale cutiei, iar pe următoarele $m$ linii cele $m \cdot n$ numere reprezentând cantitatea de hrană existentă în fiecare cămăruță, câte $n$ numere pe fiecare linie, separate prin spații.

# Date de ieșire
În fișierul de ieșire `mouse.out` se vor scrie pe prima linie două numere separate printr-un spațiu: numărul de cămăruțe vizitate și cantitatea de hrană maximă culeasă. Pe următoarele linii se va scrie un traseu posibil pentru cantitatea dată, sub formă de perechi de numere, începând cu $(1, 1)$ și terminând cu $(m, n)$.

# Restricții și precizări
- Toate valorile din fișier sunt numere naturale între $1$ și $100$.
- Veți primi 40 de puncte pentru afișarea primelor două numere.

---

Example:
`mouse.in`
```
2 4
1 2 6 3
3 4 1 2
```

`mouse.out`
```
7 21
1 1
2 1
2 2
1 2
1 3
1 4
2 4
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```python
def read_matrix(filename):
    with open(filename) as file:
        m, n = map(int, file.readline().split())
        matrix = [list(map(int, line.split())) for line in file]
    return m, n, matrix

def write_output(filename, cnt, max_food, path):
    with open(filename, 'w') as file:
        file.write(f'{cnt} {max_food}\n')
        file.writelines(f'{r} {c}\n' for r, c in path)

def find_max_food_path(m, n, grid):
    dp = [[0] * n for _ in range(m)]
    for i in range(m):
        for j in range(n):
            dp[i][j] = grid[i][j]
            if i > 0:
                dp[i][j] = max(dp[i][j], dp[i-1][j] + grid[i][j])
            if j > 0:
                dp[i][j] = max(dp[i][j], dp[i][j-1] + grid[i][j])
    
    max_food = dp[-1][-1]
    path = [(m, n)]
    i, j = m - 1, n - 1
    while i > 0 or j > 0:
        if i == 0:
            j -= 1
        elif j == 0:
            i -= 1
        else:
            if dp[i-1][j] > dp[i][j-1]:
                i -= 1
            else:
                j -= 1
        path.append((i + 1, j + 1))
    path.reverse()
    return len(path), max_food, path

m, n, matrix = read_matrix('mouse.in')
cnt, max_food, path = find_max_food_path(m, n, matrix)
write_output('mouse.out', cnt, max_food, path)
```

This Python code reads from `mouse.in`, where it expects to find the grid dimensions and the grid itself, and writes the result to `mouse.out`, including the maximum food collected and one possible path to collect it.
---------- user ----------


Program result did not match expected result.
Input data:
```
2 4
1 2 6 3
3 4 1 2
```
Expected output:
```
7 21
1 1
2 1
2 2
1 2
1 3
1 4
2 4
```
Found output:
```
5 14
1 1
1 2
1 3
1 4
2 4
```

Evaluate the differences between the expected and found result.
Write a comprehensive explanation of why the results differ.
If the solution has a bug fix it, else reimplement it using a different algorithm or data structure.

Rewrite the solution.

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

The original algorithm didn't consider the constraint that the mouse can move in all four directions but cannot return to a visited cell. The dynamic programming approach only maximized the food by looking at the immediate top and left neighbors, which doesn't necessarily result in the correct path since it doesn't account for the mouse's ability to move downwards and to the right after moving upwards and to the left.

The issue in the provided code is that the dynamic programming table only allows movement to the right and downwards. To ensure the mouse can move to all adjacent cells while adhering to the rules, a depth-first search (DFS) approach should be used. The DFS will explore all possible paths and keep track of the maximum food collected.

Let's rewrite the solution using DFS:

```python
# Helper function to write to a file.
def write_to_file(filename, content):
    with open(filename, 'w') as file:
        file.write(content)

# Function to perform DFS and find the optimal path.
def dfs(matrix, m, n, x, y, visited, current_path, current_food, best_path, best_food):
    # Mark the current cell as visited and add its food to the current food count.
    visited[x][y] = True
    current_path.append((x+1, y+1))
    current_food += matrix[x][y]
    
    # If we reach the last cell, update the best path and food count if current is better.
    if x == m-1 and y == n-1:
        if current_food > best_food[0]:
            best_food[0] = current_food
            best_path.clear()
            best_path.extend(current_path)
    else:
        # Explore all four possible directions.
        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            new_x, new_y = x + dx, y + dy
            if 0 <= new_x < m and 0 <= new_y < n and not visited[new_x][new_y]:
                dfs(matrix, m, n, new_x, new_y, visited, current_path, current_food, best_path, best_food)
    
    # Backtrack: unmark the current cell as visited and remove it from the path.
    visited[x][y] = False
    current_path.pop()
    current_food -= matrix[x][y]

# Read input data.
with open('mouse.in', 'r') as file:
    m, n = map(int, file.readline().split())
    matrix = [list(map(int, file.readline().split())) for _ in range(m)]

# Initialize variables for DFS.
visited = [[False] * n for _ in range(m)]
best_path = []
best_food = [0]
current_path = []
current_food = 0

# Perform DFS to find the optimal path.
dfs(matrix, m, n, 0, 0, visited, current_path, current_food, best_path, best_food)

# Prepare the result.
result = f"{len(best_path)} {best_food[0]}\n" + "\n".join(f"{x} {y}" for x, y in best_path)

# Write output data.
write_to_file('mouse.out', result)
```

This revised solution uses a depth-first search to find the best path for the mouse. It maintains a `visited` matrix to ensure the mouse does not revisit cells and uses backtracking to explore all possible paths to find the one with the most food. It then writes the best result to `mouse.out`.
