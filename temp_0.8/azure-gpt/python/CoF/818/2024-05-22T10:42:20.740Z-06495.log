---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in python. The code must compile and be correct.
The solution must read from `roata.in` and write to `roata.out`.
The solution must not use `input()` or `print()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Una dintre atracţiile celebrului parc de distracţii Prater din Viena este Marea Roată Vieneză. Din ea se poate admira priveliştea întregii Viene.

Roata are $n$ cabine, numerotate de la $1$ la $n$ în sens orar şi dispuse simetric pe circumferinţa roţii. Îmbarcarea clienţilor se face în cabina în care roata este tangentă cu solul, iar rotirea începe cu cabina $1$ aflată în poziţia de îmbarcare şi se face în sens antiorar. Un client plăteşte pentru o rotire $1$ EUR şi poate cumpăra un număr oarecare de rotiri.

Cei $p$ clienţi care doresc utilizarea roţii trebuie să respecte următoarea procedură: clientul cu numărul de ordine $i$ îşi cumpără un bilet pe care sunt înscrise numărul său de ordine şi numărul de rotiri $c_i$, apoi se aşează la rând. Când în poziţia de îmbarcare este o cabină liberă sau se eliberează o cabină, roata se opreşte şi urcă următorul clientul. Un client coboară după ce se efectuează numărul de rotiri înscris pe bilet.

# Cerință

Să se scrie un program care, cunoscând numărul $n$ de cabine al roţii, numărul $p$ de clienţi, precum şi numărul de rotiri cumpărate de fiecare client, $c_i$, să calculeze:

* suma totală încasată de administratorul roţii de la clienţi;
* ordinea în care coboară clienţii din roată;
* numărul cabinei din care coboară ultimul client.

# Date de intrare


Fişierul de intrare `roata.in` conţine pe primul rând numărul natural $n$, pe al doilea rând numărul natural $p$ iar pe al treilea rând numerele naturale $c_i$, separate printr-un spaţiu, cu semnificaţiile de mai sus.


# Date de ieșire


Fişierul de ieşire `roata.out` va conţine pe prima linie suma totală încasată, pe a doua linie numerele de ordine ale clienţilor, în ordinea coborârii, separate printr-un spaţiu, iar pe a treia linie numărul cabinei din care va coborî ultimul client.


# Restricții și precizări

* $2 \leq n \leq 360$;
* $1 \leq p \leq 100 \ 000$;
* $1 \leq c_i \leq 100 \ 000$;
* pentru rezolvarea primei cerinţe se acordă $20\%$ din punctaj, iar pentru celelalte două cerinţe se acordă câte $40\%$ din punctaj fiecare.

---

Example:
`roata.in`
```
4
7
6 4 1 5 2 8 3
```

`roata.out`
```
29
3 5 2 4 1 7 6
3
```


---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in python, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```python
from collections import deque

# Read from the input file
with open("roata.in", "r") as fin:
    n = int(fin.readline().strip())
    p = int(fin.readline().strip())
    rotations = list(map(int, fin.readline().strip().split()))

# Initialize variables
total_income = sum(rotations)
customers_order = []
cabins = deque([0] * n)  # Use a deque to simulate the rotation of the cabins
last_cabin = 0
next_customer = 1
rotations_queue = deque(rotations)

# Process the customers
while p > 0:
    # Load the cabins if there are customers waiting
    for i in range(len(cabins)):
        if cabins[i] == 0 and rotations_queue:
            cabins[i] = (next_customer, rotations_queue.popleft())
            next_customer += 1

    # Rotate the cabins
    last_cabin = (last_cabin + 1) % n
    customer, remaining_rotations = cabins[last_cabin]

    # If a customer is present, decrease the remaining rotations
    if customer:
        if remaining_rotations == 1:
            # The customer is leaving
            customers_order.append(customer)
            cabins[last_cabin] = (0, 0)  # Mark the cabin as empty
            p -= 1  # One less customer to process
        else:
            # Update the remaining rotations for the customer
            cabins[last_cabin] = (customer, remaining_rotations - 1)

# Write to the output file
with open("roata.out", "w") as fout:
    fout.write(f"{total_income}\n")
    fout.write(" ".join(map(str, customers_order)))
    fout.write(f"\n{last_cabin + 1}\n")
``` 

This solution covers the requirements of the challenge, operating efficiently even with a large number of customers and rotations by using a queue to simulate the rotation of the cabins and process customers. The output is formatted according to the specifications.
---------- user ----------


Program exited with code 137.
stdout:
```

```
stderr:
```

```

Think of what has caused the exit code. Use the standard out and standard error to help you understand the issue.
Implement a solution to fix the program

---

Rewrite the entire solution applying necessary fixes.
---------- assistant ----------

Exit code 137 typically indicates that a program was forcibly killed by the system, often due to using too much memory or taking too long to execute. Since there's no specific output in stdout or stderr, it's likely that the provided code has a performance issue leading to a memory overflow or an infinite loop.

Upon reviewing the provided code, there's a potential for an infinite loop if the condition for a customer to leave is never met, specifically if `remaining_rotations` does not reach 1. This could happen if the logic for decrementing the rotations is incorrect or if there's an issue with the input data. However, the logic for decrementing rotations in the code seems correct, so it might be an efficiency problem when handling a large number of customers or rotations.

To address potential performance issues, we can optimize the solution by using an index to keep track of the current cabin to be unloaded, improving the rotation logic, and ensuring that the loop terminates correctly.

Let's rewrite the solution with these optimizations:

```python
from collections import deque

# Read from the input file
with open("roata.in", "r") as fin:
    n = int(fin.readline().strip())
    p = int(fin.readline().strip())
    rotations = list(map(int, fin.readline().strip().split()))

# Initialize variables
total_income = sum(rotations)
customers_order = []
cabins = [0] * n  # List to hold the remaining rotations for each cabin
cabins_customers = [0] * n  # List to hold the customer number for each cabin
rotations_queue = deque(rotations)
next_customer = 1
current_cabin_to_unload = 0  # Index of the next cabin to unload

# Load the initial customers into the cabins
for i in range(min(n, p)):
    cabins[i] = rotations_queue.popleft()
    cabins_customers[i] = next_customer
    next_customer += 1

# Process the rotations
while p > 0:
    # Unload the cabin if it's occupied and rotations are done
    if cabins[current_cabin_to_unload] == 1:
        customers_order.append(cabins_customers[current_cabin_to_unload])
        cabins[current_cabin_to_unload] = 0
        p -= 1  # One customer has been processed
    elif cabins[current_cabin_to_unload] > 1:
        # Decrement remaining rotations if cabin is occupied
        cabins[current_cabin_to_unload] -= 1
    
    # Load a new customer into the cabin if available
    if cabins[current_cabin_to_unload] == 0 and rotations_queue:
        cabins[current_cabin_to_unload] = rotations_queue.popleft()
        cabins_customers[current_cabin_to_unload] = next_customer
        next_customer += 1

    # Move to the next cabin to unload in the next iteration
    last_cabin = current_cabin_to_unload  # Remember last cabin for final output
    current_cabin_to_unload = (current_cabin_to_unload + 1) % n

# Write to the output file
with open("roata.out", "w") as fout:
    fout.write(f"{total_income}\n")
    fout.write(" ".join(map(str, customers_order)) + "\n")
    fout.write(f"{last_cabin + 1}\n")
```

This solution ensures that we decrement the remaining rotations correctly, load new customers efficiently, and terminate the loop as soon as all customers have been processed. The use of separate lists to track the remaining rotations and the customers in the cabins helps to streamline the logic and improve efficiency. The cabin index is now tracked with a single variable, which simplifies the rotation process.
