---------- user ----------

Here is a programming challenge. Points will be awarded for fastest code execution.
Create the most efficient solution for this challenge in c++. The code must compile and be correct.
The solution must read from `cerc.in` and write to `cerc.out`.
The solution must not use `cin >>` or `cout <<` or `printf()` or `scanf()` to read input data or write output data.

The solution must be written in a markdown code block.

---

Se desenează $n$ cercuri distincte în plan, numerotate cu numerele de la $1$ la $n$. Pentru fiecare cerc $k$ ($k \in \{1, 2, ..., n\}$) se cunosc: raza cercului, $r_k$, şi coodonatele ($x_k, y_k$) ale centrului cercului, coordonate referitoare la reperul cartezian $xOy$ cu originea în punctul $O$ din plan. Din punctul $O$, se desenează $m$ drepte distincte, astfel încât pentru fiecare dreaptă, dintre cele $m$ desenate, să existe cel puţin un cerc, dintre cele $n$, al cărui centru să fie situat pe această dreaptă şi pentru fiecare cerc desenat, să existe o singură dreaptă, dintre cele $m$ desenate, care să treacă prin centrul lui.  

# Cerinţă
Să se scrie un program care să se determine:
a) numărul $m$ de drepte distincte; 
b) cel mai mare număr $q$ de cercuri, dintre cele $n$, exterioare două câte două, ale căror centre sunt situate pe o aceeaşi dreaptă care trece prin punctul $O$, dintre cele $m$ desenate; 
c) numărul $p$ al dreptelor distincte, dintre cele $m$ desenate, pe care sunt situate centrele a câte $q$ cercuri, dintre cele $n$, exterioare două câte două.

# Date de intrare
Fişierul de intrare `cerc.in`  conţine:
$n$
$x_1\ y_1\ r_1$
...
$x_n\ y_n\ r_n$	
- pe prima linie, o valoare naturală nenulă $n$, reprezentând numărul de cercuri
- următoarele $n$ linii conţin câte trei numere naturale nenule, separate prin câte un spaţiu, care reprezintă coordonatele centrului $(x_1, y_1)$ şi raza $r_1$ ale primului cerc, ..., coordonatele centrului $(x_n, y_n)$ şi raza $r_n$ ale celui de-al $n$-lea cerc 

# Date de ieşire
Fişierul de ieşire `cerc.out` va conţine o singură linie pe care se vor scrie cele trei numere naturale $m$, $q$ şi $p$, separate prin câte un spaţiu. 

# Restricţii şi precizări
* $1 ≤ n ≤ 2\ 000$
* $1 ≤ x_1, x_2, ..., x_n ≤ 1\ 000$ ; $1 ≤ y_1, y_2, ..., y_n ≤ 1\ 000$ ; $1 ≤ r_1, r_2, ..., r_n ≤ 70$
* dacă două cercuri, dintre cele $n$, au centrele în acelaşi punct din plan, atunci razele lor sunt distincte
* două cercuri sunt exterioare dacă nu au niciun punct comun şi nici interioarele lor nu au puncte comune
* Pentru rezolvarea cerinţei a) se acordă $20%$ din punctaj, pentru cerinţa b) $50%$ din punctaj şi pentru cerinţa c) $30%$ din punctaj.

---

Example:
`cerc.in`
```
12
2 6 1
3 9 1
4 12 3
4 4 2
9 9 2
10 10 6
12 12 1
6 3 1
10 5 1
14 7 2
14 7 1
12 4 2
```

`cerc.out`
```
4 3 2
```


---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:
---------- assistant ----------

Before writing my solution in c++, I will think about the challenge step by step, come up with the most optimal solution, then I will verify the logic against the example.
Here are all the necessary steps to solve the challenge:```c++
#include <bits/stdc++.h>
using namespace std;

struct Point {
    long long x, y;
    Point(long long x = 0, long long y = 0) : x(x), y(y) {}
    bool operator<(const Point &other) const {
        return x < other.x || (x == other.x && y < other.y);
    }
};

struct Circle {
    Point center;
    long long radius;
    Circle(const Point &center, long long radius) : center(center), radius(radius) {}
};

struct Line {
    Point point;
    long long slope;
    Line(const Point &point, long long slope) : point(point), slope(slope) {}
};

const int NMAX = 2005;

long long n, x[NMAX], y[NMAX], r[NMAX];
Circle circles[NMAX];
Line lines[NMAX];
vector<Point> points;

bool on_line(const Point &p1, const Point &p2, const Point &p3) {
    return (p2.x - p1.x) * (p3.y - p2.y) == (p2.y - p1.y) * (p3.x - p2.x);
}

long long oriented_area(const Point &p1, const Point &p2, const Point &p3) {
    return (p2.x - p1.x) * (p3.y - p2.y) - (p2.y - p1.y) * (p3.x - p2.x);
}

long long distance_squared(const Point &p1, const Point &p2) {
    return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);
}

bool inside_circle(const Point &p, const Circle &circle) {
    return distance_squared(p, circle.center) <= circle.radius * circle.radius;
}

bool intersect(const Circle &c1, const Circle &c2) {
    return distance_squared(c1.center, c2.center) <= (c1.radius + c2.radius) * (c1.radius + c2.radius);
}

void add_line(const Point &p1, const Point &p2) {
    if (p1.x == p2.x) {
        lines[n] = Line(p1, LLONG_MAX);
    } else {
        long long slope = (p1.y - p2.y) / (p1.x - p2.x);
        lines[n] = Line(p1, slope);
    }
    n++;
}

bool compare_lines(const Line &l1, const Line &l2) {
    if (l1.slope == LLONG_MAX && l2.slope == LLONG_MAX) {
        return l1.point.x < l2.point.x;
    } else if (l1.slope == LLONG_MAX || l2.slope == LLONG_MAX) {
        return l1.slope == LLONG_MAX;
    } else {
        return l1.slope < l2.slope;
    }
}

int main() {
    ifstream fin("cerc.in");
    ofstream fout("cerc.out");

    fin >> n;
    for (long long i = 0; i < n; i++) {
        fin >> x[i] >> y[i] >> r[i];
        circles[i] = Circle(Point(x[i], y[i]), r[i]);
    }
    fin.close();

    for (long long i = 0; i < n; i++) {
        for (long long j = i + 1; j < n; j++) {
            if (intersect(circles[i], circles[j])) {
                points.push_back(circles[i].center);
                points.push_back(circles[j].center);
            }
        }
    }

    sort(points.begin(), points.end());
    points.erase(unique(points.begin(), points.end()), points.end());

    for (long long i = 0; i < points.size(); i++) {
        for (long long j = i + 1; j < points.size(); j++) {
            if (points[i].x != points[j].x) {
                add_line(points[i], points[j]);
            }
        }
    }

    sort(lines, lines + n, compare_lines);

    long long mx_cnt_lines = 0, mx_cnt_circles = 0, cnt_lines = 0;
    map<Line, long long> cnt_circles_on_line;
    for (long long i = 0; i < n; i++) {
        for (long long j = i + 1; j < n; j++) {
            if (on_line(lines[i].point, lines[j].point, circles[j].center) && inside_circle(lines[j].point, circles[j])) {
                cnt_circles_on_line[lines[i]]++;
                cnt_circles++;
                if (cnt_circles_on_line[lines[i]] == mx_cnt_circles) {
                    cnt_lines++;
                } else if (cnt_circles_on_line[lines[i]] > mx_cnt_circles) {
                    mx_cnt_circles = cnt_circles_on_line[lines[i]];
                    cnt_lines = 1;
                }
            }
        }
    }

    mx_cnt_lines += (mx_cnt_circles > 0);
    fout << mx_cnt_lines << " " << mx_cnt_circles << " " << cnt_lines << "\n";
    fout.close();

    return 0;
}
```
